var BT = Object.defineProperty;
var eE = (r) => {
  throw TypeError(r);
};
var LT = (r, e, t) => e in r ? BT(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var F = (r, e, t) => LT(r, typeof e != "symbol" ? e + "" : e, t), Cm = (r, e, t) => e.has(r) || eE("Cannot " + t);
var m = (r, e, t) => (Cm(r, e, "read from private field"), t ? t.call(r) : e.get(r)), M = (r, e, t) => e.has(r) ? eE("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), S = (r, e, t, n) => (Cm(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t), V = (r, e, t) => (Cm(r, e, "access private method"), t);
var Ju = (r, e, t, n) => ({
  set _(s) {
    S(r, e, s, t);
  },
  get _() {
    return m(r, e, n);
  }
});
const FT = Symbol(), tE = Object.getPrototypeOf, qw = /* @__PURE__ */ new WeakMap(), $T = (r) => r && (qw.has(r) ? qw.get(r) : tE(r) === Object.prototype || tE(r) === Array.prototype), MT = (r) => $T(r) && r[FT] || null, rE = (r, e = !0) => {
  qw.set(r, e);
}, Vp = {}, _m = (r) => typeof r == "object" && r !== null, uo = /* @__PURE__ */ new WeakMap(), Eh = /* @__PURE__ */ new WeakSet(), jT = (r = Object.is, e = (l, u) => new Proxy(l, u), t = (l) => _m(l) && !Eh.has(l) && (Array.isArray(l) || !(Symbol.iterator in l)) && !(l instanceof WeakMap) && !(l instanceof WeakSet) && !(l instanceof Error) && !(l instanceof Number) && !(l instanceof Date) && !(l instanceof String) && !(l instanceof RegExp) && !(l instanceof ArrayBuffer), n = (l) => {
  switch (l.status) {
    case "fulfilled":
      return l.value;
    case "rejected":
      throw l.reason;
    default:
      throw l;
  }
}, s = /* @__PURE__ */ new WeakMap(), i = (l, u, h = n) => {
  const d = s.get(l);
  if ((d == null ? void 0 : d[0]) === u)
    return d[1];
  const f = Array.isArray(l) ? [] : Object.create(Object.getPrototypeOf(l));
  return rE(f, !0), s.set(l, [u, f]), Reflect.ownKeys(l).forEach((g) => {
    if (Object.getOwnPropertyDescriptor(f, g))
      return;
    const p = Reflect.get(l, g), { enumerable: w } = Reflect.getOwnPropertyDescriptor(
      l,
      g
    ), E = {
      value: p,
      enumerable: w,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: !0
    };
    if (Eh.has(p))
      rE(p, !1);
    else if (p instanceof Promise)
      delete E.value, E.get = () => h(p);
    else if (uo.has(p)) {
      const [I, A] = uo.get(
        p
      );
      E.value = i(
        I,
        A(),
        h
      );
    }
    Object.defineProperty(f, g, E);
  }), Object.preventExtensions(f);
}, o = /* @__PURE__ */ new WeakMap(), a = [1, 1], c = (l) => {
  if (!_m(l))
    throw new Error("object required");
  const u = o.get(l);
  if (u)
    return u;
  let h = a[0];
  const d = /* @__PURE__ */ new Set(), f = (P, $ = ++a[0]) => {
    h !== $ && (h = $, d.forEach((U) => U(P, $)));
  };
  let g = a[1];
  const p = (P = ++a[1]) => (g !== P && !d.size && (g = P, E.forEach(([$]) => {
    const U = $[1](P);
    U > h && (h = U);
  })), h), w = (P) => ($, U) => {
    const j = [...$];
    j[1] = [P, ...j[1]], f(j, U);
  }, E = /* @__PURE__ */ new Map(), I = (P, $) => {
    if ((Vp ? "production" : void 0) !== "production" && E.has(P))
      throw new Error("prop listener already exists");
    if (d.size) {
      const U = $[3](w(P));
      E.set(P, [$, U]);
    } else
      E.set(P, [$]);
  }, A = (P) => {
    var $;
    const U = E.get(P);
    U && (E.delete(P), ($ = U[1]) == null || $.call(U));
  }, C = (P) => (d.add(P), d.size === 1 && E.forEach(([U, j], H) => {
    if ((Vp ? "production" : void 0) !== "production" && j)
      throw new Error("remove already exists");
    const ee = U[3](w(H));
    E.set(H, [U, ee]);
  }), () => {
    d.delete(P), d.size === 0 && E.forEach(([U, j], H) => {
      j && (j(), E.set(H, [U]));
    });
  }), N = Array.isArray(l) ? [] : Object.create(Object.getPrototypeOf(l)), O = e(N, {
    deleteProperty(P, $) {
      const U = Reflect.get(P, $);
      A($);
      const j = Reflect.deleteProperty(P, $);
      return j && f(["delete", [$], U]), j;
    },
    set(P, $, U, j) {
      const H = Reflect.has(P, $), ee = Reflect.get(P, $, j);
      if (H && (r(ee, U) || o.has(U) && r(ee, o.get(U))))
        return !0;
      A($), _m(U) && (U = MT(U) || U);
      let y = U;
      if (U instanceof Promise)
        U.then((b) => {
          U.status = "fulfilled", U.value = b, f(["resolve", [$], b]);
        }).catch((b) => {
          U.status = "rejected", U.reason = b, f(["reject", [$], b]);
        });
      else {
        !uo.has(U) && t(U) && (y = c(U));
        const b = !Eh.has(y) && uo.get(y);
        b && I($, b);
      }
      return Reflect.set(P, $, y, j), f(["set", [$], U, ee]), !0;
    }
  });
  o.set(l, O);
  const k = [
    N,
    p,
    i,
    C
  ];
  return uo.set(O, k), Reflect.ownKeys(l).forEach((P) => {
    const $ = Object.getOwnPropertyDescriptor(
      l,
      P
    );
    "value" in $ && (O[P] = l[P], delete $.value, delete $.writable), Object.defineProperty(N, P, $);
  }), O;
}) => [
  // public functions
  c,
  // shared state
  uo,
  Eh,
  // internal things
  r,
  e,
  t,
  n,
  s,
  i,
  o,
  a
], [HT] = jT();
function _t(r = {}) {
  return HT(r);
}
function fr(r, e, t) {
  const n = uo.get(r);
  (Vp ? "production" : void 0) !== "production" && !n && console.warn("Please use proxy object");
  let s;
  const i = [], o = n[3];
  let a = !1;
  const l = o((u) => {
    i.push(u), s || (s = Promise.resolve().then(() => {
      s = void 0, a && e(i.splice(0));
    }));
  });
  return a = !0, () => {
    a = !1, l();
  };
}
function Yh(r, e) {
  const t = uo.get(r);
  (Vp ? "production" : void 0) !== "production" && !t && console.warn("Please use proxy object");
  const [n, s, i] = t;
  return i(n, s(), e);
}
function ac(r) {
  return Eh.add(r), r;
}
function Tr(r, e, t, n) {
  let s = r[e];
  return fr(
    r,
    () => {
      const i = r[e];
      Object.is(s, i) || t(s = i);
    }
  );
}
function zT(r) {
  const e = _t({
    data: Array.from([]),
    has(t) {
      return this.data.some((n) => n[0] === t);
    },
    set(t, n) {
      const s = this.data.find((i) => i[0] === t);
      return s ? s[1] = n : this.data.push([t, n]), this;
    },
    get(t) {
      var n;
      return (n = this.data.find((s) => s[0] === t)) == null ? void 0 : n[1];
    },
    delete(t) {
      const n = this.data.findIndex((s) => s[0] === t);
      return n === -1 ? !1 : (this.data.splice(n, 1), !0);
    },
    clear() {
      this.data.splice(0);
    },
    get size() {
      return this.data.length;
    },
    toJSON() {
      return new Map(this.data);
    },
    forEach(t) {
      this.data.forEach((n) => {
        t(n[1], n[0], this);
      });
    },
    keys() {
      return this.data.map((t) => t[0]).values();
    },
    values() {
      return this.data.map((t) => t[1]).values();
    },
    entries() {
      return new Map(this.data).entries();
    },
    get [Symbol.toStringTag]() {
      return "Map";
    },
    [Symbol.iterator]() {
      return this.entries();
    }
  });
  return Object.defineProperties(e, {
    data: {
      enumerable: !1
    },
    size: {
      enumerable: !1
    },
    toJSON: {
      enumerable: !1
    }
  }), Object.seal(e), e;
}
var js = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function P0(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function qT(r) {
  if (r.__esModule) return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(t, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), t;
}
const W = {
  WC_NAME_SUFFIX: ".reown.id",
  WC_NAME_SUFFIX_LEGACY: ".wcn.id",
  BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
  PULSE_API_URL: "https://pulse.walletconnect.org",
  W3M_API_URL: "https://api.web3modal.org",
  CONNECTOR_ID: {
    WALLET_CONNECT: "walletConnect",
    INJECTED: "injected",
    WALLET_STANDARD: "announced",
    COINBASE: "coinbaseWallet",
    COINBASE_SDK: "coinbaseWalletSDK",
    SAFE: "safe",
    LEDGER: "ledger",
    OKX: "okx",
    EIP6963: "eip6963",
    AUTH: "ID_AUTH"
  },
  CONNECTOR_NAMES: {
    AUTH: "Auth"
  },
  AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
  LIMITS: {
    PENDING_TRANSACTIONS: 99
  },
  CHAIN: {
    EVM: "eip155",
    SOLANA: "solana",
    POLKADOT: "polkadot",
    BITCOIN: "bip122"
  },
  CHAIN_NAME_MAP: {
    eip155: "EVM Networks",
    solana: "Solana",
    polkadot: "Polkadot",
    bip122: "Bitcoin",
    cosmos: "Cosmos"
  },
  ADAPTER_TYPES: {
    BITCOIN: "bitcoin",
    SOLANA: "solana",
    WAGMI: "wagmi",
    ETHERS: "ethers",
    ETHERS5: "ethers5"
  },
  USDT_CONTRACT_ADDRESSES: [
    "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
    "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
    "0x919C1c267BC06a7039e03fcc2eF738525769109c",
    "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
    "0x55d398326f99059fF775485246999027B3197955",
    "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9"
  ],
  HTTP_STATUS_CODES: {
    SERVER_ERROR: 500,
    TOO_MANY_REQUESTS: 429,
    SERVICE_UNAVAILABLE: 503,
    FORBIDDEN: 403
  },
  UNSUPPORTED_NETWORK_NAME: "Unknown Network",
  SECURE_SITE_SDK_ORIGIN: (typeof process < "u" && typeof process.env < "u" ? process.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) || "https://secure.walletconnect.org"
}, jC = {
  caipNetworkIdToNumber(r) {
    return r ? Number(r.split(":")[1]) : void 0;
  },
  parseEvmChainId(r) {
    return typeof r == "string" ? this.caipNetworkIdToNumber(r) : r;
  },
  getNetworksByNamespace(r, e) {
    return (r == null ? void 0 : r.filter((t) => t.chainNamespace === e)) || [];
  },
  getFirstNetworkByNamespace(r, e) {
    return this.getNetworksByNamespace(r, e)[0];
  },
  getNetworkNameByCaipNetworkId(r, e) {
    var s;
    if (!e)
      return;
    const t = r.find((i) => i.caipNetworkId === e);
    if (t)
      return t.name;
    const [n] = e.split(":");
    return ((s = W.CHAIN_NAME_MAP) == null ? void 0 : s[n]) || void 0;
  }
};
var WT = 20, VT = 1, cc = 1e6, nE = 1e6, GT = -7, KT = 21, JT = !1, ff = "[big.js] ", Cc = ff + "Invalid ", jg = Cc + "decimal places", YT = Cc + "rounding mode", HC = ff + "Division by zero", lt = {}, Ks = void 0, QT = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function zC() {
  function r(e) {
    var t = this;
    if (!(t instanceof r)) return e === Ks ? zC() : new r(e);
    if (e instanceof r)
      t.s = e.s, t.e = e.e, t.c = e.c.slice();
    else {
      if (typeof e != "string") {
        if (r.strict === !0 && typeof e != "bigint")
          throw TypeError(Cc + "value");
        e = e === 0 && 1 / e < 0 ? "-0" : String(e);
      }
      ZT(t, e);
    }
    t.constructor = r;
  }
  return r.prototype = lt, r.DP = WT, r.RM = VT, r.NE = GT, r.PE = KT, r.strict = JT, r.roundDown = 0, r.roundHalfUp = 1, r.roundHalfEven = 2, r.roundUp = 3, r;
}
function ZT(r, e) {
  var t, n, s;
  if (!QT.test(e))
    throw Error(Cc + "number");
  for (r.s = e.charAt(0) == "-" ? (e = e.slice(1), -1) : 1, (t = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (t < 0 && (t = n), t += +e.slice(n + 1), e = e.substring(0, n)) : t < 0 && (t = e.length), s = e.length, n = 0; n < s && e.charAt(n) == "0"; ) ++n;
  if (n == s)
    r.c = [r.e = 0];
  else {
    for (; s > 0 && e.charAt(--s) == "0"; ) ;
    for (r.e = t - n - 1, r.c = [], t = 0; n <= s; ) r.c[t++] = +e.charAt(n++);
  }
  return r;
}
function _c(r, e, t, n) {
  var s = r.c;
  if (t === Ks && (t = r.constructor.RM), t !== 0 && t !== 1 && t !== 2 && t !== 3)
    throw Error(YT);
  if (e < 1)
    n = t === 3 && (n || !!s[0]) || e === 0 && (t === 1 && s[0] >= 5 || t === 2 && (s[0] > 5 || s[0] === 5 && (n || s[1] !== Ks))), s.length = 1, n ? (r.e = r.e - e + 1, s[0] = 1) : s[0] = r.e = 0;
  else if (e < s.length) {
    if (n = t === 1 && s[e] >= 5 || t === 2 && (s[e] > 5 || s[e] === 5 && (n || s[e + 1] !== Ks || s[e - 1] & 1)) || t === 3 && (n || !!s[0]), s.length = e, n) {
      for (; ++s[--e] > 9; )
        if (s[e] = 0, e === 0) {
          ++r.e, s.unshift(1);
          break;
        }
    }
    for (e = s.length; !s[--e]; ) s.pop();
  }
  return r;
}
function Ic(r, e, t) {
  var n = r.e, s = r.c.join(""), i = s.length;
  if (e)
    s = s.charAt(0) + (i > 1 ? "." + s.slice(1) : "") + (n < 0 ? "e" : "e+") + n;
  else if (n < 0) {
    for (; ++n; ) s = "0" + s;
    s = "0." + s;
  } else if (n > 0)
    if (++n > i)
      for (n -= i; n--; ) s += "0";
    else n < i && (s = s.slice(0, n) + "." + s.slice(n));
  else i > 1 && (s = s.charAt(0) + "." + s.slice(1));
  return r.s < 0 && t ? "-" + s : s;
}
lt.abs = function() {
  var r = new this.constructor(this);
  return r.s = 1, r;
};
lt.cmp = function(r) {
  var e, t = this, n = t.c, s = (r = new t.constructor(r)).c, i = t.s, o = r.s, a = t.e, c = r.e;
  if (!n[0] || !s[0]) return n[0] ? i : s[0] ? -o : 0;
  if (i != o) return i;
  if (e = i < 0, a != c) return a > c ^ e ? 1 : -1;
  for (o = (a = n.length) < (c = s.length) ? a : c, i = -1; ++i < o; )
    if (n[i] != s[i]) return n[i] > s[i] ^ e ? 1 : -1;
  return a == c ? 0 : a > c ^ e ? 1 : -1;
};
lt.div = function(r) {
  var e = this, t = e.constructor, n = e.c, s = (r = new t(r)).c, i = e.s == r.s ? 1 : -1, o = t.DP;
  if (o !== ~~o || o < 0 || o > cc)
    throw Error(jg);
  if (!s[0])
    throw Error(HC);
  if (!n[0])
    return r.s = i, r.c = [r.e = 0], r;
  var a, c, l, u, h, d = s.slice(), f = a = s.length, g = n.length, p = n.slice(0, a), w = p.length, E = r, I = E.c = [], A = 0, C = o + (E.e = e.e - r.e) + 1;
  for (E.s = i, i = C < 0 ? 0 : C, d.unshift(0); w++ < a; ) p.push(0);
  do {
    for (l = 0; l < 10; l++) {
      if (a != (w = p.length))
        u = a > w ? 1 : -1;
      else
        for (h = -1, u = 0; ++h < a; )
          if (s[h] != p[h]) {
            u = s[h] > p[h] ? 1 : -1;
            break;
          }
      if (u < 0) {
        for (c = w == a ? s : d; w; ) {
          if (p[--w] < c[w]) {
            for (h = w; h && !p[--h]; ) p[h] = 9;
            --p[h], p[w] += 10;
          }
          p[w] -= c[w];
        }
        for (; !p[0]; ) p.shift();
      } else
        break;
    }
    I[A++] = u ? l : ++l, p[0] && u ? p[w] = n[f] || 0 : p = [n[f]];
  } while ((f++ < g || p[0] !== Ks) && i--);
  return !I[0] && A != 1 && (I.shift(), E.e--, C--), A > C && _c(E, C, t.RM, p[0] !== Ks), E;
};
lt.eq = function(r) {
  return this.cmp(r) === 0;
};
lt.gt = function(r) {
  return this.cmp(r) > 0;
};
lt.gte = function(r) {
  return this.cmp(r) > -1;
};
lt.lt = function(r) {
  return this.cmp(r) < 0;
};
lt.lte = function(r) {
  return this.cmp(r) < 1;
};
lt.minus = lt.sub = function(r) {
  var e, t, n, s, i = this, o = i.constructor, a = i.s, c = (r = new o(r)).s;
  if (a != c)
    return r.s = -c, i.plus(r);
  var l = i.c.slice(), u = i.e, h = r.c, d = r.e;
  if (!l[0] || !h[0])
    return h[0] ? r.s = -c : l[0] ? r = new o(i) : r.s = 1, r;
  if (a = u - d) {
    for ((s = a < 0) ? (a = -a, n = l) : (d = u, n = h), n.reverse(), c = a; c--; ) n.push(0);
    n.reverse();
  } else
    for (t = ((s = l.length < h.length) ? l : h).length, a = c = 0; c < t; c++)
      if (l[c] != h[c]) {
        s = l[c] < h[c];
        break;
      }
  if (s && (n = l, l = h, h = n, r.s = -r.s), (c = (t = h.length) - (e = l.length)) > 0) for (; c--; ) l[e++] = 0;
  for (c = e; t > a; ) {
    if (l[--t] < h[t]) {
      for (e = t; e && !l[--e]; ) l[e] = 9;
      --l[e], l[t] += 10;
    }
    l[t] -= h[t];
  }
  for (; l[--c] === 0; ) l.pop();
  for (; l[0] === 0; )
    l.shift(), --d;
  return l[0] || (r.s = 1, l = [d = 0]), r.c = l, r.e = d, r;
};
lt.mod = function(r) {
  var e, t = this, n = t.constructor, s = t.s, i = (r = new n(r)).s;
  if (!r.c[0])
    throw Error(HC);
  return t.s = r.s = 1, e = r.cmp(t) == 1, t.s = s, r.s = i, e ? new n(t) : (s = n.DP, i = n.RM, n.DP = n.RM = 0, t = t.div(r), n.DP = s, n.RM = i, this.minus(t.times(r)));
};
lt.neg = function() {
  var r = new this.constructor(this);
  return r.s = -r.s, r;
};
lt.plus = lt.add = function(r) {
  var e, t, n, s = this, i = s.constructor;
  if (r = new i(r), s.s != r.s)
    return r.s = -r.s, s.minus(r);
  var o = s.e, a = s.c, c = r.e, l = r.c;
  if (!a[0] || !l[0])
    return l[0] || (a[0] ? r = new i(s) : r.s = s.s), r;
  if (a = a.slice(), e = o - c) {
    for (e > 0 ? (c = o, n = l) : (e = -e, n = a), n.reverse(); e--; ) n.push(0);
    n.reverse();
  }
  for (a.length - l.length < 0 && (n = l, l = a, a = n), e = l.length, t = 0; e; a[e] %= 10) t = (a[--e] = a[e] + l[e] + t) / 10 | 0;
  for (t && (a.unshift(t), ++c), e = a.length; a[--e] === 0; ) a.pop();
  return r.c = a, r.e = c, r;
};
lt.pow = function(r) {
  var e = this, t = new e.constructor("1"), n = t, s = r < 0;
  if (r !== ~~r || r < -nE || r > nE)
    throw Error(Cc + "exponent");
  for (s && (r = -r); r & 1 && (n = n.times(e)), r >>= 1, !!r; )
    e = e.times(e);
  return s ? t.div(n) : n;
};
lt.prec = function(r, e) {
  if (r !== ~~r || r < 1 || r > cc)
    throw Error(Cc + "precision");
  return _c(new this.constructor(this), r, e);
};
lt.round = function(r, e) {
  if (r === Ks) r = 0;
  else if (r !== ~~r || r < -cc || r > cc)
    throw Error(jg);
  return _c(new this.constructor(this), r + this.e + 1, e);
};
lt.sqrt = function() {
  var r, e, t, n = this, s = n.constructor, i = n.s, o = n.e, a = new s("0.5");
  if (!n.c[0]) return new s(n);
  if (i < 0)
    throw Error(ff + "No square root");
  i = Math.sqrt(+Ic(n, !0, !0)), i === 0 || i === 1 / 0 ? (e = n.c.join(""), e.length + o & 1 || (e += "0"), i = Math.sqrt(e), o = ((o + 1) / 2 | 0) - (o < 0 || o & 1), r = new s((i == 1 / 0 ? "5e" : (i = i.toExponential()).slice(0, i.indexOf("e") + 1)) + o)) : r = new s(i + ""), o = r.e + (s.DP += 4);
  do
    t = r, r = a.times(t.plus(n.div(t)));
  while (t.c.slice(0, o).join("") !== r.c.slice(0, o).join(""));
  return _c(r, (s.DP -= 4) + r.e + 1, s.RM);
};
lt.times = lt.mul = function(r) {
  var e, t = this, n = t.constructor, s = t.c, i = (r = new n(r)).c, o = s.length, a = i.length, c = t.e, l = r.e;
  if (r.s = t.s == r.s ? 1 : -1, !s[0] || !i[0])
    return r.c = [r.e = 0], r;
  for (r.e = c + l, o < a && (e = s, s = i, i = e, l = o, o = a, a = l), e = new Array(l = o + a); l--; ) e[l] = 0;
  for (c = a; c--; ) {
    for (a = 0, l = o + c; l > c; )
      a = e[l] + i[c] * s[l - c - 1] + a, e[l--] = a % 10, a = a / 10 | 0;
    e[l] = a;
  }
  for (a ? ++r.e : e.shift(), c = e.length; !e[--c]; ) e.pop();
  return r.c = e, r;
};
lt.toExponential = function(r, e) {
  var t = this, n = t.c[0];
  if (r !== Ks) {
    if (r !== ~~r || r < 0 || r > cc)
      throw Error(jg);
    for (t = _c(new t.constructor(t), ++r, e); t.c.length < r; ) t.c.push(0);
  }
  return Ic(t, !0, !!n);
};
lt.toFixed = function(r, e) {
  var t = this, n = t.c[0];
  if (r !== Ks) {
    if (r !== ~~r || r < 0 || r > cc)
      throw Error(jg);
    for (t = _c(new t.constructor(t), r + t.e + 1, e), r = r + t.e + 1; t.c.length < r; ) t.c.push(0);
  }
  return Ic(t, !1, !!n);
};
lt[Symbol.for("nodejs.util.inspect.custom")] = lt.toJSON = lt.toString = function() {
  var r = this, e = r.constructor;
  return Ic(r, r.e <= e.NE || r.e >= e.PE, !!r.c[0]);
};
lt.toNumber = function() {
  var r = +Ic(this, !0, !0);
  if (this.constructor.strict === !0 && !this.eq(r.toString()))
    throw Error(ff + "Imprecise conversion");
  return r;
};
lt.toPrecision = function(r, e) {
  var t = this, n = t.constructor, s = t.c[0];
  if (r !== Ks) {
    if (r !== ~~r || r < 1 || r > cc)
      throw Error(Cc + "precision");
    for (t = _c(new n(t), r, e); t.c.length < r; ) t.c.push(0);
  }
  return Ic(t, r <= t.e || t.e <= n.NE || t.e >= n.PE, !!s);
};
lt.valueOf = function() {
  var r = this, e = r.constructor;
  if (e.strict === !0)
    throw Error(ff + "valueOf disallowed");
  return Ic(r, r.e <= e.NE || r.e >= e.PE, !0);
};
var Yu = zC();
const XT = {
  bigNumber(r) {
    return r ? new Yu(r) : new Yu(0);
  },
  multiply(r, e) {
    if (r === void 0 || e === void 0)
      return new Yu(0);
    const t = new Yu(r), n = new Yu(e);
    return t.times(n);
  },
  formatNumberToLocalString(r, e = 2) {
    return r === void 0 ? "0.00" : typeof r == "number" ? r.toLocaleString("en-US", {
      maximumFractionDigits: e,
      minimumFractionDigits: e
    }) : parseFloat(r).toLocaleString("en-US", {
      maximumFractionDigits: e,
      minimumFractionDigits: e
    });
  },
  parseLocalStringToNumber(r) {
    return r === void 0 ? 0 : parseFloat(r.replace(/,/gu, ""));
  }
}, ex = [
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
], tx = [
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    outputs: [{ type: "bool" }]
  }
], rx = [
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
], nx = {
  getERC20Abi: (r) => W.USDT_CONTRACT_ADDRESSES.includes(r) ? rx : ex,
  getSwapAbi: () => tx
}, tn = {
  validateCaipAddress(r) {
    var e;
    if (((e = r.split(":")) == null ? void 0 : e.length) !== 3)
      throw new Error("Invalid CAIP Address");
    return r;
  },
  parseCaipAddress(r) {
    const e = r.split(":");
    if (e.length !== 3)
      throw new Error(`Invalid CAIP-10 address: ${r}`);
    const [t, n, s] = e;
    if (!t || !n || !s)
      throw new Error(`Invalid CAIP-10 address: ${r}`);
    return {
      chainNamespace: t,
      chainId: n,
      address: s
    };
  },
  parseCaipNetworkId(r) {
    const e = r.split(":");
    if (e.length !== 2)
      throw new Error(`Invalid CAIP-2 network id: ${r}`);
    const [t, n] = e;
    if (!t || !n)
      throw new Error(`Invalid CAIP-2 network id: ${r}`);
    return {
      chainNamespace: t,
      chainId: n
    };
  }
}, Se = {
  WALLET_ID: "@appkit/wallet_id",
  WALLET_NAME: "@appkit/wallet_name",
  SOLANA_WALLET: "@appkit/solana_wallet",
  SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
  ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
  CONNECTED_SOCIAL: "@appkit/connected_social",
  CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
  RECENT_WALLETS: "@appkit/recent_wallets",
  DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
  ACTIVE_NAMESPACE: "@appkit/active_namespace",
  CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
  CONNECTION_STATUS: "@appkit/connection_status",
  SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
  SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
  TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
  NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
  PORTFOLIO_CACHE: "@appkit/portfolio_cache",
  ENS_CACHE: "@appkit/ens_cache",
  IDENTITY_CACHE: "@appkit/identity_cache",
  PREFERRED_ACCOUNT_TYPES: "@appkit/preferred_account_types",
  CONNECTIONS: "@appkit/connections",
  DISCONNECTED_CONNECTOR_IDS: "@appkit/disconnected_connector_ids"
};
function Im(r) {
  if (!r)
    throw new Error("Namespace is required for CONNECTED_CONNECTOR_ID");
  return `@appkit/${r}:connected_connector_id`;
}
const _e = {
  setItem(r, e) {
    vh() && e !== void 0 && localStorage.setItem(r, e);
  },
  getItem(r) {
    if (vh())
      return localStorage.getItem(r) || void 0;
  },
  removeItem(r) {
    vh() && localStorage.removeItem(r);
  },
  clear() {
    vh() && localStorage.clear();
  }
};
function vh() {
  return typeof window < "u" && typeof localStorage < "u";
}
function Ri(r, e) {
  return e === "light" ? {
    "--w3m-accent": (r == null ? void 0 : r["--w3m-accent"]) || "hsla(231, 100%, 70%, 1)",
    "--w3m-background": "#fff"
  } : {
    "--w3m-accent": (r == null ? void 0 : r["--w3m-accent"]) || "hsla(230, 100%, 67%, 1)",
    "--w3m-background": "#121313"
  };
}
const Sm = (
  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
  (typeof process < "u" && typeof process.env < "u" ? process.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) || "https://secure.walletconnect.org"
), qC = [
  {
    label: "Meld.io",
    name: "meld",
    feeRange: "1-2%",
    url: "https://meldcrypto.com",
    supportedChains: ["eip155", "solana"]
  },
  {
    label: "Coinbase",
    name: "coinbase",
    feeRange: "1-2%",
    url: "",
    supportedChains: ["eip155"]
  }
], sx = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU", at = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  FIVE_SEC_MS: 5e3,
  THREE_SEC_MS: 3e3,
  ONE_SEC_MS: 1e3,
  SECURE_SITE: Sm,
  SECURE_SITE_DASHBOARD: `${Sm}/dashboard`,
  SECURE_SITE_FAVICON: `${Sm}/images/favicon.png`,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  /**
   * Network name to Coinbase Pay SDK chain name map object
   * @see supported chain names on Coinbase for Pay SDK: https://github.com/coinbase/cbpay-js/blob/d4bda2c05c4d5917c8db6a05476b603546046394/src/types/onramp.ts
   */
  WC_COINBASE_PAY_SDK_CHAINS: [
    "ethereum",
    "arbitrum",
    "polygon",
    "berachain",
    "avalanche-c-chain",
    "optimism",
    "celo",
    "base"
  ],
  WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
  WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
    Ethereum: "ethereum",
    "Arbitrum One": "arbitrum",
    Polygon: "polygon",
    Berachain: "berachain",
    Avalanche: "avalanche-c-chain",
    "OP Mainnet": "optimism",
    Celo: "celo",
    Base: "base"
  },
  WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
  SWAP_SUGGESTED_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP"
  ],
  SWAP_POPULAR_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP",
    "METAL",
    "DAI",
    "CHAMP",
    "WOLF",
    "SALE",
    "BAL",
    "BUSD",
    "MUST",
    "BTCpx",
    "ROUTE",
    "HEX",
    "WELT",
    "amDAI",
    "VSQ",
    "VISION",
    "AURUM",
    "pSP",
    "SNX",
    "VC",
    "LINK",
    "CHP",
    "amUSDT",
    "SPHERE",
    "FOX",
    "GIDDY",
    "GFC",
    "OMEN",
    "OX_OLD",
    "DE",
    "WNT"
  ],
  BALANCE_SUPPORTED_CHAINS: ["eip155", "solana"],
  SWAP_SUPPORTED_NETWORKS: [
    // Ethereum'
    "eip155:1",
    // Arbitrum One'
    "eip155:42161",
    // Optimism'
    "eip155:10",
    // ZKSync Era'
    "eip155:324",
    // Base'
    "eip155:8453",
    // BNB Smart Chain'
    "eip155:56",
    // Polygon'
    "eip155:137",
    // Gnosis'
    "eip155:100",
    // Avalanche'
    "eip155:43114",
    // Fantom'
    "eip155:250",
    // Klaytn'
    "eip155:8217",
    // Aurora
    "eip155:1313161554"
  ],
  NAMES_SUPPORTED_CHAIN_NAMESPACES: ["eip155"],
  ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ["eip155", "solana"],
  ACTIVITY_ENABLED_CHAIN_NAMESPACES: ["eip155"],
  NATIVE_TOKEN_ADDRESS: {
    eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    solana: "So11111111111111111111111111111111111111111",
    polkadot: "0x",
    bip122: "0x",
    cosmos: "0x"
  },
  CONVERT_SLIPPAGE_TOLERANCE: 1,
  CONNECT_LABELS: {
    MOBILE: "Open and continue in the wallet app",
    WEB: "Open and continue in the wallet app"
  },
  SEND_SUPPORTED_NAMESPACES: ["eip155", "solana"],
  DEFAULT_REMOTE_FEATURES: {
    swaps: ["1inch"],
    onramp: ["meld", "coinbase"],
    email: !0,
    socials: [
      "google",
      "x",
      "discord",
      "farcaster",
      "github",
      "apple",
      "facebook"
    ],
    activity: !0,
    reownBranding: !0
  },
  DEFAULT_REMOTE_FEATURES_DISABLED: {
    email: !1,
    socials: !1,
    swaps: !1,
    onramp: !1,
    activity: !1,
    reownBranding: !1
  },
  DEFAULT_FEATURES: {
    receive: !0,
    send: !0,
    emailShowWallets: !0,
    connectorTypeOrder: [
      "walletConnect",
      "recent",
      "injected",
      "featured",
      "custom",
      "external",
      "recommended"
    ],
    analytics: !0,
    allWallets: !0,
    legalCheckbox: !1,
    smartSessions: !1,
    collapseWallets: !1,
    walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
    connectMethodsOrder: void 0,
    pay: !1
  },
  DEFAULT_SOCIALS: [
    "google",
    "x",
    "farcaster",
    "discord",
    "apple",
    "github",
    "facebook"
  ],
  DEFAULT_ACCOUNT_TYPES: {
    bip122: "payment",
    eip155: "smartAccount",
    polkadot: "eoa",
    solana: "eoa"
  },
  ADAPTER_TYPES: {
    UNIVERSAL: "universal",
    SOLANA: "solana",
    WAGMI: "wagmi",
    ETHERS: "ethers",
    ETHERS5: "ethers5",
    BITCOIN: "bitcoin"
  }
}, te = {
  // Cache expiry in milliseconds
  cacheExpiry: {
    portfolio: 3e4,
    nativeBalance: 3e4,
    ens: 3e5,
    identity: 3e5
  },
  isCacheExpired(r, e) {
    return Date.now() - r > e;
  },
  getActiveNetworkProps() {
    const r = te.getActiveNamespace(), e = te.getActiveCaipNetworkId(), t = e ? e.split(":")[1] : void 0, n = t ? isNaN(Number(t)) ? t : Number(t) : void 0;
    return {
      namespace: r,
      caipNetworkId: e,
      chainId: n
    };
  },
  setWalletConnectDeepLink({ name: r, href: e }) {
    try {
      _e.setItem(Se.DEEPLINK_CHOICE, JSON.stringify({ href: e, name: r }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const r = _e.getItem(Se.DEEPLINK_CHOICE);
      if (r)
        return JSON.parse(r);
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
  },
  deleteWalletConnectDeepLink() {
    try {
      _e.removeItem(Se.DEEPLINK_CHOICE);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setActiveNamespace(r) {
    try {
      _e.setItem(Se.ACTIVE_NAMESPACE, r);
    } catch {
      console.info("Unable to set active namespace");
    }
  },
  setActiveCaipNetworkId(r) {
    try {
      _e.setItem(Se.ACTIVE_CAIP_NETWORK_ID, r), te.setActiveNamespace(r.split(":")[0]);
    } catch {
      console.info("Unable to set active caip network id");
    }
  },
  getActiveCaipNetworkId() {
    try {
      return _e.getItem(Se.ACTIVE_CAIP_NETWORK_ID);
    } catch {
      console.info("Unable to get active caip network id");
      return;
    }
  },
  deleteActiveCaipNetworkId() {
    try {
      _e.removeItem(Se.ACTIVE_CAIP_NETWORK_ID);
    } catch {
      console.info("Unable to delete active caip network id");
    }
  },
  deleteConnectedConnectorId(r) {
    try {
      const e = Im(r);
      _e.removeItem(e);
    } catch {
      console.info("Unable to delete connected connector id");
    }
  },
  setAppKitRecent(r) {
    try {
      const e = te.getRecentWallets();
      e.find((n) => n.id === r.id) || (e.unshift(r), e.length > 2 && e.pop(), _e.setItem(Se.RECENT_WALLETS, JSON.stringify(e)));
    } catch {
      console.info("Unable to set AppKit recent");
    }
  },
  getRecentWallets() {
    try {
      const r = _e.getItem(Se.RECENT_WALLETS);
      return r ? JSON.parse(r) : [];
    } catch {
      console.info("Unable to get AppKit recent");
    }
    return [];
  },
  setConnectedConnectorId(r, e) {
    try {
      const t = Im(r);
      _e.setItem(t, e);
    } catch {
      console.info("Unable to set Connected Connector Id");
    }
  },
  getActiveNamespace() {
    try {
      return _e.getItem(Se.ACTIVE_NAMESPACE);
    } catch {
      console.info("Unable to get active namespace");
    }
  },
  getConnectedConnectorId(r) {
    if (r)
      try {
        const e = Im(r);
        return _e.getItem(e);
      } catch {
        console.info("Unable to get connected connector id in namespace", r);
      }
  },
  setConnectedSocialProvider(r) {
    try {
      _e.setItem(Se.CONNECTED_SOCIAL, r);
    } catch {
      console.info("Unable to set connected social provider");
    }
  },
  getConnectedSocialProvider() {
    try {
      return _e.getItem(Se.CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to get connected social provider");
    }
  },
  deleteConnectedSocialProvider() {
    try {
      _e.removeItem(Se.CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to delete connected social provider");
    }
  },
  getConnectedSocialUsername() {
    try {
      return _e.getItem(Se.CONNECTED_SOCIAL_USERNAME);
    } catch {
      console.info("Unable to get connected social username");
    }
  },
  getStoredActiveCaipNetworkId() {
    var t;
    const r = _e.getItem(Se.ACTIVE_CAIP_NETWORK_ID);
    return (t = r == null ? void 0 : r.split(":")) == null ? void 0 : t[1];
  },
  setConnectionStatus(r) {
    try {
      _e.setItem(Se.CONNECTION_STATUS, r);
    } catch {
      console.info("Unable to set connection status");
    }
  },
  getConnectionStatus() {
    try {
      return _e.getItem(Se.CONNECTION_STATUS);
    } catch {
      return;
    }
  },
  getConnectedNamespaces() {
    try {
      const r = _e.getItem(Se.CONNECTED_NAMESPACES);
      return r != null && r.length ? r.split(",") : [];
    } catch {
      return [];
    }
  },
  setConnectedNamespaces(r) {
    try {
      const e = Array.from(new Set(r));
      _e.setItem(Se.CONNECTED_NAMESPACES, e.join(","));
    } catch {
      console.info("Unable to set namespaces in storage");
    }
  },
  addConnectedNamespace(r) {
    try {
      const e = te.getConnectedNamespaces();
      e.includes(r) || (e.push(r), te.setConnectedNamespaces(e));
    } catch {
      console.info("Unable to add connected namespace");
    }
  },
  removeConnectedNamespace(r) {
    try {
      const e = te.getConnectedNamespaces(), t = e.indexOf(r);
      t > -1 && (e.splice(t, 1), te.setConnectedNamespaces(e));
    } catch {
      console.info("Unable to remove connected namespace");
    }
  },
  getTelegramSocialProvider() {
    try {
      return _e.getItem(Se.TELEGRAM_SOCIAL_PROVIDER);
    } catch {
      return console.info("Unable to get telegram social provider"), null;
    }
  },
  setTelegramSocialProvider(r) {
    try {
      _e.setItem(Se.TELEGRAM_SOCIAL_PROVIDER, r);
    } catch {
      console.info("Unable to set telegram social provider");
    }
  },
  removeTelegramSocialProvider() {
    try {
      _e.removeItem(Se.TELEGRAM_SOCIAL_PROVIDER);
    } catch {
      console.info("Unable to remove telegram social provider");
    }
  },
  getBalanceCache() {
    let r = {};
    try {
      const e = _e.getItem(Se.PORTFOLIO_CACHE);
      r = e ? JSON.parse(e) : {};
    } catch {
      console.info("Unable to get balance cache");
    }
    return r;
  },
  removeAddressFromBalanceCache(r) {
    try {
      const e = te.getBalanceCache();
      _e.setItem(Se.PORTFOLIO_CACHE, JSON.stringify({ ...e, [r]: void 0 }));
    } catch {
      console.info("Unable to remove address from balance cache", r);
    }
  },
  getBalanceCacheForCaipAddress(r) {
    try {
      const t = te.getBalanceCache()[r];
      if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.portfolio))
        return t.balance;
      te.removeAddressFromBalanceCache(r);
    } catch {
      console.info("Unable to get balance cache for address", r);
    }
  },
  updateBalanceCache(r) {
    try {
      const e = te.getBalanceCache();
      e[r.caipAddress] = r, _e.setItem(Se.PORTFOLIO_CACHE, JSON.stringify(e));
    } catch {
      console.info("Unable to update balance cache", r);
    }
  },
  getNativeBalanceCache() {
    let r = {};
    try {
      const e = _e.getItem(Se.NATIVE_BALANCE_CACHE);
      r = e ? JSON.parse(e) : {};
    } catch {
      console.info("Unable to get balance cache");
    }
    return r;
  },
  removeAddressFromNativeBalanceCache(r) {
    try {
      const e = te.getBalanceCache();
      _e.setItem(Se.NATIVE_BALANCE_CACHE, JSON.stringify({ ...e, [r]: void 0 }));
    } catch {
      console.info("Unable to remove address from balance cache", r);
    }
  },
  getNativeBalanceCacheForCaipAddress(r) {
    try {
      const t = te.getNativeBalanceCache()[r];
      if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.nativeBalance))
        return t;
      console.info("Discarding cache for address", r), te.removeAddressFromBalanceCache(r);
    } catch {
      console.info("Unable to get balance cache for address", r);
    }
  },
  updateNativeBalanceCache(r) {
    try {
      const e = te.getNativeBalanceCache();
      e[r.caipAddress] = r, _e.setItem(Se.NATIVE_BALANCE_CACHE, JSON.stringify(e));
    } catch {
      console.info("Unable to update balance cache", r);
    }
  },
  getEnsCache() {
    let r = {};
    try {
      const e = _e.getItem(Se.ENS_CACHE);
      r = e ? JSON.parse(e) : {};
    } catch {
      console.info("Unable to get ens name cache");
    }
    return r;
  },
  getEnsFromCacheForAddress(r) {
    try {
      const t = te.getEnsCache()[r];
      if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.ens))
        return t.ens;
      te.removeEnsFromCache(r);
    } catch {
      console.info("Unable to get ens name from cache", r);
    }
  },
  updateEnsCache(r) {
    try {
      const e = te.getEnsCache();
      e[r.address] = r, _e.setItem(Se.ENS_CACHE, JSON.stringify(e));
    } catch {
      console.info("Unable to update ens name cache", r);
    }
  },
  removeEnsFromCache(r) {
    try {
      const e = te.getEnsCache();
      _e.setItem(Se.ENS_CACHE, JSON.stringify({ ...e, [r]: void 0 }));
    } catch {
      console.info("Unable to remove ens name from cache", r);
    }
  },
  getIdentityCache() {
    let r = {};
    try {
      const e = _e.getItem(Se.IDENTITY_CACHE);
      r = e ? JSON.parse(e) : {};
    } catch {
      console.info("Unable to get identity cache");
    }
    return r;
  },
  getIdentityFromCacheForAddress(r) {
    try {
      const t = te.getIdentityCache()[r];
      if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.identity))
        return t.identity;
      te.removeIdentityFromCache(r);
    } catch {
      console.info("Unable to get identity from cache", r);
    }
  },
  updateIdentityCache(r) {
    try {
      const e = te.getIdentityCache();
      e[r.address] = {
        identity: r.identity,
        timestamp: r.timestamp
      }, _e.setItem(Se.IDENTITY_CACHE, JSON.stringify(e));
    } catch {
      console.info("Unable to update identity cache", r);
    }
  },
  removeIdentityFromCache(r) {
    try {
      const e = te.getIdentityCache();
      _e.setItem(Se.IDENTITY_CACHE, JSON.stringify({ ...e, [r]: void 0 }));
    } catch {
      console.info("Unable to remove identity from cache", r);
    }
  },
  clearAddressCache() {
    try {
      _e.removeItem(Se.PORTFOLIO_CACHE), _e.removeItem(Se.NATIVE_BALANCE_CACHE), _e.removeItem(Se.ENS_CACHE), _e.removeItem(Se.IDENTITY_CACHE);
    } catch {
      console.info("Unable to clear address cache");
    }
  },
  setPreferredAccountTypes(r) {
    try {
      _e.setItem(Se.PREFERRED_ACCOUNT_TYPES, JSON.stringify(r));
    } catch {
      console.info("Unable to set preferred account types", r);
    }
  },
  getPreferredAccountTypes() {
    try {
      const r = _e.getItem(Se.PREFERRED_ACCOUNT_TYPES);
      return r ? JSON.parse(r) : {};
    } catch {
      console.info("Unable to get preferred account types");
    }
    return {};
  },
  setConnections(r, e) {
    try {
      const t = te.getConnections(), n = t[e] ?? [], s = /* @__PURE__ */ new Map();
      for (const o of n)
        s.set(o.connectorId, { ...o });
      for (const o of r) {
        const a = s.get(o.connectorId), c = o.connectorId === W.CONNECTOR_ID.AUTH;
        if (a && !c) {
          const l = new Set(a.accounts.map((h) => h.address.toLowerCase())), u = o.accounts.filter((h) => !l.has(h.address.toLowerCase()));
          a.accounts.push(...u);
        } else
          s.set(o.connectorId, { ...o });
      }
      const i = {
        ...t,
        [e]: Array.from(s.values())
      };
      _e.setItem(Se.CONNECTIONS, JSON.stringify(i));
    } catch (t) {
      console.error("Unable to sync connections to storage", t);
    }
  },
  getConnections() {
    try {
      const r = _e.getItem(Se.CONNECTIONS);
      return r ? JSON.parse(r) : {};
    } catch (r) {
      return console.error("Unable to get connections from storage", r), {};
    }
  },
  deleteAddressFromConnection({ connectorId: r, address: e, namespace: t }) {
    try {
      const n = te.getConnections(), s = n[t] ?? [], i = new Map(s.map((a) => [a.connectorId, a])), o = i.get(r);
      o && (o.accounts.filter((c) => c.address.toLowerCase() !== e.toLowerCase()).length === 0 ? i.delete(r) : i.set(r, {
        ...o,
        accounts: o.accounts.filter((c) => c.address.toLowerCase() !== e.toLowerCase())
      })), _e.setItem(Se.CONNECTIONS, JSON.stringify({
        ...n,
        [t]: Array.from(i.values())
      }));
    } catch {
      console.error(`Unable to remove address "${e}" from connector "${r}" in namespace "${t}"`);
    }
  },
  getDisconnectedConnectorIds() {
    try {
      const r = _e.getItem(Se.DISCONNECTED_CONNECTOR_IDS);
      return r ? JSON.parse(r) : {};
    } catch {
      console.info("Unable to get disconnected connector ids");
    }
    return {};
  },
  addDisconnectedConnectorId(r, e) {
    try {
      const t = te.getDisconnectedConnectorIds(), n = t[e] ?? [];
      n.push(r), _e.setItem(Se.DISCONNECTED_CONNECTOR_IDS, JSON.stringify({
        ...t,
        [e]: Array.from(new Set(n))
      }));
    } catch {
      console.error(`Unable to set disconnected connector id "${r}" for namespace "${e}"`);
    }
  },
  removeDisconnectedConnectorId(r, e) {
    try {
      const t = te.getDisconnectedConnectorIds();
      let n = t[e] ?? [];
      n = n.filter((s) => s.toLowerCase() !== r.toLowerCase()), _e.setItem(Se.DISCONNECTED_CONNECTOR_IDS, JSON.stringify({
        ...t,
        [e]: Array.from(new Set(n))
      }));
    } catch {
      console.error(`Unable to remove disconnected connector id "${r}" for namespace "${e}"`);
    }
  },
  isConnectorDisconnected(r, e) {
    try {
      return (te.getDisconnectedConnectorIds()[e] ?? []).some((s) => s.toLowerCase() === r.toLowerCase());
    } catch {
      console.info(`Unable to get disconnected connector id "${r}" for namespace "${e}"`);
    }
    return !1;
  }
}, me = {
  isMobile() {
    var r;
    return this.isClient() ? !!(window != null && window.matchMedia && typeof window.matchMedia == "function" && ((r = window.matchMedia("(pointer:coarse)")) != null && r.matches) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
  },
  checkCaipNetwork(r, e = "") {
    return r == null ? void 0 : r.caipNetworkId.toLocaleLowerCase().includes(e.toLowerCase());
  },
  isAndroid() {
    if (!this.isMobile())
      return !1;
    const r = window == null ? void 0 : window.navigator.userAgent.toLowerCase();
    return me.isMobile() && r.includes("android");
  },
  isIos() {
    if (!this.isMobile())
      return !1;
    const r = window == null ? void 0 : window.navigator.userAgent.toLowerCase();
    return r.includes("iphone") || r.includes("ipad");
  },
  isSafari() {
    return this.isClient() ? (window == null ? void 0 : window.navigator.userAgent.toLowerCase()).includes("safari") : !1;
  },
  isClient() {
    return typeof window < "u";
  },
  isPairingExpired(r) {
    return r ? r - Date.now() <= at.TEN_SEC_MS : !0;
  },
  isAllowedRetry(r, e = at.ONE_SEC_MS) {
    return Date.now() - r >= e;
  },
  copyToClopboard(r) {
    navigator.clipboard.writeText(r);
  },
  isIframe() {
    try {
      return (window == null ? void 0 : window.self) !== (window == null ? void 0 : window.top);
    } catch {
      return !1;
    }
  },
  isSafeApp() {
    var r, e;
    if (me.isClient() && window.self !== window.top)
      try {
        const t = (e = (r = window == null ? void 0 : window.location) == null ? void 0 : r.ancestorOrigins) == null ? void 0 : e[0], n = "https://app.safe.global";
        if (t) {
          const s = new URL(t), i = new URL(n);
          return s.hostname === i.hostname;
        }
      } catch {
        return !1;
      }
    return !1;
  },
  getPairingExpiry() {
    return Date.now() + at.FOUR_MINUTES_MS;
  },
  getNetworkId(r) {
    return r == null ? void 0 : r.split(":")[1];
  },
  getPlainAddress(r) {
    return r == null ? void 0 : r.split(":")[2];
  },
  async wait(r) {
    return new Promise((e) => {
      setTimeout(e, r);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debounce(r, e = 500) {
    let t;
    return (...n) => {
      function s() {
        r(...n);
      }
      t && clearTimeout(t), t = setTimeout(s, e);
    };
  },
  isHttpUrl(r) {
    return r.startsWith("http://") || r.startsWith("https://");
  },
  formatNativeUrl(r, e, t = null) {
    if (me.isHttpUrl(r))
      return this.formatUniversalUrl(r, e);
    let n = r, s = t;
    n.includes("://") || (n = r.replaceAll("/", "").replaceAll(":", ""), n = `${n}://`), n.endsWith("/") || (n = `${n}/`), s && !(s != null && s.endsWith("/")) && (s = `${s}/`), this.isTelegram() && this.isAndroid() && (e = encodeURIComponent(e));
    const i = encodeURIComponent(e);
    return {
      redirect: `${n}wc?uri=${i}`,
      redirectUniversalLink: s ? `${s}wc?uri=${i}` : void 0,
      href: n
    };
  },
  formatUniversalUrl(r, e) {
    if (!me.isHttpUrl(r))
      return this.formatNativeUrl(r, e);
    let t = r;
    t.endsWith("/") || (t = `${t}/`);
    const n = encodeURIComponent(e);
    return {
      redirect: `${t}wc?uri=${n}`,
      href: t
    };
  },
  getOpenTargetForPlatform(r) {
    return r === "popupWindow" ? r : this.isTelegram() ? te.getTelegramSocialProvider() ? "_top" : "_blank" : r;
  },
  openHref(r, e, t) {
    window == null || window.open(r, this.getOpenTargetForPlatform(e), t || "noreferrer noopener");
  },
  returnOpenHref(r, e, t) {
    return window == null ? void 0 : window.open(r, this.getOpenTargetForPlatform(e), t || "noreferrer noopener");
  },
  isTelegram() {
    return typeof window < "u" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (!!window.TelegramWebviewProxy || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    !!window.Telegram || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    !!window.TelegramWebviewProxyProto);
  },
  isPWA() {
    var t, n;
    if (typeof window > "u")
      return !1;
    const r = window != null && window.matchMedia && typeof window.matchMedia == "function" ? (t = window.matchMedia("(display-mode: standalone)")) == null ? void 0 : t.matches : !1, e = (n = window == null ? void 0 : window.navigator) == null ? void 0 : n.standalone;
    return !!(r || e);
  },
  async preloadImage(r) {
    const e = new Promise((t, n) => {
      const s = new Image();
      s.onload = t, s.onerror = n, s.crossOrigin = "anonymous", s.src = r;
    });
    return Promise.race([e, me.wait(2e3)]);
  },
  formatBalance(r, e) {
    let t = "0.000";
    if (typeof r == "string") {
      const n = Number(r);
      if (n) {
        const s = Math.floor(n * 1e3) / 1e3;
        s && (t = s.toString());
      }
    }
    return `${t}${e ? ` ${e}` : ""}`;
  },
  formatBalance2(r, e) {
    var n;
    let t;
    if (r === "0")
      t = "0";
    else if (typeof r == "string") {
      const s = Number(r);
      s && (t = (n = s.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : n[0]);
    }
    return {
      value: t ?? "0",
      rest: t === "0" ? "000" : "",
      symbol: e
    };
  },
  getApiUrl() {
    return W.W3M_API_URL;
  },
  getBlockchainApiUrl() {
    return W.BLOCKCHAIN_API_RPC_URL;
  },
  getAnalyticsUrl() {
    return W.PULSE_API_URL;
  },
  getUUID() {
    return crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (r) => {
      const e = Math.random() * 16 | 0;
      return (r === "x" ? e : e & 3 | 8).toString(16);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseError(r) {
    var e, t;
    return typeof r == "string" ? r : typeof ((t = (e = r == null ? void 0 : r.issues) == null ? void 0 : e[0]) == null ? void 0 : t.message) == "string" ? r.issues[0].message : r instanceof Error ? r.message : "Unknown error";
  },
  sortRequestedNetworks(r, e = []) {
    const t = {};
    return e && r && (r.forEach((n, s) => {
      t[n] = s;
    }), e.sort((n, s) => {
      const i = t[n.id], o = t[s.id];
      return i !== void 0 && o !== void 0 ? i - o : i !== void 0 ? -1 : o !== void 0 ? 1 : 0;
    })), e;
  },
  calculateBalance(r) {
    let e = 0;
    for (const t of r)
      e += t.value ?? 0;
    return e;
  },
  formatTokenBalance(r) {
    const e = r.toFixed(2), [t, n] = e.split(".");
    return { dollars: t, pennies: n };
  },
  isAddress(r, e = "eip155") {
    switch (e) {
      case "eip155":
        if (/^(?:0x)?[0-9a-f]{40}$/iu.test(r)) {
          if (/^(?:0x)?[0-9a-f]{40}$/iu.test(r) || /^(?:0x)?[0-9A-F]{40}$/iu.test(r))
            return !0;
        } else return !1;
        return !1;
      case "solana":
        return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(r);
      default:
        return !1;
    }
  },
  uniqueBy(r, e) {
    const t = /* @__PURE__ */ new Set();
    return r.filter((n) => {
      const s = n[e];
      return t.has(s) ? !1 : (t.add(s), !0);
    });
  },
  generateSdkVersion(r, e, t) {
    const s = r.length === 0 ? at.ADAPTER_TYPES.UNIVERSAL : r.map((i) => i.adapterType).join(",");
    return `${e}-${s}-${t}`;
  },
  // eslint-disable-next-line max-params
  createAccount(r, e, t, n, s) {
    return {
      namespace: r,
      address: e,
      type: t,
      publicKey: n,
      path: s
    };
  },
  isCaipAddress(r) {
    if (typeof r != "string")
      return !1;
    const e = r.split(":"), t = e[0];
    return e.filter(Boolean).length === 3 && t in W.CHAIN_NAME_MAP;
  },
  isMac() {
    const r = window == null ? void 0 : window.navigator.userAgent.toLowerCase();
    return r.includes("macintosh") && !r.includes("safari");
  },
  formatTelegramSocialLoginUrl(r) {
    const e = `--${encodeURIComponent(window == null ? void 0 : window.location.href)}`, t = "state=";
    if (new URL(r).host === "auth.magic.link") {
      const s = "provider_authorization_url=", i = r.substring(r.indexOf(s) + s.length), o = this.injectIntoUrl(decodeURIComponent(i), t, e);
      return r.replace(i, encodeURIComponent(o));
    }
    return this.injectIntoUrl(r, t, e);
  },
  injectIntoUrl(r, e, t) {
    const n = r.indexOf(e);
    if (n === -1)
      throw new Error(`${e} parameter not found in the URL: ${r}`);
    const s = r.indexOf("&", n), i = e.length, o = s !== -1 ? s : r.length, a = r.substring(0, n + i), c = r.substring(n + i, o), l = r.substring(s), u = c + t;
    return a + u + l;
  }
};
async function Qu(...r) {
  const e = await fetch(...r);
  if (!e.ok)
    throw new Error(`HTTP status code: ${e.status}`, {
      cause: e
    });
  return e;
}
class pf {
  constructor({ baseUrl: e, clientId: t }) {
    this.baseUrl = e, this.clientId = t;
  }
  async get({ headers: e, signal: t, cache: n, ...s }) {
    const i = this.createUrl(s);
    return (await Qu(i, { method: "GET", headers: e, signal: t, cache: n })).json();
  }
  async getBlob({ headers: e, signal: t, ...n }) {
    const s = this.createUrl(n);
    return (await Qu(s, { method: "GET", headers: e, signal: t })).blob();
  }
  async post({ body: e, headers: t, signal: n, ...s }) {
    const i = this.createUrl(s);
    return (await Qu(i, {
      method: "POST",
      headers: t,
      body: e ? JSON.stringify(e) : void 0,
      signal: n
    })).json();
  }
  async put({ body: e, headers: t, signal: n, ...s }) {
    const i = this.createUrl(s);
    return (await Qu(i, {
      method: "PUT",
      headers: t,
      body: e ? JSON.stringify(e) : void 0,
      signal: n
    })).json();
  }
  async delete({ body: e, headers: t, signal: n, ...s }) {
    const i = this.createUrl(s);
    return (await Qu(i, {
      method: "DELETE",
      headers: t,
      body: e ? JSON.stringify(e) : void 0,
      signal: n
    })).json();
  }
  createUrl({ path: e, params: t }) {
    const n = new URL(e, this.baseUrl);
    return t && Object.entries(t).forEach(([s, i]) => {
      i && n.searchParams.append(s, i);
    }), this.clientId && n.searchParams.append("clientId", this.clientId), n;
  }
}
const ix = {
  getFeatureValue(r, e) {
    const t = e == null ? void 0 : e[r];
    return t === void 0 ? at.DEFAULT_FEATURES[r] : t;
  },
  filterSocialsByPlatform(r) {
    if (!r || !r.length)
      return r;
    if (me.isTelegram()) {
      if (me.isIos())
        return r.filter((e) => e !== "google");
      if (me.isMac())
        return r.filter((e) => e !== "x");
      if (me.isAndroid())
        return r.filter((e) => !["facebook", "x"].includes(e));
    }
    return r;
  }
}, Ee = _t({
  features: at.DEFAULT_FEATURES,
  projectId: "",
  sdkType: "appkit",
  sdkVersion: "html-wagmi-undefined",
  defaultAccountTypes: at.DEFAULT_ACCOUNT_TYPES,
  enableNetworkSwitch: !0,
  experimental_preferUniversalLinks: !1,
  remoteFeatures: {}
}), K = {
  state: Ee,
  subscribeKey(r, e) {
    return Tr(Ee, r, e);
  },
  setOptions(r) {
    Object.assign(Ee, r);
  },
  setRemoteFeatures(r) {
    var t;
    if (!r)
      return;
    const e = { ...Ee.remoteFeatures, ...r };
    Ee.remoteFeatures = e, (t = Ee.remoteFeatures) != null && t.socials && (Ee.remoteFeatures.socials = ix.filterSocialsByPlatform(Ee.remoteFeatures.socials));
  },
  setFeatures(r) {
    if (!r)
      return;
    Ee.features || (Ee.features = at.DEFAULT_FEATURES);
    const e = { ...Ee.features, ...r };
    Ee.features = e;
  },
  setProjectId(r) {
    Ee.projectId = r;
  },
  setCustomRpcUrls(r) {
    Ee.customRpcUrls = r;
  },
  setAllWallets(r) {
    Ee.allWallets = r;
  },
  setIncludeWalletIds(r) {
    Ee.includeWalletIds = r;
  },
  setExcludeWalletIds(r) {
    Ee.excludeWalletIds = r;
  },
  setFeaturedWalletIds(r) {
    Ee.featuredWalletIds = r;
  },
  setTokens(r) {
    Ee.tokens = r;
  },
  setTermsConditionsUrl(r) {
    Ee.termsConditionsUrl = r;
  },
  setPrivacyPolicyUrl(r) {
    Ee.privacyPolicyUrl = r;
  },
  setCustomWallets(r) {
    Ee.customWallets = r;
  },
  setIsSiweEnabled(r) {
    Ee.isSiweEnabled = r;
  },
  setIsUniversalProvider(r) {
    Ee.isUniversalProvider = r;
  },
  setSdkVersion(r) {
    Ee.sdkVersion = r;
  },
  setMetadata(r) {
    Ee.metadata = r;
  },
  setDisableAppend(r) {
    Ee.disableAppend = r;
  },
  setEIP6963Enabled(r) {
    Ee.enableEIP6963 = r;
  },
  setDebug(r) {
    Ee.debug = r;
  },
  setEnableWalletConnect(r) {
    Ee.enableWalletConnect = r;
  },
  setEnableWalletGuide(r) {
    Ee.enableWalletGuide = r;
  },
  setEnableAuthLogger(r) {
    Ee.enableAuthLogger = r;
  },
  setEnableWallets(r) {
    Ee.enableWallets = r;
  },
  setPreferUniversalLinks(r) {
    Ee.experimental_preferUniversalLinks = r;
  },
  setHasMultipleAddresses(r) {
    Ee.hasMultipleAddresses = r;
  },
  setSIWX(r) {
    Ee.siwx = r;
  },
  setConnectMethodsOrder(r) {
    Ee.features = {
      ...Ee.features,
      connectMethodsOrder: r
    };
  },
  setWalletFeaturesOrder(r) {
    Ee.features = {
      ...Ee.features,
      walletFeaturesOrder: r
    };
  },
  setSocialsOrder(r) {
    Ee.remoteFeatures = {
      ...Ee.remoteFeatures,
      socials: r
    };
  },
  setCollapseWallets(r) {
    Ee.features = {
      ...Ee.features,
      collapseWallets: r
    };
  },
  setEnableEmbedded(r) {
    Ee.enableEmbedded = r;
  },
  setAllowUnsupportedChain(r) {
    Ee.allowUnsupportedChain = r;
  },
  setManualWCControl(r) {
    Ee.manualWCControl = r;
  },
  setEnableNetworkSwitch(r) {
    Ee.enableNetworkSwitch = r;
  },
  setDefaultAccountTypes(r = {}) {
    Object.entries(r).forEach(([e, t]) => {
      t && (Ee.defaultAccountTypes[e] = t);
    });
  },
  setUniversalProviderConfigOverride(r) {
    Ee.universalProviderConfigOverride = r;
  },
  getUniversalProviderConfigOverride() {
    return Ee.universalProviderConfigOverride;
  },
  getSnapshot() {
    return Yh(Ee);
  }
}, ox = Object.freeze({
  enabled: !0,
  events: []
}), ax = new pf({ baseUrl: me.getAnalyticsUrl(), clientId: null }), cx = 5, lx = 60 * 1e3, Vi = _t({
  ...ox
}), ux = {
  state: Vi,
  subscribeKey(r, e) {
    return Tr(Vi, r, e);
  },
  async sendError(r, e) {
    if (!Vi.enabled)
      return;
    const t = Date.now();
    if (Vi.events.filter((i) => {
      const o = new Date(i.properties.timestamp || "").getTime();
      return t - o < lx;
    }).length >= cx)
      return;
    const s = {
      type: "error",
      event: e,
      properties: {
        errorType: r.name,
        errorMessage: r.message,
        stackTrace: r.stack,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    Vi.events.push(s);
    try {
      if (typeof window > "u")
        return;
      const { projectId: i, sdkType: o, sdkVersion: a } = K.state;
      await ax.post({
        path: "/e",
        params: {
          projectId: i,
          st: o,
          sv: a || "html-wagmi-4.2.2"
        },
        body: {
          eventId: me.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          props: {
            type: "error",
            event: e,
            errorType: r.name,
            errorMessage: r.message,
            stackTrace: r.stack
          }
        }
      });
    } catch {
    }
  },
  enable() {
    Vi.enabled = !0;
  },
  disable() {
    Vi.enabled = !1;
  },
  clearEvents() {
    Vi.events = [];
  }
};
class Eu extends Error {
  constructor(e, t, n) {
    super(e), this.name = "AppKitError", this.category = t, this.originalError = n, Object.setPrototypeOf(this, Eu.prototype);
    let s = !1;
    if (n instanceof Error && typeof n.stack == "string" && n.stack) {
      const i = n.stack, o = i.indexOf(`
`);
      if (o > -1) {
        const a = i.substring(o + 1);
        this.stack = `${this.name}: ${this.message}
${a}`, s = !0;
      }
    }
    s || (Error.captureStackTrace ? Error.captureStackTrace(this, Eu) : this.stack || (this.stack = `${this.name}: ${this.message}`));
  }
}
function sE(r, e) {
  const t = r instanceof Eu ? r : new Eu(r instanceof Error ? r.message : String(r), e, r);
  throw ux.sendError(t, t.category), t;
}
function Sn(r, e = "INTERNAL_SDK_ERROR") {
  const t = {};
  return Object.keys(r).forEach((n) => {
    const s = r[n];
    if (typeof s == "function") {
      let i = s;
      s.constructor.name === "AsyncFunction" ? i = async (...o) => {
        try {
          return await s(...o);
        } catch (a) {
          return sE(a, e);
        }
      } : i = (...o) => {
        try {
          return s(...o);
        } catch (a) {
          return sE(a, e);
        }
      }, t[n] = i;
    } else
      t[n] = s;
  }), t;
}
const Hs = {
  PHANTOM: {
    id: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
    url: "https://phantom.app"
  },
  SOLFLARE: {
    id: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
    url: "https://solflare.com"
  },
  COINBASE: {
    id: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    url: "https://go.cb-w.com"
  }
}, hx = {
  /**
   * Handles mobile wallet redirection for wallets that have Universal Links and doesn't support WalletConnect Deep Links.
   *
   * @param {string} id - The id of the wallet.
   * @param {ChainNamespace} namespace - The namespace of the chain.
   */
  handleMobileDeeplinkRedirect(r, e) {
    const t = window.location.href, n = encodeURIComponent(t);
    if (r === Hs.PHANTOM.id && !("phantom" in window)) {
      const s = t.startsWith("https") ? "https" : "http", i = t.split("/")[2], o = encodeURIComponent(`${s}://${i}`);
      window.location.href = `${Hs.PHANTOM.url}/ul/browse/${n}?ref=${o}`;
    }
    r === Hs.SOLFLARE.id && !("solflare" in window) && (window.location.href = `${Hs.SOLFLARE.url}/ul/v1/browse/${n}?ref=${n}`), e === W.CHAIN.SOLANA && r === Hs.COINBASE.id && !("coinbaseSolana" in window) && (window.location.href = `${Hs.COINBASE.url}/dapp?cb_url=${n}`);
  }
}, fn = _t({
  walletImages: {},
  networkImages: {},
  chainImages: {},
  connectorImages: {},
  tokenImages: {},
  currencyImages: {}
}), dx = {
  state: fn,
  subscribeNetworkImages(r) {
    return fr(fn.networkImages, () => r(fn.networkImages));
  },
  subscribeKey(r, e) {
    return Tr(fn, r, e);
  },
  subscribe(r) {
    return fr(fn, () => r(fn));
  },
  setWalletImage(r, e) {
    fn.walletImages[r] = e;
  },
  setNetworkImage(r, e) {
    fn.networkImages[r] = e;
  },
  setChainImage(r, e) {
    fn.chainImages[r] = e;
  },
  setConnectorImage(r, e) {
    fn.connectorImages = { ...fn.connectorImages, [r]: e };
  },
  setTokenImage(r, e) {
    fn.tokenImages[r] = e;
  },
  setCurrencyImage(r, e) {
    fn.currencyImages[r] = e;
  }
}, us = Sn(dx), fx = {
  // Ethereum
  eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
  // Solana
  solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
  // Polkadot
  polkadot: "",
  // Bitcoin
  bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
  // Cosmos
  cosmos: ""
}, Nm = _t({
  networkImagePromises: {}
}), WC = {
  async fetchWalletImage(r) {
    if (r)
      return await ye._fetchWalletImage(r), this.getWalletImageById(r);
  },
  async fetchNetworkImage(r) {
    if (!r)
      return;
    const e = this.getNetworkImageById(r);
    return e || (Nm.networkImagePromises[r] || (Nm.networkImagePromises[r] = ye._fetchNetworkImage(r)), await Nm.networkImagePromises[r], this.getNetworkImageById(r));
  },
  getWalletImageById(r) {
    if (r)
      return us.state.walletImages[r];
  },
  getWalletImage(r) {
    if (r != null && r.image_url)
      return r == null ? void 0 : r.image_url;
    if (r != null && r.image_id)
      return us.state.walletImages[r.image_id];
  },
  getNetworkImage(r) {
    var e, t, n;
    if ((e = r == null ? void 0 : r.assets) != null && e.imageUrl)
      return (t = r == null ? void 0 : r.assets) == null ? void 0 : t.imageUrl;
    if ((n = r == null ? void 0 : r.assets) != null && n.imageId)
      return us.state.networkImages[r.assets.imageId];
  },
  getNetworkImageById(r) {
    if (r)
      return us.state.networkImages[r];
  },
  getConnectorImage(r) {
    var e;
    if (r != null && r.imageUrl)
      return r.imageUrl;
    if ((e = r == null ? void 0 : r.info) != null && e.icon)
      return r.info.icon;
    if (r != null && r.imageId)
      return us.state.connectorImages[r.imageId];
  },
  getChainImage(r) {
    return us.state.networkImages[fx[r]];
  }
}, Gi = _t({
  message: "",
  variant: "info",
  open: !1
}), px = {
  state: Gi,
  subscribeKey(r, e) {
    return Tr(Gi, r, e);
  },
  open(r, e) {
    const { debug: t } = K.state, { shortMessage: n, longMessage: s } = r;
    t && (Gi.message = n, Gi.variant = e, Gi.open = !0), s && console.error(typeof s == "function" ? s() : s);
  },
  close() {
    Gi.open = !1, Gi.message = "", Gi.variant = "info";
  }
}, Zr = Sn(px), gx = me.getAnalyticsUrl(), mx = new pf({ baseUrl: gx, clientId: null }), wx = ["MODAL_CREATED"], ni = _t({
  timestamp: Date.now(),
  reportedErrors: {},
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
}), ct = {
  state: ni,
  subscribe(r) {
    return fr(ni, () => r(ni));
  },
  getSdkProperties() {
    const { projectId: r, sdkType: e, sdkVersion: t } = K.state;
    return {
      projectId: r,
      st: e,
      sv: t || "html-wagmi-4.2.2"
    };
  },
  async _sendAnalyticsEvent(r) {
    try {
      const e = X.state.address;
      if (wx.includes(r.data.event) || typeof window > "u")
        return;
      await mx.post({
        path: "/e",
        params: ct.getSdkProperties(),
        body: {
          eventId: me.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: r.timestamp,
          props: { ...r.data, address: e }
        }
      }), ni.reportedErrors.FORBIDDEN = !1;
    } catch (e) {
      e instanceof Error && e.cause instanceof Response && e.cause.status === W.HTTP_STATUS_CODES.FORBIDDEN && !ni.reportedErrors.FORBIDDEN && (Zr.open({
        shortMessage: "Invalid App Configuration",
        longMessage: `Origin ${vh() ? window.origin : "uknown"} not found on Allowlist - update configuration on cloud.reown.com`
      }, "error"), ni.reportedErrors.FORBIDDEN = !0);
    }
  },
  sendEvent(r) {
    var e;
    ni.timestamp = Date.now(), ni.data = r, (e = K.state.features) != null && e.analytics && ct._sendAnalyticsEvent(ni);
  }
}, yx = me.getApiUrl(), jr = new pf({
  baseUrl: yx,
  clientId: null
}), bx = 40, iE = 4, Ex = 20, Oe = _t({
  promises: {},
  page: 1,
  count: 0,
  featured: [],
  allFeatured: [],
  recommended: [],
  allRecommended: [],
  wallets: [],
  filteredWallets: [],
  search: [],
  isAnalyticsEnabled: !1,
  excludedWallets: [],
  isFetchingRecommendedWallets: !1
}), ye = {
  state: Oe,
  subscribeKey(r, e) {
    return Tr(Oe, r, e);
  },
  _getSdkProperties() {
    const { projectId: r, sdkType: e, sdkVersion: t } = K.state;
    return {
      projectId: r,
      st: e || "appkit",
      sv: t || "html-wagmi-4.2.2"
    };
  },
  _filterOutExtensions(r) {
    return K.state.isUniversalProvider ? r.filter((e) => !!(e.mobile_link || e.desktop_link || e.webapp_link)) : r;
  },
  async _fetchWalletImage(r) {
    const e = `${jr.baseUrl}/getWalletImage/${r}`, t = await jr.getBlob({ path: e, params: ye._getSdkProperties() });
    us.setWalletImage(r, URL.createObjectURL(t));
  },
  async _fetchNetworkImage(r) {
    const e = `${jr.baseUrl}/public/getAssetImage/${r}`, t = await jr.getBlob({ path: e, params: ye._getSdkProperties() });
    us.setNetworkImage(r, URL.createObjectURL(t));
  },
  async _fetchConnectorImage(r) {
    const e = `${jr.baseUrl}/public/getAssetImage/${r}`, t = await jr.getBlob({ path: e, params: ye._getSdkProperties() });
    us.setConnectorImage(r, URL.createObjectURL(t));
  },
  async _fetchCurrencyImage(r) {
    const e = `${jr.baseUrl}/public/getCurrencyImage/${r}`, t = await jr.getBlob({ path: e, params: ye._getSdkProperties() });
    us.setCurrencyImage(r, URL.createObjectURL(t));
  },
  async _fetchTokenImage(r) {
    const e = `${jr.baseUrl}/public/getTokenImage/${r}`, t = await jr.getBlob({ path: e, params: ye._getSdkProperties() });
    us.setTokenImage(r, URL.createObjectURL(t));
  },
  _filterWalletsByPlatform(r) {
    return me.isMobile() ? r == null ? void 0 : r.filter((t) => t.mobile_link || t.id === Hs.COINBASE.id ? !0 : _.state.activeChain === "solana" && (t.id === Hs.SOLFLARE.id || t.id === Hs.PHANTOM.id)) : r;
  },
  async fetchProjectConfig() {
    return (await jr.get({
      path: "/appkit/v1/config",
      params: ye._getSdkProperties()
    })).features;
  },
  async fetchAllowedOrigins() {
    try {
      const { allowedOrigins: r } = await jr.get({
        path: "/projects/v1/origins",
        params: ye._getSdkProperties()
      });
      return r;
    } catch (r) {
      if (r instanceof Error && r.cause instanceof Response) {
        const e = r.cause.status;
        if (e === W.HTTP_STATUS_CODES.TOO_MANY_REQUESTS)
          throw new Error("RATE_LIMITED", { cause: r });
        if (e >= W.HTTP_STATUS_CODES.SERVER_ERROR && e < 600)
          throw new Error("SERVER_ERROR", { cause: r });
        return [];
      }
      return [];
    }
  },
  async fetchNetworkImages() {
    const r = _.getAllRequestedCaipNetworks(), e = r == null ? void 0 : r.map(({ assets: t }) => t == null ? void 0 : t.imageId).filter(Boolean).filter((t) => !WC.getNetworkImageById(t));
    e && await Promise.allSettled(e.map((t) => ye._fetchNetworkImage(t)));
  },
  async fetchConnectorImages() {
    const { connectors: r } = re.state, e = r.map(({ imageId: t }) => t).filter(Boolean);
    await Promise.allSettled(e.map((t) => ye._fetchConnectorImage(t)));
  },
  async fetchCurrencyImages(r = []) {
    await Promise.allSettled(r.map((e) => ye._fetchCurrencyImage(e)));
  },
  async fetchTokenImages(r = []) {
    await Promise.allSettled(r.map((e) => ye._fetchTokenImage(e)));
  },
  async fetchWallets(r) {
    var i;
    const e = r.exclude ?? [];
    ye._getSdkProperties().sv.startsWith("html-core-") && e.push(...Object.values(Hs).map((o) => o.id));
    const n = await jr.get({
      path: "/getWallets",
      params: {
        ...ye._getSdkProperties(),
        ...r,
        page: String(r.page),
        entries: String(r.entries),
        include: (i = r.include) == null ? void 0 : i.join(","),
        exclude: e.join(",")
      }
    });
    return {
      data: ye._filterWalletsByPlatform(n == null ? void 0 : n.data) || [],
      // Keep original count for display on main page
      count: n == null ? void 0 : n.count
    };
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds: r } = K.state;
    if (r != null && r.length) {
      const e = {
        ...ye._getSdkProperties(),
        page: 1,
        entries: (r == null ? void 0 : r.length) ?? iE,
        include: r
      }, { data: t } = await ye.fetchWallets(e), n = [...t].sort((i, o) => r.indexOf(i.id) - r.indexOf(o.id)), s = n.map((i) => i.image_id).filter(Boolean);
      await Promise.allSettled(s.map((i) => ye._fetchWalletImage(i))), Oe.featured = n, Oe.allFeatured = n;
    }
  },
  async fetchRecommendedWallets() {
    try {
      Oe.isFetchingRecommendedWallets = !0;
      const { includeWalletIds: r, excludeWalletIds: e, featuredWalletIds: t } = K.state, n = [...e ?? [], ...t ?? []].filter(Boolean), s = _.getRequestedCaipNetworkIds().join(","), i = {
        page: 1,
        entries: iE,
        include: r,
        exclude: n,
        chains: s
      }, { data: o, count: a } = await ye.fetchWallets(i), c = te.getRecentWallets(), l = o.map((h) => h.image_id).filter(Boolean), u = c.map((h) => h.image_id).filter(Boolean);
      await Promise.allSettled([...l, ...u].map((h) => ye._fetchWalletImage(h))), Oe.recommended = o, Oe.allRecommended = o, Oe.count = a ?? 0;
    } catch {
    } finally {
      Oe.isFetchingRecommendedWallets = !1;
    }
  },
  async fetchWalletsByPage({ page: r }) {
    const { includeWalletIds: e, excludeWalletIds: t, featuredWalletIds: n } = K.state, s = _.getRequestedCaipNetworkIds().join(","), i = [
      ...Oe.recommended.map(({ id: u }) => u),
      ...t ?? [],
      ...n ?? []
    ].filter(Boolean), o = {
      page: r,
      entries: bx,
      include: e,
      exclude: i,
      chains: s
    }, { data: a, count: c } = await ye.fetchWallets(o), l = a.slice(0, Ex).map((u) => u.image_id).filter(Boolean);
    await Promise.allSettled(l.map((u) => ye._fetchWalletImage(u))), Oe.wallets = me.uniqueBy([...Oe.wallets, ...ye._filterOutExtensions(a)], "id").filter((u) => {
      var h;
      return (h = u.chains) == null ? void 0 : h.some((d) => s.includes(d));
    }), Oe.count = c > Oe.count ? c : Oe.count, Oe.page = r;
  },
  async initializeExcludedWallets({ ids: r }) {
    const e = {
      page: 1,
      entries: r.length,
      include: r
    }, { data: t } = await ye.fetchWallets(e);
    t && t.forEach((n) => {
      Oe.excludedWallets.push({ rdns: n.rdns, name: n.name });
    });
  },
  async searchWallet({ search: r, badge: e }) {
    const { includeWalletIds: t, excludeWalletIds: n } = K.state, s = _.getRequestedCaipNetworkIds().join(",");
    Oe.search = [];
    const i = {
      page: 1,
      entries: 100,
      search: r == null ? void 0 : r.trim(),
      badge_type: e,
      include: t,
      exclude: n,
      chains: s
    }, { data: o } = await ye.fetchWallets(i);
    ct.sendEvent({
      type: "track",
      event: "SEARCH_WALLET",
      properties: { badge: e ?? "", search: r ?? "" }
    });
    const a = o.map((c) => c.image_id).filter(Boolean);
    await Promise.allSettled([
      ...a.map((c) => ye._fetchWalletImage(c)),
      me.wait(300)
    ]), Oe.search = ye._filterOutExtensions(o);
  },
  initPromise(r, e) {
    const t = Oe.promises[r];
    return t || (Oe.promises[r] = e());
  },
  prefetch({ fetchConnectorImages: r = !0, fetchFeaturedWallets: e = !0, fetchRecommendedWallets: t = !0, fetchNetworkImages: n = !0 } = {}) {
    const s = [
      r && ye.initPromise("connectorImages", ye.fetchConnectorImages),
      e && ye.initPromise("featuredWallets", ye.fetchFeaturedWallets),
      t && ye.initPromise("recommendedWallets", ye.fetchRecommendedWallets),
      n && ye.initPromise("networkImages", ye.fetchNetworkImages)
    ].filter(Boolean);
    return Promise.allSettled(s);
  },
  prefetchAnalyticsConfig() {
    var r;
    (r = K.state.features) != null && r.analytics && ye.fetchAnalyticsConfig();
  },
  async fetchAnalyticsConfig() {
    try {
      const { isAnalyticsEnabled: r } = await jr.get({
        path: "/getAnalyticsConfig",
        params: ye._getSdkProperties()
      });
      K.setFeatures({ analytics: r });
    } catch {
      K.setFeatures({ analytics: !1 });
    }
  },
  filterByNamespaces(r) {
    if (!(r != null && r.length)) {
      Oe.featured = Oe.allFeatured, Oe.recommended = Oe.allRecommended;
      return;
    }
    const e = _.getRequestedCaipNetworkIds().join(",");
    Oe.featured = Oe.allFeatured.filter((t) => {
      var n;
      return (n = t.chains) == null ? void 0 : n.some((s) => e.includes(s));
    }), Oe.recommended = Oe.allRecommended.filter((t) => {
      var n;
      return (n = t.chains) == null ? void 0 : n.some((s) => e.includes(s));
    }), Oe.filteredWallets = Oe.wallets.filter((t) => {
      var n;
      return (n = t.chains) == null ? void 0 : n.some((s) => e.includes(s));
    });
  },
  clearFilterByNamespaces() {
    Oe.filteredWallets = [];
  },
  setFilterByNamespace(r) {
    if (!r) {
      Oe.featured = Oe.allFeatured, Oe.recommended = Oe.allRecommended;
      return;
    }
    const e = _.getRequestedCaipNetworkIds().join(",");
    Oe.featured = Oe.allFeatured.filter((t) => {
      var n;
      return (n = t.chains) == null ? void 0 : n.some((s) => e.includes(s));
    }), Oe.recommended = Oe.allRecommended.filter((t) => {
      var n;
      return (n = t.chains) == null ? void 0 : n.some((s) => e.includes(s));
    }), Oe.filteredWallets = Oe.wallets.filter((t) => {
      var n;
      return (n = t.chains) == null ? void 0 : n.some((s) => e.includes(s));
    });
  }
}, ut = _t({
  view: "Connect",
  history: ["Connect"],
  transactionStack: []
}), vx = {
  state: ut,
  subscribeKey(r, e) {
    return Tr(ut, r, e);
  },
  pushTransactionStack(r) {
    ut.transactionStack.push(r);
  },
  popTransactionStack(r) {
    const e = ut.transactionStack.pop();
    if (!e)
      return;
    const { onSuccess: t, onError: n, onCancel: s } = e;
    switch (r) {
      case "success":
        t == null || t();
        break;
      case "error":
        n == null || n(), Ce.goBack();
        break;
      case "cancel":
        s == null || s(), Ce.goBack();
        break;
    }
  },
  push(r, e) {
    r !== ut.view && (ut.view = r, ut.history.push(r), ut.data = e);
  },
  reset(r, e) {
    ut.view = r, ut.history = [r], ut.data = e;
  },
  replace(r, e) {
    ut.history.at(-1) === r || (ut.view = r, ut.history[ut.history.length - 1] = r, ut.data = e);
  },
  goBack() {
    var n;
    const r = _.state.activeCaipAddress, e = Ce.state.view === "ConnectingFarcaster", t = !r && e;
    if (ut.history.length > 1) {
      ut.history.pop();
      const [s] = ut.history.slice(-1);
      s && (r && s === "Connect" ? ut.view = "Account" : ut.view = s);
    } else
      nt.close();
    (n = ut.data) != null && n.wallet && (ut.data.wallet = void 0), setTimeout(() => {
      var s, i, o;
      if (t) {
        X.setFarcasterUrl(void 0, _.state.activeChain);
        const a = re.getAuthConnector();
        (s = a == null ? void 0 : a.provider) == null || s.reload();
        const c = Yh(K.state);
        (o = (i = a == null ? void 0 : a.provider) == null ? void 0 : i.syncDappData) == null || o.call(i, {
          metadata: c.metadata,
          sdkVersion: c.sdkVersion,
          projectId: c.projectId,
          sdkType: c.sdkType
        });
      }
    }, 100);
  },
  goBackToIndex(r) {
    if (ut.history.length > 1) {
      ut.history = ut.history.slice(0, r + 1);
      const [e] = ut.history.slice(-1);
      e && (ut.view = e);
    }
  },
  goBackOrCloseModal() {
    Ce.state.history.length > 1 ? Ce.goBack() : nt.close();
  }
}, Ce = Sn(vx), si = _t({
  themeMode: "dark",
  themeVariables: {},
  w3mThemeVariables: void 0
}), Ww = {
  state: si,
  subscribe(r) {
    return fr(si, () => r(si));
  },
  setThemeMode(r) {
    si.themeMode = r;
    try {
      const e = re.getAuthConnector();
      if (e) {
        const t = Ww.getSnapshot().themeVariables;
        e.provider.syncTheme({
          themeMode: r,
          themeVariables: t,
          w3mThemeVariables: Ri(t, r)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  setThemeVariables(r) {
    si.themeVariables = { ...si.themeVariables, ...r };
    try {
      const e = re.getAuthConnector();
      if (e) {
        const t = Ww.getSnapshot().themeVariables;
        e.provider.syncTheme({
          themeVariables: t,
          w3mThemeVariables: Ri(si.themeVariables, si.themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  getSnapshot() {
    return Yh(si);
  }
}, Xr = Sn(Ww), VC = {
  eip155: void 0,
  solana: void 0,
  polkadot: void 0,
  bip122: void 0,
  cosmos: void 0
}, Ge = _t({
  allConnectors: [],
  connectors: [],
  activeConnector: void 0,
  filterByNamespace: void 0,
  activeConnectorIds: { ...VC },
  filterByNamespaceMap: {
    eip155: !0,
    solana: !0,
    polkadot: !0,
    bip122: !0,
    cosmos: !0
  }
}), Ax = {
  state: Ge,
  subscribe(r) {
    return fr(Ge, () => {
      r(Ge);
    });
  },
  subscribeKey(r, e) {
    return Tr(Ge, r, e);
  },
  initialize(r) {
    r.forEach((e) => {
      const t = te.getConnectedConnectorId(e);
      t && re.setConnectorId(t, e);
    });
  },
  setActiveConnector(r) {
    r && (Ge.activeConnector = ac(r));
  },
  setConnectors(r) {
    r.filter((s) => !Ge.allConnectors.some((i) => i.id === s.id && re.getConnectorName(i.name) === re.getConnectorName(s.name) && i.chain === s.chain)).forEach((s) => {
      s.type !== "MULTI_CHAIN" && Ge.allConnectors.push(ac(s));
    });
    const t = re.getEnabledNamespaces(), n = re.getEnabledConnectors(t);
    Ge.connectors = re.mergeMultiChainConnectors(n);
  },
  filterByNamespaces(r) {
    Object.keys(Ge.filterByNamespaceMap).forEach((e) => {
      Ge.filterByNamespaceMap[e] = !1;
    }), r.forEach((e) => {
      Ge.filterByNamespaceMap[e] = !0;
    }), re.updateConnectorsForEnabledNamespaces();
  },
  filterByNamespace(r, e) {
    Ge.filterByNamespaceMap[r] = e, re.updateConnectorsForEnabledNamespaces();
  },
  updateConnectorsForEnabledNamespaces() {
    const r = re.getEnabledNamespaces(), e = re.getEnabledConnectors(r), t = re.areAllNamespacesEnabled();
    Ge.connectors = re.mergeMultiChainConnectors(e), t ? ye.clearFilterByNamespaces() : ye.filterByNamespaces(r);
  },
  getEnabledNamespaces() {
    return Object.entries(Ge.filterByNamespaceMap).filter(([r, e]) => e).map(([r]) => r);
  },
  getEnabledConnectors(r) {
    return Ge.allConnectors.filter((e) => r.includes(e.chain));
  },
  areAllNamespacesEnabled() {
    return Object.values(Ge.filterByNamespaceMap).every((r) => r);
  },
  mergeMultiChainConnectors(r) {
    const e = re.generateConnectorMapByName(r), t = [];
    return e.forEach((n) => {
      const s = n[0], i = (s == null ? void 0 : s.id) === W.CONNECTOR_ID.AUTH;
      n.length > 1 && s ? t.push({
        name: s.name,
        imageUrl: s.imageUrl,
        imageId: s.imageId,
        connectors: [...n],
        type: i ? "AUTH" : "MULTI_CHAIN",
        // These values are just placeholders, we don't use them in multi-chain connector select screen
        chain: "eip155",
        id: (s == null ? void 0 : s.id) || ""
      }) : s && t.push(s);
    }), t;
  },
  generateConnectorMapByName(r) {
    const e = /* @__PURE__ */ new Map();
    return r.forEach((t) => {
      const { name: n } = t, s = re.getConnectorName(n);
      if (!s)
        return;
      const i = e.get(s) || [];
      i.find((a) => a.chain === t.chain) || i.push(t), e.set(s, i);
    }), e;
  },
  getConnectorName(r) {
    return r && ({
      "Trust Wallet": "Trust"
    }[r] || r);
  },
  getUniqueConnectorsByName(r) {
    const e = [];
    return r.forEach((t) => {
      e.find((n) => n.chain === t.chain) || e.push(t);
    }), e;
  },
  addConnector(r) {
    var e, t, n;
    if (r.id === W.CONNECTOR_ID.AUTH) {
      const s = r, i = Yh(K.state), o = Xr.getSnapshot().themeMode, a = Xr.getSnapshot().themeVariables;
      (t = (e = s == null ? void 0 : s.provider) == null ? void 0 : e.syncDappData) == null || t.call(e, {
        metadata: i.metadata,
        sdkVersion: i.sdkVersion,
        projectId: i.projectId,
        sdkType: i.sdkType
      }), (n = s == null ? void 0 : s.provider) == null || n.syncTheme({
        themeMode: o,
        themeVariables: a,
        w3mThemeVariables: Ri(a, o)
      }), re.setConnectors([r]);
    } else
      re.setConnectors([r]);
  },
  getAuthConnector(r) {
    var n;
    const e = r || _.state.activeChain, t = Ge.connectors.find((s) => s.id === W.CONNECTOR_ID.AUTH);
    if (t)
      return (n = t == null ? void 0 : t.connectors) != null && n.length ? t.connectors.find((i) => i.chain === e) : t;
  },
  getAnnouncedConnectorRdns() {
    return Ge.connectors.filter((r) => r.type === "ANNOUNCED").map((r) => {
      var e;
      return (e = r.info) == null ? void 0 : e.rdns;
    });
  },
  getConnectorById(r) {
    return Ge.allConnectors.find((e) => e.id === r);
  },
  getConnector(r, e) {
    return Ge.allConnectors.filter((n) => n.chain === _.state.activeChain).find((n) => {
      var s;
      return n.explorerId === r || ((s = n.info) == null ? void 0 : s.rdns) === e;
    });
  },
  syncIfAuthConnector(r) {
    var i, o;
    if (r.id !== "ID_AUTH")
      return;
    const e = r, t = Yh(K.state), n = Xr.getSnapshot().themeMode, s = Xr.getSnapshot().themeVariables;
    (o = (i = e == null ? void 0 : e.provider) == null ? void 0 : i.syncDappData) == null || o.call(i, {
      metadata: t.metadata,
      sdkVersion: t.sdkVersion,
      sdkType: t.sdkType,
      projectId: t.projectId
    }), e.provider.syncTheme({
      themeMode: n,
      themeVariables: s,
      w3mThemeVariables: Ri(s, n)
    });
  },
  /**
   * Returns the connectors filtered by namespace.
   * @param namespace - The namespace to filter the connectors by.
   * @returns ConnectorWithProviders[].
   */
  getConnectorsByNamespace(r) {
    const e = Ge.allConnectors.filter((t) => t.chain === r);
    return re.mergeMultiChainConnectors(e);
  },
  selectWalletConnector(r) {
    const e = re.getConnector(r.id, r.rdns), t = _.state.activeChain;
    hx.handleMobileDeeplinkRedirect((e == null ? void 0 : e.explorerId) || r.id, t), e ? Ce.push("ConnectingExternal", { connector: e }) : Ce.push("ConnectingWalletConnect", { wallet: r });
  },
  /**
   * Returns the connectors. If a namespace is provided, the connectors are filtered by namespace.
   * @param namespace - The namespace to filter the connectors by. If not provided, all connectors are returned.
   * @returns ConnectorWithProviders[].
   */
  getConnectors(r) {
    return r ? re.getConnectorsByNamespace(r) : re.mergeMultiChainConnectors(Ge.allConnectors);
  },
  /**
   * Sets the filter by namespace and updates the connectors.
   * @param namespace - The namespace to filter the connectors by.
   */
  setFilterByNamespace(r) {
    Ge.filterByNamespace = r, Ge.connectors = re.getConnectors(r), ye.setFilterByNamespace(r);
  },
  setConnectorId(r, e) {
    r && (Ge.activeConnectorIds = {
      ...Ge.activeConnectorIds,
      [e]: r
    }, te.setConnectedConnectorId(e, r));
  },
  removeConnectorId(r) {
    Ge.activeConnectorIds = {
      ...Ge.activeConnectorIds,
      [r]: void 0
    }, te.deleteConnectedConnectorId(r);
  },
  getConnectorId(r) {
    if (r)
      return Ge.activeConnectorIds[r];
  },
  isConnected(r) {
    return r ? !!Ge.activeConnectorIds[r] : Object.values(Ge.activeConnectorIds).some((e) => !!e);
  },
  resetConnectorIds() {
    Ge.activeConnectorIds = { ...VC };
  }
}, re = Sn(Ax), Qh = {
  getConnectionStatus(r, e) {
    const t = re.state.activeConnectorIds[e], n = ue.state.connections.get(e) ?? [];
    return !!t && r.connectorId === t ? "connected" : n.some((o) => o.connectorId.toLowerCase() === r.connectorId.toLowerCase()) ? "active" : "disconnected";
  },
  validateAccountSwitch({ namespace: r, connection: e, address: t }) {
    if (r === W.CHAIN.BITCOIN) {
      if (!t)
        throw new Error("Address parameter is required for switching bip122 connection");
      const { type: s } = e.accounts.find((i) => i.address.toLowerCase() === t.toLowerCase()) ?? {};
      if (typeof s == "string" && s !== "payment")
        throw new Error(`Switching to non-payment accounts is not allowed for ${r}`);
    }
  },
  excludeConnectorAddressFromConnections({ connections: r, connectorId: e, addresses: t }) {
    return r.map((n) => {
      if ((e ? n.connectorId.toLowerCase() === e.toLowerCase() : !1) && t) {
        const i = n.accounts.filter((o) => !t.some((c) => c.toLowerCase() === o.address.toLowerCase()));
        return { ...n, accounts: i };
      }
      return n;
    });
  },
  excludeExistingConnections(r, e) {
    const t = new Set(r);
    return e.filter((n) => !t.has(n.connectorId));
  },
  getConnectionsByConnectorId(r, e) {
    return r.filter((t) => t.connectorId.toLowerCase() === e.toLowerCase());
  },
  filterConnectionsByAccountType(r, e) {
    return r.map((t) => {
      const n = t.accounts.filter((s) => typeof s.type == "string" ? s.type.toLowerCase() === e.toLowerCase() : !0);
      return { ...t, accounts: n };
    });
  },
  getConnectionsData(r) {
    const e = ue.state.connections.get(r) ?? [], t = e.filter((a) => !a.recent), n = re.state.activeConnectorIds[r], i = e.filter((a) => a.recent).filter((a) => re.getConnectorById(a.connectorId)), o = Qh.excludeExistingConnections([...t.map((a) => a.connectorId), ...n ? [n] : []], i);
    return {
      connections: t,
      recentConnections: o
    };
  }
}, Cx = "https://secure.walletconnect.org/sdk", _x = (typeof process < "u" && typeof process.env < "u" ? process.env.NEXT_PUBLIC_SECURE_SITE_SDK_URL : void 0) || Cx, Ix = (typeof process < "u" && typeof process.env < "u" ? process.env.NEXT_PUBLIC_DEFAULT_LOG_LEVEL : void 0) || "error", Sx = (typeof process < "u" && typeof process.env < "u" ? process.env.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION : void 0) || "4", pe = {
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@appkit-wallet/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
  SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
  SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
  SOCIAL_USERNAME: "SOCIAL_USERNAME",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
  APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
  APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
  APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
  APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
  APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
  APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
  APP_RELOAD: "@w3m-app/RELOAD",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
  FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
  FRAME_CONNECT_FARCASTER_SUCCESS: "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
  FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
  FRAME_GET_FARCASTER_URI_SUCCESS: "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
  FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
  FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
  FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
  FRAME_INIT_SMART_ACCOUNT_SUCCESS: "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
  FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
  FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
  FRAME_SET_PREFERRED_ACCOUNT_ERROR: "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
  FRAME_READY: "@w3m-frame/READY",
  FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
  FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
  RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
  RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
  RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT"
}, rr = {
  SAFE_RPC_METHODS: [
    "eth_accounts",
    "eth_blockNumber",
    "eth_call",
    "eth_chainId",
    "eth_estimateGas",
    "eth_feeHistory",
    "eth_gasPrice",
    "eth_getAccount",
    "eth_getBalance",
    "eth_getBlockByHash",
    "eth_getBlockByNumber",
    "eth_getBlockReceipts",
    "eth_getBlockTransactionCountByHash",
    "eth_getBlockTransactionCountByNumber",
    "eth_getCode",
    "eth_getFilterChanges",
    "eth_getFilterLogs",
    "eth_getLogs",
    "eth_getProof",
    "eth_getStorageAt",
    "eth_getTransactionByBlockHashAndIndex",
    "eth_getTransactionByBlockNumberAndIndex",
    "eth_getTransactionByHash",
    "eth_getTransactionCount",
    "eth_getTransactionReceipt",
    "eth_getUncleCountByBlockHash",
    "eth_getUncleCountByBlockNumber",
    "eth_maxPriorityFeePerGas",
    "eth_newBlockFilter",
    "eth_newFilter",
    "eth_newPendingTransactionFilter",
    "eth_sendRawTransaction",
    "eth_syncing",
    "eth_uninstallFilter",
    "wallet_getCapabilities",
    "wallet_getCallsStatus",
    "eth_getUserOperationReceipt",
    "eth_estimateUserOperationGas",
    "eth_getUserOperationByHash",
    "eth_supportedEntryPoints",
    "wallet_getAssets"
  ],
  NOT_SAFE_RPC_METHODS: [
    "personal_sign",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "solana_signMessage",
    "solana_signTransaction",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction",
    "wallet_sendCalls",
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    "eth_sendUserOperation"
  ],
  GET_CHAIN_ID: "eth_chainId",
  RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
  RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
  ACCOUNT_TYPES: {
    EOA: "eoa",
    SMART_ACCOUNT: "smartAccount"
  }
}, Nx = 1e3, xi = {
  checkNamespaceConnectorId(r, e) {
    return re.getConnectorId(r) === e;
  },
  isSocialProvider(r) {
    return at.DEFAULT_REMOTE_FEATURES.socials.includes(r);
  },
  connectWalletConnect({ walletConnect: r, connector: e, closeModalOnConnect: t = !0, redirectViewOnModalClose: n = "Connect", onOpen: s, onConnect: i }) {
    return new Promise((o, a) => {
      if (r && re.setActiveConnector(e), s == null || s(me.isMobile() && r), n) {
        const l = nt.subscribeKey("open", (u) => {
          u || (Ce.state.view !== n && Ce.replace(n), l(), a(new Error("Modal closed")));
        });
      }
      const c = _.subscribeKey("activeCaipAddress", (l) => {
        l && (i == null || i(), t && nt.close(), c(), o(tn.parseCaipAddress(l)));
      });
    });
  },
  connectExternal(r) {
    return new Promise((e, t) => {
      const n = _.subscribeKey("activeCaipAddress", (s) => {
        s && (nt.close(), n(), e(tn.parseCaipAddress(s)));
      });
      ue.connectExternal(r, r.chain).catch(() => {
        n(), t(new Error("Connection rejected"));
      });
    });
  },
  connectSocial({ social: r, closeModalOnConnect: e = !0, onOpenFarcaster: t, onConnect: n }) {
    let s = X.state.socialWindow, i = X.state.socialProvider, o = !1, a = null;
    const c = _.subscribeKey("activeCaipAddress", (l) => {
      l && (e && nt.close(), c());
    });
    return new Promise((l, u) => {
      async function h(f) {
        var g;
        if ((g = f.data) != null && g.resultUri)
          if (f.origin === W.SECURE_SITE_SDK_ORIGIN) {
            window.removeEventListener("message", h, !1);
            try {
              const p = re.getAuthConnector();
              if (p && !o) {
                s && (s.close(), X.setSocialWindow(void 0, _.state.activeChain), s = X.state.socialWindow), o = !0;
                const w = f.data.resultUri;
                if (i && ct.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_REQUEST_USER_DATA",
                  properties: { provider: i }
                }), await p.provider.connectSocial(w), i) {
                  te.setConnectedSocialProvider(i), await ue.connectExternal({
                    id: p.id,
                    type: p.type,
                    socialUri: w
                  }, p.chain);
                  const E = _.state.activeCaipAddress;
                  if (!E) {
                    u(new Error("Failed to connect"));
                    return;
                  }
                  l(tn.parseCaipAddress(E)), ct.sendEvent({
                    type: "track",
                    event: "SOCIAL_LOGIN_SUCCESS",
                    properties: { provider: i }
                  });
                }
              }
            } catch {
              i && ct.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_ERROR",
                properties: { provider: i }
              }), u(new Error("Failed to connect"));
            }
          } else i && ct.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_ERROR",
            properties: { provider: i }
          });
      }
      async function d() {
        if (r && (X.setSocialProvider(r, _.state.activeChain), i = X.state.socialProvider, ct.sendEvent({
          type: "track",
          event: "SOCIAL_LOGIN_STARTED",
          properties: { provider: i }
        })), i === "farcaster") {
          t == null || t();
          const f = nt.subscribeKey("open", (p) => {
            !p && r === "farcaster" && (u(new Error("Popup closed")), n == null || n(), f());
          }), g = re.getAuthConnector();
          if (g && !X.state.farcasterUrl)
            try {
              const { url: p } = await g.provider.getFarcasterUri();
              X.setFarcasterUrl(p, _.state.activeChain);
            } catch {
              u(new Error("Failed to connect to farcaster"));
            }
        } else {
          const f = re.getAuthConnector();
          a = me.returnOpenHref(`${W.SECURE_SITE_SDK_ORIGIN}/loading`, "popupWindow", "width=600,height=800,scrollbars=yes");
          try {
            if (f && i) {
              const { uri: g } = await f.provider.getSocialRedirectUri({
                provider: i
              });
              if (a && g) {
                X.setSocialWindow(a, _.state.activeChain), s = X.state.socialWindow, a.location.href = g;
                const p = setInterval(() => {
                  s != null && s.closed && !o && (u(new Error("Popup closed")), clearInterval(p));
                }, 1e3);
                window.addEventListener("message", h, !1);
              } else
                a == null || a.close(), u(new Error("Failed to initiate social connection"));
            }
          } catch {
            u(new Error("Failed to initiate social connection")), a == null || a.close();
          }
        }
      }
      d();
    });
  },
  connectEmail({ closeModalOnConnect: r = !0, redirectViewOnModalClose: e = "Connect", onOpen: t, onConnect: n }) {
    return new Promise((s, i) => {
      if (t == null || t(), e) {
        const a = nt.subscribeKey("open", (c) => {
          c || (Ce.state.view !== e && Ce.replace(e), a(), i(new Error("Modal closed")));
        });
      }
      const o = _.subscribeKey("activeCaipAddress", (a) => {
        a && (n == null || n(), r && nt.close(), o(), s(tn.parseCaipAddress(a)));
      });
    });
  },
  async updateEmail() {
    const r = te.getConnectedConnectorId(_.state.activeChain), e = re.getAuthConnector();
    if (!e)
      throw new Error("No auth connector found");
    if (r !== W.CONNECTOR_ID.AUTH)
      throw new Error("Not connected to email or social");
    const t = e.provider.getEmail() ?? "";
    return Ce.push("UpdateEmailWallet", {
      email: t,
      redirectView: void 0
    }), new Promise((n, s) => {
      const i = setInterval(() => {
        const a = e.provider.getEmail() ?? "";
        a !== t && (nt.close(), clearInterval(i), o(), n({ email: a }));
      }, Nx), o = nt.subscribeKey("open", (a) => {
        a || (Ce.state.view !== "Connect" && Ce.push("Connect"), clearInterval(i), o(), s(new Error("Modal closed")));
      });
    });
  },
  canSwitchToSmartAccount(r) {
    var t;
    return _.checkIfSmartAccountEnabled() && ((t = X.state.preferredAccountTypes) == null ? void 0 : t[r]) === rr.ACCOUNT_TYPES.EOA;
  }
}, fa = Object.freeze({
  message: "",
  variant: "success",
  svg: void 0,
  open: !1,
  autoClose: !0
}), Mt = _t({
  ...fa
}), Tx = {
  state: Mt,
  subscribeKey(r, e) {
    return Tr(Mt, r, e);
  },
  showLoading(r, e = {}) {
    this._showMessage({ message: r, variant: "loading", ...e });
  },
  showSuccess(r) {
    this._showMessage({ message: r, variant: "success" });
  },
  showSvg(r, e) {
    this._showMessage({ message: r, svg: e });
  },
  showError(r) {
    const e = me.parseError(r);
    this._showMessage({ message: e, variant: "error" });
  },
  hide() {
    Mt.message = fa.message, Mt.variant = fa.variant, Mt.svg = fa.svg, Mt.open = fa.open, Mt.autoClose = fa.autoClose;
  },
  _showMessage({ message: r, svg: e, variant: t = "success", autoClose: n = fa.autoClose }) {
    Mt.open ? (Mt.open = !1, setTimeout(() => {
      Mt.message = r, Mt.variant = t, Mt.svg = e, Mt.open = !0, Mt.autoClose = n;
    }, 150)) : (Mt.message = r, Mt.variant = t, Mt.svg = e, Mt.open = !0, Mt.autoClose = n);
  }
}, ds = Tx, bt = _t({
  transactions: [],
  coinbaseTransactions: {},
  transactionsByYear: {},
  lastNetworkInView: void 0,
  loading: !1,
  empty: !1,
  next: void 0
}), xx = {
  state: bt,
  subscribe(r) {
    return fr(bt, () => r(bt));
  },
  setLastNetworkInView(r) {
    bt.lastNetworkInView = r;
  },
  async fetchTransactions(r, e) {
    var t, n;
    if (!r)
      throw new Error("Transactions can't be fetched without an accountAddress");
    bt.loading = !0;
    try {
      const s = await ve.fetchTransactions({
        account: r,
        cursor: bt.next,
        onramp: e,
        // Coinbase transaction history state updates require the latest data
        cache: e === "coinbase" ? "no-cache" : void 0,
        chainId: (t = _.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId
      }), i = Ah.filterSpamTransactions(s.data), o = Ah.filterByConnectedChain(i), a = [...bt.transactions, ...o];
      bt.loading = !1, e === "coinbase" ? bt.coinbaseTransactions = Ah.groupTransactionsByYearAndMonth(bt.coinbaseTransactions, s.data) : (bt.transactions = a, bt.transactionsByYear = Ah.groupTransactionsByYearAndMonth(bt.transactionsByYear, o)), bt.empty = a.length === 0, bt.next = s.next ? s.next : void 0;
    } catch {
      const i = _.state.activeChain;
      ct.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: r,
          projectId: K.state.projectId,
          cursor: bt.next,
          isSmartAccount: ((n = X.state.preferredAccountTypes) == null ? void 0 : n[i]) === rr.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      }), ds.showError("Failed to fetch transactions"), bt.loading = !1, bt.empty = !0, bt.next = void 0;
    }
  },
  groupTransactionsByYearAndMonth(r = {}, e = []) {
    const t = r;
    return e.forEach((n) => {
      const s = new Date(n.metadata.minedAt).getFullYear(), i = new Date(n.metadata.minedAt).getMonth(), o = t[s] ?? {}, c = (o[i] ?? []).filter((l) => l.id !== n.id);
      t[s] = {
        ...o,
        [i]: [...c, n].sort((l, u) => new Date(u.metadata.minedAt).getTime() - new Date(l.metadata.minedAt).getTime())
      };
    }), t;
  },
  filterSpamTransactions(r) {
    return r.filter((e) => !e.transfers.every((n) => {
      var s;
      return ((s = n.nft_info) == null ? void 0 : s.flags.is_spam) === !0;
    }));
  },
  filterByConnectedChain(r) {
    var n;
    const e = (n = _.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId;
    return r.filter((s) => s.metadata.chain === e);
  },
  clearCursor() {
    bt.next = void 0;
  },
  resetTransactions() {
    bt.transactions = [], bt.transactionsByYear = {}, bt.lastNetworkInView = void 0, bt.loading = !1, bt.empty = !1, bt.next = void 0;
  }
}, Ah = Sn(xx, "API_ERROR"), qe = _t({
  connections: /* @__PURE__ */ new Map(),
  isSwitchingConnection: !1,
  wcError: !1,
  buffering: !1,
  status: "disconnected"
});
let sa;
const Ox = {
  state: qe,
  subscribe(r) {
    return fr(qe, () => r(qe));
  },
  subscribeKey(r, e) {
    return Tr(qe, r, e);
  },
  _getClient() {
    return qe._client;
  },
  setClient(r) {
    qe._client = ac(r);
  },
  initialize(r) {
    const e = te.getConnections();
    for (const t of r) {
      const n = t.namespace;
      if (n) {
        const s = qe.connections.get(n) ?? [], i = e[n] ?? [], o = [...s, ...i];
        qe.connections.set(n, o);
      }
    }
  },
  async connectWalletConnect() {
    var r, e, t, n;
    if (me.isTelegram() || me.isSafari() && me.isIos()) {
      if (sa) {
        await sa, sa = void 0;
        return;
      }
      if (!me.isPairingExpired(qe == null ? void 0 : qe.wcPairingExpiry)) {
        const s = qe.wcUri;
        qe.wcUri = s;
        return;
      }
      sa = (e = (r = ue._getClient()) == null ? void 0 : r.connectWalletConnect) == null ? void 0 : e.call(r).catch(() => {
      }), ue.state.status = "connecting", await sa, sa = void 0, qe.wcPairingExpiry = void 0, ue.state.status = "connected";
    } else
      await ((n = (t = ue._getClient()) == null ? void 0 : t.connectWalletConnect) == null ? void 0 : n.call(t));
  },
  async connectExternal(r, e, t = !0) {
    var s, i;
    const n = await ((i = (s = ue._getClient()) == null ? void 0 : s.connectExternal) == null ? void 0 : i.call(s, r));
    return t && _.setActiveNamespace(e), n;
  },
  async reconnectExternal(r) {
    var t, n;
    await ((n = (t = ue._getClient()) == null ? void 0 : t.reconnectExternal) == null ? void 0 : n.call(t, r));
    const e = r.chain || _.state.activeChain;
    e && re.setConnectorId(r.id, e);
  },
  async setPreferredAccountType(r, e) {
    var n;
    nt.setLoading(!0, _.state.activeChain);
    const t = re.getAuthConnector();
    t && (X.setPreferredAccountType(r, e), await t.provider.setPreferredAccount(r), te.setPreferredAccountTypes(X.state.preferredAccountTypes ?? { [e]: r }), await ue.reconnectExternal(t), nt.setLoading(!1, _.state.activeChain), ct.sendEvent({
      type: "track",
      event: "SET_PREFERRED_ACCOUNT_TYPE",
      properties: {
        accountType: r,
        network: ((n = _.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId) || ""
      }
    }));
  },
  async signMessage(r) {
    var e;
    return (e = ue._getClient()) == null ? void 0 : e.signMessage(r);
  },
  parseUnits(r, e) {
    var t;
    return (t = ue._getClient()) == null ? void 0 : t.parseUnits(r, e);
  },
  formatUnits(r, e) {
    var t;
    return (t = ue._getClient()) == null ? void 0 : t.formatUnits(r, e);
  },
  async sendTransaction(r) {
    var e;
    return (e = ue._getClient()) == null ? void 0 : e.sendTransaction(r);
  },
  async getCapabilities(r) {
    var e;
    return (e = ue._getClient()) == null ? void 0 : e.getCapabilities(r);
  },
  async grantPermissions(r) {
    var e;
    return (e = ue._getClient()) == null ? void 0 : e.grantPermissions(r);
  },
  async walletGetAssets(r) {
    var e;
    return ((e = ue._getClient()) == null ? void 0 : e.walletGetAssets(r)) ?? {};
  },
  async estimateGas(r) {
    var e;
    return (e = ue._getClient()) == null ? void 0 : e.estimateGas(r);
  },
  async writeContract(r) {
    var e;
    return (e = ue._getClient()) == null ? void 0 : e.writeContract(r);
  },
  async getEnsAddress(r) {
    var e;
    return (e = ue._getClient()) == null ? void 0 : e.getEnsAddress(r);
  },
  async getEnsAvatar(r) {
    var e;
    return (e = ue._getClient()) == null ? void 0 : e.getEnsAvatar(r);
  },
  checkInstalled(r) {
    var e, t;
    return ((t = (e = ue._getClient()) == null ? void 0 : e.checkInstalled) == null ? void 0 : t.call(e, r)) || !1;
  },
  resetWcConnection() {
    qe.wcUri = void 0, qe.wcPairingExpiry = void 0, qe.wcLinking = void 0, qe.recentWallet = void 0, qe.status = "disconnected", Ah.resetTransactions(), te.deleteWalletConnectDeepLink();
  },
  resetUri() {
    qe.wcUri = void 0, qe.wcPairingExpiry = void 0, sa = void 0;
  },
  finalizeWcConnection() {
    var t, n;
    const { wcLinking: r, recentWallet: e } = ue.state;
    r && te.setWalletConnectDeepLink(r), e && te.setAppKitRecent(e), ct.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: r ? "mobile" : "qrcode",
        name: ((n = (t = Ce.state.data) == null ? void 0 : t.wallet) == null ? void 0 : n.name) || "Unknown"
      }
    });
  },
  setWcBasic(r) {
    qe.wcBasic = r;
  },
  setUri(r) {
    qe.wcUri = r, qe.wcPairingExpiry = me.getPairingExpiry();
  },
  setWcLinking(r) {
    qe.wcLinking = r;
  },
  setWcError(r) {
    qe.wcError = r, qe.buffering = !1;
  },
  setRecentWallet(r) {
    qe.recentWallet = r;
  },
  setBuffering(r) {
    qe.buffering = r;
  },
  setStatus(r) {
    qe.status = r;
  },
  setIsSwitchingConnection(r) {
    qe.isSwitchingConnection = r;
  },
  async disconnect({ id: r, namespace: e } = {}) {
    var t;
    try {
      await ((t = ue._getClient()) == null ? void 0 : t.disconnect({
        id: r,
        chainNamespace: e
      }));
    } catch (n) {
      throw new Eu("Failed to disconnect", "INTERNAL_SDK_ERROR", n);
    }
  },
  setConnections(r, e) {
    qe.connections = new Map(qe.connections.set(e, r));
  },
  async handleAuthAccountSwitch({ address: r, connection: e, namespace: t }) {
    var o;
    const n = (o = e.accounts.find((a) => a.type === "smartAccount")) == null ? void 0 : o.address, i = (n == null ? void 0 : n.toLowerCase()) === r.toLowerCase() && xi.canSwitchToSmartAccount(t) ? "smartAccount" : "eoa";
    await ue.setPreferredAccountType(i, t);
  },
  async handleActiveConnection({ connection: r, namespace: e, address: t }) {
    const n = re.getConnectorById(r.connectorId), s = r.connectorId === W.CONNECTOR_ID.AUTH;
    if (!n)
      throw new Error(`No connector found for connection: ${r.connectorId}`);
    const i = await ue.connectExternal({
      id: n.id,
      type: n.type,
      provider: n.provider,
      address: t,
      chain: e
    }, e);
    return s && t && await ue.handleAuthAccountSwitch({ address: t, connection: r, namespace: e }), i == null ? void 0 : i.address;
  },
  async handleDisconnectedConnection({ connection: r, namespace: e, address: t, closeModalOnConnect: n }) {
    var l, u;
    const s = re.getConnectorById(r.connectorId), i = (u = (l = r.auth) == null ? void 0 : l.name) == null ? void 0 : u.toLowerCase(), o = r.connectorId === W.CONNECTOR_ID.AUTH, a = r.connectorId === W.CONNECTOR_ID.WALLET_CONNECT;
    if (!s)
      throw new Error(`No connector found for connection: ${r.connectorId}`);
    let c;
    if (o)
      if (i && xi.isSocialProvider(i)) {
        const { address: h } = await xi.connectSocial({
          social: i,
          closeModalOnConnect: n,
          onOpenFarcaster() {
            nt.open({ view: "ConnectingFarcaster" });
          },
          onConnect() {
            Ce.replace("ProfileWallets");
          }
        });
        c = h;
      } else {
        const { address: h } = await xi.connectEmail({
          closeModalOnConnect: n,
          onOpen() {
            nt.open({ view: "EmailLogin" });
          },
          onConnect() {
            Ce.replace("ProfileWallets");
          }
        });
        c = h;
      }
    else if (a) {
      const { address: h } = await xi.connectWalletConnect({
        walletConnect: !0,
        connector: s,
        closeModalOnConnect: n,
        onOpen(d) {
          nt.open({ view: d ? "AllWallets" : "ConnectingWalletConnect" });
        },
        onConnect() {
          Ce.replace("ProfileWallets");
        }
      });
      c = h;
    } else {
      const h = await ue.connectExternal({
        id: s.id,
        type: s.type,
        provider: s.provider,
        chain: e
      }, e);
      h && (c = h.address);
    }
    return o && t && await ue.handleAuthAccountSwitch({ address: t, connection: r, namespace: e }), c;
  },
  async switchConnection({ connection: r, address: e, namespace: t, closeModalOnConnect: n, onChange: s }) {
    Qh.validateAccountSwitch({ namespace: t, connection: r, address: e });
    let i;
    const o = X.getCaipAddress(t);
    if (o) {
      const { address: c } = tn.parseCaipAddress(o);
      i = c;
    }
    const a = Qh.getConnectionStatus(r, t);
    switch (a) {
      case "connected":
      case "active": {
        const c = await ue.handleActiveConnection({
          connection: r,
          namespace: t,
          address: e
        });
        if (i && c) {
          const l = c.toLowerCase() !== i.toLowerCase();
          s == null || s({
            address: c,
            namespace: t,
            hasSwitchedAccount: l,
            hasSwitchedWallet: a === "active"
          });
        }
        break;
      }
      case "disconnected": {
        const c = await ue.handleDisconnectedConnection({
          connection: r,
          namespace: t,
          address: e,
          closeModalOnConnect: n
        });
        c && (s == null || s({
          address: c,
          namespace: t,
          hasSwitchedAccount: !0,
          hasSwitchedWallet: !0
        }));
        break;
      }
      default:
        throw new Error(`Invalid connection status: ${a}`);
    }
  }
}, ue = Sn(Ox), kc = _t({
  loading: !1,
  open: !1,
  selectedNetworkId: void 0,
  activeChain: void 0,
  initialized: !1
}), Js = {
  state: kc,
  subscribe(r) {
    return fr(kc, () => r(kc));
  },
  subscribeOpen(r) {
    return Tr(kc, "open", r);
  },
  set(r) {
    Object.assign(kc, { ...kc, ...r });
  }
};
function Px(r) {
  const e = Array.from(_.state.chains.keys());
  let t = [];
  return r ? (t.push([r, _.state.chains.get(r)]), xi.checkNamespaceConnectorId(r, W.CONNECTOR_ID.WALLET_CONNECT) ? e.forEach((n) => {
    n !== r && xi.checkNamespaceConnectorId(n, W.CONNECTOR_ID.WALLET_CONNECT) && t.push([n, _.state.chains.get(n)]);
  }) : xi.checkNamespaceConnectorId(r, W.CONNECTOR_ID.AUTH) && e.forEach((n) => {
    n !== r && xi.checkNamespaceConnectorId(n, W.CONNECTOR_ID.AUTH) && t.push([n, _.state.chains.get(n)]);
  })) : t = Array.from(_.state.chains.entries()), t;
}
function GC() {
  var n, s;
  const r = ((n = _.state.activeCaipNetwork) == null ? void 0 : n.chainNamespace) || "eip155", e = ((s = _.state.activeCaipNetwork) == null ? void 0 : s.id) || 1, t = at.NATIVE_TOKEN_ADDRESS[r];
  return `${r}:${e}:${t}`;
}
const Rx = {
  async getTokenList() {
    var n;
    const r = _.state.activeCaipNetwork, e = await ve.fetchSwapTokens({
      chainId: r == null ? void 0 : r.caipNetworkId
    });
    return ((n = e == null ? void 0 : e.tokens) == null ? void 0 : n.map((s) => ({
      ...s,
      eip2612: !1,
      quantity: {
        decimals: "0",
        numeric: "0"
      },
      price: 0,
      value: 0
    }))) || [];
  },
  async fetchGasPrice() {
    var e;
    const r = _.state.activeCaipNetwork;
    if (!r)
      return null;
    try {
      switch (r.chainNamespace) {
        case "solana":
          const t = (e = await (ue == null ? void 0 : ue.estimateGas({ chainNamespace: "solana" }))) == null ? void 0 : e.toString();
          return {
            standard: t,
            fast: t,
            instant: t
          };
        case "eip155":
        default:
          return await ve.fetchGasPrice({
            chainId: r.caipNetworkId
          });
      }
    } catch {
      return null;
    }
  },
  async fetchSwapAllowance({ tokenAddress: r, userAddress: e, sourceTokenAmount: t, sourceTokenDecimals: n }) {
    const s = await ve.fetchSwapAllowance({
      tokenAddress: r,
      userAddress: e
    });
    if (s != null && s.allowance && t && n) {
      const i = ue.parseUnits(t, n) || 0;
      return BigInt(s.allowance) >= i;
    }
    return !1;
  },
  async getMyTokensWithBalance(r) {
    const e = await L0.getMyTokensWithBalance(r);
    return X.setTokenBalance(e, _.state.activeChain), this.mapBalancesToSwapTokens(e);
  },
  /**
   * Maps the balances from Blockchain API to SwapTokenWithBalance array
   * @param balances
   * @returns SwapTokenWithBalance[]
   */
  mapBalancesToSwapTokens(r) {
    return (r == null ? void 0 : r.map((e) => ({
      ...e,
      address: e != null && e.address ? e.address : GC(),
      decimals: parseInt(e.quantity.decimals, 10),
      logoUri: e.iconUrl,
      eip2612: !1
    }))) || [];
  }
}, ot = _t({
  tokenBalances: [],
  loading: !1
}), Dx = {
  state: ot,
  subscribe(r) {
    return fr(ot, () => r(ot));
  },
  subscribeKey(r, e) {
    return Tr(ot, r, e);
  },
  setToken(r) {
    r && (ot.token = ac(r));
  },
  setTokenAmount(r) {
    ot.sendTokenAmount = r;
  },
  setReceiverAddress(r) {
    ot.receiverAddress = r;
  },
  setReceiverProfileImageUrl(r) {
    ot.receiverProfileImageUrl = r;
  },
  setReceiverProfileName(r) {
    ot.receiverProfileName = r;
  },
  setNetworkBalanceInUsd(r) {
    ot.networkBalanceInUSD = r;
  },
  setLoading(r) {
    ot.loading = r;
  },
  async sendToken() {
    var r;
    try {
      switch (tt.setLoading(!0), (r = _.state.activeCaipNetwork) == null ? void 0 : r.chainNamespace) {
        case "eip155":
          await tt.sendEvmToken();
          return;
        case "solana":
          await tt.sendSolanaToken();
          return;
        default:
          throw new Error("Unsupported chain");
      }
    } finally {
      tt.setLoading(!1);
    }
  },
  async sendEvmToken() {
    var t, n, s, i;
    const r = _.state.activeChain, e = (t = X.state.preferredAccountTypes) == null ? void 0 : t[r];
    if (!tt.state.sendTokenAmount || !tt.state.receiverAddress)
      throw new Error("An amount and receiver address are required");
    if (!tt.state.token)
      throw new Error("A token is required");
    (n = tt.state.token) != null && n.address ? (ct.sendEvent({
      type: "track",
      event: "SEND_INITIATED",
      properties: {
        isSmartAccount: e === rr.ACCOUNT_TYPES.SMART_ACCOUNT,
        token: tt.state.token.address,
        amount: tt.state.sendTokenAmount,
        network: ((s = _.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId) || ""
      }
    }), await tt.sendERC20Token({
      receiverAddress: tt.state.receiverAddress,
      tokenAddress: tt.state.token.address,
      sendTokenAmount: tt.state.sendTokenAmount,
      decimals: tt.state.token.quantity.decimals
    })) : (ct.sendEvent({
      type: "track",
      event: "SEND_INITIATED",
      properties: {
        isSmartAccount: e === rr.ACCOUNT_TYPES.SMART_ACCOUNT,
        token: tt.state.token.symbol || "",
        amount: tt.state.sendTokenAmount,
        network: ((i = _.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId) || ""
      }
    }), await tt.sendNativeToken({
      receiverAddress: tt.state.receiverAddress,
      sendTokenAmount: tt.state.sendTokenAmount,
      decimals: tt.state.token.quantity.decimals
    }));
  },
  async fetchTokenBalance(r) {
    var i, o;
    ot.loading = !0;
    const e = (i = _.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId, t = (o = _.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace, n = _.state.activeCaipAddress, s = n ? me.getPlainAddress(n) : void 0;
    if (ot.lastRetry && !me.isAllowedRetry(ot.lastRetry, 30 * at.ONE_SEC_MS))
      return ot.loading = !1, [];
    try {
      if (s && e && t) {
        const a = await L0.getMyTokensWithBalance();
        return ot.tokenBalances = a, ot.lastRetry = void 0, a;
      }
    } catch (a) {
      ot.lastRetry = Date.now(), r == null || r(a), ds.showError("Token Balance Unavailable");
    } finally {
      ot.loading = !1;
    }
    return [];
  },
  fetchNetworkBalance() {
    if (ot.tokenBalances.length === 0)
      return;
    const r = Rx.mapBalancesToSwapTokens(ot.tokenBalances);
    if (!r)
      return;
    const e = r.find((t) => t.address === GC());
    e && (ot.networkBalanceInUSD = e ? XT.multiply(e.quantity.numeric, e.price).toString() : "0");
  },
  async sendNativeToken(r) {
    var i, o, a, c;
    Ce.pushTransactionStack({});
    const e = r.receiverAddress, t = X.state.address, n = ue.parseUnits(r.sendTokenAmount.toString(), Number(r.decimals));
    await ue.sendTransaction({
      chainNamespace: "eip155",
      to: e,
      address: t,
      data: "0x",
      value: n ?? BigInt(0)
    }), ct.sendEvent({
      type: "track",
      event: "SEND_SUCCESS",
      properties: {
        isSmartAccount: ((i = X.state.preferredAccountTypes) == null ? void 0 : i.eip155) === rr.ACCOUNT_TYPES.SMART_ACCOUNT,
        token: ((o = tt.state.token) == null ? void 0 : o.symbol) || "",
        amount: r.sendTokenAmount,
        network: ((a = _.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId) || ""
      }
    }), (c = ue._getClient()) == null || c.updateBalance("eip155"), tt.resetSend();
  },
  async sendERC20Token(r) {
    Ce.pushTransactionStack({
      onSuccess() {
        Ce.replace("Account");
      }
    });
    const e = ue.parseUnits(r.sendTokenAmount.toString(), Number(r.decimals));
    if (X.state.address && r.sendTokenAmount && r.receiverAddress && r.tokenAddress) {
      const t = me.getPlainAddress(r.tokenAddress);
      await ue.writeContract({
        fromAddress: X.state.address,
        tokenAddress: t,
        args: [r.receiverAddress, e ?? BigInt(0)],
        method: "transfer",
        abi: nx.getERC20Abi(t),
        chainNamespace: "eip155"
      }), tt.resetSend();
    }
  },
  async sendSolanaToken() {
    var r;
    if (!tt.state.sendTokenAmount || !tt.state.receiverAddress)
      throw new Error("An amount and receiver address are required");
    Ce.pushTransactionStack({
      onSuccess() {
        Ce.replace("Account");
      }
    }), await ue.sendTransaction({
      chainNamespace: "solana",
      to: tt.state.receiverAddress,
      value: tt.state.sendTokenAmount
    }), (r = ue._getClient()) == null || r.updateBalance("solana"), tt.resetSend();
  },
  resetSend() {
    ot.token = void 0, ot.sendTokenAmount = void 0, ot.receiverAddress = void 0, ot.receiverProfileImageUrl = void 0, ot.receiverProfileName = void 0, ot.loading = !1, ot.tokenBalances = [];
  }
}, tt = Sn(Dx), Tm = {
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: !1,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: [],
  user: void 0
}, $f = {
  caipNetwork: void 0,
  supportsAllNetworks: !0,
  smartAccountEnabledNetworks: []
}, oe = _t({
  chains: zT(),
  activeCaipAddress: void 0,
  activeChain: void 0,
  activeCaipNetwork: void 0,
  noAdapters: !1,
  universalAdapter: {
    networkControllerClient: void 0,
    connectionControllerClient: void 0
  },
  isSwitchingNamespace: !1
}), kx = {
  state: oe,
  subscribe(r) {
    return fr(oe, () => {
      r(oe);
    });
  },
  subscribeKey(r, e) {
    return Tr(oe, r, e);
  },
  subscribeChainProp(r, e, t) {
    let n;
    return fr(oe.chains, () => {
      var i;
      const s = t || oe.activeChain;
      if (s) {
        const o = (i = oe.chains.get(s)) == null ? void 0 : i[r];
        n !== o && (n = o, e(o));
      }
    });
  },
  initialize(r, e, t) {
    const { chainId: n, namespace: s } = te.getActiveNetworkProps(), i = e == null ? void 0 : e.find((u) => u.id.toString() === (n == null ? void 0 : n.toString())), a = r.find((u) => (u == null ? void 0 : u.namespace) === s) || (r == null ? void 0 : r[0]), c = r.map((u) => u.namespace).filter((u) => u !== void 0), l = K.state.enableEmbedded ? /* @__PURE__ */ new Set([...c]) : /* @__PURE__ */ new Set([...(e == null ? void 0 : e.map((u) => u.chainNamespace)) ?? []]);
    ((r == null ? void 0 : r.length) === 0 || !a) && (oe.noAdapters = !0), oe.noAdapters || (oe.activeChain = a == null ? void 0 : a.namespace, oe.activeCaipNetwork = i, _.setChainNetworkData(a == null ? void 0 : a.namespace, {
      caipNetwork: i
    }), oe.activeChain && Js.set({ activeChain: a == null ? void 0 : a.namespace })), l.forEach((u) => {
      const h = e == null ? void 0 : e.filter((d) => d.chainNamespace === u);
      _.state.chains.set(u, {
        namespace: u,
        networkState: _t({
          ...$f,
          caipNetwork: h == null ? void 0 : h[0]
        }),
        accountState: _t(Tm),
        caipNetworks: h ?? [],
        ...t
      }), _.setRequestedCaipNetworks(h ?? [], u);
    });
  },
  removeAdapter(r) {
    var e, t;
    if (oe.activeChain === r) {
      const n = Array.from(oe.chains.entries()).find(([s]) => s !== r);
      if (n) {
        const s = (t = (e = n[1]) == null ? void 0 : e.caipNetworks) == null ? void 0 : t[0];
        s && _.setActiveCaipNetwork(s);
      }
    }
    oe.chains.delete(r);
  },
  addAdapter(r, { networkControllerClient: e, connectionControllerClient: t }, n) {
    oe.chains.set(r.namespace, {
      namespace: r.namespace,
      networkState: {
        ...$f,
        caipNetwork: n[0]
      },
      accountState: Tm,
      caipNetworks: n,
      connectionControllerClient: t,
      networkControllerClient: e
    }), _.setRequestedCaipNetworks((n == null ? void 0 : n.filter((s) => s.chainNamespace === r.namespace)) ?? [], r.namespace);
  },
  addNetwork(r) {
    var t;
    const e = oe.chains.get(r.chainNamespace);
    if (e) {
      const n = [...e.caipNetworks || []];
      (t = e.caipNetworks) != null && t.find((s) => s.id === r.id) || n.push(r), oe.chains.set(r.chainNamespace, { ...e, caipNetworks: n }), _.setRequestedCaipNetworks(n, r.chainNamespace), re.filterByNamespace(r.chainNamespace, !0);
    }
  },
  removeNetwork(r, e) {
    var n, s, i;
    const t = oe.chains.get(r);
    if (t) {
      const o = ((n = oe.activeCaipNetwork) == null ? void 0 : n.id) === e, a = [
        ...((s = t.caipNetworks) == null ? void 0 : s.filter((c) => c.id !== e)) || []
      ];
      o && ((i = t == null ? void 0 : t.caipNetworks) != null && i[0]) && _.setActiveCaipNetwork(t.caipNetworks[0]), oe.chains.set(r, { ...t, caipNetworks: a }), _.setRequestedCaipNetworks(a || [], r), a.length === 0 && re.filterByNamespace(r, !1);
    }
  },
  setAdapterNetworkState(r, e) {
    const t = oe.chains.get(r);
    t && (t.networkState = {
      ...t.networkState || $f,
      ...e
    }, oe.chains.set(r, t));
  },
  setChainAccountData(r, e, t = !0) {
    if (!r)
      throw new Error("Chain is required to update chain account data");
    const n = oe.chains.get(r);
    if (n) {
      const s = { ...n.accountState || Tm, ...e };
      oe.chains.set(r, { ...n, accountState: s }), (oe.chains.size === 1 || oe.activeChain === r) && (e.caipAddress && (oe.activeCaipAddress = e.caipAddress), X.replaceState(s));
    }
  },
  setChainNetworkData(r, e) {
    if (!r)
      return;
    const t = oe.chains.get(r);
    if (t) {
      const n = { ...t.networkState || $f, ...e };
      oe.chains.set(r, { ...t, networkState: n });
    }
  },
  // eslint-disable-next-line max-params
  setAccountProp(r, e, t, n = !0) {
    _.setChainAccountData(t, { [r]: e }, n), r === "status" && e === "disconnected" && t && re.removeConnectorId(t);
  },
  setActiveNamespace(r) {
    var n, s;
    oe.activeChain = r;
    const e = r ? oe.chains.get(r) : void 0, t = (n = e == null ? void 0 : e.networkState) == null ? void 0 : n.caipNetwork;
    t != null && t.id && r && (oe.activeCaipAddress = (s = e == null ? void 0 : e.accountState) == null ? void 0 : s.caipAddress, oe.activeCaipNetwork = t, _.setChainNetworkData(r, { caipNetwork: t }), te.setActiveCaipNetworkId(t == null ? void 0 : t.caipNetworkId), Js.set({
      activeChain: r,
      selectedNetworkId: t == null ? void 0 : t.caipNetworkId
    }));
  },
  setActiveCaipNetwork(r) {
    var n, s, i;
    if (!r)
      return;
    oe.activeChain !== r.chainNamespace && _.setIsSwitchingNamespace(!0);
    const e = oe.chains.get(r.chainNamespace);
    oe.activeChain = r.chainNamespace, oe.activeCaipNetwork = r, _.setChainNetworkData(r.chainNamespace, { caipNetwork: r }), (n = e == null ? void 0 : e.accountState) != null && n.address ? oe.activeCaipAddress = `${r.chainNamespace}:${r.id}:${(s = e == null ? void 0 : e.accountState) == null ? void 0 : s.address}` : oe.activeCaipAddress = void 0, _.setAccountProp("caipAddress", oe.activeCaipAddress, r.chainNamespace), e && X.replaceState(e.accountState), tt.resetSend(), Js.set({
      activeChain: oe.activeChain,
      selectedNetworkId: (i = oe.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
    }), te.setActiveCaipNetworkId(r.caipNetworkId), !_.checkIfSupportedNetwork(r.chainNamespace) && K.state.enableNetworkSwitch && !K.state.allowUnsupportedChain && !ue.state.wcBasic && _.showUnsupportedChainUI();
  },
  addCaipNetwork(r) {
    var t;
    if (!r)
      return;
    const e = oe.chains.get(r.chainNamespace);
    e && ((t = e == null ? void 0 : e.caipNetworks) == null || t.push(r));
  },
  async switchActiveNamespace(r) {
    var s;
    if (!r)
      return;
    const e = r !== _.state.activeChain, t = (s = _.getNetworkData(r)) == null ? void 0 : s.caipNetwork, n = _.getCaipNetworkByNamespace(r, t == null ? void 0 : t.id);
    e && n && await _.switchActiveNetwork(n);
  },
  async switchActiveNetwork(r) {
    var s;
    const e = _.state.chains.get(_.state.activeChain), t = !((s = e == null ? void 0 : e.caipNetworks) != null && s.some((i) => {
      var o;
      return i.id === ((o = oe.activeCaipNetwork) == null ? void 0 : o.id);
    })), n = _.getNetworkControllerClient(r.chainNamespace);
    if (n) {
      try {
        await n.switchCaipNetwork(r), t && nt.close();
      } catch {
        Ce.goBack();
      }
      ct.sendEvent({
        type: "track",
        event: "SWITCH_NETWORK",
        properties: { network: r.caipNetworkId }
      });
    }
  },
  getNetworkControllerClient(r) {
    const e = r || oe.activeChain, t = oe.chains.get(e);
    if (!t)
      throw new Error("Chain adapter not found");
    if (!t.networkControllerClient)
      throw new Error("NetworkController client not set");
    return t.networkControllerClient;
  },
  getConnectionControllerClient(r) {
    const e = r || oe.activeChain;
    if (!e)
      throw new Error("Chain is required to get connection controller client");
    const t = oe.chains.get(e);
    if (!(t != null && t.connectionControllerClient))
      throw new Error("ConnectionController client not set");
    return t.connectionControllerClient;
  },
  getAccountProp(r, e) {
    var s;
    let t = oe.activeChain;
    if (e && (t = e), !t)
      return;
    const n = (s = oe.chains.get(t)) == null ? void 0 : s.accountState;
    if (n)
      return n[r];
  },
  getNetworkProp(r, e) {
    var n;
    const t = (n = oe.chains.get(e)) == null ? void 0 : n.networkState;
    if (t)
      return t[r];
  },
  getRequestedCaipNetworks(r) {
    const e = oe.chains.get(r), { approvedCaipNetworkIds: t = [], requestedCaipNetworks: n = [] } = (e == null ? void 0 : e.networkState) || {};
    return me.sortRequestedNetworks(t, n);
  },
  getAllRequestedCaipNetworks() {
    const r = [];
    return oe.chains.forEach((e) => {
      const t = _.getRequestedCaipNetworks(e.namespace);
      r.push(...t);
    }), r;
  },
  setRequestedCaipNetworks(r, e) {
    _.setAdapterNetworkState(e, { requestedCaipNetworks: r });
    const n = _.getAllRequestedCaipNetworks().map((i) => i.chainNamespace), s = Array.from(new Set(n));
    re.filterByNamespaces(s);
  },
  getAllApprovedCaipNetworkIds() {
    const r = [];
    return oe.chains.forEach((e) => {
      const t = _.getApprovedCaipNetworkIds(e.namespace);
      r.push(...t);
    }), r;
  },
  getActiveCaipNetwork() {
    return oe.activeCaipNetwork;
  },
  getActiveCaipAddress() {
    return oe.activeCaipAddress;
  },
  getApprovedCaipNetworkIds(r) {
    var n;
    const e = oe.chains.get(r);
    return ((n = e == null ? void 0 : e.networkState) == null ? void 0 : n.approvedCaipNetworkIds) || [];
  },
  async setApprovedCaipNetworksData(r) {
    const e = _.getNetworkControllerClient(), t = await (e == null ? void 0 : e.getApprovedCaipNetworksData());
    _.setAdapterNetworkState(r, {
      approvedCaipNetworkIds: t == null ? void 0 : t.approvedCaipNetworkIds,
      supportsAllNetworks: t == null ? void 0 : t.supportsAllNetworks
    });
  },
  checkIfSupportedNetwork(r, e) {
    const t = e || oe.activeCaipNetwork, n = _.getRequestedCaipNetworks(r);
    return n.length ? n == null ? void 0 : n.some((s) => s.id === (t == null ? void 0 : t.id)) : !0;
  },
  checkIfSupportedChainId(r) {
    if (!oe.activeChain)
      return !0;
    const e = _.getRequestedCaipNetworks(oe.activeChain);
    return e == null ? void 0 : e.some((t) => t.id === r);
  },
  // Smart Account Network Handlers
  setSmartAccountEnabledNetworks(r, e) {
    _.setAdapterNetworkState(e, { smartAccountEnabledNetworks: r });
  },
  checkIfSmartAccountEnabled() {
    var n;
    const r = jC.caipNetworkIdToNumber((n = oe.activeCaipNetwork) == null ? void 0 : n.caipNetworkId), e = oe.activeChain;
    if (!e || !r)
      return !1;
    const t = _.getNetworkProp("smartAccountEnabledNetworks", e);
    return !!(t != null && t.includes(Number(r)));
  },
  showUnsupportedChainUI() {
    nt.open({ view: "UnsupportedChain" });
  },
  checkIfNamesSupported() {
    const r = oe.activeCaipNetwork;
    return !!(r != null && r.chainNamespace && at.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(r.chainNamespace));
  },
  resetNetwork(r) {
    _.setAdapterNetworkState(r, {
      approvedCaipNetworkIds: void 0,
      supportsAllNetworks: !0,
      smartAccountEnabledNetworks: []
    });
  },
  resetAccount(r) {
    const e = r;
    if (!e)
      throw new Error("Chain is required to set account prop");
    oe.activeCaipAddress = void 0, _.setChainAccountData(e, {
      smartAccountDeployed: !1,
      currentTab: 0,
      caipAddress: void 0,
      address: void 0,
      balance: void 0,
      balanceSymbol: void 0,
      profileName: void 0,
      profileImage: void 0,
      addressExplorerUrl: void 0,
      tokenBalance: [],
      connectedWalletInfo: void 0,
      preferredAccountTypes: void 0,
      socialProvider: void 0,
      socialWindow: void 0,
      farcasterUrl: void 0,
      allAccounts: [],
      user: void 0,
      status: "disconnected"
    }), re.removeConnectorId(e);
  },
  setIsSwitchingNamespace(r) {
    oe.isSwitchingNamespace = r;
  },
  getFirstCaipNetworkSupportsAuthConnector() {
    var t, n;
    const r = [];
    let e;
    if (oe.chains.forEach((s) => {
      W.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((i) => i === s.namespace) && s.namespace && r.push(s.namespace);
    }), r.length > 0) {
      const s = r[0];
      return e = s ? (n = (t = oe.chains.get(s)) == null ? void 0 : t.caipNetworks) == null ? void 0 : n[0] : void 0, e;
    }
  },
  getAccountData(r) {
    var e;
    return r ? (e = _.state.chains.get(r)) == null ? void 0 : e.accountState : X.state;
  },
  getNetworkData(r) {
    var t;
    const e = r || oe.activeChain;
    if (e)
      return (t = _.state.chains.get(e)) == null ? void 0 : t.networkState;
  },
  getCaipNetworkByNamespace(r, e) {
    var s, i, o;
    if (!r)
      return;
    const t = _.state.chains.get(r), n = (s = t == null ? void 0 : t.caipNetworks) == null ? void 0 : s.find((a) => a.id === e);
    return n || ((i = t == null ? void 0 : t.networkState) == null ? void 0 : i.caipNetwork) || ((o = t == null ? void 0 : t.caipNetworks) == null ? void 0 : o[0]);
  },
  /**
   * Get the requested CaipNetwork IDs for a given namespace. If namespace is not provided, all requested CaipNetwork IDs will be returned
   * @param namespace - The namespace to get the requested CaipNetwork IDs for
   * @returns The requested CaipNetwork IDs
   */
  getRequestedCaipNetworkIds() {
    const r = re.state.filterByNamespace;
    return (r ? [oe.chains.get(r)] : Array.from(oe.chains.values())).flatMap((t) => (t == null ? void 0 : t.caipNetworks) || []).map((t) => t.caipNetworkId);
  },
  getCaipNetworks(r) {
    return r ? _.getRequestedCaipNetworks(r) : _.getAllRequestedCaipNetworks();
  }
}, _ = Sn(kx), Ux = {
  purchaseCurrencies: [
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "USD Coin",
      symbol: "USDC",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    },
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "Ether",
      symbol: "ETH",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    }
  ],
  paymentCurrencies: [
    {
      id: "USD",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    },
    {
      id: "EUR",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    }
  ]
}, KC = me.getBlockchainApiUrl(), Hr = _t({
  clientId: null,
  api: new pf({ baseUrl: KC, clientId: null }),
  supportedChains: { http: [], ws: [] }
}), ve = {
  state: Hr,
  async get(r) {
    const { st: e, sv: t } = ve.getSdkProperties(), n = K.state.projectId, s = {
      ...r.params || {},
      st: e,
      sv: t,
      projectId: n
    };
    return Hr.api.get({
      ...r,
      params: s
    });
  },
  getSdkProperties() {
    const { sdkType: r, sdkVersion: e } = K.state;
    return {
      st: r || "unknown",
      sv: e || "unknown"
    };
  },
  async isNetworkSupported(r) {
    if (!r)
      return !1;
    try {
      Hr.supportedChains.http.length || await ve.getSupportedNetworks();
    } catch {
      return !1;
    }
    return Hr.supportedChains.http.includes(r);
  },
  async getSupportedNetworks() {
    try {
      const r = await ve.get({
        path: "v1/supported-chains"
      });
      return Hr.supportedChains = r, r;
    } catch {
      return Hr.supportedChains;
    }
  },
  async fetchIdentity({ address: r, caipNetworkId: e }) {
    if (!await ve.isNetworkSupported(e))
      return { avatar: "", name: "" };
    const n = te.getIdentityFromCacheForAddress(r);
    if (n)
      return n;
    const s = await ve.get({
      path: `/v1/identity/${r}`,
      params: {
        sender: _.state.activeCaipAddress ? me.getPlainAddress(_.state.activeCaipAddress) : void 0
      }
    });
    return te.updateIdentityCache({
      address: r,
      identity: s,
      timestamp: Date.now()
    }), s;
  },
  async fetchTransactions({ account: r, cursor: e, onramp: t, signal: n, cache: s, chainId: i }) {
    var a;
    return await ve.isNetworkSupported((a = _.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId) ? ve.get({
      path: `/v1/account/${r}/history`,
      params: {
        cursor: e,
        onramp: t,
        chainId: i
      },
      signal: n,
      cache: s
    }) : { data: [], next: void 0 };
  },
  async fetchSwapQuote({ amount: r, userAddress: e, from: t, to: n, gasPrice: s }) {
    var o;
    return await ve.isNetworkSupported((o = _.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId) ? ve.get({
      path: "/v1/convert/quotes",
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        amount: r,
        userAddress: e,
        from: t,
        to: n,
        gasPrice: s
      }
    }) : { quotes: [] };
  },
  async fetchSwapTokens({ chainId: r }) {
    var t;
    return await ve.isNetworkSupported((t = _.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId) ? ve.get({
      path: "/v1/convert/tokens",
      params: { chainId: r }
    }) : { tokens: [] };
  },
  async fetchTokenPrice({ addresses: r }) {
    var t;
    return await ve.isNetworkSupported((t = _.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId) ? Hr.api.post({
      path: "/v1/fungible/price",
      body: {
        currency: "usd",
        addresses: r,
        projectId: K.state.projectId
      },
      headers: {
        "Content-Type": "application/json"
      }
    }) : { fungibles: [] };
  },
  async fetchSwapAllowance({ tokenAddress: r, userAddress: e }) {
    var n;
    return await ve.isNetworkSupported((n = _.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId) ? ve.get({
      path: "/v1/convert/allowance",
      params: {
        tokenAddress: r,
        userAddress: e
      },
      headers: {
        "Content-Type": "application/json"
      }
    }) : { allowance: "0" };
  },
  async fetchGasPrice({ chainId: r }) {
    var s;
    const { st: e, sv: t } = ve.getSdkProperties();
    if (!await ve.isNetworkSupported((s = _.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId))
      throw new Error("Network not supported for Gas Price");
    return ve.get({
      path: "/v1/convert/gas-price",
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        chainId: r,
        st: e,
        sv: t
      }
    });
  },
  async generateSwapCalldata({ amount: r, from: e, to: t, userAddress: n, disableEstimate: s }) {
    var o;
    if (!await ve.isNetworkSupported((o = _.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId))
      throw new Error("Network not supported for Swaps");
    return Hr.api.post({
      path: "/v1/convert/build-transaction",
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        amount: r,
        eip155: {
          slippage: at.CONVERT_SLIPPAGE_TOLERANCE
        },
        projectId: K.state.projectId,
        from: e,
        to: t,
        userAddress: n,
        disableEstimate: s
      }
    });
  },
  async generateApproveCalldata({ from: r, to: e, userAddress: t }) {
    var o;
    const { st: n, sv: s } = ve.getSdkProperties();
    if (!await ve.isNetworkSupported((o = _.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId))
      throw new Error("Network not supported for Swaps");
    return ve.get({
      path: "/v1/convert/build-approve",
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        userAddress: t,
        from: r,
        to: e,
        st: n,
        sv: s
      }
    });
  },
  async getBalance(r, e, t) {
    var l;
    const { st: n, sv: s } = ve.getSdkProperties();
    if (!await ve.isNetworkSupported((l = _.state.activeCaipNetwork) == null ? void 0 : l.caipNetworkId))
      return ds.showError("Token Balance Unavailable"), { balances: [] };
    const o = `${e}:${r}`, a = te.getBalanceCacheForCaipAddress(o);
    if (a)
      return a;
    const c = await ve.get({
      path: `/v1/account/${r}/balance`,
      params: {
        currency: "usd",
        chainId: e,
        forceUpdate: t,
        st: n,
        sv: s
      }
    });
    return te.updateBalanceCache({
      caipAddress: o,
      balance: c,
      timestamp: Date.now()
    }), c;
  },
  async lookupEnsName(r) {
    var t;
    return await ve.isNetworkSupported((t = _.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId) ? ve.get({
      path: `/v1/profile/account/${r}`,
      params: { apiVersion: "2" }
    }) : { addresses: {}, attributes: [] };
  },
  async reverseLookupEnsName({ address: r }) {
    var t;
    return await ve.isNetworkSupported((t = _.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId) ? ve.get({
      path: `/v1/profile/reverse/${r}`,
      params: {
        sender: X.state.address,
        apiVersion: "2"
      }
    }) : [];
  },
  async getEnsNameSuggestions(r) {
    var t;
    return await ve.isNetworkSupported((t = _.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId) ? ve.get({
      path: `/v1/profile/suggestions/${r}`,
      params: { zone: "reown.id" }
    }) : { suggestions: [] };
  },
  async registerEnsName({ coinType: r, address: e, message: t, signature: n }) {
    var i;
    return await ve.isNetworkSupported((i = _.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId) ? Hr.api.post({
      path: "/v1/profile/account",
      body: { coin_type: r, address: e, message: t, signature: n },
      headers: {
        "Content-Type": "application/json"
      }
    }) : { success: !1 };
  },
  async generateOnRampURL({ destinationWallets: r, partnerUserId: e, defaultNetwork: t, purchaseAmount: n, paymentAmount: s }) {
    var a;
    return await ve.isNetworkSupported((a = _.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId) ? (await Hr.api.post({
      path: "/v1/generators/onrampurl",
      params: {
        projectId: K.state.projectId
      },
      body: {
        destinationWallets: r,
        defaultNetwork: t,
        partnerUserId: e,
        defaultExperience: "buy",
        presetCryptoAmount: n,
        presetFiatAmount: s
      }
    })).url : "";
  },
  async getOnrampOptions() {
    var e;
    if (!await ve.isNetworkSupported((e = _.state.activeCaipNetwork) == null ? void 0 : e.caipNetworkId))
      return { paymentCurrencies: [], purchaseCurrencies: [] };
    try {
      return await ve.get({
        path: "/v1/onramp/options"
      });
    } catch {
      return Ux;
    }
  },
  async getOnrampQuote({ purchaseCurrency: r, paymentCurrency: e, amount: t, network: n }) {
    var s;
    try {
      return await ve.isNetworkSupported((s = _.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId) ? await Hr.api.post({
        path: "/v1/onramp/quote",
        params: {
          projectId: K.state.projectId
        },
        body: {
          purchaseCurrency: r,
          paymentCurrency: e,
          amount: t,
          network: n
        }
      }) : null;
    } catch {
      return {
        coinbaseFee: { amount: t, currency: e.id },
        networkFee: { amount: t, currency: e.id },
        paymentSubtotal: { amount: t, currency: e.id },
        paymentTotal: { amount: t, currency: e.id },
        purchaseAmount: { amount: t, currency: e.id },
        quoteId: "mocked-quote-id"
      };
    }
  },
  async getSmartSessions(r) {
    var t;
    return await ve.isNetworkSupported((t = _.state.activeCaipNetwork) == null ? void 0 : t.caipNetworkId) ? ve.get({
      path: `/v1/sessions/${r}`
    }) : [];
  },
  async revokeSmartSession(r, e, t) {
    var s;
    return await ve.isNetworkSupported((s = _.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId) ? Hr.api.post({
      path: `/v1/sessions/${r}/revoke`,
      params: {
        projectId: K.state.projectId
      },
      body: {
        pci: e,
        signature: t
      }
    }) : { success: !1 };
  },
  setClientId(r) {
    Hr.clientId = r, Hr.api = new pf({ baseUrl: KC, clientId: r });
  }
};
function Bx(r, { strict: e = !0 } = {}) {
  return !r || typeof r != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(r) : r.startsWith("0x");
}
function oE(r) {
  return Bx(r, { strict: !1 }) ? Math.ceil((r.length - 2) / 2) : r.length;
}
const JC = "2.31.3";
let Zu = {
  getDocsUrl: ({ docsBaseUrl: r, docsPath: e = "", docsSlug: t }) => e ? `${r ?? "https://viem.sh"}${e}${t ? `#${t}` : ""}` : void 0,
  version: `viem@${JC}`
}, vs = class Vw extends Error {
  constructor(e, t = {}) {
    var a;
    const n = (() => {
      var c;
      return t.cause instanceof Vw ? t.cause.details : (c = t.cause) != null && c.message ? t.cause.message : t.details;
    })(), s = t.cause instanceof Vw && t.cause.docsPath || t.docsPath, i = (a = Zu.getDocsUrl) == null ? void 0 : a.call(Zu, { ...t, docsPath: s }), o = [
      e || "An error occurred.",
      "",
      ...t.metaMessages ? [...t.metaMessages, ""] : [],
      ...i ? [`Docs: ${i}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...Zu.version ? [`Version: ${Zu.version}`] : []
    ].join(`
`);
    super(o, t.cause ? { cause: t.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = s, this.metaMessages = t.metaMessages, this.name = t.name ?? this.name, this.shortMessage = e, this.version = JC;
  }
  walk(e) {
    return YC(this, e);
  }
};
function YC(r, e) {
  return e != null && e(r) ? r : r && typeof r == "object" && "cause" in r && r.cause !== void 0 ? YC(r.cause, e) : e ? null : r;
}
class WJ extends vs {
  constructor({ offset: e, position: t, size: n }) {
    super(`Slice ${t === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${n}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
let QC = class extends vs {
  constructor({ size: e, targetSize: t, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};
function R0(r, { dir: e, size: t = 32 } = {}) {
  return typeof r == "string" ? Lx(r, { dir: e, size: t }) : Fx(r, { dir: e, size: t });
}
function Lx(r, { dir: e, size: t = 32 } = {}) {
  if (t === null)
    return r;
  const n = r.replace("0x", "");
  if (n.length > t * 2)
    throw new QC({
      size: Math.ceil(n.length / 2),
      targetSize: t,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](t * 2, "0")}`;
}
function Fx(r, { dir: e, size: t = 32 } = {}) {
  if (t === null)
    return r;
  if (r.length > t)
    throw new QC({
      size: r.length,
      targetSize: t,
      type: "bytes"
    });
  const n = new Uint8Array(t);
  for (let s = 0; s < t; s++) {
    const i = e === "right";
    n[i ? s : t - s - 1] = r[i ? s : r.length - s - 1];
  }
  return n;
}
let $x = class extends vs {
  constructor({ max: e, min: t, signed: n, size: s, value: i }) {
    super(`Number "${i}" is not in safe ${s ? `${s * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`, { name: "IntegerOutOfRangeError" });
  }
}, Mx = class extends vs {
  constructor({ givenSize: e, maxSize: t }) {
    super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
};
function ZC(r, { size: e }) {
  if (oE(r) > e)
    throw new Mx({
      givenSize: oE(r),
      maxSize: e
    });
}
const jx = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function aE(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? zx(r, e) : typeof r == "string" ? e_(r, e) : typeof r == "boolean" ? Hx(r, e) : XC(r, e);
}
function Hx(r, e = {}) {
  const t = `0x${Number(r)}`;
  return typeof e.size == "number" ? (ZC(t, { size: e.size }), R0(t, { size: e.size })) : t;
}
function XC(r, e = {}) {
  let t = "";
  for (let s = 0; s < r.length; s++)
    t += jx[r[s]];
  const n = `0x${t}`;
  return typeof e.size == "number" ? (ZC(n, { size: e.size }), R0(n, { dir: "right", size: e.size })) : n;
}
function zx(r, e = {}) {
  const { signed: t, size: n } = e, s = BigInt(r);
  let i;
  n ? t ? i = (1n << BigInt(n) * 8n - 1n) - 1n : i = 2n ** (BigInt(n) * 8n) - 1n : typeof r == "number" && (i = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof i == "bigint" && t ? -i - 1n : 0;
  if (i && s > i || s < o) {
    const c = typeof r == "bigint" ? "n" : "";
    throw new $x({
      max: i ? `${i}${c}` : void 0,
      min: `${o}${c}`,
      signed: t,
      size: n,
      value: `${r}${c}`
    });
  }
  const a = `0x${(t && s < 0 ? (1n << BigInt(n * 8)) + BigInt(s) : s).toString(16)}`;
  return n ? R0(a, { size: n }) : a;
}
const qx = /* @__PURE__ */ new TextEncoder();
function e_(r, e = {}) {
  const t = qx.encode(r);
  return XC(t, e);
}
const Mf = /* @__PURE__ */ BigInt(2 ** 32 - 1), cE = /* @__PURE__ */ BigInt(32);
function Wx(r, e = !1) {
  return e ? { h: Number(r & Mf), l: Number(r >> cE & Mf) } : { h: Number(r >> cE & Mf) | 0, l: Number(r & Mf) | 0 };
}
function Vx(r, e = !1) {
  const t = r.length;
  let n = new Uint32Array(t), s = new Uint32Array(t);
  for (let i = 0; i < t; i++) {
    const { h: o, l: a } = Wx(r[i], e);
    [n[i], s[i]] = [o, a];
  }
  return [n, s];
}
const Gx = (r, e, t) => r << t | e >>> 32 - t, Kx = (r, e, t) => e << t | r >>> 32 - t, Jx = (r, e, t) => e << t - 32 | r >>> 64 - t, Yx = (r, e, t) => r << t - 32 | e >>> 64 - t, Uc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Qx(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Gp(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error("positive integer expected, got " + r);
}
function vu(r, ...e) {
  if (!Qx(r))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function JJ(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  Gp(r.outputLen), Gp(r.blockLen);
}
function lE(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function Zx(r, e) {
  vu(r);
  const t = e.outputLen;
  if (r.length < t)
    throw new Error("digestInto() expects output buffer of length at least " + t);
}
function Xx(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function t_(...r) {
  for (let e = 0; e < r.length; e++)
    r[e].fill(0);
}
function YJ(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function QJ(r, e) {
  return r << 32 - e | r >>> e;
}
const eO = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function tO(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
function rO(r) {
  for (let e = 0; e < r.length; e++)
    r[e] = tO(r[e]);
  return r;
}
const uE = eO ? (r) => r : rO, nO = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", sO = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function ZJ(r) {
  if (vu(r), nO)
    return r.toHex();
  let e = "";
  for (let t = 0; t < r.length; t++)
    e += sO[r[t]];
  return e;
}
function iO(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function D0(r) {
  return typeof r == "string" && (r = iO(r)), vu(r), r;
}
function XJ(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    vu(s), e += s.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    t.set(i, s), s += i.length;
  }
  return t;
}
let oO = class {
};
function aO(r) {
  const e = (n) => r().update(D0(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function cO(r) {
  const e = (n, s) => r(s).update(D0(n)).digest(), t = r({});
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (n) => r(n), e;
}
function tY(r = 32) {
  if (Uc && typeof Uc.getRandomValues == "function")
    return Uc.getRandomValues(new Uint8Array(r));
  if (Uc && typeof Uc.randomBytes == "function")
    return Uint8Array.from(Uc.randomBytes(r));
  throw new Error("crypto.getRandomValues must be defined");
}
const lO = BigInt(0), Xu = BigInt(1), uO = BigInt(2), hO = BigInt(7), dO = BigInt(256), fO = BigInt(113), r_ = [], n_ = [], s_ = [];
for (let r = 0, e = Xu, t = 1, n = 0; r < 24; r++) {
  [t, n] = [n, (2 * t + 3 * n) % 5], r_.push(2 * (5 * n + t)), n_.push((r + 1) * (r + 2) / 2 % 64);
  let s = lO;
  for (let i = 0; i < 7; i++)
    e = (e << Xu ^ (e >> hO) * fO) % dO, e & uO && (s ^= Xu << (Xu << /* @__PURE__ */ BigInt(i)) - Xu);
  s_.push(s);
}
const i_ = Vx(s_, !0), pO = i_[0], gO = i_[1], hE = (r, e, t) => t > 32 ? Jx(r, e, t) : Gx(r, e, t), dE = (r, e, t) => t > 32 ? Yx(r, e, t) : Kx(r, e, t);
function o_(r, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, l = t[c], u = t[c + 1], h = hE(l, u, 1) ^ t[a], d = dE(l, u, 1) ^ t[a + 1];
      for (let f = 0; f < 50; f += 10)
        r[o + f] ^= h, r[o + f + 1] ^= d;
    }
    let s = r[2], i = r[3];
    for (let o = 0; o < 24; o++) {
      const a = n_[o], c = hE(s, i, a), l = dE(s, i, a), u = r_[o];
      s = r[u], i = r[u + 1], r[u] = c, r[u + 1] = l;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        t[a] = r[o + a];
      for (let a = 0; a < 10; a++)
        r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    r[0] ^= pO[n], r[1] ^= gO[n];
  }
  t_(t);
}
let k0 = class a_ extends oO {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, t, n, s = !1, i = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = s, this.rounds = i, Gp(n), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = Xx(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    uE(this.state32), o_(this.state32, this.rounds), uE(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    lE(this), e = D0(e), vu(e);
    const { blockLen: t, state: n } = this, s = e.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(t - this.pos, s - i);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[i++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: t, pos: n, blockLen: s } = this;
    e[n] ^= t, t & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    lE(this, !1), vu(e), this.finish();
    const t = this.state, { blockLen: n } = this;
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - s);
      e.set(t.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Gp(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Zx(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, t_(this.state);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
    return e || (e = new a_(t, n, s, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
};
const ea = (r, e, t) => aO(() => new k0(e, r, t)), mO = ea(6, 144, 224 / 8), wO = ea(6, 136, 256 / 8), yO = ea(6, 104, 384 / 8), bO = ea(6, 72, 512 / 8), EO = ea(1, 144, 224 / 8), c_ = ea(1, 136, 256 / 8), vO = ea(1, 104, 384 / 8), AO = ea(1, 72, 512 / 8), l_ = (r, e, t) => cO((n = {}) => new k0(e, r, n.dkLen === void 0 ? t : n.dkLen, !0)), CO = l_(31, 168, 128 / 8), _O = l_(31, 136, 256 / 8), rY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Keccak: k0,
  keccakP: o_,
  keccak_224: EO,
  keccak_256: c_,
  keccak_384: vO,
  keccak_512: AO,
  sha3_224: mO,
  sha3_256: wO,
  sha3_384: yO,
  sha3_512: bO,
  shake128: CO,
  shake256: _O
}, Symbol.toStringTag, { value: "Module" }));
let IO = class extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const t = super.get(e);
    return super.has(e) && t !== void 0 && (this.delete(e), super.set(e, t)), t;
  }
  set(e, t) {
    if (super.set(e, t), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
};
const ec = (r, e, t) => JSON.stringify(r, (n, s) => typeof s == "bigint" ? s.toString() : s, t);
function SO(r, e) {
  let t = r.toString();
  const n = t.startsWith("-");
  n && (t = t.slice(1)), t = t.padStart(e, "0");
  let [s, i] = [
    t.slice(0, t.length - e),
    t.slice(t.length - e)
  ];
  return i = i.replace(/(0+)$/, ""), `${n ? "-" : ""}${s || "0"}${i ? `.${i}` : ""}`;
}
const U0 = (r) => r;
class Dh extends vs {
  constructor({ body: e, cause: t, details: n, headers: s, status: i, url: o }) {
    super("HTTP request failed.", {
      cause: t,
      details: n,
      metaMessages: [
        i && `Status: ${i}`,
        `URL: ${U0(o)}`,
        e && `Request body: ${ec(e)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = e, this.headers = s, this.status = i, this.url = o;
  }
}
class u_ extends vs {
  constructor({ body: e, error: t, url: n }) {
    super("RPC Request failed.", {
      cause: t,
      details: t.message,
      metaMessages: [`URL: ${U0(n)}`, `Request body: ${ec(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = t.code, this.data = t.data;
  }
}
class fE extends vs {
  constructor({ body: e, url: t }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${U0(t)}`, `Request body: ${ec(e)}`],
      name: "TimeoutError"
    });
  }
}
const NO = -1;
class hn extends vs {
  constructor(e, { code: t, docsPath: n, metaMessages: s, name: i, shortMessage: o }) {
    super(o, {
      cause: e,
      docsPath: n,
      metaMessages: s || (e == null ? void 0 : e.metaMessages),
      name: i || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = i || e.name, this.code = e instanceof u_ ? e.code : t ?? NO;
  }
}
class Nn extends hn {
  constructor(e, t) {
    super(e, t), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t.data;
  }
}
class Zh extends hn {
  constructor(e) {
    super(e, {
      code: Zh.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(Zh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class Xh extends hn {
  constructor(e) {
    super(e, {
      code: Xh.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(Xh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class ed extends hn {
  constructor(e, { method: t } = {}) {
    super(e, {
      code: ed.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${t ? ` "${t}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(ed, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class td extends hn {
  constructor(e) {
    super(e, {
      code: td.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(td, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class Au extends hn {
  constructor(e) {
    super(e, {
      code: Au.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(Au, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class rd extends hn {
  constructor(e) {
    super(e, {
      code: rd.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(rd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class nd extends hn {
  constructor(e) {
    super(e, {
      code: nd.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(nd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class sd extends hn {
  constructor(e) {
    super(e, {
      code: sd.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(sd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class Cu extends hn {
  constructor(e) {
    super(e, {
      code: Cu.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(Cu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class Ia extends hn {
  constructor(e, { method: t } = {}) {
    super(e, {
      code: Ia.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${t ? ` "${t}"` : ""} is not supported.`
    });
  }
}
Object.defineProperty(Ia, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class _u extends hn {
  constructor(e) {
    super(e, {
      code: _u.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(_u, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class id extends hn {
  constructor(e) {
    super(e, {
      code: id.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(id, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class tc extends Nn {
  constructor(e) {
    super(e, {
      code: tc.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(tc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class od extends Nn {
  constructor(e) {
    super(e, {
      code: od.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(od, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class ad extends Nn {
  constructor(e, { method: t } = {}) {
    super(e, {
      code: ad.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${t ? ` " ${t}"` : ""}.`
    });
  }
}
Object.defineProperty(ad, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class cd extends Nn {
  constructor(e) {
    super(e, {
      code: cd.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(cd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class ld extends Nn {
  constructor(e) {
    super(e, {
      code: ld.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(ld, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class ud extends Nn {
  constructor(e) {
    super(e, {
      code: ud.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(ud, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class hd extends Nn {
  constructor(e) {
    super(e, {
      code: hd.code,
      name: "UnsupportedNonOptionalCapabilityError",
      shortMessage: "This Wallet does not support a capability that was not marked as optional."
    });
  }
}
Object.defineProperty(hd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5700
});
class dd extends Nn {
  constructor(e) {
    super(e, {
      code: dd.code,
      name: "UnsupportedChainIdError",
      shortMessage: "This Wallet does not support the requested chain ID."
    });
  }
}
Object.defineProperty(dd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5710
});
class fd extends Nn {
  constructor(e) {
    super(e, {
      code: fd.code,
      name: "DuplicateIdError",
      shortMessage: "There is already a bundle submitted with this ID."
    });
  }
}
Object.defineProperty(fd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5720
});
class pd extends Nn {
  constructor(e) {
    super(e, {
      code: pd.code,
      name: "UnknownBundleIdError",
      shortMessage: "This bundle id is unknown / has not been submitted"
    });
  }
}
Object.defineProperty(pd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5730
});
class gd extends Nn {
  constructor(e) {
    super(e, {
      code: gd.code,
      name: "BundleTooLargeError",
      shortMessage: "The call bundle is too large for the Wallet to process."
    });
  }
}
Object.defineProperty(gd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5740
});
class md extends Nn {
  constructor(e) {
    super(e, {
      code: md.code,
      name: "AtomicReadyWalletRejectedUpgradeError",
      shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
    });
  }
}
Object.defineProperty(md, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5750
});
class wd extends Nn {
  constructor(e) {
    super(e, {
      code: wd.code,
      name: "AtomicityNotSupportedError",
      shortMessage: "The wallet does not support atomic execution but the request requires it."
    });
  }
}
Object.defineProperty(wd, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5760
});
class TO extends hn {
  constructor(e) {
    super(e, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
class B0 extends vs {
  constructor({ cause: e, message: t } = {}) {
    var s;
    const n = (s = t == null ? void 0 : t.replace("execution reverted: ", "")) == null ? void 0 : s.replace("execution reverted", "");
    super(`Execution reverted ${n ? `with reason: ${n}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(B0, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(B0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
function xO() {
  let r = () => {
  }, e = () => {
  };
  return { promise: new Promise((n, s) => {
    r = n, e = s;
  }), resolve: r, reject: e };
}
const xm = /* @__PURE__ */ new Map();
function OO({ fn: r, id: e, shouldSplitBatch: t, wait: n = 0, sort: s }) {
  const i = async () => {
    const u = c();
    o();
    const h = u.map(({ args: d }) => d);
    h.length !== 0 && r(h).then((d) => {
      s && Array.isArray(d) && d.sort(s);
      for (let f = 0; f < u.length; f++) {
        const { resolve: g } = u[f];
        g == null || g([d[f], d]);
      }
    }).catch((d) => {
      for (let f = 0; f < u.length; f++) {
        const { reject: g } = u[f];
        g == null || g(d);
      }
    });
  }, o = () => xm.delete(e), a = () => c().map(({ args: u }) => u), c = () => xm.get(e) || [], l = (u) => xm.set(e, [...c(), u]);
  return {
    flush: o,
    async schedule(u) {
      const { promise: h, resolve: d, reject: f } = xO();
      return (t == null ? void 0 : t([...a(), u])) && i(), c().length > 0 ? (l({ args: u, resolve: d, reject: f }), h) : (l({ args: u, resolve: d, reject: f }), setTimeout(i, n), h);
    }
  };
}
async function h_(r) {
  return new Promise((e) => setTimeout(e, r));
}
const Gw = 256;
let jf = Gw, Hf;
function PO(r = 11) {
  if (!Hf || jf + r > Gw * 2) {
    Hf = "", jf = 0;
    for (let e = 0; e < Gw; e++)
      Hf += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return Hf.substring(jf, jf++ + r);
}
const zf = /* @__PURE__ */ new IO(8192);
function RO(r, { enabled: e = !0, id: t }) {
  if (!e || !t)
    return r();
  if (zf.get(t))
    return zf.get(t);
  const n = r().finally(() => zf.delete(t));
  return zf.set(t, n), n;
}
function DO(r, { delay: e = 100, retryCount: t = 2, shouldRetry: n = () => !0 } = {}) {
  return new Promise((s, i) => {
    const o = async ({ count: a = 0 } = {}) => {
      const c = async ({ error: l }) => {
        const u = typeof e == "function" ? e({ count: a, error: l }) : e;
        u && await h_(u), o({ count: a + 1 });
      };
      try {
        const l = await r();
        s(l);
      } catch (l) {
        if (a < t && await n({ count: a, error: l }))
          return c({ error: l });
        i(l);
      }
    };
    o();
  });
}
function kO(r, e = {}) {
  return async (t, n = {}) => {
    var h;
    const { dedupe: s = !1, methods: i, retryDelay: o = 150, retryCount: a = 3, uid: c } = {
      ...e,
      ...n
    }, { method: l } = t;
    if ((h = i == null ? void 0 : i.exclude) != null && h.includes(l))
      throw new Ia(new Error("method not supported"), {
        method: l
      });
    if (i != null && i.include && !i.include.includes(l))
      throw new Ia(new Error("method not supported"), {
        method: l
      });
    const u = s ? e_(`${c}.${ec(t)}`) : void 0;
    return RO(() => DO(async () => {
      try {
        return await r(t);
      } catch (d) {
        const f = d;
        switch (f.code) {
          case Zh.code:
            throw new Zh(f);
          case Xh.code:
            throw new Xh(f);
          case ed.code:
            throw new ed(f, { method: t.method });
          case td.code:
            throw new td(f);
          case Au.code:
            throw new Au(f);
          case rd.code:
            throw new rd(f);
          case nd.code:
            throw new nd(f);
          case sd.code:
            throw new sd(f);
          case Cu.code:
            throw new Cu(f);
          case Ia.code:
            throw new Ia(f, {
              method: t.method
            });
          case _u.code:
            throw new _u(f);
          case id.code:
            throw new id(f);
          case tc.code:
            throw new tc(f);
          case od.code:
            throw new od(f);
          case ad.code:
            throw new ad(f);
          case cd.code:
            throw new cd(f);
          case ld.code:
            throw new ld(f);
          case ud.code:
            throw new ud(f);
          case hd.code:
            throw new hd(f);
          case dd.code:
            throw new dd(f);
          case fd.code:
            throw new fd(f);
          case pd.code:
            throw new pd(f);
          case gd.code:
            throw new gd(f);
          case md.code:
            throw new md(f);
          case wd.code:
            throw new wd(f);
          case 5e3:
            throw new tc(f);
          default:
            throw d instanceof vs ? d : new TO(f);
        }
      }
    }, {
      delay: ({ count: d, error: f }) => {
        var g;
        if (f && f instanceof Dh) {
          const p = (g = f == null ? void 0 : f.headers) == null ? void 0 : g.get("Retry-After");
          if (p != null && p.match(/\d/))
            return Number.parseInt(p) * 1e3;
        }
        return ~~(1 << d) * o;
      },
      retryCount: a,
      shouldRetry: ({ error: d }) => UO(d)
    }), { enabled: s, id: u });
  };
}
function UO(r) {
  return "code" in r && typeof r.code == "number" ? r.code === -1 || r.code === _u.code || r.code === Au.code : r instanceof Dh && r.status ? r.status === 403 || r.status === 408 || r.status === 413 || r.status === 429 || r.status === 500 || r.status === 502 || r.status === 503 || r.status === 504 : !0;
}
function d_({ key: r, methods: e, name: t, request: n, retryCount: s = 3, retryDelay: i = 150, timeout: o, type: a }, c) {
  const l = PO();
  return {
    config: {
      key: r,
      methods: e,
      name: t,
      request: n,
      retryCount: s,
      retryDelay: i,
      timeout: o,
      type: a
    },
    request: kO(n, { methods: e, retryCount: s, retryDelay: i, uid: l }),
    value: c
  };
}
function pE(r, e = {}) {
  const { key: t = "fallback", name: n = "Fallback", rank: s = !1, shouldThrow: i = BO, retryCount: o, retryDelay: a } = e;
  return ({ chain: c, pollingInterval: l = 4e3, timeout: u, ...h }) => {
    let d = r, f = () => {
    };
    const g = d_({
      key: t,
      name: n,
      async request({ method: p, params: w }) {
        let E;
        const I = async (A = 0) => {
          const C = d[A]({
            ...h,
            chain: c,
            retryCount: 0,
            timeout: u
          });
          try {
            const N = await C.request({
              method: p,
              params: w
            });
            return f({
              method: p,
              params: w,
              response: N,
              transport: C,
              status: "success"
            }), N;
          } catch (N) {
            if (f({
              error: N,
              method: p,
              params: w,
              transport: C,
              status: "error"
            }), i(N) || A === d.length - 1 || (E ?? (E = d.slice(A + 1).some((x) => {
              const { include: O, exclude: k } = x({ chain: c }).config.methods || {};
              return O ? O.includes(p) : k ? !k.includes(p) : !0;
            })), !E))
              throw N;
            return I(A + 1);
          }
        };
        return I();
      },
      retryCount: o,
      retryDelay: a,
      type: "fallback"
    }, {
      onResponse: (p) => f = p,
      transports: d.map((p) => p({ chain: c, retryCount: 0 }))
    });
    if (s) {
      const p = typeof s == "object" ? s : {};
      LO({
        chain: c,
        interval: p.interval ?? l,
        onTransports: (w) => d = w,
        ping: p.ping,
        sampleCount: p.sampleCount,
        timeout: p.timeout,
        transports: d,
        weights: p.weights
      });
    }
    return g;
  };
}
function BO(r) {
  return !!("code" in r && typeof r.code == "number" && (r.code === Cu.code || r.code === tc.code || B0.nodeMessage.test(r.message) || r.code === 5e3));
}
function LO({ chain: r, interval: e = 4e3, onTransports: t, ping: n, sampleCount: s = 10, timeout: i = 1e3, transports: o, weights: a = {} }) {
  const { stability: c = 0.7, latency: l = 0.3 } = a, u = [], h = async () => {
    const d = await Promise.all(o.map(async (p) => {
      const w = p({ chain: r, retryCount: 0, timeout: i }), E = Date.now();
      let I, A;
      try {
        await (n ? n({ transport: w }) : w.request({ method: "net_listening" })), A = 1;
      } catch {
        A = 0;
      } finally {
        I = Date.now();
      }
      return { latency: I - E, success: A };
    }));
    u.push(d), u.length > s && u.shift();
    const f = Math.max(...u.map((p) => Math.max(...p.map(({ latency: w }) => w)))), g = o.map((p, w) => {
      const E = u.map((x) => x[w].latency), A = 1 - E.reduce((x, O) => x + O, 0) / E.length / f, C = u.map((x) => x[w].success), N = C.reduce((x, O) => x + O, 0) / C.length;
      return N === 0 ? [0, w] : [
        l * A + c * N,
        w
      ];
    }).sort((p, w) => w[0] - p[0]);
    t(g.map(([, p]) => o[p])), await h_(e), h();
  };
  h();
}
class FO extends vs {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}
function $O(r, { errorInstance: e = new Error("timed out"), timeout: t, signal: n }) {
  return new Promise((s, i) => {
    (async () => {
      let o;
      try {
        const a = new AbortController();
        t > 0 && (o = setTimeout(() => {
          n && a.abort();
        }, t)), s(await r({ signal: (a == null ? void 0 : a.signal) || null }));
      } catch (a) {
        (a == null ? void 0 : a.name) === "AbortError" && i(e), i(a);
      } finally {
        clearTimeout(o);
      }
    })();
  });
}
function MO() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const gE = /* @__PURE__ */ MO();
function jO(r, e = {}) {
  return {
    async request(t) {
      var h;
      const { body: n, onRequest: s = e.onRequest, onResponse: i = e.onResponse, timeout: o = e.timeout ?? 1e4 } = t, a = {
        ...e.fetchOptions ?? {},
        ...t.fetchOptions ?? {}
      }, { headers: c, method: l, signal: u } = a;
      try {
        const d = await $O(async ({ signal: g }) => {
          const p = {
            ...a,
            body: Array.isArray(n) ? ec(n.map((A) => ({
              jsonrpc: "2.0",
              id: A.id ?? gE.take(),
              ...A
            }))) : ec({
              jsonrpc: "2.0",
              id: n.id ?? gE.take(),
              ...n
            }),
            headers: {
              "Content-Type": "application/json",
              ...c
            },
            method: l || "POST",
            signal: u || (o > 0 ? g : null)
          }, w = new Request(r, p), E = await (s == null ? void 0 : s(w, p)) ?? { ...p, url: r };
          return await fetch(E.url ?? r, E);
        }, {
          errorInstance: new fE({ body: n, url: r }),
          timeout: o,
          signal: !0
        });
        i && await i(d);
        let f;
        if ((h = d.headers.get("Content-Type")) != null && h.startsWith("application/json"))
          f = await d.json();
        else {
          f = await d.text();
          try {
            f = JSON.parse(f || "{}");
          } catch (g) {
            if (d.ok)
              throw g;
            f = { error: f };
          }
        }
        if (!d.ok)
          throw new Dh({
            body: n,
            details: ec(f.error) || d.statusText,
            headers: d.headers,
            status: d.status,
            url: r
          });
        return f;
      } catch (d) {
        throw d instanceof Dh || d instanceof fE ? d : new Dh({
          body: n,
          cause: d,
          url: r
        });
      }
    }
  };
}
function qf(r, e = {}) {
  const { batch: t, fetchOptions: n, key: s = "http", methods: i, name: o = "HTTP JSON-RPC", onFetchRequest: a, onFetchResponse: c, retryDelay: l, raw: u } = e;
  return ({ chain: h, retryCount: d, timeout: f }) => {
    const { batchSize: g = 1e3, wait: p = 0 } = typeof t == "object" ? t : {}, w = e.retryCount ?? d, E = f ?? e.timeout ?? 1e4, I = r || (h == null ? void 0 : h.rpcUrls.default.http[0]);
    if (!I)
      throw new FO();
    const A = jO(I, {
      fetchOptions: n,
      onRequest: a,
      onResponse: c,
      timeout: E
    });
    return d_({
      key: s,
      methods: i,
      name: o,
      async request({ method: C, params: N }) {
        const x = { method: C, params: N }, { schedule: O } = OO({
          id: I,
          wait: p,
          shouldSplitBatch(U) {
            return U.length > g;
          },
          fn: (U) => A.request({
            body: U
          }),
          sort: (U, j) => U.id - j.id
        }), k = async (U) => t ? O(U) : [
          await A.request({
            body: U
          })
        ], [{ error: P, result: $ }] = await k(x);
        if (u)
          return { error: P, result: $ };
        if (P)
          throw new u_({
            body: x,
            error: P,
            url: I
          });
        return $;
      },
      retryCount: w,
      retryDelay: l,
      timeout: E,
      type: "http"
    }, {
      fetchOptions: n,
      url: I
    });
  };
}
function HO(r) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...r
  };
}
const Om = {
  /**
   * Creates a Balance object from an ERC7811 Asset object
   * @param asset - Asset object to convert
   * @param chainId - Chain ID in CAIP-2 format
   * @returns Balance object
   */
  createBalance(r, e) {
    const t = {
      name: r.metadata.name || "",
      symbol: r.metadata.symbol || "",
      decimals: r.metadata.decimals || 0,
      value: r.metadata.value || 0,
      price: r.metadata.price || 0,
      iconUrl: r.metadata.iconUrl || ""
    };
    return {
      name: t.name,
      symbol: t.symbol,
      chainId: e,
      address: r.address === "native" ? void 0 : this.convertAddressToCAIP10Address(r.address, e),
      value: t.value,
      price: t.price,
      quantity: {
        decimals: t.decimals.toString(),
        numeric: this.convertHexToBalance({
          hex: r.balance,
          decimals: t.decimals
        })
      },
      iconUrl: t.iconUrl
    };
  },
  /**
   * Converts a hex string to a Balance object
   * @param hex - Hex string to convert
   * @param decimals - Number of decimals to use
   * @returns Balance object
   */
  convertHexToBalance({ hex: r, decimals: e }) {
    return SO(BigInt(r), e);
  },
  /**
   * Converts an address to a CAIP-10 address
   * @param address - Address to convert
   * @param chainId - Chain ID in CAIP-2 format
   * @returns CAIP-10 address
   */
  convertAddressToCAIP10Address(r, e) {
    return `${e}:${r}`;
  },
  /**
   *  Creates a CAIP-2 Chain ID from a chain ID and namespace
   * @param chainId  - Chain ID in hex format
   * @param namespace  - Chain namespace
   * @returns
   */
  createCAIP2ChainId(r, e) {
    return `${e}:${parseInt(r, 16)}`;
  },
  /**
   * Gets the chain ID in hex format from a CAIP-2 Chain ID
   * @param caip2ChainId - CAIP-2 Chain ID
   * @returns Chain ID in hex format
   */
  getChainIdHexFromCAIP2ChainId(r) {
    const e = r.split(":");
    if (e.length < 2 || !e[1])
      return "0x0";
    const t = e[1], n = parseInt(t, 10);
    return isNaN(n) ? "0x0" : `0x${n.toString(16)}`;
  },
  /**
   * Checks if a response is a valid WalletGetAssetsResponse
   * @param response - The response to check
   * @returns True if the response is a valid WalletGetAssetsResponse, false otherwise
   */
  isWalletGetAssetsResponse(r) {
    return typeof r != "object" || r === null ? !1 : Object.values(r).every((e) => Array.isArray(e) && e.every((t) => this.isValidAsset(t)));
  },
  /**
   * Checks if an asset object is valid.
   * @param asset - The asset object to check.
   * @returns True if the asset is valid, false otherwise.
   */
  isValidAsset(r) {
    return typeof r == "object" && r !== null && typeof r.address == "string" && typeof r.balance == "string" && (r.type === "ERC20" || r.type === "NATIVE") && typeof r.metadata == "object" && r.metadata !== null && typeof r.metadata.name == "string" && typeof r.metadata.symbol == "string" && typeof r.metadata.decimals == "number" && typeof r.metadata.price == "number" && typeof r.metadata.iconUrl == "string";
  }
}, L0 = {
  /**
   * Get the balances of the user's tokens. If user connected with Auth provider or and on the EIP155 network,
   * it'll use the `wallet_getAssets` and `wallet_getCapabilities` calls to fetch the balance rather than Blockchain API
   * @param forceUpdate - If true, the balances will be fetched from the server
   * @returns The balances of the user's tokens
   */
  async getMyTokensWithBalance(r) {
    const e = X.state.address, t = _.state.activeCaipNetwork, n = re.getConnectorId("eip155") === W.CONNECTOR_ID.AUTH;
    if (!e || !t)
      return [];
    const s = `${t.caipNetworkId}:${e}`, i = te.getBalanceCacheForCaipAddress(s);
    if (i)
      return i.balances;
    if (t.chainNamespace === "eip155" && n) {
      const a = await this.getEIP155Balances(e, t);
      if (a)
        return this.filterLowQualityTokens(a);
    }
    const o = await ve.getBalance(e, t.caipNetworkId, r);
    return this.filterLowQualityTokens(o.balances);
  },
  /**
   * Get the balances of the user's tokens on the EIP155 network using native `wallet_getAssets` and `wallet_getCapabilities` calls
   * @param address - The address of the user
   * @param caipNetwork - The CAIP network
   * @returns The balances of the user's tokens on the EIP155 network
   */
  async getEIP155Balances(r, e) {
    var t, n;
    try {
      const s = Om.getChainIdHexFromCAIP2ChainId(e.caipNetworkId), i = await ue.getCapabilities(r);
      if (!((n = (t = i == null ? void 0 : i[s]) == null ? void 0 : t.assetDiscovery) != null && n.supported))
        return null;
      const o = await ue.walletGetAssets({
        account: r,
        chainFilter: [s]
      });
      if (!Om.isWalletGetAssetsResponse(o))
        return null;
      const c = (o[s] || []).map((l) => Om.createBalance(l, e.caipNetworkId));
      return te.updateBalanceCache({
        caipAddress: `${e.caipNetworkId}:${r}`,
        balance: { balances: c },
        timestamp: Date.now()
      }), c;
    } catch {
      return null;
    }
  },
  /**
   * The 1Inch API includes many low-quality tokens in the balance response,
   * which appear inconsistently. This filter prevents them from being displayed.
   */
  filterLowQualityTokens(r) {
    return r.filter((e) => e.quantity.decimals !== "0");
  }
}, xn = _t({
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: !1,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: []
}), zO = {
  state: xn,
  replaceState(r) {
    r && Object.assign(xn, ac(r));
  },
  subscribe(r) {
    return _.subscribeChainProp("accountState", (e) => {
      if (e)
        return r(e);
    });
  },
  subscribeKey(r, e, t) {
    let n;
    return _.subscribeChainProp("accountState", (s) => {
      if (s) {
        const i = s[r];
        n !== i && (n = i, e(i));
      }
    }, t);
  },
  setStatus(r, e) {
    _.setAccountProp("status", r, e);
  },
  getCaipAddress(r) {
    return _.getAccountProp("caipAddress", r);
  },
  setCaipAddress(r, e) {
    const t = r ? me.getPlainAddress(r) : void 0;
    e === _.state.activeChain && (_.state.activeCaipAddress = r), _.setAccountProp("caipAddress", r, e), _.setAccountProp("address", t, e);
  },
  setBalance(r, e, t) {
    _.setAccountProp("balance", r, t), _.setAccountProp("balanceSymbol", e, t);
  },
  setProfileName(r, e) {
    _.setAccountProp("profileName", r, e);
  },
  setProfileImage(r, e) {
    _.setAccountProp("profileImage", r, e);
  },
  setUser(r, e) {
    _.setAccountProp("user", r, e);
  },
  setAddressExplorerUrl(r, e) {
    _.setAccountProp("addressExplorerUrl", r, e);
  },
  setSmartAccountDeployed(r, e) {
    _.setAccountProp("smartAccountDeployed", r, e);
  },
  setCurrentTab(r) {
    _.setAccountProp("currentTab", r, _.state.activeChain);
  },
  setTokenBalance(r, e) {
    r && _.setAccountProp("tokenBalance", r, e);
  },
  setShouldUpdateToAddress(r, e) {
    _.setAccountProp("shouldUpdateToAddress", r, e);
  },
  setAllAccounts(r, e) {
    _.setAccountProp("allAccounts", r, e);
  },
  addAddressLabel(r, e, t) {
    const n = _.getAccountProp("addressLabels", t) || /* @__PURE__ */ new Map();
    n.set(r, e), _.setAccountProp("addressLabels", n, t);
  },
  removeAddressLabel(r, e) {
    const t = _.getAccountProp("addressLabels", e) || /* @__PURE__ */ new Map();
    t.delete(r), _.setAccountProp("addressLabels", t, e);
  },
  setConnectedWalletInfo(r, e) {
    _.setAccountProp("connectedWalletInfo", r, e, !1);
  },
  setPreferredAccountType(r, e) {
    _.setAccountProp("preferredAccountTypes", {
      ...xn.preferredAccountTypes,
      [e]: r
    }, e);
  },
  setPreferredAccountTypes(r) {
    xn.preferredAccountTypes = r;
  },
  setSocialProvider(r, e) {
    r && _.setAccountProp("socialProvider", r, e);
  },
  setSocialWindow(r, e) {
    _.setAccountProp("socialWindow", r ? ac(r) : void 0, e);
  },
  setFarcasterUrl(r, e) {
    _.setAccountProp("farcasterUrl", r, e);
  },
  async fetchTokenBalance(r) {
    var i, o;
    xn.balanceLoading = !0;
    const e = (i = _.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId, t = (o = _.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace, n = _.state.activeCaipAddress, s = n ? me.getPlainAddress(n) : void 0;
    if (xn.lastRetry && !me.isAllowedRetry(xn.lastRetry, 30 * at.ONE_SEC_MS))
      return xn.balanceLoading = !1, [];
    try {
      if (s && e && t) {
        const a = await L0.getMyTokensWithBalance();
        return X.setTokenBalance(a, t), xn.lastRetry = void 0, xn.balanceLoading = !1, a;
      }
    } catch (a) {
      xn.lastRetry = Date.now(), r == null || r(a), ds.showError("Token Balance Unavailable");
    } finally {
      xn.balanceLoading = !1;
    }
    return [];
  },
  resetAccount(r) {
    _.resetAccount(r);
  }
}, X = Sn(zO), qO = {
  /**
   * Function to handle the network switch.
   * This function has variety of conditions to handle the network switch depending on the connectors or namespace's connection states.
   * @param args.network - The network to switch to.
   * @param args.shouldConfirmSwitch - Whether to confirm the switch. If true, the user will be asked to confirm the switch if necessary.
   * @returns void
   */
  onSwitchNetwork({ network: r, ignoreSwitchConfirmation: e = !1 }) {
    const t = _.state.activeCaipNetwork, n = Ce.state.data;
    if (r.id === (t == null ? void 0 : t.id))
      return;
    const i = X.getCaipAddress(_.state.activeChain), o = r.chainNamespace !== _.state.activeChain, a = X.getCaipAddress(r.chainNamespace), l = re.getConnectorId(_.state.activeChain) === W.CONNECTOR_ID.AUTH, u = W.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((h) => h === r.chainNamespace);
    e || l && u ? Ce.push("SwitchNetwork", { ...n, network: r }) : /** * If user switching to a different namespace and next namespace is not connected, we need to show switch active chain view for confirmation first. */ i && o && !a ? Ce.push("SwitchActiveChain", {
      switchToChain: r.chainNamespace,
      navigateTo: "Connect",
      navigateWithReplace: !0,
      network: r
    }) : Ce.push("SwitchNetwork", { ...n, network: r });
  }
}, zr = _t({
  loading: !1,
  loadingNamespaceMap: /* @__PURE__ */ new Map(),
  open: !1,
  shake: !1,
  namespace: void 0
}), WO = {
  state: zr,
  subscribe(r) {
    return fr(zr, () => r(zr));
  },
  subscribeKey(r, e) {
    return Tr(zr, r, e);
  },
  async open(r) {
    var o, a;
    const e = X.state.status === "connected", t = r == null ? void 0 : r.namespace, n = _.state.activeChain, s = t && t !== n, i = (o = _.getAccountData(r == null ? void 0 : r.namespace)) == null ? void 0 : o.caipAddress;
    if (ue.state.wcBasic ? ye.prefetch({ fetchNetworkImages: !1, fetchConnectorImages: !1 }) : await ye.prefetch({
      fetchConnectorImages: !e,
      fetchFeaturedWallets: !e,
      fetchRecommendedWallets: !e
    }), re.setFilterByNamespace(r == null ? void 0 : r.namespace), nt.setLoading(!0, t), t && s) {
      const c = ((a = _.getNetworkData(t)) == null ? void 0 : a.caipNetwork) || _.getRequestedCaipNetworks(t)[0];
      c && qO.onSwitchNetwork({ network: c, ignoreSwitchConfirmation: !0 });
    } else {
      const c = _.state.noAdapters;
      K.state.manualWCControl || c && !i ? me.isMobile() ? Ce.reset("AllWallets") : Ce.reset("ConnectingWalletConnectBasic") : r != null && r.view ? Ce.reset(r.view, r.data) : i ? Ce.reset("Account") : Ce.reset("Connect");
    }
    zr.open = !0, Js.set({ open: !0 }), ct.sendEvent({
      type: "track",
      event: "MODAL_OPEN",
      properties: { connected: !!i }
    });
  },
  close() {
    const r = K.state.enableEmbedded, e = !!_.state.activeCaipAddress;
    zr.open && ct.sendEvent({
      type: "track",
      event: "MODAL_CLOSE",
      properties: { connected: e }
    }), zr.open = !1, Ce.reset("Connect"), nt.clearLoading(), r ? e ? Ce.replace("Account") : Ce.push("Connect") : Js.set({ open: !1 }), ue.resetUri();
  },
  setLoading(r, e) {
    e && zr.loadingNamespaceMap.set(e, r), zr.loading = r, Js.set({ loading: r });
  },
  clearLoading() {
    zr.loadingNamespaceMap.clear(), zr.loading = !1;
  },
  shake() {
    zr.shake || (zr.shake = !0, setTimeout(() => {
      zr.shake = !1;
    }, 500));
  }
}, nt = Sn(WO), kh = {
  id: "2b92315d-eab7-5bef-84fa-089a131333f5",
  name: "USD Coin",
  symbol: "USDC",
  networks: [
    {
      name: "ethereum-mainnet",
      display_name: "Ethereum",
      chain_id: "1",
      contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    {
      name: "polygon-mainnet",
      display_name: "Polygon",
      chain_id: "137",
      contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }
  ]
}, Kw = {
  id: "USD",
  payment_method_limits: [
    {
      id: "card",
      min: "10.00",
      max: "7500.00"
    },
    {
      id: "ach_bank_account",
      min: "10.00",
      max: "25000.00"
    }
  ]
}, VO = {
  providers: qC,
  selectedProvider: null,
  error: null,
  purchaseCurrency: kh,
  paymentCurrency: Kw,
  purchaseCurrencies: [kh],
  paymentCurrencies: [],
  quotesLoading: !1
}, We = _t(VO), GO = {
  state: We,
  subscribe(r) {
    return fr(We, () => r(We));
  },
  subscribeKey(r, e) {
    return Tr(We, r, e);
  },
  setSelectedProvider(r) {
    if (r && r.name === "meld") {
      const e = _.state.activeChain === W.CHAIN.SOLANA ? "SOL" : "USDC", t = X.state.address ?? "", n = new URL(r.url);
      n.searchParams.append("publicKey", sx), n.searchParams.append("destinationCurrencyCode", e), n.searchParams.append("walletAddress", t), n.searchParams.append("externalCustomerId", K.state.projectId), We.selectedProvider = { ...r, url: n.toString() };
    } else
      We.selectedProvider = r;
  },
  setOnrampProviders(r) {
    if (Array.isArray(r) && r.every((e) => typeof e == "string")) {
      const e = r, t = qC.filter((n) => e.includes(n.name));
      We.providers = t;
    } else
      We.providers = [];
  },
  setPurchaseCurrency(r) {
    We.purchaseCurrency = r;
  },
  setPaymentCurrency(r) {
    We.paymentCurrency = r;
  },
  setPurchaseAmount(r) {
    Jw.state.purchaseAmount = r;
  },
  setPaymentAmount(r) {
    Jw.state.paymentAmount = r;
  },
  async getAvailableCurrencies() {
    const r = await ve.getOnrampOptions();
    We.purchaseCurrencies = r.purchaseCurrencies, We.paymentCurrencies = r.paymentCurrencies, We.paymentCurrency = r.paymentCurrencies[0] || Kw, We.purchaseCurrency = r.purchaseCurrencies[0] || kh, await ye.fetchCurrencyImages(r.paymentCurrencies.map((e) => e.id)), await ye.fetchTokenImages(r.purchaseCurrencies.map((e) => e.symbol));
  },
  async getQuote() {
    var r, e;
    We.quotesLoading = !0;
    try {
      const t = await ve.getOnrampQuote({
        purchaseCurrency: We.purchaseCurrency,
        paymentCurrency: We.paymentCurrency,
        amount: ((r = We.paymentAmount) == null ? void 0 : r.toString()) || "0",
        network: (e = We.purchaseCurrency) == null ? void 0 : e.symbol
      });
      return We.quotesLoading = !1, We.purchaseAmount = Number(t == null ? void 0 : t.purchaseAmount.amount), t;
    } catch (t) {
      return We.error = t.message, We.quotesLoading = !1, null;
    } finally {
      We.quotesLoading = !1;
    }
  },
  resetState() {
    We.selectedProvider = null, We.error = null, We.purchaseCurrency = kh, We.paymentCurrency = Kw, We.purchaseCurrencies = [kh], We.paymentCurrencies = [], We.paymentAmount = void 0, We.purchaseAmount = void 0, We.quotesLoading = !1;
  }
}, Jw = Sn(GO), mE = 2147483648, KO = {
  convertEVMChainIdToCoinType(r) {
    if (r >= mE)
      throw new Error("Invalid chainId");
    return (mE | r) >>> 0;
  }
}, On = _t({
  suggestions: [],
  loading: !1
}), JO = {
  state: On,
  subscribe(r) {
    return fr(On, () => r(On));
  },
  subscribeKey(r, e) {
    return Tr(On, r, e);
  },
  async resolveName(r) {
    var e, t;
    try {
      return await ve.lookupEnsName(r);
    } catch (n) {
      const s = n;
      throw new Error(((t = (e = s == null ? void 0 : s.reasons) == null ? void 0 : e[0]) == null ? void 0 : t.description) || "Error resolving name");
    }
  },
  async isNameRegistered(r) {
    try {
      return await ve.lookupEnsName(r), !0;
    } catch {
      return !1;
    }
  },
  async getSuggestions(r) {
    try {
      On.loading = !0, On.suggestions = [];
      const e = await ve.getEnsNameSuggestions(r);
      return On.suggestions = e.suggestions.map((t) => ({
        ...t,
        name: t.name
      })) || [], On.suggestions;
    } catch (e) {
      const t = Uh.parseEnsApiError(e, "Error fetching name suggestions");
      throw new Error(t);
    } finally {
      On.loading = !1;
    }
  },
  async getNamesForAddress(r) {
    try {
      if (!_.state.activeCaipNetwork)
        return [];
      const t = te.getEnsFromCacheForAddress(r);
      if (t)
        return t;
      const n = await ve.reverseLookupEnsName({ address: r });
      return te.updateEnsCache({
        address: r,
        ens: n,
        timestamp: Date.now()
      }), n;
    } catch (e) {
      const t = Uh.parseEnsApiError(e, "Error fetching names for address");
      throw new Error(t);
    }
  },
  async registerName(r) {
    const e = _.state.activeCaipNetwork;
    if (!e)
      throw new Error("Network not found");
    const t = X.state.address, n = re.getAuthConnector();
    if (!t || !n)
      throw new Error("Address or auth connector not found");
    On.loading = !0;
    try {
      const s = JSON.stringify({
        name: r,
        attributes: {},
        // Unix timestamp
        timestamp: Math.floor(Date.now() / 1e3)
      });
      Ce.pushTransactionStack({
        onCancel() {
          Ce.replace("RegisterAccountName");
        }
      });
      const i = await ue.signMessage(s);
      On.loading = !1;
      const o = e.id;
      if (!o)
        throw new Error("Network not found");
      const a = KO.convertEVMChainIdToCoinType(Number(o));
      await ve.registerEnsName({
        coinType: a,
        address: t,
        signature: i,
        message: s
      }), X.setProfileName(r, e.chainNamespace), Ce.replace("RegisterAccountNameSuccess");
    } catch (s) {
      const i = Uh.parseEnsApiError(s, `Error registering name ${r}`);
      throw Ce.replace("RegisterAccountName"), new Error(i);
    } finally {
      On.loading = !1;
    }
  },
  validateName(r) {
    return /^[a-zA-Z0-9-]{4,}$/u.test(r);
  },
  parseEnsApiError(r, e) {
    var n, s;
    const t = r;
    return ((s = (n = t == null ? void 0 : t.reasons) == null ? void 0 : n[0]) == null ? void 0 : s.description) || e;
  }
}, Uh = Sn(JO);
var F0 = { exports: {} }, El = typeof Reflect == "object" ? Reflect : null, wE = El && typeof El.apply == "function" ? El.apply : function(e, t, n) {
  return Function.prototype.apply.call(e, t, n);
}, Ap;
El && typeof El.ownKeys == "function" ? Ap = El.ownKeys : Object.getOwnPropertySymbols ? Ap = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Ap = function(e) {
  return Object.getOwnPropertyNames(e);
};
function YO(r) {
  console && console.warn && console.warn(r);
}
var f_ = Number.isNaN || function(e) {
  return e !== e;
};
function gt() {
  gt.init.call(this);
}
F0.exports = gt;
F0.exports.once = eP;
gt.EventEmitter = gt;
gt.prototype._events = void 0;
gt.prototype._eventsCount = 0;
gt.prototype._maxListeners = void 0;
var yE = 10;
function Hg(r) {
  if (typeof r != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
}
Object.defineProperty(gt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return yE;
  },
  set: function(r) {
    if (typeof r != "number" || r < 0 || f_(r))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
    yE = r;
  }
});
gt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
gt.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || f_(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function p_(r) {
  return r._maxListeners === void 0 ? gt.defaultMaxListeners : r._maxListeners;
}
gt.prototype.getMaxListeners = function() {
  return p_(this);
};
gt.prototype.emit = function(e) {
  for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
  var s = e === "error", i = this._events;
  if (i !== void 0)
    s = s && i.error === void 0;
  else if (!s)
    return !1;
  if (s) {
    var o;
    if (t.length > 0 && (o = t[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var c = i[e];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    wE(c, this, t);
  else
    for (var l = c.length, u = b_(c, l), n = 0; n < l; ++n)
      wE(u[n], this, t);
  return !0;
};
function g_(r, e, t, n) {
  var s, i, o;
  if (Hg(t), i = r._events, i === void 0 ? (i = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (i.newListener !== void 0 && (r.emit(
    "newListener",
    e,
    t.listener ? t.listener : t
  ), i = r._events), o = i[e]), o === void 0)
    o = i[e] = t, ++r._eventsCount;
  else if (typeof o == "function" ? o = i[e] = n ? [t, o] : [o, t] : n ? o.unshift(t) : o.push(t), s = p_(r), s > 0 && o.length > s && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = r, a.type = e, a.count = o.length, YO(a);
  }
  return r;
}
gt.prototype.addListener = function(e, t) {
  return g_(this, e, t, !1);
};
gt.prototype.on = gt.prototype.addListener;
gt.prototype.prependListener = function(e, t) {
  return g_(this, e, t, !0);
};
function QO() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function m_(r, e, t) {
  var n = { fired: !1, wrapFn: void 0, target: r, type: e, listener: t }, s = QO.bind(n);
  return s.listener = t, n.wrapFn = s, s;
}
gt.prototype.once = function(e, t) {
  return Hg(t), this.on(e, m_(this, e, t)), this;
};
gt.prototype.prependOnceListener = function(e, t) {
  return Hg(t), this.prependListener(e, m_(this, e, t)), this;
};
gt.prototype.removeListener = function(e, t) {
  var n, s, i, o, a;
  if (Hg(t), s = this._events, s === void 0)
    return this;
  if (n = s[e], n === void 0)
    return this;
  if (n === t || n.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, n.listener || t));
  else if (typeof n != "function") {
    for (i = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === t || n[o].listener === t) {
        a = n[o].listener, i = o;
        break;
      }
    if (i < 0)
      return this;
    i === 0 ? n.shift() : ZO(n, i), n.length === 1 && (s[e] = n[0]), s.removeListener !== void 0 && this.emit("removeListener", e, a || t);
  }
  return this;
};
gt.prototype.off = gt.prototype.removeListener;
gt.prototype.removeAllListeners = function(e) {
  var t, n, s;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var i = Object.keys(n), o;
    for (s = 0; s < i.length; ++s)
      o = i[s], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = n[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (s = t.length - 1; s >= 0; s--)
      this.removeListener(e, t[s]);
  return this;
};
function w_(r, e, t) {
  var n = r._events;
  if (n === void 0)
    return [];
  var s = n[e];
  return s === void 0 ? [] : typeof s == "function" ? t ? [s.listener || s] : [s] : t ? XO(s) : b_(s, s.length);
}
gt.prototype.listeners = function(e) {
  return w_(this, e, !0);
};
gt.prototype.rawListeners = function(e) {
  return w_(this, e, !1);
};
gt.listenerCount = function(r, e) {
  return typeof r.listenerCount == "function" ? r.listenerCount(e) : y_.call(r, e);
};
gt.prototype.listenerCount = y_;
function y_(r) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[r];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
gt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Ap(this._events) : [];
};
function b_(r, e) {
  for (var t = new Array(e), n = 0; n < e; ++n)
    t[n] = r[n];
  return t;
}
function ZO(r, e) {
  for (; e + 1 < r.length; e++)
    r[e] = r[e + 1];
  r.pop();
}
function XO(r) {
  for (var e = new Array(r.length), t = 0; t < e.length; ++t)
    e[t] = r[t].listener || r[t];
  return e;
}
function eP(r, e) {
  return new Promise(function(t, n) {
    function s(o) {
      r.removeListener(e, i), n(o);
    }
    function i() {
      typeof r.removeListener == "function" && r.removeListener("error", s), t([].slice.call(arguments));
    }
    E_(r, e, i, { once: !0 }), e !== "error" && tP(r, s, { once: !0 });
  });
}
function tP(r, e, t) {
  typeof r.on == "function" && E_(r, "error", e, t);
}
function E_(r, e, t, n) {
  if (typeof r.on == "function")
    n.once ? r.once(e, t) : r.on(e, t);
  else if (typeof r.addEventListener == "function")
    r.addEventListener(e, function s(i) {
      n.once && r.removeEventListener(e, s), t(i);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r);
}
var Vn = F0.exports;
const $0 = /* @__PURE__ */ P0(Vn);
var Q = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Yw = function(r, e) {
  return Yw = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var s in n) n.hasOwnProperty(s) && (t[s] = n[s]);
  }, Yw(r, e);
};
function rP(r, e) {
  Yw(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Qw = function() {
  return Qw = Object.assign || function(e) {
    for (var t, n = 1, s = arguments.length; n < s; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, Qw.apply(this, arguments);
};
function nP(r, e) {
  var t = {};
  for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, n = Object.getOwnPropertySymbols(r); s < n.length; s++)
      e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[s]) && (t[n[s]] = r[n[s]]);
  return t;
}
function sP(r, e, t, n) {
  var s = arguments.length, i = s < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(r, e, t, n);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, t, i) : o(e, t)) || i);
  return s > 3 && i && Object.defineProperty(e, t, i), i;
}
function iP(r, e) {
  return function(t, n) {
    e(t, n, r);
  };
}
function oP(r, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(r, e);
}
function aP(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(u) {
      try {
        l(n.next(u));
      } catch (h) {
        o(h);
      }
    }
    function c(u) {
      try {
        l(n.throw(u));
      } catch (h) {
        o(h);
      }
    }
    function l(u) {
      u.done ? i(u.value) : s(u.value).then(a, c);
    }
    l((n = n.apply(r, e || [])).next());
  });
}
function cP(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (n = 1, s && (i = l[0] & 2 ? s.return : l[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, l[1])).done) return i;
      switch (s = 0, i && (l = [l[0] & 2, i.value]), l[0]) {
        case 0:
        case 1:
          i = l;
          break;
        case 4:
          return t.label++, { value: l[1], done: !1 };
        case 5:
          t.label++, s = l[1], l = [0];
          continue;
        case 7:
          l = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            t = 0;
            continue;
          }
          if (l[0] === 3 && (!i || l[1] > i[0] && l[1] < i[3])) {
            t.label = l[1];
            break;
          }
          if (l[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = l;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(l);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      l = e.call(r, t);
    } catch (u) {
      l = [6, u], s = 0;
    } finally {
      n = i = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function lP(r, e, t, n) {
  n === void 0 && (n = t), r[n] = e[t];
}
function uP(r, e) {
  for (var t in r) t !== "default" && !e.hasOwnProperty(t) && (e[t] = r[t]);
}
function Zw(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function v_(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t) return r;
  var n = t.call(r), s, i = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = n.next()).done; ) i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (t = n.return) && t.call(n);
    } finally {
      if (o) throw o.error;
    }
  }
  return i;
}
function hP() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r = r.concat(v_(arguments[e]));
  return r;
}
function dP() {
  for (var r = 0, e = 0, t = arguments.length; e < t; e++) r += arguments[e].length;
  for (var n = Array(r), s = 0, e = 0; e < t; e++)
    for (var i = arguments[e], o = 0, a = i.length; o < a; o++, s++)
      n[s] = i[o];
  return n;
}
function yd(r) {
  return this instanceof yd ? (this.v = r, this) : new yd(r);
}
function fP(r, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), s, i = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(d) {
    n[d] && (s[d] = function(f) {
      return new Promise(function(g, p) {
        i.push([d, f, g, p]) > 1 || a(d, f);
      });
    });
  }
  function a(d, f) {
    try {
      c(n[d](f));
    } catch (g) {
      h(i[0][3], g);
    }
  }
  function c(d) {
    d.value instanceof yd ? Promise.resolve(d.value.v).then(l, u) : h(i[0][2], d);
  }
  function l(d) {
    a("next", d);
  }
  function u(d) {
    a("throw", d);
  }
  function h(d, f) {
    d(f), i.shift(), i.length && a(i[0][0], i[0][1]);
  }
}
function pP(r) {
  var e, t;
  return e = {}, n("next"), n("throw", function(s) {
    throw s;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(s, i) {
    e[s] = r[s] ? function(o) {
      return (t = !t) ? { value: yd(r[s](o)), done: s === "return" } : i ? i(o) : o;
    } : i;
  }
}
function gP(r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof Zw == "function" ? Zw(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function n(i) {
    t[i] = r[i] && function(o) {
      return new Promise(function(a, c) {
        o = r[i](o), s(a, c, o.done, o.value);
      });
    };
  }
  function s(i, o, a, c) {
    Promise.resolve(c).then(function(l) {
      i({ value: l, done: a });
    }, o);
  }
}
function mP(r, e) {
  return Object.defineProperty ? Object.defineProperty(r, "raw", { value: e }) : r.raw = e, r;
}
function wP(r) {
  if (r && r.__esModule) return r;
  var e = {};
  if (r != null) for (var t in r) Object.hasOwnProperty.call(r, t) && (e[t] = r[t]);
  return e.default = r, e;
}
function yP(r) {
  return r && r.__esModule ? r : { default: r };
}
function bP(r, e) {
  if (!e.has(r))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(r);
}
function EP(r, e, t) {
  if (!e.has(r))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(r, t), t;
}
const vP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return Qw;
  },
  __asyncDelegator: pP,
  __asyncGenerator: fP,
  __asyncValues: gP,
  __await: yd,
  __awaiter: aP,
  __classPrivateFieldGet: bP,
  __classPrivateFieldSet: EP,
  __createBinding: lP,
  __decorate: sP,
  __exportStar: uP,
  __extends: rP,
  __generator: cP,
  __importDefault: yP,
  __importStar: wP,
  __makeTemplateObject: mP,
  __metadata: oP,
  __param: iP,
  __read: v_,
  __rest: nP,
  __spread: hP,
  __spreadArrays: dP,
  __values: Zw
}, Symbol.toStringTag, { value: "Module" })), gf = /* @__PURE__ */ qT(vP);
var Pm = {}, eh = {}, bE;
function AP() {
  if (bE) return eh;
  bE = 1, Object.defineProperty(eh, "__esModule", { value: !0 }), eh.delay = void 0;
  function r(e) {
    return new Promise((t) => {
      setTimeout(() => {
        t(!0);
      }, e);
    });
  }
  return eh.delay = r, eh;
}
var ia = {}, Rm = {}, oa = {}, EE;
function CP() {
  return EE || (EE = 1, Object.defineProperty(oa, "__esModule", { value: !0 }), oa.ONE_THOUSAND = oa.ONE_HUNDRED = void 0, oa.ONE_HUNDRED = 100, oa.ONE_THOUSAND = 1e3), oa;
}
var Dm = {}, vE;
function _P() {
  return vE || (vE = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.ONE_YEAR = r.FOUR_WEEKS = r.THREE_WEEKS = r.TWO_WEEKS = r.ONE_WEEK = r.THIRTY_DAYS = r.SEVEN_DAYS = r.FIVE_DAYS = r.THREE_DAYS = r.ONE_DAY = r.TWENTY_FOUR_HOURS = r.TWELVE_HOURS = r.SIX_HOURS = r.THREE_HOURS = r.ONE_HOUR = r.SIXTY_MINUTES = r.THIRTY_MINUTES = r.TEN_MINUTES = r.FIVE_MINUTES = r.ONE_MINUTE = r.SIXTY_SECONDS = r.THIRTY_SECONDS = r.TEN_SECONDS = r.FIVE_SECONDS = r.ONE_SECOND = void 0, r.ONE_SECOND = 1, r.FIVE_SECONDS = 5, r.TEN_SECONDS = 10, r.THIRTY_SECONDS = 30, r.SIXTY_SECONDS = 60, r.ONE_MINUTE = r.SIXTY_SECONDS, r.FIVE_MINUTES = r.ONE_MINUTE * 5, r.TEN_MINUTES = r.ONE_MINUTE * 10, r.THIRTY_MINUTES = r.ONE_MINUTE * 30, r.SIXTY_MINUTES = r.ONE_MINUTE * 60, r.ONE_HOUR = r.SIXTY_MINUTES, r.THREE_HOURS = r.ONE_HOUR * 3, r.SIX_HOURS = r.ONE_HOUR * 6, r.TWELVE_HOURS = r.ONE_HOUR * 12, r.TWENTY_FOUR_HOURS = r.ONE_HOUR * 24, r.ONE_DAY = r.TWENTY_FOUR_HOURS, r.THREE_DAYS = r.ONE_DAY * 3, r.FIVE_DAYS = r.ONE_DAY * 5, r.SEVEN_DAYS = r.ONE_DAY * 7, r.THIRTY_DAYS = r.ONE_DAY * 30, r.ONE_WEEK = r.SEVEN_DAYS, r.TWO_WEEKS = r.ONE_WEEK * 2, r.THREE_WEEKS = r.ONE_WEEK * 3, r.FOUR_WEEKS = r.ONE_WEEK * 4, r.ONE_YEAR = r.ONE_DAY * 365;
  }(Dm)), Dm;
}
var AE;
function A_() {
  return AE || (AE = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 });
    const e = gf;
    e.__exportStar(CP(), r), e.__exportStar(_P(), r);
  }(Rm)), Rm;
}
var CE;
function IP() {
  if (CE) return ia;
  CE = 1, Object.defineProperty(ia, "__esModule", { value: !0 }), ia.fromMiliseconds = ia.toMiliseconds = void 0;
  const r = A_();
  function e(n) {
    return n * r.ONE_THOUSAND;
  }
  ia.toMiliseconds = e;
  function t(n) {
    return Math.floor(n / r.ONE_THOUSAND);
  }
  return ia.fromMiliseconds = t, ia;
}
var _E;
function SP() {
  return _E || (_E = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 });
    const e = gf;
    e.__exportStar(AP(), r), e.__exportStar(IP(), r);
  }(Pm)), Pm;
}
var Bc = {}, IE;
function NP() {
  if (IE) return Bc;
  IE = 1, Object.defineProperty(Bc, "__esModule", { value: !0 }), Bc.Watch = void 0;
  class r {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(t) {
      if (this.timestamps.has(t))
        throw new Error(`Watch already started for label: ${t}`);
      this.timestamps.set(t, { started: Date.now() });
    }
    stop(t) {
      const n = this.get(t);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${t}`);
      const s = Date.now() - n.started;
      this.timestamps.set(t, { started: n.started, elapsed: s });
    }
    get(t) {
      const n = this.timestamps.get(t);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${t}`);
      return n;
    }
    elapsed(t) {
      const n = this.get(t);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return Bc.Watch = r, Bc.default = r, Bc;
}
var km = {}, th = {}, SE;
function TP() {
  if (SE) return th;
  SE = 1, Object.defineProperty(th, "__esModule", { value: !0 }), th.IWatch = void 0;
  class r {
  }
  return th.IWatch = r, th;
}
var NE;
function xP() {
  return NE || (NE = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), gf.__exportStar(TP(), r);
  }(km)), km;
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  const e = gf;
  e.__exportStar(SP(), r), e.__exportStar(NP(), r), e.__exportStar(xP(), r), e.__exportStar(A_(), r);
})(Q);
class Sc {
}
let OP = class extends Sc {
  constructor(e) {
    super();
  }
};
const TE = Q.FIVE_SECONDS, Nc = { pulse: "heartbeat_pulse" };
let PP = class C_ extends OP {
  constructor(e) {
    super(e), this.events = new Vn.EventEmitter(), this.interval = TE, this.interval = (e == null ? void 0 : e.interval) || TE;
  }
  static async init(e) {
    const t = new C_(e);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), Q.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(Nc.pulse);
  }
};
const RP = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, DP = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, kP = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function UP(r, e) {
  if (r === "__proto__" || r === "constructor" && e && typeof e == "object" && "prototype" in e) {
    BP(r);
    return;
  }
  return e;
}
function BP(r) {
  console.warn(`[destr] Dropping "${r}" key to prevent prototype pollution.`);
}
function Wf(r, e = {}) {
  if (typeof r != "string")
    return r;
  if (r[0] === '"' && r[r.length - 1] === '"' && r.indexOf("\\") === -1)
    return r.slice(1, -1);
  const t = r.trim();
  if (t.length <= 9)
    switch (t.toLowerCase()) {
      case "true":
        return !0;
      case "false":
        return !1;
      case "undefined":
        return;
      case "null":
        return null;
      case "nan":
        return Number.NaN;
      case "infinity":
        return Number.POSITIVE_INFINITY;
      case "-infinity":
        return Number.NEGATIVE_INFINITY;
    }
  if (!kP.test(r)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return r;
  }
  try {
    if (RP.test(r) || DP.test(r)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(r, UP);
    }
    return JSON.parse(r);
  } catch (n) {
    if (e.strict)
      throw n;
    return r;
  }
}
function LP(r) {
  return !r || typeof r.then != "function" ? Promise.resolve(r) : r;
}
function Kt(r, ...e) {
  try {
    return LP(r(...e));
  } catch (t) {
    return Promise.reject(t);
  }
}
function FP(r) {
  const e = typeof r;
  return r === null || e !== "object" && e !== "function";
}
function $P(r) {
  const e = Object.getPrototypeOf(r);
  return !e || e.isPrototypeOf(Object);
}
function Cp(r) {
  if (FP(r))
    return String(r);
  if ($P(r) || Array.isArray(r))
    return JSON.stringify(r);
  if (typeof r.toJSON == "function")
    return Cp(r.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
const Xw = "base64:";
function MP(r) {
  return typeof r == "string" ? r : Xw + zP(r);
}
function jP(r) {
  return typeof r != "string" || !r.startsWith(Xw) ? r : HP(r.slice(Xw.length));
}
function HP(r) {
  return globalThis.Buffer ? Buffer.from(r, "base64") : Uint8Array.from(
    globalThis.atob(r),
    (e) => e.codePointAt(0)
  );
}
function zP(r) {
  return globalThis.Buffer ? Buffer.from(r).toString("base64") : globalThis.btoa(String.fromCodePoint(...r));
}
function Kr(r) {
  var e;
  return r && ((e = r.split("?")[0]) == null ? void 0 : e.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function qP(...r) {
  return Kr(r.join(":"));
}
function Vf(r) {
  return r = Kr(r), r ? r + ":" : "";
}
function WP(r, e) {
  if (e === void 0)
    return !0;
  let t = 0, n = r.indexOf(":");
  for (; n > -1; )
    t++, n = r.indexOf(":", n + 1);
  return t <= e;
}
function VP(r, e) {
  return e ? r.startsWith(e) && r[r.length - 1] !== "$" : r[r.length - 1] !== "$";
}
const GP = "memory", KP = () => {
  const r = /* @__PURE__ */ new Map();
  return {
    name: GP,
    getInstance: () => r,
    hasItem(e) {
      return r.has(e);
    },
    getItem(e) {
      return r.get(e) ?? null;
    },
    getItemRaw(e) {
      return r.get(e) ?? null;
    },
    setItem(e, t) {
      r.set(e, t);
    },
    setItemRaw(e, t) {
      r.set(e, t);
    },
    removeItem(e) {
      r.delete(e);
    },
    getKeys() {
      return [...r.keys()];
    },
    clear() {
      r.clear();
    },
    dispose() {
      r.clear();
    }
  };
};
function JP(r = {}) {
  const e = {
    mounts: { "": r.driver || KP() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, t = (l) => {
    for (const u of e.mountpoints)
      if (l.startsWith(u))
        return {
          base: u,
          relativeKey: l.slice(u.length),
          driver: e.mounts[u]
        };
    return {
      base: "",
      relativeKey: l,
      driver: e.mounts[""]
    };
  }, n = (l, u) => e.mountpoints.filter(
    (h) => h.startsWith(l) || u && l.startsWith(h)
  ).map((h) => ({
    relativeBase: l.length > h.length ? l.slice(h.length) : void 0,
    mountpoint: h,
    driver: e.mounts[h]
  })), s = (l, u) => {
    if (e.watching) {
      u = Kr(u);
      for (const h of e.watchListeners)
        h(l, u);
    }
  }, i = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const l in e.mounts)
        e.unwatch[l] = await xE(
          e.mounts[l],
          s,
          l
        );
    }
  }, o = async () => {
    if (e.watching) {
      for (const l in e.unwatch)
        await e.unwatch[l]();
      e.unwatch = {}, e.watching = !1;
    }
  }, a = (l, u, h) => {
    const d = /* @__PURE__ */ new Map(), f = (g) => {
      let p = d.get(g.base);
      return p || (p = {
        driver: g.driver,
        base: g.base,
        items: []
      }, d.set(g.base, p)), p;
    };
    for (const g of l) {
      const p = typeof g == "string", w = Kr(p ? g : g.key), E = p ? void 0 : g.value, I = p || !g.options ? u : { ...u, ...g.options }, A = t(w);
      f(A).items.push({
        key: w,
        value: E,
        relativeKey: A.relativeKey,
        options: I
      });
    }
    return Promise.all([...d.values()].map((g) => h(g))).then(
      (g) => g.flat()
    );
  }, c = {
    // Item
    hasItem(l, u = {}) {
      l = Kr(l);
      const { relativeKey: h, driver: d } = t(l);
      return Kt(d.hasItem, h, u);
    },
    getItem(l, u = {}) {
      l = Kr(l);
      const { relativeKey: h, driver: d } = t(l);
      return Kt(d.getItem, h, u).then(
        (f) => Wf(f)
      );
    },
    getItems(l, u = {}) {
      return a(l, u, (h) => h.driver.getItems ? Kt(
        h.driver.getItems,
        h.items.map((d) => ({
          key: d.relativeKey,
          options: d.options
        })),
        u
      ).then(
        (d) => d.map((f) => ({
          key: qP(h.base, f.key),
          value: Wf(f.value)
        }))
      ) : Promise.all(
        h.items.map((d) => Kt(
          h.driver.getItem,
          d.relativeKey,
          d.options
        ).then((f) => ({
          key: d.key,
          value: Wf(f)
        })))
      ));
    },
    getItemRaw(l, u = {}) {
      l = Kr(l);
      const { relativeKey: h, driver: d } = t(l);
      return d.getItemRaw ? Kt(d.getItemRaw, h, u) : Kt(d.getItem, h, u).then(
        (f) => jP(f)
      );
    },
    async setItem(l, u, h = {}) {
      if (u === void 0)
        return c.removeItem(l);
      l = Kr(l);
      const { relativeKey: d, driver: f } = t(l);
      f.setItem && (await Kt(f.setItem, d, Cp(u), h), f.watch || s("update", l));
    },
    async setItems(l, u) {
      await a(l, u, async (h) => {
        if (h.driver.setItems)
          return Kt(
            h.driver.setItems,
            h.items.map((d) => ({
              key: d.relativeKey,
              value: Cp(d.value),
              options: d.options
            })),
            u
          );
        h.driver.setItem && await Promise.all(
          h.items.map((d) => Kt(
            h.driver.setItem,
            d.relativeKey,
            Cp(d.value),
            d.options
          ))
        );
      });
    },
    async setItemRaw(l, u, h = {}) {
      if (u === void 0)
        return c.removeItem(l, h);
      l = Kr(l);
      const { relativeKey: d, driver: f } = t(l);
      if (f.setItemRaw)
        await Kt(f.setItemRaw, d, u, h);
      else if (f.setItem)
        await Kt(f.setItem, d, MP(u), h);
      else
        return;
      f.watch || s("update", l);
    },
    async removeItem(l, u = {}) {
      typeof u == "boolean" && (u = { removeMeta: u }), l = Kr(l);
      const { relativeKey: h, driver: d } = t(l);
      d.removeItem && (await Kt(d.removeItem, h, u), (u.removeMeta || u.removeMata) && await Kt(d.removeItem, h + "$", u), d.watch || s("remove", l));
    },
    // Meta
    async getMeta(l, u = {}) {
      typeof u == "boolean" && (u = { nativeOnly: u }), l = Kr(l);
      const { relativeKey: h, driver: d } = t(l), f = /* @__PURE__ */ Object.create(null);
      if (d.getMeta && Object.assign(f, await Kt(d.getMeta, h, u)), !u.nativeOnly) {
        const g = await Kt(
          d.getItem,
          h + "$",
          u
        ).then((p) => Wf(p));
        g && typeof g == "object" && (typeof g.atime == "string" && (g.atime = new Date(g.atime)), typeof g.mtime == "string" && (g.mtime = new Date(g.mtime)), Object.assign(f, g));
      }
      return f;
    },
    setMeta(l, u, h = {}) {
      return this.setItem(l + "$", u, h);
    },
    removeMeta(l, u = {}) {
      return this.removeItem(l + "$", u);
    },
    // Keys
    async getKeys(l, u = {}) {
      var w;
      l = Vf(l);
      const h = n(l, !0);
      let d = [];
      const f = [];
      let g = !0;
      for (const E of h) {
        (w = E.driver.flags) != null && w.maxDepth || (g = !1);
        const I = await Kt(
          E.driver.getKeys,
          E.relativeBase,
          u
        );
        for (const A of I) {
          const C = E.mountpoint + Kr(A);
          d.some((N) => C.startsWith(N)) || f.push(C);
        }
        d = [
          E.mountpoint,
          ...d.filter((A) => !A.startsWith(E.mountpoint))
        ];
      }
      const p = u.maxDepth !== void 0 && !g;
      return f.filter(
        (E) => (!p || WP(E, u.maxDepth)) && VP(E, l)
      );
    },
    // Utils
    async clear(l, u = {}) {
      l = Vf(l), await Promise.all(
        n(l, !1).map(async (h) => {
          if (h.driver.clear)
            return Kt(h.driver.clear, h.relativeBase, u);
          if (h.driver.removeItem) {
            const d = await h.driver.getKeys(h.relativeBase || "", u);
            return Promise.all(
              d.map((f) => h.driver.removeItem(f, u))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((l) => OE(l))
      );
    },
    async watch(l) {
      return await i(), e.watchListeners.push(l), async () => {
        e.watchListeners = e.watchListeners.filter(
          (u) => u !== l
        ), e.watchListeners.length === 0 && await o();
      };
    },
    async unwatch() {
      e.watchListeners = [], await o();
    },
    // Mount
    mount(l, u) {
      if (l = Vf(l), l && e.mounts[l])
        throw new Error(`already mounted at ${l}`);
      return l && (e.mountpoints.push(l), e.mountpoints.sort((h, d) => d.length - h.length)), e.mounts[l] = u, e.watching && Promise.resolve(xE(u, s, l)).then((h) => {
        e.unwatch[l] = h;
      }).catch(console.error), c;
    },
    async unmount(l, u = !0) {
      var h, d;
      l = Vf(l), !(!l || !e.mounts[l]) && (e.watching && l in e.unwatch && ((d = (h = e.unwatch)[l]) == null || d.call(h), delete e.unwatch[l]), u && await OE(e.mounts[l]), e.mountpoints = e.mountpoints.filter((f) => f !== l), delete e.mounts[l]);
    },
    getMount(l = "") {
      l = Kr(l) + ":";
      const u = t(l);
      return {
        driver: u.driver,
        base: u.base
      };
    },
    getMounts(l = "", u = {}) {
      return l = Kr(l), n(l, u.parents).map((d) => ({
        driver: d.driver,
        base: d.mountpoint
      }));
    },
    // Aliases
    keys: (l, u = {}) => c.getKeys(l, u),
    get: (l, u = {}) => c.getItem(l, u),
    set: (l, u, h = {}) => c.setItem(l, u, h),
    has: (l, u = {}) => c.hasItem(l, u),
    del: (l, u = {}) => c.removeItem(l, u),
    remove: (l, u = {}) => c.removeItem(l, u)
  };
  return c;
}
function xE(r, e, t) {
  return r.watch ? r.watch((n, s) => e(n, t + s)) : () => {
  };
}
async function OE(r) {
  typeof r.dispose == "function" && await Kt(r.dispose);
}
function Tc(r) {
  return new Promise((e, t) => {
    r.oncomplete = r.onsuccess = () => e(r.result), r.onabort = r.onerror = () => t(r.error);
  });
}
function __(r, e) {
  let t;
  const n = () => {
    if (t)
      return t;
    const s = indexedDB.open(r);
    return s.onupgradeneeded = () => s.result.createObjectStore(e), t = Tc(s), t.then((i) => {
      i.onclose = () => t = void 0;
    }, () => {
    }), t;
  };
  return (s, i) => n().then((o) => i(o.transaction(e, s).objectStore(e)));
}
let Um;
function mf() {
  return Um || (Um = __("keyval-store", "keyval")), Um;
}
function PE(r, e = mf()) {
  return e("readonly", (t) => Tc(t.get(r)));
}
function YP(r, e, t = mf()) {
  return t("readwrite", (n) => (n.put(e, r), Tc(n.transaction)));
}
function QP(r, e = mf()) {
  return e("readwrite", (t) => (t.delete(r), Tc(t.transaction)));
}
function ZP(r = mf()) {
  return r("readwrite", (e) => (e.clear(), Tc(e.transaction)));
}
function XP(r, e) {
  return r.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, Tc(r.transaction);
}
function eR(r = mf()) {
  return r("readonly", (e) => {
    if (e.getAllKeys)
      return Tc(e.getAllKeys());
    const t = [];
    return XP(e, (n) => t.push(n.key)).then(() => t);
  });
}
const tR = (r) => JSON.stringify(r, (e, t) => typeof t == "bigint" ? t.toString() + "n" : t), rR = (r) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, t = r.replace(e, '$1"$2n"$3');
  return JSON.parse(t, (n, s) => typeof s == "string" && s.match(/^\d+n$/) ? BigInt(s.substring(0, s.length - 1)) : s);
};
function lc(r) {
  if (typeof r != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof r}`);
  try {
    return rR(r);
  } catch {
    return r;
  }
}
function $i(r) {
  return typeof r == "string" ? r : tR(r) || "";
}
const nR = "idb-keyval";
var sR = (r = {}) => {
  const e = r.base && r.base.length > 0 ? `${r.base}:` : "", t = (s) => e + s;
  let n;
  return r.dbName && r.storeName && (n = __(r.dbName, r.storeName)), { name: nR, options: r, async hasItem(s) {
    return !(typeof await PE(t(s), n) > "u");
  }, async getItem(s) {
    return await PE(t(s), n) ?? null;
  }, setItem(s, i) {
    return YP(t(s), i, n);
  }, removeItem(s) {
    return QP(t(s), n);
  }, getKeys() {
    return eR(n);
  }, clear() {
    return ZP(n);
  } };
};
const iR = "WALLET_CONNECT_V2_INDEXED_DB", oR = "keyvaluestorage";
let aR = class {
  constructor() {
    this.indexedDb = JP({ driver: sR({ dbName: iR, storeName: oR }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const t = await this.indexedDb.getItem(e);
    if (t !== null) return t;
  }
  async setItem(e, t) {
    await this.indexedDb.setItem(e, $i(t));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var Bm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, _p = { exports: {} };
(function() {
  let r;
  function e() {
  }
  r = e, r.prototype.getItem = function(t) {
    return this.hasOwnProperty(t) ? String(this[t]) : null;
  }, r.prototype.setItem = function(t, n) {
    this[t] = String(n);
  }, r.prototype.removeItem = function(t) {
    delete this[t];
  }, r.prototype.clear = function() {
    const t = this;
    Object.keys(t).forEach(function(n) {
      t[n] = void 0, delete t[n];
    });
  }, r.prototype.key = function(t) {
    return t = t || 0, Object.keys(this)[t];
  }, r.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof Bm < "u" && Bm.localStorage ? _p.exports = Bm.localStorage : typeof window < "u" && window.localStorage ? _p.exports = window.localStorage : _p.exports = new e();
})();
function cR(r) {
  var e;
  return [r[0], lc((e = r[1]) != null ? e : "")];
}
let lR = class {
  constructor() {
    this.localStorage = _p.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(cR);
  }
  async getItem(e) {
    const t = this.localStorage.getItem(e);
    if (t !== null) return lc(t);
  }
  async setItem(e, t) {
    this.localStorage.setItem(e, $i(t));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const uR = "wc_storage_version", RE = 1, hR = async (r, e, t) => {
  const n = uR, s = await e.getItem(n);
  if (s && s >= RE) {
    t(e);
    return;
  }
  const i = await r.getKeys();
  if (!i.length) {
    t(e);
    return;
  }
  const o = [];
  for (; i.length; ) {
    const a = i.shift();
    if (!a) continue;
    const c = a.toLowerCase();
    if (c.includes("wc@") || c.includes("walletconnect") || c.includes("wc_") || c.includes("wallet_connect")) {
      const l = await r.getItem(a);
      await e.setItem(a, l), o.push(a);
    }
  }
  await e.setItem(n, RE), t(e), dR(r, o);
}, dR = async (r, e) => {
  e.length && e.forEach(async (t) => {
    await r.removeItem(t);
  });
};
let fR = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (t) => {
      this.storage = t, this.initialized = !0;
    };
    const e = new lR();
    this.storage = e;
    try {
      const t = new aR();
      hR(e, t, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, t) {
    return await this.initialize(), this.storage.setItem(e, t);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const t = setInterval(() => {
        this.initialized && (clearInterval(t), e());
      }, 20);
    });
  }
};
function pR(r) {
  try {
    return JSON.stringify(r);
  } catch {
    return '"[Circular]"';
  }
}
var gR = mR;
function mR(r, e, t) {
  var n = t && t.stringify || pR, s = 1;
  if (typeof r == "object" && r !== null) {
    var i = e.length + s;
    if (i === 1) return r;
    var o = new Array(i);
    o[0] = n(r);
    for (var a = 1; a < i; a++)
      o[a] = n(e[a]);
    return o.join(" ");
  }
  if (typeof r != "string")
    return r;
  var c = e.length;
  if (c === 0) return r;
  for (var l = "", u = 1 - s, h = -1, d = r && r.length || 0, f = 0; f < d; ) {
    if (r.charCodeAt(f) === 37 && f + 1 < d) {
      switch (h = h > -1 ? h : 0, r.charCodeAt(f + 1)) {
        case 100:
        case 102:
          if (u >= c || e[u] == null) break;
          h < f && (l += r.slice(h, f)), l += Number(e[u]), h = f + 2, f++;
          break;
        case 105:
          if (u >= c || e[u] == null) break;
          h < f && (l += r.slice(h, f)), l += Math.floor(Number(e[u])), h = f + 2, f++;
          break;
        case 79:
        case 111:
        case 106:
          if (u >= c || e[u] === void 0) break;
          h < f && (l += r.slice(h, f));
          var g = typeof e[u];
          if (g === "string") {
            l += "'" + e[u] + "'", h = f + 2, f++;
            break;
          }
          if (g === "function") {
            l += e[u].name || "<anonymous>", h = f + 2, f++;
            break;
          }
          l += n(e[u]), h = f + 2, f++;
          break;
        case 115:
          if (u >= c)
            break;
          h < f && (l += r.slice(h, f)), l += String(e[u]), h = f + 2, f++;
          break;
        case 37:
          h < f && (l += r.slice(h, f)), l += "%", h = f + 2, f++, u--;
          break;
      }
      ++u;
    }
    ++f;
  }
  return h === -1 ? r : (h < d && (l += r.slice(h)), l);
}
const DE = gR;
var sl = Ys;
const bd = SR().console || {}, wR = {
  mapHttpRequest: Gf,
  mapHttpResponse: Gf,
  wrapRequestSerializer: Lm,
  wrapResponseSerializer: Lm,
  wrapErrorSerializer: Lm,
  req: Gf,
  res: Gf,
  err: AR
};
function yR(r, e) {
  return Array.isArray(r) ? r.filter(function(n) {
    return n !== "!stdSerializers.err";
  }) : r === !0 ? Object.keys(e) : !1;
}
function Ys(r) {
  r = r || {}, r.browser = r.browser || {};
  const e = r.browser.transmit;
  if (e && typeof e.send != "function")
    throw Error("pino: transmit option must have a send function");
  const t = r.browser.write || bd;
  r.browser.write && (r.browser.asObject = !0);
  const n = r.serializers || {}, s = yR(r.browser.serialize, n);
  let i = r.browser.serialize;
  Array.isArray(r.browser.serialize) && r.browser.serialize.indexOf("!stdSerializers.err") > -1 && (i = !1);
  const o = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof t == "function" && (t.error = t.fatal = t.warn = t.info = t.debug = t.trace = t), r.enabled === !1 && (r.level = "silent");
  const a = r.level || "info", c = Object.create(t);
  c.log || (c.log = Ed), Object.defineProperty(c, "levelVal", {
    get: u
  }), Object.defineProperty(c, "level", {
    get: h,
    set: d
  });
  const l = {
    transmit: e,
    serialize: s,
    asObject: r.browser.asObject,
    levels: o,
    timestamp: CR(r)
  };
  c.levels = Ys.levels, c.level = a, c.setMaxListeners = c.getMaxListeners = c.emit = c.addListener = c.on = c.prependListener = c.once = c.prependOnceListener = c.removeListener = c.removeAllListeners = c.listeners = c.listenerCount = c.eventNames = c.write = c.flush = Ed, c.serializers = n, c._serialize = s, c._stdErrSerialize = i, c.child = f, e && (c._logEvent = ey());
  function u() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function h() {
    return this._level;
  }
  function d(g) {
    if (g !== "silent" && !this.levels.values[g])
      throw Error("unknown level " + g);
    this._level = g, Lc(l, c, "error", "log"), Lc(l, c, "fatal", "error"), Lc(l, c, "warn", "error"), Lc(l, c, "info", "log"), Lc(l, c, "debug", "log"), Lc(l, c, "trace", "log");
  }
  function f(g, p) {
    if (!g)
      throw new Error("missing bindings for child Pino");
    p = p || {}, s && g.serializers && (p.serializers = g.serializers);
    const w = p.serializers;
    if (s && w) {
      var E = Object.assign({}, n, w), I = r.browser.serialize === !0 ? Object.keys(E) : s;
      delete g.serializers, zg([g], I, E, this._stdErrSerialize);
    }
    function A(C) {
      this._childLevel = (C._childLevel | 0) + 1, this.error = Fc(C, g, "error"), this.fatal = Fc(C, g, "fatal"), this.warn = Fc(C, g, "warn"), this.info = Fc(C, g, "info"), this.debug = Fc(C, g, "debug"), this.trace = Fc(C, g, "trace"), E && (this.serializers = E, this._serialize = I), e && (this._logEvent = ey(
        [].concat(C._logEvent.bindings, g)
      ));
    }
    return A.prototype = this, new A(this);
  }
  return c;
}
Ys.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
Ys.stdSerializers = wR;
Ys.stdTimeFunctions = Object.assign({}, { nullTime: I_, epochTime: S_, unixTime: _R, isoTime: IR });
function Lc(r, e, t, n) {
  const s = Object.getPrototypeOf(e);
  e[t] = e.levelVal > e.levels.values[t] ? Ed : s[t] ? s[t] : bd[t] || bd[n] || Ed, bR(r, e, t);
}
function bR(r, e, t) {
  !r.transmit && e[t] === Ed || (e[t] = /* @__PURE__ */ function(n) {
    return function() {
      const i = r.timestamp(), o = new Array(arguments.length), a = Object.getPrototypeOf && Object.getPrototypeOf(this) === bd ? bd : this;
      for (var c = 0; c < o.length; c++) o[c] = arguments[c];
      if (r.serialize && !r.asObject && zg(o, this._serialize, this.serializers, this._stdErrSerialize), r.asObject ? n.call(a, ER(this, t, o, i)) : n.apply(a, o), r.transmit) {
        const l = r.transmit.level || e.level, u = Ys.levels.values[l], h = Ys.levels.values[t];
        if (h < u) return;
        vR(this, {
          ts: i,
          methodLevel: t,
          methodValue: h,
          transmitValue: Ys.levels.values[r.transmit.level || e.level],
          send: r.transmit.send,
          val: e.levelVal
        }, o);
      }
    };
  }(e[t]));
}
function ER(r, e, t, n) {
  r._serialize && zg(t, r._serialize, r.serializers, r._stdErrSerialize);
  const s = t.slice();
  let i = s[0];
  const o = {};
  n && (o.time = n), o.level = Ys.levels.values[e];
  let a = (r._childLevel | 0) + 1;
  if (a < 1 && (a = 1), i !== null && typeof i == "object") {
    for (; a-- && typeof s[0] == "object"; )
      Object.assign(o, s.shift());
    i = s.length ? DE(s.shift(), s) : void 0;
  } else typeof i == "string" && (i = DE(s.shift(), s));
  return i !== void 0 && (o.msg = i), o;
}
function zg(r, e, t, n) {
  for (const s in r)
    if (n && r[s] instanceof Error)
      r[s] = Ys.stdSerializers.err(r[s]);
    else if (typeof r[s] == "object" && !Array.isArray(r[s]))
      for (const i in r[s])
        e && e.indexOf(i) > -1 && i in t && (r[s][i] = t[i](r[s][i]));
}
function Fc(r, e, t) {
  return function() {
    const n = new Array(1 + arguments.length);
    n[0] = e;
    for (var s = 1; s < n.length; s++)
      n[s] = arguments[s - 1];
    return r[t].apply(this, n);
  };
}
function vR(r, e, t) {
  const n = e.send, s = e.ts, i = e.methodLevel, o = e.methodValue, a = e.val, c = r._logEvent.bindings;
  zg(
    t,
    r._serialize || Object.keys(r.serializers),
    r.serializers,
    r._stdErrSerialize === void 0 ? !0 : r._stdErrSerialize
  ), r._logEvent.ts = s, r._logEvent.messages = t.filter(function(l) {
    return c.indexOf(l) === -1;
  }), r._logEvent.level.label = i, r._logEvent.level.value = o, n(i, r._logEvent, a), r._logEvent = ey(c);
}
function ey(r) {
  return {
    ts: 0,
    messages: [],
    bindings: r || [],
    level: { label: "", value: 0 }
  };
}
function AR(r) {
  const e = {
    type: r.constructor.name,
    msg: r.message,
    stack: r.stack
  };
  for (const t in r)
    e[t] === void 0 && (e[t] = r[t]);
  return e;
}
function CR(r) {
  return typeof r.timestamp == "function" ? r.timestamp : r.timestamp === !1 ? I_ : S_;
}
function Gf() {
  return {};
}
function Lm(r) {
  return r;
}
function Ed() {
}
function I_() {
  return !1;
}
function S_() {
  return Date.now();
}
function _R() {
  return Math.round(Date.now() / 1e3);
}
function IR() {
  return new Date(Date.now()).toISOString();
}
function SR() {
  function r(e) {
    return typeof e < "u" && e;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return r(self) || r(window) || r(this) || {};
  }
}
const wf = /* @__PURE__ */ P0(sl), NR = { level: "info" }, yf = "custom_context", M0 = 1e3 * 1024;
let TR = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, kE = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const t = new TR(e);
    if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
    for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
  }
  shift() {
    if (!this.head) return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let t = this.head;
    for (; t !== null; ) e.push(t.value), t = t.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e) return { done: !0, value: null };
      const t = e.value;
      return e = e.next, { done: !1, value: t };
    } };
  }
}, N_ = class {
  constructor(e, t = M0) {
    this.level = e ?? "error", this.levelValue = sl.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new kE(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, t) {
    t === sl.levels.values.error ? console.error(e) : t === sl.levels.values.warn ? console.warn(e) : t === sl.levels.values.debug ? console.debug(e) : t === sl.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append($i({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const t = typeof e == "string" ? JSON.parse(e).level : e.level;
    t >= this.levelValue && this.forwardToConsole(e, t);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new kE(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const t = this.getLogArray();
    return t.push($i({ extraMetadata: e })), new Blob(t, { type: "application/json" });
  }
}, xR = class {
  constructor(e, t = M0) {
    this.baseChunkLogger = new N_(e, t);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const t = URL.createObjectURL(this.logsToBlob(e)), n = document.createElement("a");
    n.href = t, n.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(t);
  }
}, OR = class {
  constructor(e, t = M0) {
    this.baseChunkLogger = new N_(e, t);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var PR = Object.defineProperty, RR = Object.defineProperties, DR = Object.getOwnPropertyDescriptors, UE = Object.getOwnPropertySymbols, kR = Object.prototype.hasOwnProperty, UR = Object.prototype.propertyIsEnumerable, BE = (r, e, t) => e in r ? PR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Kp = (r, e) => {
  for (var t in e || (e = {})) kR.call(e, t) && BE(r, t, e[t]);
  if (UE) for (var t of UE(e)) UR.call(e, t) && BE(r, t, e[t]);
  return r;
}, Jp = (r, e) => RR(r, DR(e));
function Fu(r) {
  return Jp(Kp({}, r), { level: (r == null ? void 0 : r.level) || NR.level });
}
function BR(r, e = yf) {
  return r[e] || "";
}
function LR(r, e, t = yf) {
  return r[t] = e, r;
}
function dn(r, e = yf) {
  let t = "";
  return typeof r.bindings > "u" ? t = BR(r, e) : t = r.bindings().context || "", t;
}
function FR(r, e, t = yf) {
  const n = dn(r, t);
  return n.trim() ? `${n}/${e}` : e;
}
function xr(r, e, t = yf) {
  const n = FR(r, e, t), s = r.child({ context: n });
  return LR(s, n, t);
}
function $R(r) {
  var e, t;
  const n = new xR((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);
  return { logger: wf(Jp(Kp({}, r.opts), { level: "trace", browser: Jp(Kp({}, (t = r.opts) == null ? void 0 : t.browser), { write: (s) => n.write(s) }) })), chunkLoggerController: n };
}
function MR(r) {
  var e;
  const t = new OR((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);
  return { logger: wf(Jp(Kp({}, r.opts), { level: "trace" }), t), chunkLoggerController: t };
}
function j0(r) {
  return typeof r.loggerOverride < "u" && typeof r.loggerOverride != "string" ? { logger: r.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? $R(r) : MR(r);
}
var jR = Object.defineProperty, HR = (r, e, t) => e in r ? jR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, LE = (r, e, t) => HR(r, typeof e != "symbol" ? e + "" : e, t);
let zR = class extends Sc {
  constructor(e) {
    super(), this.opts = e, LE(this, "protocol", "wc"), LE(this, "version", 2);
  }
};
var qR = Object.defineProperty, WR = (r, e, t) => e in r ? qR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, VR = (r, e, t) => WR(r, e + "", t);
let GR = class extends Sc {
  constructor(e, t) {
    super(), this.core = e, this.logger = t, VR(this, "records", /* @__PURE__ */ new Map());
  }
}, KR = class {
  constructor(e, t) {
    this.logger = e, this.core = t;
  }
}, JR = class extends Sc {
  constructor(e, t) {
    super(), this.relayer = e, this.logger = t;
  }
}, YR = class extends Sc {
  constructor(e) {
    super();
  }
}, QR = class {
  constructor(e, t, n, s) {
    this.core = e, this.logger = t, this.name = n;
  }
}, ZR = class extends Sc {
  constructor(e, t) {
    super(), this.relayer = e, this.logger = t;
  }
}, XR = class extends Sc {
  constructor(e, t) {
    super(), this.core = e, this.logger = t;
  }
}, e3 = class {
  constructor(e, t, n) {
    this.core = e, this.logger = t, this.store = n;
  }
}, t3 = class {
  constructor(e, t) {
    this.projectId = e, this.logger = t;
  }
}, r3 = class {
  constructor(e, t, n) {
    this.core = e, this.logger = t, this.telemetryEnabled = n;
  }
};
var n3 = Object.defineProperty, s3 = (r, e, t) => e in r ? n3(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, FE = (r, e, t) => s3(r, typeof e != "symbol" ? e + "" : e, t);
let i3 = class {
  constructor(e) {
    this.opts = e, FE(this, "protocol", "wc"), FE(this, "version", 2);
  }
}, o3 = class {
  constructor(e) {
    this.client = e;
  }
};
function a3(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function T_(r, ...e) {
  if (!a3(r)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function $E(r, e = !0) {
  if (r.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function c3(r, e) {
  T_(r);
  const t = e.outputLen;
  if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
const $c = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Fm = (r) => new DataView(r.buffer, r.byteOffset, r.byteLength);
function l3(r) {
  if (typeof r != "string") throw new Error("utf8ToBytes expected string, got " + typeof r);
  return new Uint8Array(new TextEncoder().encode(r));
}
function x_(r) {
  return typeof r == "string" && (r = l3(r)), T_(r), r;
}
let u3 = class {
  clone() {
    return this._cloneInto();
  }
};
function h3(r) {
  const e = (n) => r().update(x_(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function O_(r = 32) {
  if ($c && typeof $c.getRandomValues == "function") return $c.getRandomValues(new Uint8Array(r));
  if ($c && typeof $c.randomBytes == "function") return $c.randomBytes(r);
  throw new Error("crypto.getRandomValues must be defined");
}
function d3(r, e, t, n) {
  if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), c = n ? 4 : 0, l = n ? 0 : 4;
  r.setUint32(e + c, o, n), r.setUint32(e + l, a, n);
}
let f3 = class extends u3 {
  constructor(e, t, n, s) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Fm(this.buffer);
  }
  update(e) {
    $E(this);
    const { view: t, buffer: n, blockLen: s } = this;
    e = x_(e);
    const i = e.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o);
      if (a === s) {
        const c = Fm(e);
        for (; s <= i - o; o += s) this.process(c, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    $E(this), c3(e, this), this.finished = !0;
    const { buffer: t, view: n, blockLen: s, isLE: i } = this;
    let { pos: o } = this;
    t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
    for (let h = o; h < s; h++) t[h] = 0;
    d3(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Fm(e), c = this.outputLen;
    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = c / 4, u = this.get();
    if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < l; h++) a.setUint32(4 * h, u[h], i);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
    return e.length = s, e.pos = a, e.finished = i, e.destroyed = o, s % t && e.buffer.set(n), e;
  }
};
const Kf = BigInt(2 ** 32 - 1), ty = BigInt(32);
function P_(r, e = !1) {
  return e ? { h: Number(r & Kf), l: Number(r >> ty & Kf) } : { h: Number(r >> ty & Kf) | 0, l: Number(r & Kf) | 0 };
}
function p3(r, e = !1) {
  let t = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let s = 0; s < r.length; s++) {
    const { h: i, l: o } = P_(r[s], e);
    [t[s], n[s]] = [i, o];
  }
  return [t, n];
}
const g3 = (r, e) => BigInt(r >>> 0) << ty | BigInt(e >>> 0), m3 = (r, e, t) => r >>> t, w3 = (r, e, t) => r << 32 - t | e >>> t, y3 = (r, e, t) => r >>> t | e << 32 - t, b3 = (r, e, t) => r << 32 - t | e >>> t, E3 = (r, e, t) => r << 64 - t | e >>> t - 32, v3 = (r, e, t) => r >>> t - 32 | e << 64 - t, A3 = (r, e) => e, C3 = (r, e) => r, _3 = (r, e, t) => r << t | e >>> 32 - t, I3 = (r, e, t) => e << t | r >>> 32 - t, S3 = (r, e, t) => e << t - 32 | r >>> 64 - t, N3 = (r, e, t) => r << t - 32 | e >>> 64 - t;
function T3(r, e, t, n) {
  const s = (e >>> 0) + (n >>> 0);
  return { h: r + t + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const x3 = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0), O3 = (r, e, t, n) => e + t + n + (r / 2 ** 32 | 0) | 0, P3 = (r, e, t, n) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0), R3 = (r, e, t, n, s) => e + t + n + s + (r / 2 ** 32 | 0) | 0, D3 = (r, e, t, n, s) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0), k3 = (r, e, t, n, s, i) => e + t + n + s + i + (r / 2 ** 32 | 0) | 0, Ue = { fromBig: P_, split: p3, toBig: g3, shrSH: m3, shrSL: w3, rotrSH: y3, rotrSL: b3, rotrBH: E3, rotrBL: v3, rotr32H: A3, rotr32L: C3, rotlSH: _3, rotlSL: I3, rotlBH: S3, rotlBL: N3, add: T3, add3L: x3, add3H: O3, add4L: P3, add4H: R3, add5H: k3, add5L: D3 }, [U3, B3] = Ue.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((r) => BigInt(r))), Ki = new Uint32Array(80), Ji = new Uint32Array(80);
let L3 = class extends f3 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e, Al: t, Bh: n, Bl: s, Ch: i, Cl: o, Dh: a, Dl: c, Eh: l, El: u, Fh: h, Fl: d, Gh: f, Gl: g, Hh: p, Hl: w } = this;
    return [e, t, n, s, i, o, a, c, l, u, h, d, f, g, p, w];
  }
  set(e, t, n, s, i, o, a, c, l, u, h, d, f, g, p, w) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = u | 0, this.Fh = h | 0, this.Fl = d | 0, this.Gh = f | 0, this.Gl = g | 0, this.Hh = p | 0, this.Hl = w | 0;
  }
  process(e, t) {
    for (let A = 0; A < 16; A++, t += 4) Ki[A] = e.getUint32(t), Ji[A] = e.getUint32(t += 4);
    for (let A = 16; A < 80; A++) {
      const C = Ki[A - 15] | 0, N = Ji[A - 15] | 0, x = Ue.rotrSH(C, N, 1) ^ Ue.rotrSH(C, N, 8) ^ Ue.shrSH(C, N, 7), O = Ue.rotrSL(C, N, 1) ^ Ue.rotrSL(C, N, 8) ^ Ue.shrSL(C, N, 7), k = Ki[A - 2] | 0, P = Ji[A - 2] | 0, $ = Ue.rotrSH(k, P, 19) ^ Ue.rotrBH(k, P, 61) ^ Ue.shrSH(k, P, 6), U = Ue.rotrSL(k, P, 19) ^ Ue.rotrBL(k, P, 61) ^ Ue.shrSL(k, P, 6), j = Ue.add4L(O, U, Ji[A - 7], Ji[A - 16]), H = Ue.add4H(j, x, $, Ki[A - 7], Ki[A - 16]);
      Ki[A] = H | 0, Ji[A] = j | 0;
    }
    let { Ah: n, Al: s, Bh: i, Bl: o, Ch: a, Cl: c, Dh: l, Dl: u, Eh: h, El: d, Fh: f, Fl: g, Gh: p, Gl: w, Hh: E, Hl: I } = this;
    for (let A = 0; A < 80; A++) {
      const C = Ue.rotrSH(h, d, 14) ^ Ue.rotrSH(h, d, 18) ^ Ue.rotrBH(h, d, 41), N = Ue.rotrSL(h, d, 14) ^ Ue.rotrSL(h, d, 18) ^ Ue.rotrBL(h, d, 41), x = h & f ^ ~h & p, O = d & g ^ ~d & w, k = Ue.add5L(I, N, O, B3[A], Ji[A]), P = Ue.add5H(k, E, C, x, U3[A], Ki[A]), $ = k | 0, U = Ue.rotrSH(n, s, 28) ^ Ue.rotrBH(n, s, 34) ^ Ue.rotrBH(n, s, 39), j = Ue.rotrSL(n, s, 28) ^ Ue.rotrBL(n, s, 34) ^ Ue.rotrBL(n, s, 39), H = n & i ^ n & a ^ i & a, ee = s & o ^ s & c ^ o & c;
      E = p | 0, I = w | 0, p = f | 0, w = g | 0, f = h | 0, g = d | 0, { h, l: d } = Ue.add(l | 0, u | 0, P | 0, $ | 0), l = a | 0, u = c | 0, a = i | 0, c = o | 0, i = n | 0, o = s | 0;
      const y = Ue.add3L($, j, ee);
      n = Ue.add3H(y, P, U, H), s = y | 0;
    }
    ({ h: n, l: s } = Ue.add(this.Ah | 0, this.Al | 0, n | 0, s | 0)), { h: i, l: o } = Ue.add(this.Bh | 0, this.Bl | 0, i | 0, o | 0), { h: a, l: c } = Ue.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: l, l: u } = Ue.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0), { h, l: d } = Ue.add(this.Eh | 0, this.El | 0, h | 0, d | 0), { h: f, l: g } = Ue.add(this.Fh | 0, this.Fl | 0, f | 0, g | 0), { h: p, l: w } = Ue.add(this.Gh | 0, this.Gl | 0, p | 0, w | 0), { h: E, l: I } = Ue.add(this.Hh | 0, this.Hl | 0, E | 0, I | 0), this.set(n, s, i, o, a, c, l, u, h, d, f, g, p, w, E, I);
  }
  roundClean() {
    Ki.fill(0), Ji.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const F3 = h3(() => new L3());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const H0 = BigInt(0), R_ = BigInt(1), $3 = BigInt(2);
function z0(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function q0(r) {
  if (!z0(r)) throw new Error("Uint8Array expected");
}
function $m(r, e) {
  if (typeof e != "boolean") throw new Error(r + " boolean expected, got " + e);
}
const M3 = Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function W0(r) {
  q0(r);
  let e = "";
  for (let t = 0; t < r.length; t++) e += M3[r[t]];
  return e;
}
function D_(r) {
  if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
  return r === "" ? H0 : BigInt("0x" + r);
}
const ii = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function ME(r) {
  if (r >= ii._0 && r <= ii._9) return r - ii._0;
  if (r >= ii.A && r <= ii.F) return r - (ii.A - 10);
  if (r >= ii.a && r <= ii.f) return r - (ii.a - 10);
}
function k_(r) {
  if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
  const e = r.length, t = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(t);
  for (let s = 0, i = 0; s < t; s++, i += 2) {
    const o = ME(r.charCodeAt(i)), a = ME(r.charCodeAt(i + 1));
    if (o === void 0 || a === void 0) {
      const c = r[i] + r[i + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + i);
    }
    n[s] = o * 16 + a;
  }
  return n;
}
function j3(r) {
  return D_(W0(r));
}
function Ip(r) {
  return q0(r), D_(W0(Uint8Array.from(r).reverse()));
}
function U_(r, e) {
  return k_(r.toString(16).padStart(e * 2, "0"));
}
function ry(r, e) {
  return U_(r, e).reverse();
}
function oi(r, e, t) {
  let n;
  if (typeof e == "string") try {
    n = k_(e);
  } catch (i) {
    throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
  }
  else if (z0(e)) n = Uint8Array.from(e);
  else throw new Error(r + " must be hex string or Uint8Array");
  const s = n.length;
  if (typeof t == "number" && s !== t) throw new Error(r + " of length " + t + " expected, got " + s);
  return n;
}
function jE(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    q0(s), e += s.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    t.set(i, s), s += i.length;
  }
  return t;
}
const Mm = (r) => typeof r == "bigint" && H0 <= r;
function H3(r, e, t) {
  return Mm(r) && Mm(e) && Mm(t) && e <= r && r < t;
}
function rh(r, e, t, n) {
  if (!H3(e, t, n)) throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function z3(r) {
  let e;
  for (e = 0; r > H0; r >>= R_, e += 1) ;
  return e;
}
const q3 = (r) => ($3 << BigInt(r - 1)) - R_, W3 = { bigint: (r) => typeof r == "bigint", function: (r) => typeof r == "function", boolean: (r) => typeof r == "boolean", string: (r) => typeof r == "string", stringOrUint8Array: (r) => typeof r == "string" || z0(r), isSafeInteger: (r) => Number.isSafeInteger(r), array: (r) => Array.isArray(r), field: (r, e) => e.Fp.isValid(r), hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen) };
function V0(r, e, t = {}) {
  const n = (s, i, o) => {
    const a = W3[i];
    if (typeof a != "function") throw new Error("invalid validator function");
    const c = r[s];
    if (!(o && c === void 0) && !a(c, r)) throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + c);
  };
  for (const [s, i] of Object.entries(e)) n(s, i, !1);
  for (const [s, i] of Object.entries(t)) n(s, i, !0);
  return r;
}
function HE(r) {
  const e = /* @__PURE__ */ new WeakMap();
  return (t, ...n) => {
    const s = e.get(t);
    if (s !== void 0) return s;
    const i = r(t, ...n);
    return e.set(t, i), i;
  };
}
const er = BigInt(0), kt = BigInt(1), wa = BigInt(2), V3 = BigInt(3), ny = BigInt(4), zE = BigInt(5), qE = BigInt(8);
function zt(r, e) {
  const t = r % e;
  return t >= er ? t : e + t;
}
function G3(r, e, t) {
  if (e < er) throw new Error("invalid exponent, negatives unsupported");
  if (t <= er) throw new Error("invalid modulus");
  if (t === kt) return er;
  let n = kt;
  for (; e > er; ) e & kt && (n = n * r % t), r = r * r % t, e >>= kt;
  return n;
}
function _s(r, e, t) {
  let n = r;
  for (; e-- > er; ) n *= n, n %= t;
  return n;
}
function WE(r, e) {
  if (r === er) throw new Error("invert: expected non-zero number");
  if (e <= er) throw new Error("invert: expected positive modulus, got " + e);
  let t = zt(r, e), n = e, s = er, i = kt;
  for (; t !== er; ) {
    const o = n / t, a = n % t, c = s - i * o;
    n = t, t = a, s = i, i = c;
  }
  if (n !== kt) throw new Error("invert: does not exist");
  return zt(s, e);
}
function K3(r) {
  const e = (r - kt) / wa;
  let t, n, s;
  for (t = r - kt, n = 0; t % wa === er; t /= wa, n++) ;
  for (s = wa; s < r && G3(s, e, r) !== r - kt; s++) if (s > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (n === 1) {
    const o = (r + kt) / ny;
    return function(a, c) {
      const l = a.pow(c, o);
      if (!a.eql(a.sqr(l), c)) throw new Error("Cannot find square root");
      return l;
    };
  }
  const i = (t + kt) / wa;
  return function(o, a) {
    if (o.pow(a, e) === o.neg(o.ONE)) throw new Error("Cannot find square root");
    let c = n, l = o.pow(o.mul(o.ONE, s), t), u = o.pow(a, i), h = o.pow(a, t);
    for (; !o.eql(h, o.ONE); ) {
      if (o.eql(h, o.ZERO)) return o.ZERO;
      let d = 1;
      for (let g = o.sqr(h); d < c && !o.eql(g, o.ONE); d++) g = o.sqr(g);
      const f = o.pow(l, kt << BigInt(c - d - 1));
      l = o.sqr(f), u = o.mul(u, f), h = o.mul(h, l), c = d;
    }
    return u;
  };
}
function J3(r) {
  if (r % ny === V3) {
    const e = (r + kt) / ny;
    return function(t, n) {
      const s = t.pow(n, e);
      if (!t.eql(t.sqr(s), n)) throw new Error("Cannot find square root");
      return s;
    };
  }
  if (r % qE === zE) {
    const e = (r - zE) / qE;
    return function(t, n) {
      const s = t.mul(n, wa), i = t.pow(s, e), o = t.mul(n, i), a = t.mul(t.mul(o, wa), i), c = t.mul(o, t.sub(a, t.ONE));
      if (!t.eql(t.sqr(c), n)) throw new Error("Cannot find square root");
      return c;
    };
  }
  return K3(r);
}
const Y3 = (r, e) => (zt(r, e) & kt) === kt, Q3 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Z3(r) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, t = Q3.reduce((n, s) => (n[s] = "function", n), e);
  return V0(r, t);
}
function X3(r, e, t) {
  if (t < er) throw new Error("invalid exponent, negatives unsupported");
  if (t === er) return r.ONE;
  if (t === kt) return e;
  let n = r.ONE, s = e;
  for (; t > er; ) t & kt && (n = r.mul(n, s)), s = r.sqr(s), t >>= kt;
  return n;
}
function eD(r, e) {
  const t = new Array(e.length), n = e.reduce((i, o, a) => r.is0(o) ? i : (t[a] = i, r.mul(i, o)), r.ONE), s = r.inv(n);
  return e.reduceRight((i, o, a) => r.is0(o) ? i : (t[a] = r.mul(i, t[a]), r.mul(i, o)), s), t;
}
function B_(r, e) {
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function L_(r, e, t = !1, n = {}) {
  if (r <= er) throw new Error("invalid field: expected ORDER > 0, got " + r);
  const { nBitLength: s, nByteLength: i } = B_(r, e);
  if (i > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o;
  const a = Object.freeze({ ORDER: r, isLE: t, BITS: s, BYTES: i, MASK: q3(s), ZERO: er, ONE: kt, create: (c) => zt(c, r), isValid: (c) => {
    if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
    return er <= c && c < r;
  }, is0: (c) => c === er, isOdd: (c) => (c & kt) === kt, neg: (c) => zt(-c, r), eql: (c, l) => c === l, sqr: (c) => zt(c * c, r), add: (c, l) => zt(c + l, r), sub: (c, l) => zt(c - l, r), mul: (c, l) => zt(c * l, r), pow: (c, l) => X3(a, c, l), div: (c, l) => zt(c * WE(l, r), r), sqrN: (c) => c * c, addN: (c, l) => c + l, subN: (c, l) => c - l, mulN: (c, l) => c * l, inv: (c) => WE(c, r), sqrt: n.sqrt || ((c) => (o || (o = J3(r)), o(a, c))), invertBatch: (c) => eD(a, c), cmov: (c, l, u) => u ? l : c, toBytes: (c) => t ? ry(c, i) : U_(c, i), fromBytes: (c) => {
    if (c.length !== i) throw new Error("Field.fromBytes: expected " + i + " bytes, got " + c.length);
    return t ? Ip(c) : j3(c);
  } });
  return Object.freeze(a);
}
const VE = BigInt(0), Jf = BigInt(1);
function jm(r, e) {
  const t = e.negate();
  return r ? t : e;
}
function F_(r, e) {
  if (!Number.isSafeInteger(r) || r <= 0 || r > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function Hm(r, e) {
  F_(r, e);
  const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1);
  return { windows: t, windowSize: n };
}
function tD(r, e) {
  if (!Array.isArray(r)) throw new Error("array expected");
  r.forEach((t, n) => {
    if (!(t instanceof e)) throw new Error("invalid point at index " + n);
  });
}
function rD(r, e) {
  if (!Array.isArray(r)) throw new Error("array of scalars expected");
  r.forEach((t, n) => {
    if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
  });
}
const zm = /* @__PURE__ */ new WeakMap(), $_ = /* @__PURE__ */ new WeakMap();
function qm(r) {
  return $_.get(r) || 1;
}
function nD(r, e) {
  return { constTimeNegate: jm, hasPrecomputes(t) {
    return qm(t) !== 1;
  }, unsafeLadder(t, n, s = r.ZERO) {
    let i = t;
    for (; n > VE; ) n & Jf && (s = s.add(i)), i = i.double(), n >>= Jf;
    return s;
  }, precomputeWindow(t, n) {
    const { windows: s, windowSize: i } = Hm(n, e), o = [];
    let a = t, c = a;
    for (let l = 0; l < s; l++) {
      c = a, o.push(c);
      for (let u = 1; u < i; u++) c = c.add(a), o.push(c);
      a = c.double();
    }
    return o;
  }, wNAF(t, n, s) {
    const { windows: i, windowSize: o } = Hm(t, e);
    let a = r.ZERO, c = r.BASE;
    const l = BigInt(2 ** t - 1), u = 2 ** t, h = BigInt(t);
    for (let d = 0; d < i; d++) {
      const f = d * o;
      let g = Number(s & l);
      s >>= h, g > o && (g -= u, s += Jf);
      const p = f, w = f + Math.abs(g) - 1, E = d % 2 !== 0, I = g < 0;
      g === 0 ? c = c.add(jm(E, n[p])) : a = a.add(jm(I, n[w]));
    }
    return { p: a, f: c };
  }, wNAFUnsafe(t, n, s, i = r.ZERO) {
    const { windows: o, windowSize: a } = Hm(t, e), c = BigInt(2 ** t - 1), l = 2 ** t, u = BigInt(t);
    for (let h = 0; h < o; h++) {
      const d = h * a;
      if (s === VE) break;
      let f = Number(s & c);
      if (s >>= u, f > a && (f -= l, s += Jf), f === 0) continue;
      let g = n[d + Math.abs(f) - 1];
      f < 0 && (g = g.negate()), i = i.add(g);
    }
    return i;
  }, getPrecomputes(t, n, s) {
    let i = zm.get(n);
    return i || (i = this.precomputeWindow(n, t), t !== 1 && zm.set(n, s(i))), i;
  }, wNAFCached(t, n, s) {
    const i = qm(t);
    return this.wNAF(i, this.getPrecomputes(i, t, s), n);
  }, wNAFCachedUnsafe(t, n, s, i) {
    const o = qm(t);
    return o === 1 ? this.unsafeLadder(t, n, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, s), n, i);
  }, setWindowSize(t, n) {
    F_(n, e), $_.set(t, n), zm.delete(t);
  } };
}
function sD(r, e, t, n) {
  if (tD(t, r), rD(n, e), t.length !== n.length) throw new Error("arrays of points and scalars must have equal length");
  const s = r.ZERO, i = z3(BigInt(t.length)), o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1, a = (1 << o) - 1, c = new Array(a + 1).fill(s), l = Math.floor((e.BITS - 1) / o) * o;
  let u = s;
  for (let h = l; h >= 0; h -= o) {
    c.fill(s);
    for (let f = 0; f < n.length; f++) {
      const g = n[f], p = Number(g >> BigInt(h) & BigInt(a));
      c[p] = c[p].add(t[f]);
    }
    let d = s;
    for (let f = c.length - 1, g = s; f > 0; f--) g = g.add(c[f]), d = d.add(g);
    if (u = u.add(d), h !== 0) for (let f = 0; f < o; f++) u = u.double();
  }
  return u;
}
function iD(r) {
  return Z3(r.Fp), V0(r, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...B_(r.n, r.nBitLength), ...r, p: r.Fp.ORDER });
}
const Jn = BigInt(0), qr = BigInt(1), Yf = BigInt(2), oD = BigInt(8), aD = { zip215: !0 };
function cD(r) {
  const e = iD(r);
  return V0(r, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e });
}
function lD(r) {
  const e = cD(r), { Fp: t, n, prehash: s, hash: i, randomBytes: o, nByteLength: a, h: c } = e, l = Yf << BigInt(a * 8) - qr, u = t.create, h = L_(e.n, e.nBitLength), d = e.uvRatio || ((y, b) => {
    try {
      return { isValid: !0, value: t.sqrt(y * t.inv(b)) };
    } catch {
      return { isValid: !1, value: Jn };
    }
  }), f = e.adjustScalarBytes || ((y) => y), g = e.domain || ((y, b, T) => {
    if ($m("phflag", T), b.length || T) throw new Error("Contexts/pre-hash are not supported");
    return y;
  });
  function p(y, b) {
    rh("coordinate " + y, b, Jn, l);
  }
  function w(y) {
    if (!(y instanceof A)) throw new Error("ExtendedPoint expected");
  }
  const E = HE((y, b) => {
    const { ex: T, ey: B, ez: R } = y, L = y.is0();
    b == null && (b = L ? oD : t.inv(R));
    const q = u(T * b), Y = u(B * b), de = u(R * b);
    if (L) return { x: Jn, y: qr };
    if (de !== qr) throw new Error("invZ was invalid");
    return { x: q, y: Y };
  }), I = HE((y) => {
    const { a: b, d: T } = e;
    if (y.is0()) throw new Error("bad point: ZERO");
    const { ex: B, ey: R, ez: L, et: q } = y, Y = u(B * B), de = u(R * R), ne = u(L * L), we = u(ne * ne), ke = u(Y * b), xe = u(ne * u(ke + de)), Ve = u(we + u(T * u(Y * de)));
    if (xe !== Ve) throw new Error("bad point: equation left != right (1)");
    const Ne = u(B * R), yt = u(L * q);
    if (Ne !== yt) throw new Error("bad point: equation left != right (2)");
    return !0;
  });
  class A {
    constructor(b, T, B, R) {
      this.ex = b, this.ey = T, this.ez = B, this.et = R, p("x", b), p("y", T), p("z", B), p("t", R), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(b) {
      if (b instanceof A) throw new Error("extended point not allowed");
      const { x: T, y: B } = b || {};
      return p("x", T), p("y", B), new A(T, B, qr, u(T * B));
    }
    static normalizeZ(b) {
      const T = t.invertBatch(b.map((B) => B.ez));
      return b.map((B, R) => B.toAffine(T[R])).map(A.fromAffine);
    }
    static msm(b, T) {
      return sD(A, h, b, T);
    }
    _setWindowSize(b) {
      x.setWindowSize(this, b);
    }
    assertValidity() {
      I(this);
    }
    equals(b) {
      w(b);
      const { ex: T, ey: B, ez: R } = this, { ex: L, ey: q, ez: Y } = b, de = u(T * Y), ne = u(L * R), we = u(B * Y), ke = u(q * R);
      return de === ne && we === ke;
    }
    is0() {
      return this.equals(A.ZERO);
    }
    negate() {
      return new A(u(-this.ex), this.ey, this.ez, u(-this.et));
    }
    double() {
      const { a: b } = e, { ex: T, ey: B, ez: R } = this, L = u(T * T), q = u(B * B), Y = u(Yf * u(R * R)), de = u(b * L), ne = T + B, we = u(u(ne * ne) - L - q), ke = de + q, xe = ke - Y, Ve = de - q, Ne = u(we * xe), yt = u(ke * Ve), Wt = u(we * Ve), Bt = u(xe * ke);
      return new A(Ne, yt, Bt, Wt);
    }
    add(b) {
      w(b);
      const { a: T, d: B } = e, { ex: R, ey: L, ez: q, et: Y } = this, { ex: de, ey: ne, ez: we, et: ke } = b;
      if (T === BigInt(-1)) {
        const Gb = u((L - R) * (ne + de)), Kb = u((L + R) * (ne - de)), Am = u(Kb - Gb);
        if (Am === Jn) return this.double();
        const Jb = u(q * Yf * ke), Yb = u(Y * Yf * we), Qb = Yb + Jb, Zb = Kb + Gb, Xb = Yb - Jb, RT = u(Qb * Am), DT = u(Zb * Xb), kT = u(Qb * Xb), UT = u(Am * Zb);
        return new A(RT, DT, UT, kT);
      }
      const xe = u(R * de), Ve = u(L * ne), Ne = u(Y * B * ke), yt = u(q * we), Wt = u((R + L) * (de + ne) - xe - Ve), Bt = yt - Ne, It = yt + Ne, Rt = u(Ve - T * xe), Tn = u(Wt * Bt), na = u(It * Rt), OT = u(Wt * Rt), PT = u(Bt * It);
      return new A(Tn, na, PT, OT);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    wNAF(b) {
      return x.wNAFCached(this, b, A.normalizeZ);
    }
    multiply(b) {
      const T = b;
      rh("scalar", T, qr, n);
      const { p: B, f: R } = this.wNAF(T);
      return A.normalizeZ([B, R])[0];
    }
    multiplyUnsafe(b, T = A.ZERO) {
      const B = b;
      return rh("scalar", B, Jn, n), B === Jn ? N : this.is0() || B === qr ? this : x.wNAFCachedUnsafe(this, B, A.normalizeZ, T);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c).is0();
    }
    isTorsionFree() {
      return x.unsafeLadder(this, n).is0();
    }
    toAffine(b) {
      return E(this, b);
    }
    clearCofactor() {
      const { h: b } = e;
      return b === qr ? this : this.multiplyUnsafe(b);
    }
    static fromHex(b, T = !1) {
      const { d: B, a: R } = e, L = t.BYTES;
      b = oi("pointHex", b, L), $m("zip215", T);
      const q = b.slice(), Y = b[L - 1];
      q[L - 1] = Y & -129;
      const de = Ip(q), ne = T ? l : t.ORDER;
      rh("pointHex.y", de, Jn, ne);
      const we = u(de * de), ke = u(we - qr), xe = u(B * we - R);
      let { isValid: Ve, value: Ne } = d(ke, xe);
      if (!Ve) throw new Error("Point.fromHex: invalid y coordinate");
      const yt = (Ne & qr) === qr, Wt = (Y & 128) !== 0;
      if (!T && Ne === Jn && Wt) throw new Error("Point.fromHex: x=0 and x_0=1");
      return Wt !== yt && (Ne = u(-Ne)), A.fromAffine({ x: Ne, y: de });
    }
    static fromPrivateKey(b) {
      return P(b).point;
    }
    toRawBytes() {
      const { x: b, y: T } = this.toAffine(), B = ry(T, t.BYTES);
      return B[B.length - 1] |= b & qr ? 128 : 0, B;
    }
    toHex() {
      return W0(this.toRawBytes());
    }
  }
  A.BASE = new A(e.Gx, e.Gy, qr, u(e.Gx * e.Gy)), A.ZERO = new A(Jn, qr, qr, Jn);
  const { BASE: C, ZERO: N } = A, x = nD(A, a * 8);
  function O(y) {
    return zt(y, n);
  }
  function k(y) {
    return O(Ip(y));
  }
  function P(y) {
    const b = t.BYTES;
    y = oi("private key", y, b);
    const T = oi("hashed private key", i(y), 2 * b), B = f(T.slice(0, b)), R = T.slice(b, 2 * b), L = k(B), q = C.multiply(L), Y = q.toRawBytes();
    return { head: B, prefix: R, scalar: L, point: q, pointBytes: Y };
  }
  function $(y) {
    return P(y).pointBytes;
  }
  function U(y = new Uint8Array(), ...b) {
    const T = jE(...b);
    return k(i(g(T, oi("context", y), !!s)));
  }
  function j(y, b, T = {}) {
    y = oi("message", y), s && (y = s(y));
    const { prefix: B, scalar: R, pointBytes: L } = P(b), q = U(T.context, B, y), Y = C.multiply(q).toRawBytes(), de = U(T.context, Y, L, y), ne = O(q + de * R);
    rh("signature.s", ne, Jn, n);
    const we = jE(Y, ry(ne, t.BYTES));
    return oi("result", we, t.BYTES * 2);
  }
  const H = aD;
  function ee(y, b, T, B = H) {
    const { context: R, zip215: L } = B, q = t.BYTES;
    y = oi("signature", y, 2 * q), b = oi("message", b), T = oi("publicKey", T, q), L !== void 0 && $m("zip215", L), s && (b = s(b));
    const Y = Ip(y.slice(q, 2 * q));
    let de, ne, we;
    try {
      de = A.fromHex(T, L), ne = A.fromHex(y.slice(0, q), L), we = C.multiplyUnsafe(Y);
    } catch {
      return !1;
    }
    if (!L && de.isSmallOrder()) return !1;
    const ke = U(R, ne.toRawBytes(), de.toRawBytes(), b);
    return ne.add(de.multiplyUnsafe(ke)).subtract(we).clearCofactor().equals(A.ZERO);
  }
  return C._setWindowSize(8), { CURVE: e, getPublicKey: $, sign: j, verify: ee, ExtendedPoint: A, utils: { getExtendedPublicKey: P, randomPrivateKey: () => o(t.BYTES), precompute(y = 8, b = A.BASE) {
    return b._setWindowSize(y), b.multiply(BigInt(3)), b;
  } } };
}
BigInt(0), BigInt(1);
const G0 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), GE = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const uD = BigInt(1), KE = BigInt(2);
BigInt(3);
const hD = BigInt(5), dD = BigInt(8);
function fD(r) {
  const e = BigInt(10), t = BigInt(20), n = BigInt(40), s = BigInt(80), i = G0, o = r * r % i * r % i, a = _s(o, KE, i) * o % i, c = _s(a, uD, i) * r % i, l = _s(c, hD, i) * c % i, u = _s(l, e, i) * l % i, h = _s(u, t, i) * u % i, d = _s(h, n, i) * h % i, f = _s(d, s, i) * d % i, g = _s(f, s, i) * d % i, p = _s(g, e, i) * l % i;
  return { pow_p_5_8: _s(p, KE, i) * r % i, b2: o };
}
function pD(r) {
  return r[0] &= 248, r[31] &= 127, r[31] |= 64, r;
}
function gD(r, e) {
  const t = G0, n = zt(e * e * e, t), s = zt(n * n * e, t), i = fD(r * s).pow_p_5_8;
  let o = zt(r * n * i, t);
  const a = zt(e * o * o, t), c = o, l = zt(o * GE, t), u = a === r, h = a === zt(-r, t), d = a === zt(-r * GE, t);
  return u && (o = c), (h || d) && (o = l), Y3(o, t) && (o = zt(-o, t)), { isValid: u || h, value: o };
}
const mD = L_(G0, void 0, !0), wD = { a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: mD, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: dD, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: F3, randomBytes: O_, adjustScalarBytes: pD, uvRatio: gD }, M_ = lD(wD), yD = "EdDSA", bD = "JWT", Yp = ".", qg = "base64url", j_ = "utf8", H_ = "utf8", ED = ":", vD = "did", AD = "key", JE = "base58btc", CD = "z", _D = "K36", ID = 32;
function K0(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function z_(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? K0(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function q_(r, e) {
  e || (e = r.reduce((s, i) => s + i.length, 0));
  const t = z_(e);
  let n = 0;
  for (const s of r) t.set(s, n), n += s.length;
  return K0(t);
}
function SD(r, e) {
  if (r.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var s = 0; s < r.length; s++) {
    var i = r.charAt(s), o = i.charCodeAt(0);
    if (t[o] !== 255) throw new TypeError(i + " is ambiguous");
    t[o] = s;
  }
  var a = r.length, c = r.charAt(0), l = Math.log(a) / Math.log(256), u = Math.log(256) / Math.log(a);
  function h(g) {
    if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (g.length === 0) return "";
    for (var p = 0, w = 0, E = 0, I = g.length; E !== I && g[E] === 0; ) E++, p++;
    for (var A = (I - E) * u + 1 >>> 0, C = new Uint8Array(A); E !== I; ) {
      for (var N = g[E], x = 0, O = A - 1; (N !== 0 || x < w) && O !== -1; O--, x++) N += 256 * C[O] >>> 0, C[O] = N % a >>> 0, N = N / a >>> 0;
      if (N !== 0) throw new Error("Non-zero carry");
      w = x, E++;
    }
    for (var k = A - w; k !== A && C[k] === 0; ) k++;
    for (var P = c.repeat(p); k < A; ++k) P += r.charAt(C[k]);
    return P;
  }
  function d(g) {
    if (typeof g != "string") throw new TypeError("Expected String");
    if (g.length === 0) return new Uint8Array();
    var p = 0;
    if (g[p] !== " ") {
      for (var w = 0, E = 0; g[p] === c; ) w++, p++;
      for (var I = (g.length - p) * l + 1 >>> 0, A = new Uint8Array(I); g[p]; ) {
        var C = t[g.charCodeAt(p)];
        if (C === 255) return;
        for (var N = 0, x = I - 1; (C !== 0 || N < E) && x !== -1; x--, N++) C += a * A[x] >>> 0, A[x] = C % 256 >>> 0, C = C / 256 >>> 0;
        if (C !== 0) throw new Error("Non-zero carry");
        E = N, p++;
      }
      if (g[p] !== " ") {
        for (var O = I - E; O !== I && A[O] === 0; ) O++;
        for (var k = new Uint8Array(w + (I - O)), P = w; O !== I; ) k[P++] = A[O++];
        return k;
      }
    }
  }
  function f(g) {
    var p = d(g);
    if (p) return p;
    throw new Error(`Non-${e} character`);
  }
  return { encode: h, decodeUnsafe: d, decode: f };
}
var ND = SD, TD = ND;
const W_ = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array") return r;
  if (r instanceof ArrayBuffer) return new Uint8Array(r);
  if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
}, xD = (r) => new TextEncoder().encode(r), OD = (r) => new TextDecoder().decode(r);
let PD = class {
  constructor(e, t, n) {
    this.name = e, this.prefix = t, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}, RD = class {
  constructor(e, t, n) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return V_(this, e);
  }
}, DD = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return V_(this, e);
  }
  decode(e) {
    const t = e[0], n = this.decoders[t];
    if (n) return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const V_ = (r, e) => new DD({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
let kD = class {
  constructor(e, t, n, s) {
    this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new PD(e, t, n), this.decoder = new RD(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
const Wg = ({ name: r, prefix: e, encode: t, decode: n }) => new kD(r, e, t, n), bf = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: n, decode: s } = TD(t, e);
  return Wg({ prefix: r, name: e, encode: n, decode: (i) => W_(s(i)) });
}, UD = (r, e, t, n) => {
  const s = {};
  for (let u = 0; u < e.length; ++u) s[e[u]] = u;
  let i = r.length;
  for (; r[i - 1] === "="; ) --i;
  const o = new Uint8Array(i * t / 8 | 0);
  let a = 0, c = 0, l = 0;
  for (let u = 0; u < i; ++u) {
    const h = s[r[u]];
    if (h === void 0) throw new SyntaxError(`Non-${n} character`);
    c = c << t | h, a += t, a >= 8 && (a -= 8, o[l++] = 255 & c >> a);
  }
  if (a >= t || 255 & c << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o;
}, BD = (r, e, t) => {
  const n = e[e.length - 1] === "=", s = (1 << t) - 1;
  let i = "", o = 0, a = 0;
  for (let c = 0; c < r.length; ++c) for (a = a << 8 | r[c], o += 8; o > t; ) o -= t, i += e[s & a >> o];
  if (o && (i += e[s & a << t - o]), n) for (; i.length * t & 7; ) i += "=";
  return i;
}, pr = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => Wg({ prefix: e, name: r, encode(s) {
  return BD(s, n, t);
}, decode(s) {
  return UD(s, n, t, r);
} }), LD = Wg({ prefix: "\0", name: "identity", encode: (r) => OD(r), decode: (r) => xD(r) });
var FD = Object.freeze({ __proto__: null, identity: LD });
const $D = pr({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var MD = Object.freeze({ __proto__: null, base2: $D });
const jD = pr({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var HD = Object.freeze({ __proto__: null, base8: jD });
const zD = bf({ prefix: "9", name: "base10", alphabet: "0123456789" });
var qD = Object.freeze({ __proto__: null, base10: zD });
const WD = pr({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), VD = pr({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var GD = Object.freeze({ __proto__: null, base16: WD, base16upper: VD });
const KD = pr({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), JD = pr({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), YD = pr({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), QD = pr({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), ZD = pr({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), XD = pr({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), ek = pr({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), tk = pr({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), rk = pr({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var nk = Object.freeze({ __proto__: null, base32: KD, base32upper: JD, base32pad: YD, base32padupper: QD, base32hex: ZD, base32hexupper: XD, base32hexpad: ek, base32hexpadupper: tk, base32z: rk });
const sk = bf({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), ik = bf({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ok = Object.freeze({ __proto__: null, base36: sk, base36upper: ik });
const ak = bf({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), ck = bf({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var lk = Object.freeze({ __proto__: null, base58btc: ak, base58flickr: ck });
const uk = pr({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), hk = pr({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), dk = pr({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), fk = pr({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var pk = Object.freeze({ __proto__: null, base64: uk, base64pad: hk, base64url: dk, base64urlpad: fk });
const G_ = Array.from(""), gk = G_.reduce((r, e, t) => (r[t] = e, r), []), mk = G_.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function wk(r) {
  return r.reduce((e, t) => (e += gk[t], e), "");
}
function yk(r) {
  const e = [];
  for (const t of r) {
    const n = mk[t.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const bk = Wg({ prefix: "", name: "base256emoji", encode: wk, decode: yk });
var Ek = Object.freeze({ __proto__: null, base256emoji: bk }), vk = K_, YE = 128, Ak = -128, Ck = Math.pow(2, 31);
function K_(r, e, t) {
  e = e || [], t = t || 0;
  for (var n = t; r >= Ck; ) e[t++] = r & 255 | YE, r /= 128;
  for (; r & Ak; ) e[t++] = r & 255 | YE, r >>>= 7;
  return e[t] = r | 0, K_.bytes = t - n + 1, e;
}
var _k = sy, Ik = 128, QE = 127;
function sy(r, n) {
  var t = 0, n = n || 0, s = 0, i = n, o, a = r.length;
  do {
    if (i >= a) throw sy.bytes = 0, new RangeError("Could not decode varint");
    o = r[i++], t += s < 28 ? (o & QE) << s : (o & QE) * Math.pow(2, s), s += 7;
  } while (o >= Ik);
  return sy.bytes = i - n, t;
}
var Sk = Math.pow(2, 7), Nk = Math.pow(2, 14), Tk = Math.pow(2, 21), xk = Math.pow(2, 28), Ok = Math.pow(2, 35), Pk = Math.pow(2, 42), Rk = Math.pow(2, 49), Dk = Math.pow(2, 56), kk = Math.pow(2, 63), Uk = function(r) {
  return r < Sk ? 1 : r < Nk ? 2 : r < Tk ? 3 : r < xk ? 4 : r < Ok ? 5 : r < Pk ? 6 : r < Rk ? 7 : r < Dk ? 8 : r < kk ? 9 : 10;
}, Bk = { encode: vk, decode: _k, encodingLength: Uk }, J_ = Bk;
const ZE = (r, e, t = 0) => (J_.encode(r, e, t), e), XE = (r) => J_.encodingLength(r), iy = (r, e) => {
  const t = e.byteLength, n = XE(r), s = n + XE(t), i = new Uint8Array(s + t);
  return ZE(r, i, 0), ZE(t, i, n), i.set(e, s), new Lk(r, t, e, i);
};
let Lk = class {
  constructor(e, t, n, s) {
    this.code = e, this.size = t, this.digest = n, this.bytes = s;
  }
};
const Y_ = ({ name: r, code: e, encode: t }) => new Fk(r, e, t);
let Fk = class {
  constructor(e, t, n) {
    this.name = e, this.code = t, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? iy(this.code, t) : t.then((n) => iy(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
};
const Q_ = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e)), $k = Y_({ name: "sha2-256", code: 18, encode: Q_("SHA-256") }), Mk = Y_({ name: "sha2-512", code: 19, encode: Q_("SHA-512") });
var jk = Object.freeze({ __proto__: null, sha256: $k, sha512: Mk });
const Z_ = 0, Hk = "identity", X_ = W_, zk = (r) => iy(Z_, X_(r)), qk = { code: Z_, name: Hk, encode: X_, digest: zk };
var Wk = Object.freeze({ __proto__: null, identity: qk });
new TextEncoder(), new TextDecoder();
const ev = { ...FD, ...MD, ...HD, ...qD, ...GD, ...nk, ...ok, ...lk, ...pk, ...Ek };
({ ...jk, ...Wk });
function eI(r, e, t, n) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: n } };
}
const tv = eI("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1))), Wm = eI("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = z_(r.length);
  for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);
  return e;
}), tI = { utf8: tv, "utf-8": tv, hex: ev.base16, latin1: Wm, ascii: Wm, binary: Wm, ...ev };
function Vg(r, e = "utf8") {
  const t = tI[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1);
}
function $u(r, e = "utf8") {
  const t = tI[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? K0(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
function rv(r) {
  return lc(Vg($u(r, qg), j_));
}
function Qp(r) {
  return Vg($u($i(r), j_), qg);
}
function rI(r) {
  const e = $u(_D, JE), t = CD + Vg(q_([e, r]), JE);
  return [vD, AD, t].join(ED);
}
function Vk(r) {
  return Vg(r, qg);
}
function Gk(r) {
  return $u(r, qg);
}
function Kk(r) {
  return $u([Qp(r.header), Qp(r.payload)].join(Yp), H_);
}
function Jk(r) {
  return [Qp(r.header), Qp(r.payload), Vk(r.signature)].join(Yp);
}
function oy(r) {
  const e = r.split(Yp), t = rv(e[0]), n = rv(e[1]), s = Gk(e[2]), i = $u(e.slice(0, 2).join(Yp), H_);
  return { header: t, payload: n, signature: s, data: i };
}
function nv(r = O_(ID)) {
  const e = M_.getPublicKey(r);
  return { secretKey: q_([r, e]), publicKey: e };
}
async function Yk(r, e, t, n, s = Q.fromMiliseconds(Date.now())) {
  const i = { alg: yD, typ: bD }, o = rI(n.publicKey), a = s + t, c = { iss: o, sub: r, aud: e, iat: s, exp: a }, l = Kk({ header: i, payload: c }), u = M_.sign(l, n.secretKey.slice(0, 32));
  return Jk({ header: i, payload: c, signature: u });
}
var sv = function(r, e, t) {
  if (t || arguments.length === 2) for (var n = 0, s = e.length, i; n < s; n++)
    (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
  return r.concat(i || Array.prototype.slice.call(e));
}, Qk = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t, n) {
      this.name = e, this.version = t, this.os = n, this.type = "browser";
    }
    return r;
  }()
), Zk = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return r;
  }()
), Xk = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t, n, s) {
      this.name = e, this.version = t, this.os = n, this.bot = s, this.type = "bot-device";
    }
    return r;
  }()
), eU = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return r;
  }()
), tU = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return r;
  }()
), rU = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, nU = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, iv = 3, sU = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", rU]
], ov = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function iU(r) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new tU() : typeof navigator < "u" ? aU(navigator.userAgent) : lU();
}
function oU(r) {
  return r !== "" && sU.reduce(function(e, t) {
    var n = t[0], s = t[1];
    if (e)
      return e;
    var i = s.exec(r);
    return !!i && [n, i];
  }, !1);
}
function aU(r) {
  var e = oU(r);
  if (!e)
    return null;
  var t = e[0], n = e[1];
  if (t === "searchbot")
    return new eU();
  var s = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  s ? s.length < iv && (s = sv(sv([], s, !0), uU(iv - s.length), !0)) : s = [];
  var i = s.join("."), o = cU(r), a = nU.exec(r);
  return a && a[1] ? new Xk(t, i, o, a[1]) : new Qk(t, i, o);
}
function cU(r) {
  for (var e = 0, t = ov.length; e < t; e++) {
    var n = ov[e], s = n[0], i = n[1], o = i.exec(r);
    if (o)
      return s;
  }
  return null;
}
function lU() {
  var r = typeof process < "u" && process.version;
  return r ? new Zk(process.version.slice(1)) : null;
}
function uU(r) {
  for (var e = [], t = 0; t < r; t++)
    e.push("0");
  return e;
}
var vt = {};
Object.defineProperty(vt, "__esModule", { value: !0 });
vt.getLocalStorage = vt.getLocalStorageOrThrow = vt.getCrypto = vt.getCryptoOrThrow = nI = vt.getLocation = vt.getLocationOrThrow = J0 = vt.getNavigator = vt.getNavigatorOrThrow = uc = vt.getDocument = vt.getDocumentOrThrow = vt.getFromWindowOrThrow = vt.getFromWindow = void 0;
function xc(r) {
  let e;
  return typeof window < "u" && typeof window[r] < "u" && (e = window[r]), e;
}
vt.getFromWindow = xc;
function Mu(r) {
  const e = xc(r);
  if (!e)
    throw new Error(`${r} is not defined in Window`);
  return e;
}
vt.getFromWindowOrThrow = Mu;
function hU() {
  return Mu("document");
}
vt.getDocumentOrThrow = hU;
function dU() {
  return xc("document");
}
var uc = vt.getDocument = dU;
function fU() {
  return Mu("navigator");
}
vt.getNavigatorOrThrow = fU;
function pU() {
  return xc("navigator");
}
var J0 = vt.getNavigator = pU;
function gU() {
  return Mu("location");
}
vt.getLocationOrThrow = gU;
function mU() {
  return xc("location");
}
var nI = vt.getLocation = mU;
function wU() {
  return Mu("crypto");
}
vt.getCryptoOrThrow = wU;
function yU() {
  return xc("crypto");
}
vt.getCrypto = yU;
function bU() {
  return Mu("localStorage");
}
vt.getLocalStorageOrThrow = bU;
function EU() {
  return xc("localStorage");
}
vt.getLocalStorage = EU;
var Y0 = {};
Object.defineProperty(Y0, "__esModule", { value: !0 });
var sI = Y0.getWindowMetadata = void 0;
const av = vt;
function vU() {
  let r, e;
  try {
    r = av.getDocumentOrThrow(), e = av.getLocationOrThrow();
  } catch {
    return null;
  }
  function t() {
    const h = r.getElementsByTagName("link"), d = [];
    for (let f = 0; f < h.length; f++) {
      const g = h[f], p = g.getAttribute("rel");
      if (p && p.toLowerCase().indexOf("icon") > -1) {
        const w = g.getAttribute("href");
        if (w)
          if (w.toLowerCase().indexOf("https:") === -1 && w.toLowerCase().indexOf("http:") === -1 && w.indexOf("//") !== 0) {
            let E = e.protocol + "//" + e.host;
            if (w.indexOf("/") === 0)
              E += w;
            else {
              const I = e.pathname.split("/");
              I.pop();
              const A = I.join("/");
              E += A + "/" + w;
            }
            d.push(E);
          } else if (w.indexOf("//") === 0) {
            const E = e.protocol + w;
            d.push(E);
          } else
            d.push(w);
      }
    }
    return d;
  }
  function n(...h) {
    const d = r.getElementsByTagName("meta");
    for (let f = 0; f < d.length; f++) {
      const g = d[f], p = ["itemprop", "property", "name"].map((w) => g.getAttribute(w)).filter((w) => w ? h.includes(w) : !1);
      if (p.length && p) {
        const w = g.getAttribute("content");
        if (w)
          return w;
      }
    }
    return "";
  }
  function s() {
    let h = n("name", "og:site_name", "og:title", "twitter:title");
    return h || (h = r.title), h;
  }
  function i() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const o = s(), a = i(), c = e.origin, l = t();
  return {
    description: a,
    url: c,
    icons: l,
    name: o
  };
}
sI = Y0.getWindowMetadata = vU;
function vd(r, { strict: e = !0 } = {}) {
  return !r || typeof r != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(r) : r.startsWith("0x");
}
function ay(r) {
  return vd(r, { strict: !1 }) ? Math.ceil((r.length - 2) / 2) : r.length;
}
const iI = "2.30.6";
let nh = {
  getDocsUrl: ({ docsBaseUrl: r, docsPath: e = "", docsSlug: t }) => e ? `${r ?? "https://viem.sh"}${e}${t ? `#${t}` : ""}` : void 0,
  version: `viem@${iI}`
};
class hc extends Error {
  constructor(e, t = {}) {
    var a;
    const n = (() => {
      var c;
      return t.cause instanceof hc ? t.cause.details : (c = t.cause) != null && c.message ? t.cause.message : t.details;
    })(), s = t.cause instanceof hc && t.cause.docsPath || t.docsPath, i = (a = nh.getDocsUrl) == null ? void 0 : a.call(nh, { ...t, docsPath: s }), o = [
      e || "An error occurred.",
      "",
      ...t.metaMessages ? [...t.metaMessages, ""] : [],
      ...i ? [`Docs: ${i}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...nh.version ? [`Version: ${nh.version}`] : []
    ].join(`
`);
    super(o, t.cause ? { cause: t.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = s, this.metaMessages = t.metaMessages, this.name = t.name ?? this.name, this.shortMessage = e, this.version = iI;
  }
  walk(e) {
    return oI(this, e);
  }
}
function oI(r, e) {
  return e != null && e(r) ? r : r && typeof r == "object" && "cause" in r && r.cause !== void 0 ? oI(r.cause, e) : e ? null : r;
}
class aI extends hc {
  constructor({ size: e, targetSize: t, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function ju(r, { dir: e, size: t = 32 } = {}) {
  return typeof r == "string" ? AU(r, { dir: e, size: t }) : CU(r, { dir: e, size: t });
}
function AU(r, { dir: e, size: t = 32 } = {}) {
  if (t === null)
    return r;
  const n = r.replace("0x", "");
  if (n.length > t * 2)
    throw new aI({
      size: Math.ceil(n.length / 2),
      targetSize: t,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](t * 2, "0")}`;
}
function CU(r, { dir: e, size: t = 32 } = {}) {
  if (t === null)
    return r;
  if (r.length > t)
    throw new aI({
      size: r.length,
      targetSize: t,
      type: "bytes"
    });
  const n = new Uint8Array(t);
  for (let s = 0; s < t; s++) {
    const i = e === "right";
    n[i ? s : t - s - 1] = r[i ? s : r.length - s - 1];
  }
  return n;
}
class _U extends hc {
  constructor({ max: e, min: t, signed: n, size: s, value: i }) {
    super(`Number "${i}" is not in safe ${s ? `${s * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class IU extends hc {
  constructor({ givenSize: e, maxSize: t }) {
    super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function Hu(r, { size: e }) {
  if (ay(r) > e)
    throw new IU({
      givenSize: ay(r),
      maxSize: e
    });
}
function cy(r, e = {}) {
  const { signed: t } = e;
  e.size && Hu(r, { size: e.size });
  const n = BigInt(r);
  if (!t)
    return n;
  const s = (r.length - 2) / 2, i = (1n << BigInt(s) * 8n - 1n) - 1n;
  return n <= i ? n : n - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
}
function SU(r, e = {}) {
  return Number(cy(r, e));
}
const NU = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function ly(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? lI(r, e) : typeof r == "string" ? OU(r, e) : typeof r == "boolean" ? TU(r, e) : cI(r, e);
}
function TU(r, e = {}) {
  const t = `0x${Number(r)}`;
  return typeof e.size == "number" ? (Hu(t, { size: e.size }), ju(t, { size: e.size })) : t;
}
function cI(r, e = {}) {
  let t = "";
  for (let s = 0; s < r.length; s++)
    t += NU[r[s]];
  const n = `0x${t}`;
  return typeof e.size == "number" ? (Hu(n, { size: e.size }), ju(n, { dir: "right", size: e.size })) : n;
}
function lI(r, e = {}) {
  const { signed: t, size: n } = e, s = BigInt(r);
  let i;
  n ? t ? i = (1n << BigInt(n) * 8n - 1n) - 1n : i = 2n ** (BigInt(n) * 8n) - 1n : typeof r == "number" && (i = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof i == "bigint" && t ? -i - 1n : 0;
  if (i && s > i || s < o) {
    const c = typeof r == "bigint" ? "n" : "";
    throw new _U({
      max: i ? `${i}${c}` : void 0,
      min: `${o}${c}`,
      signed: t,
      size: n,
      value: `${r}${c}`
    });
  }
  const a = `0x${(t && s < 0 ? (1n << BigInt(n * 8)) + BigInt(s) : s).toString(16)}`;
  return n ? ju(a, { size: n }) : a;
}
const xU = /* @__PURE__ */ new TextEncoder();
function OU(r, e = {}) {
  const t = xU.encode(r);
  return cI(t, e);
}
const PU = /* @__PURE__ */ new TextEncoder();
function RU(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? kU(r, e) : typeof r == "boolean" ? DU(r, e) : vd(r) ? uI(r, e) : hI(r, e);
}
function DU(r, e = {}) {
  const t = new Uint8Array(1);
  return t[0] = Number(r), typeof e.size == "number" ? (Hu(t, { size: e.size }), ju(t, { size: e.size })) : t;
}
const ai = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function cv(r) {
  if (r >= ai.zero && r <= ai.nine)
    return r - ai.zero;
  if (r >= ai.A && r <= ai.F)
    return r - (ai.A - 10);
  if (r >= ai.a && r <= ai.f)
    return r - (ai.a - 10);
}
function uI(r, e = {}) {
  let t = r;
  e.size && (Hu(t, { size: e.size }), t = ju(t, { dir: "right", size: e.size }));
  let n = t.slice(2);
  n.length % 2 && (n = `0${n}`);
  const s = n.length / 2, i = new Uint8Array(s);
  for (let o = 0, a = 0; o < s; o++) {
    const c = cv(n.charCodeAt(a++)), l = cv(n.charCodeAt(a++));
    if (c === void 0 || l === void 0)
      throw new hc(`Invalid byte sequence ("${n[a - 2]}${n[a - 1]}" in "${n}").`);
    i[o] = c * 16 + l;
  }
  return i;
}
function kU(r, e) {
  const t = lI(r, e);
  return uI(t);
}
function hI(r, e = {}) {
  const t = PU.encode(r);
  return typeof e.size == "number" ? (Hu(t, { size: e.size }), ju(t, { dir: "right", size: e.size })) : t;
}
function dI(r, e) {
  const t = e || "hex", n = c_(vd(r, { strict: !1 }) ? RU(r) : r);
  return t === "bytes" ? n : ly(n);
}
class UU extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const t = super.get(e);
    return super.has(e) && t !== void 0 && (this.delete(e), super.set(e, t)), t;
  }
  set(e, t) {
    if (super.set(e, t), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const Vm = /* @__PURE__ */ new UU(8192);
function BU(r, e) {
  if (Vm.has(`${r}.${e}`))
    return Vm.get(`${r}.${e}`);
  const t = r.substring(2).toLowerCase(), n = dI(hI(t), "bytes"), s = t.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && s[o + 1] && (s[o + 1] = s[o + 1].toUpperCase());
  const i = `0x${s.join("")}`;
  return Vm.set(`${r}.${e}`, i), i;
}
function LU(r) {
  const e = dI(`0x${r.substring(4)}`).substring(26);
  return BU(`0x${e}`);
}
async function FU({ hash: r, signature: e }) {
  const t = vd(r) ? r : ly(r), { secp256k1: n } = await import("./secp256k1-BlF_m7He.mjs");
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: l, s: u, v: h, yParity: d } = e, f = Number(d ?? h), g = lv(f);
      return new n.Signature(cy(l), cy(u)).addRecoveryBit(g);
    }
    const o = vd(e) ? e : ly(e);
    if (ay(o) !== 65)
      throw new Error("invalid signature length");
    const a = SU(`0x${o.slice(130)}`), c = lv(a);
    return n.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(c);
  })().recoverPublicKey(t.substring(2)).toHex(!1)}`;
}
function lv(r) {
  if (r === 0 || r === 1)
    return r;
  if (r === 27)
    return 0;
  if (r === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function $U({ hash: r, signature: e }) {
  return LU(await FU({ hash: r, signature: e }));
}
function MU(r) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  const e = new Uint8Array(256);
  for (let l = 0; l < e.length; l++)
    e[l] = 255;
  for (let l = 0; l < r.length; l++) {
    const u = r.charAt(l), h = u.charCodeAt(0);
    if (e[h] !== 255)
      throw new TypeError(u + " is ambiguous");
    e[h] = l;
  }
  const t = r.length, n = r.charAt(0), s = Math.log(t) / Math.log(256), i = Math.log(256) / Math.log(t);
  function o(l) {
    if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (l.length === 0)
      return "";
    let u = 0, h = 0, d = 0;
    const f = l.length;
    for (; d !== f && l[d] === 0; )
      d++, u++;
    const g = (f - d) * i + 1 >>> 0, p = new Uint8Array(g);
    for (; d !== f; ) {
      let I = l[d], A = 0;
      for (let C = g - 1; (I !== 0 || A < h) && C !== -1; C--, A++)
        I += 256 * p[C] >>> 0, p[C] = I % t >>> 0, I = I / t >>> 0;
      if (I !== 0)
        throw new Error("Non-zero carry");
      h = A, d++;
    }
    let w = g - h;
    for (; w !== g && p[w] === 0; )
      w++;
    let E = n.repeat(u);
    for (; w < g; ++w)
      E += r.charAt(p[w]);
    return E;
  }
  function a(l) {
    if (typeof l != "string")
      throw new TypeError("Expected String");
    if (l.length === 0)
      return new Uint8Array();
    let u = 0, h = 0, d = 0;
    for (; l[u] === n; )
      h++, u++;
    const f = (l.length - u) * s + 1 >>> 0, g = new Uint8Array(f);
    for (; u < l.length; ) {
      const I = l.charCodeAt(u);
      if (I > 255)
        return;
      let A = e[I];
      if (A === 255)
        return;
      let C = 0;
      for (let N = f - 1; (A !== 0 || C < d) && N !== -1; N--, C++)
        A += t * g[N] >>> 0, g[N] = A % 256 >>> 0, A = A / 256 >>> 0;
      if (A !== 0)
        throw new Error("Non-zero carry");
      d = C, u++;
    }
    let p = f - d;
    for (; p !== f && g[p] === 0; )
      p++;
    const w = new Uint8Array(h + (f - p));
    let E = h;
    for (; p !== f; )
      w[E++] = g[p++];
    return w;
  }
  function c(l) {
    const u = a(l);
    if (u)
      return u;
    throw new Error("Non-base" + t + " character");
  }
  return {
    encode: o,
    decodeUnsafe: a,
    decode: c
  };
}
var jU = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const zu = MU(jU);
function HU(r) {
  const e = r.length;
  let t = 0, n = 0;
  for (; n < e; ) {
    let s = r.charCodeAt(n++);
    if (s & 4294967168)
      if (!(s & 4294965248))
        t += 2;
      else {
        if (s >= 55296 && s <= 56319 && n < e) {
          const i = r.charCodeAt(n);
          (i & 64512) === 56320 && (++n, s = ((s & 1023) << 10) + (i & 1023) + 65536);
        }
        s & 4294901760 ? t += 4 : t += 3;
      }
    else {
      t++;
      continue;
    }
  }
  return t;
}
function zU(r, e, t) {
  const n = r.length;
  let s = t, i = 0;
  for (; i < n; ) {
    let o = r.charCodeAt(i++);
    if (o & 4294967168)
      if (!(o & 4294965248))
        e[s++] = o >> 6 & 31 | 192;
      else {
        if (o >= 55296 && o <= 56319 && i < n) {
          const a = r.charCodeAt(i);
          (a & 64512) === 56320 && (++i, o = ((o & 1023) << 10) + (a & 1023) + 65536);
        }
        o & 4294901760 ? (e[s++] = o >> 18 & 7 | 240, e[s++] = o >> 12 & 63 | 128, e[s++] = o >> 6 & 63 | 128) : (e[s++] = o >> 12 & 15 | 224, e[s++] = o >> 6 & 63 | 128);
      }
    else {
      e[s++] = o;
      continue;
    }
    e[s++] = o & 63 | 128;
  }
}
const qU = new TextEncoder(), WU = 50;
function VU(r, e, t) {
  qU.encodeInto(r, e.subarray(t));
}
function GU(r, e, t) {
  r.length > WU ? VU(r, e, t) : zU(r, e, t);
}
const KU = 4096;
function fI(r, e, t) {
  let n = e;
  const s = n + t, i = [];
  let o = "";
  for (; n < s; ) {
    const a = r[n++];
    if (!(a & 128))
      i.push(a);
    else if ((a & 224) === 192) {
      const c = r[n++] & 63;
      i.push((a & 31) << 6 | c);
    } else if ((a & 240) === 224) {
      const c = r[n++] & 63, l = r[n++] & 63;
      i.push((a & 31) << 12 | c << 6 | l);
    } else if ((a & 248) === 240) {
      const c = r[n++] & 63, l = r[n++] & 63, u = r[n++] & 63;
      let h = (a & 7) << 18 | c << 12 | l << 6 | u;
      h > 65535 && (h -= 65536, i.push(h >>> 10 & 1023 | 55296), h = 56320 | h & 1023), i.push(h);
    } else
      i.push(a);
    i.length >= KU && (o += String.fromCharCode(...i), i.length = 0);
  }
  return i.length > 0 && (o += String.fromCharCode(...i)), o;
}
const JU = new TextDecoder(), YU = 200;
function QU(r, e, t) {
  const n = r.subarray(e, e + t);
  return JU.decode(n);
}
function ZU(r, e, t) {
  return t > YU ? QU(r, e, t) : fI(r, e, t);
}
class Qf {
  constructor(e, t) {
    this.type = e, this.data = t;
  }
}
class An extends Error {
  constructor(e) {
    super(e);
    const t = Object.create(An.prototype);
    Object.setPrototypeOf(this, t), Object.defineProperty(this, "name", {
      configurable: !0,
      enumerable: !1,
      value: An.name
    });
  }
}
const sh = 4294967295;
function XU(r, e, t) {
  const n = t / 4294967296, s = t;
  r.setUint32(e, n), r.setUint32(e + 4, s);
}
function pI(r, e, t) {
  const n = Math.floor(t / 4294967296), s = t;
  r.setUint32(e, n), r.setUint32(e + 4, s);
}
function gI(r, e) {
  const t = r.getInt32(e), n = r.getUint32(e + 4);
  return t * 4294967296 + n;
}
function e8(r, e) {
  const t = r.getUint32(e), n = r.getUint32(e + 4);
  return t * 4294967296 + n;
}
const t8 = -1, r8 = 4294967296 - 1, n8 = 17179869184 - 1;
function s8({ sec: r, nsec: e }) {
  if (r >= 0 && e >= 0 && r <= n8)
    if (e === 0 && r <= r8) {
      const t = new Uint8Array(4);
      return new DataView(t.buffer).setUint32(0, r), t;
    } else {
      const t = r / 4294967296, n = r & 4294967295, s = new Uint8Array(8), i = new DataView(s.buffer);
      return i.setUint32(0, e << 2 | t & 3), i.setUint32(4, n), s;
    }
  else {
    const t = new Uint8Array(12), n = new DataView(t.buffer);
    return n.setUint32(0, e), pI(n, 4, r), t;
  }
}
function i8(r) {
  const e = r.getTime(), t = Math.floor(e / 1e3), n = (e - t * 1e3) * 1e6, s = Math.floor(n / 1e9);
  return {
    sec: t + s,
    nsec: n - s * 1e9
  };
}
function o8(r) {
  if (r instanceof Date) {
    const e = i8(r);
    return s8(e);
  } else
    return null;
}
function a8(r) {
  const e = new DataView(r.buffer, r.byteOffset, r.byteLength);
  switch (r.byteLength) {
    case 4:
      return { sec: e.getUint32(0), nsec: 0 };
    case 8: {
      const t = e.getUint32(0), n = e.getUint32(4), s = (t & 3) * 4294967296 + n, i = t >>> 2;
      return { sec: s, nsec: i };
    }
    case 12: {
      const t = gI(e, 4), n = e.getUint32(0);
      return { sec: t, nsec: n };
    }
    default:
      throw new An(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${r.length}`);
  }
}
function c8(r) {
  const e = a8(r);
  return new Date(e.sec * 1e3 + e.nsec / 1e6);
}
const l8 = {
  type: t8,
  encode: o8,
  decode: c8
};
class Zp {
  constructor() {
    this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(l8);
  }
  register({ type: e, encode: t, decode: n }) {
    if (e >= 0)
      this.encoders[e] = t, this.decoders[e] = n;
    else {
      const s = -1 - e;
      this.builtInEncoders[s] = t, this.builtInDecoders[s] = n;
    }
  }
  tryToEncode(e, t) {
    for (let n = 0; n < this.builtInEncoders.length; n++) {
      const s = this.builtInEncoders[n];
      if (s != null) {
        const i = s(e, t);
        if (i != null) {
          const o = -1 - n;
          return new Qf(o, i);
        }
      }
    }
    for (let n = 0; n < this.encoders.length; n++) {
      const s = this.encoders[n];
      if (s != null) {
        const i = s(e, t);
        if (i != null) {
          const o = n;
          return new Qf(o, i);
        }
      }
    }
    return e instanceof Qf ? e : null;
  }
  decode(e, t, n) {
    const s = t < 0 ? this.builtInDecoders[-1 - t] : this.decoders[t];
    return s ? s(e, t, n) : new Qf(t, e);
  }
}
Zp.defaultCodec = new Zp();
function u8(r) {
  return r instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && r instanceof SharedArrayBuffer;
}
function uy(r) {
  return r instanceof Uint8Array ? r : ArrayBuffer.isView(r) ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : u8(r) ? new Uint8Array(r) : Uint8Array.from(r);
}
const h8 = 100, d8 = 2048;
let f8 = class mI {
  constructor(e) {
    this.entered = !1, this.extensionCodec = (e == null ? void 0 : e.extensionCodec) ?? Zp.defaultCodec, this.context = e == null ? void 0 : e.context, this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ?? !1, this.maxDepth = (e == null ? void 0 : e.maxDepth) ?? h8, this.initialBufferSize = (e == null ? void 0 : e.initialBufferSize) ?? d8, this.sortKeys = (e == null ? void 0 : e.sortKeys) ?? !1, this.forceFloat32 = (e == null ? void 0 : e.forceFloat32) ?? !1, this.ignoreUndefined = (e == null ? void 0 : e.ignoreUndefined) ?? !1, this.forceIntegerToFloat = (e == null ? void 0 : e.forceIntegerToFloat) ?? !1, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
  }
  clone() {
    return new mI({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      maxDepth: this.maxDepth,
      initialBufferSize: this.initialBufferSize,
      sortKeys: this.sortKeys,
      forceFloat32: this.forceFloat32,
      ignoreUndefined: this.ignoreUndefined,
      forceIntegerToFloat: this.forceIntegerToFloat
    });
  }
  reinitializeState() {
    this.pos = 0;
  }
  /**
   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
   *
   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
   */
  encodeSharedRef(e) {
    if (this.entered)
      return this.clone().encodeSharedRef(e);
    try {
      return this.entered = !0, this.reinitializeState(), this.doEncode(e, 1), this.bytes.subarray(0, this.pos);
    } finally {
      this.entered = !1;
    }
  }
  /**
   * @returns Encodes the object and returns a copy of the encoder's internal buffer.
   */
  encode(e) {
    if (this.entered)
      return this.clone().encode(e);
    try {
      return this.entered = !0, this.reinitializeState(), this.doEncode(e, 1), this.bytes.slice(0, this.pos);
    } finally {
      this.entered = !1;
    }
  }
  doEncode(e, t) {
    if (t > this.maxDepth)
      throw new Error(`Too deep objects in depth ${t}`);
    e == null ? this.encodeNil() : typeof e == "boolean" ? this.encodeBoolean(e) : typeof e == "number" ? this.forceIntegerToFloat ? this.encodeNumberAsFloat(e) : this.encodeNumber(e) : typeof e == "string" ? this.encodeString(e) : this.useBigInt64 && typeof e == "bigint" ? this.encodeBigInt64(e) : this.encodeObject(e, t);
  }
  ensureBufferSizeToWrite(e) {
    const t = this.pos + e;
    this.view.byteLength < t && this.resizeBuffer(t * 2);
  }
  resizeBuffer(e) {
    const t = new ArrayBuffer(e), n = new Uint8Array(t), s = new DataView(t);
    n.set(this.bytes), this.view = s, this.bytes = n;
  }
  encodeNil() {
    this.writeU8(192);
  }
  encodeBoolean(e) {
    e === !1 ? this.writeU8(194) : this.writeU8(195);
  }
  encodeNumber(e) {
    !this.forceIntegerToFloat && Number.isSafeInteger(e) ? e >= 0 ? e < 128 ? this.writeU8(e) : e < 256 ? (this.writeU8(204), this.writeU8(e)) : e < 65536 ? (this.writeU8(205), this.writeU16(e)) : e < 4294967296 ? (this.writeU8(206), this.writeU32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(207), this.writeU64(e)) : e >= -32 ? this.writeU8(224 | e + 32) : e >= -128 ? (this.writeU8(208), this.writeI8(e)) : e >= -32768 ? (this.writeU8(209), this.writeI16(e)) : e >= -2147483648 ? (this.writeU8(210), this.writeI32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(211), this.writeI64(e)) : this.encodeNumberAsFloat(e);
  }
  encodeNumberAsFloat(e) {
    this.forceFloat32 ? (this.writeU8(202), this.writeF32(e)) : (this.writeU8(203), this.writeF64(e));
  }
  encodeBigInt64(e) {
    e >= BigInt(0) ? (this.writeU8(207), this.writeBigUint64(e)) : (this.writeU8(211), this.writeBigInt64(e));
  }
  writeStringHeader(e) {
    if (e < 32)
      this.writeU8(160 + e);
    else if (e < 256)
      this.writeU8(217), this.writeU8(e);
    else if (e < 65536)
      this.writeU8(218), this.writeU16(e);
    else if (e < 4294967296)
      this.writeU8(219), this.writeU32(e);
    else
      throw new Error(`Too long string: ${e} bytes in UTF-8`);
  }
  encodeString(e) {
    const n = HU(e);
    this.ensureBufferSizeToWrite(5 + n), this.writeStringHeader(n), GU(e, this.bytes, this.pos), this.pos += n;
  }
  encodeObject(e, t) {
    const n = this.extensionCodec.tryToEncode(e, this.context);
    if (n != null)
      this.encodeExtension(n);
    else if (Array.isArray(e))
      this.encodeArray(e, t);
    else if (ArrayBuffer.isView(e))
      this.encodeBinary(e);
    else if (typeof e == "object")
      this.encodeMap(e, t);
    else
      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(e)}`);
  }
  encodeBinary(e) {
    const t = e.byteLength;
    if (t < 256)
      this.writeU8(196), this.writeU8(t);
    else if (t < 65536)
      this.writeU8(197), this.writeU16(t);
    else if (t < 4294967296)
      this.writeU8(198), this.writeU32(t);
    else
      throw new Error(`Too large binary: ${t}`);
    const n = uy(e);
    this.writeU8a(n);
  }
  encodeArray(e, t) {
    const n = e.length;
    if (n < 16)
      this.writeU8(144 + n);
    else if (n < 65536)
      this.writeU8(220), this.writeU16(n);
    else if (n < 4294967296)
      this.writeU8(221), this.writeU32(n);
    else
      throw new Error(`Too large array: ${n}`);
    for (const s of e)
      this.doEncode(s, t + 1);
  }
  countWithoutUndefined(e, t) {
    let n = 0;
    for (const s of t)
      e[s] !== void 0 && n++;
    return n;
  }
  encodeMap(e, t) {
    const n = Object.keys(e);
    this.sortKeys && n.sort();
    const s = this.ignoreUndefined ? this.countWithoutUndefined(e, n) : n.length;
    if (s < 16)
      this.writeU8(128 + s);
    else if (s < 65536)
      this.writeU8(222), this.writeU16(s);
    else if (s < 4294967296)
      this.writeU8(223), this.writeU32(s);
    else
      throw new Error(`Too large map object: ${s}`);
    for (const i of n) {
      const o = e[i];
      this.ignoreUndefined && o === void 0 || (this.encodeString(i), this.doEncode(o, t + 1));
    }
  }
  encodeExtension(e) {
    if (typeof e.data == "function") {
      const n = e.data(this.pos + 6), s = n.length;
      if (s >= 4294967296)
        throw new Error(`Too large extension object: ${s}`);
      this.writeU8(201), this.writeU32(s), this.writeI8(e.type), this.writeU8a(n);
      return;
    }
    const t = e.data.length;
    if (t === 1)
      this.writeU8(212);
    else if (t === 2)
      this.writeU8(213);
    else if (t === 4)
      this.writeU8(214);
    else if (t === 8)
      this.writeU8(215);
    else if (t === 16)
      this.writeU8(216);
    else if (t < 256)
      this.writeU8(199), this.writeU8(t);
    else if (t < 65536)
      this.writeU8(200), this.writeU16(t);
    else if (t < 4294967296)
      this.writeU8(201), this.writeU32(t);
    else
      throw new Error(`Too large extension object: ${t}`);
    this.writeI8(e.type), this.writeU8a(e.data);
  }
  writeU8(e) {
    this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, e), this.pos++;
  }
  writeU8a(e) {
    const t = e.length;
    this.ensureBufferSizeToWrite(t), this.bytes.set(e, this.pos), this.pos += t;
  }
  writeI8(e) {
    this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, e), this.pos++;
  }
  writeU16(e) {
    this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, e), this.pos += 2;
  }
  writeI16(e) {
    this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, e), this.pos += 2;
  }
  writeU32(e) {
    this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, e), this.pos += 4;
  }
  writeI32(e) {
    this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, e), this.pos += 4;
  }
  writeF32(e) {
    this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, e), this.pos += 4;
  }
  writeF64(e) {
    this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, e), this.pos += 8;
  }
  writeU64(e) {
    this.ensureBufferSizeToWrite(8), XU(this.view, this.pos, e), this.pos += 8;
  }
  writeI64(e) {
    this.ensureBufferSizeToWrite(8), pI(this.view, this.pos, e), this.pos += 8;
  }
  writeBigUint64(e) {
    this.ensureBufferSizeToWrite(8), this.view.setBigUint64(this.pos, e), this.pos += 8;
  }
  writeBigInt64(e) {
    this.ensureBufferSizeToWrite(8), this.view.setBigInt64(this.pos, e), this.pos += 8;
  }
};
function p8(r, e) {
  return new f8(e).encodeSharedRef(r);
}
function Gm(r) {
  return `${r < 0 ? "-" : ""}0x${Math.abs(r).toString(16).padStart(2, "0")}`;
}
const g8 = 16, m8 = 16;
class w8 {
  constructor(e = g8, t = m8) {
    this.hit = 0, this.miss = 0, this.maxKeyLength = e, this.maxLengthPerKey = t, this.caches = [];
    for (let n = 0; n < this.maxKeyLength; n++)
      this.caches.push([]);
  }
  canBeCached(e) {
    return e > 0 && e <= this.maxKeyLength;
  }
  find(e, t, n) {
    const s = this.caches[n - 1];
    e: for (const i of s) {
      const o = i.bytes;
      for (let a = 0; a < n; a++)
        if (o[a] !== e[t + a])
          continue e;
      return i.str;
    }
    return null;
  }
  store(e, t) {
    const n = this.caches[e.length - 1], s = { bytes: e, str: t };
    n.length >= this.maxLengthPerKey ? n[Math.random() * n.length | 0] = s : n.push(s);
  }
  decode(e, t, n) {
    const s = this.find(e, t, n);
    if (s != null)
      return this.hit++, s;
    this.miss++;
    const i = fI(e, t, n), o = Uint8Array.prototype.slice.call(e, t, t + n);
    return this.store(o, i), i;
  }
}
const hy = "array", Bh = "map_key", wI = "map_value", y8 = (r) => {
  if (typeof r == "string" || typeof r == "number")
    return r;
  throw new An("The type of key must be string or number but " + typeof r);
};
class b8 {
  constructor() {
    this.stack = [], this.stackHeadPosition = -1;
  }
  get length() {
    return this.stackHeadPosition + 1;
  }
  top() {
    return this.stack[this.stackHeadPosition];
  }
  pushArrayState(e) {
    const t = this.getUninitializedStateFromPool();
    t.type = hy, t.position = 0, t.size = e, t.array = new Array(e);
  }
  pushMapState(e) {
    const t = this.getUninitializedStateFromPool();
    t.type = Bh, t.readCount = 0, t.size = e, t.map = {};
  }
  getUninitializedStateFromPool() {
    if (this.stackHeadPosition++, this.stackHeadPosition === this.stack.length) {
      const e = {
        type: void 0,
        size: 0,
        array: void 0,
        position: 0,
        readCount: 0,
        map: void 0,
        key: null
      };
      this.stack.push(e);
    }
    return this.stack[this.stackHeadPosition];
  }
  release(e) {
    if (this.stack[this.stackHeadPosition] !== e)
      throw new Error("Invalid stack state. Released state is not on top of the stack.");
    if (e.type === hy) {
      const n = e;
      n.size = 0, n.array = void 0, n.position = 0, n.type = void 0;
    }
    if (e.type === Bh || e.type === wI) {
      const n = e;
      n.size = 0, n.map = void 0, n.readCount = 0, n.type = void 0;
    }
    this.stackHeadPosition--;
  }
  reset() {
    this.stack.length = 0, this.stackHeadPosition = -1;
  }
}
const ih = -1, Q0 = new DataView(new ArrayBuffer(0)), E8 = new Uint8Array(Q0.buffer);
try {
  Q0.getInt8(0);
} catch (r) {
  if (!(r instanceof RangeError))
    throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
}
const uv = new RangeError("Insufficient data"), v8 = new w8();
let A8 = class yI {
  constructor(e) {
    this.totalPos = 0, this.pos = 0, this.view = Q0, this.bytes = E8, this.headByte = ih, this.stack = new b8(), this.entered = !1, this.extensionCodec = (e == null ? void 0 : e.extensionCodec) ?? Zp.defaultCodec, this.context = e == null ? void 0 : e.context, this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ?? !1, this.rawStrings = (e == null ? void 0 : e.rawStrings) ?? !1, this.maxStrLength = (e == null ? void 0 : e.maxStrLength) ?? sh, this.maxBinLength = (e == null ? void 0 : e.maxBinLength) ?? sh, this.maxArrayLength = (e == null ? void 0 : e.maxArrayLength) ?? sh, this.maxMapLength = (e == null ? void 0 : e.maxMapLength) ?? sh, this.maxExtLength = (e == null ? void 0 : e.maxExtLength) ?? sh, this.keyDecoder = (e == null ? void 0 : e.keyDecoder) !== void 0 ? e.keyDecoder : v8, this.mapKeyConverter = (e == null ? void 0 : e.mapKeyConverter) ?? y8;
  }
  clone() {
    return new yI({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      rawStrings: this.rawStrings,
      maxStrLength: this.maxStrLength,
      maxBinLength: this.maxBinLength,
      maxArrayLength: this.maxArrayLength,
      maxMapLength: this.maxMapLength,
      maxExtLength: this.maxExtLength,
      keyDecoder: this.keyDecoder
    });
  }
  reinitializeState() {
    this.totalPos = 0, this.headByte = ih, this.stack.reset();
  }
  setBuffer(e) {
    const t = uy(e);
    this.bytes = t, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength), this.pos = 0;
  }
  appendBuffer(e) {
    if (this.headByte === ih && !this.hasRemaining(1))
      this.setBuffer(e);
    else {
      const t = this.bytes.subarray(this.pos), n = uy(e), s = new Uint8Array(t.length + n.length);
      s.set(t), s.set(n, t.length), this.setBuffer(s);
    }
  }
  hasRemaining(e) {
    return this.view.byteLength - this.pos >= e;
  }
  createExtraByteError(e) {
    const { view: t, pos: n } = this;
    return new RangeError(`Extra ${t.byteLength - n} of ${t.byteLength} byte(s) found at buffer[${e}]`);
  }
  /**
   * @throws {@link DecodeError}
   * @throws {@link RangeError}
   */
  decode(e) {
    if (this.entered)
      return this.clone().decode(e);
    try {
      this.entered = !0, this.reinitializeState(), this.setBuffer(e);
      const t = this.doDecodeSync();
      if (this.hasRemaining(1))
        throw this.createExtraByteError(this.pos);
      return t;
    } finally {
      this.entered = !1;
    }
  }
  *decodeMulti(e) {
    if (this.entered) {
      yield* this.clone().decodeMulti(e);
      return;
    }
    try {
      for (this.entered = !0, this.reinitializeState(), this.setBuffer(e); this.hasRemaining(1); )
        yield this.doDecodeSync();
    } finally {
      this.entered = !1;
    }
  }
  async decodeAsync(e) {
    if (this.entered)
      return this.clone().decodeAsync(e);
    try {
      this.entered = !0;
      let t = !1, n;
      for await (const a of e) {
        if (t)
          throw this.entered = !1, this.createExtraByteError(this.totalPos);
        this.appendBuffer(a);
        try {
          n = this.doDecodeSync(), t = !0;
        } catch (c) {
          if (!(c instanceof RangeError))
            throw c;
        }
        this.totalPos += this.pos;
      }
      if (t) {
        if (this.hasRemaining(1))
          throw this.createExtraByteError(this.totalPos);
        return n;
      }
      const { headByte: s, pos: i, totalPos: o } = this;
      throw new RangeError(`Insufficient data in parsing ${Gm(s)} at ${o} (${i} in the current buffer)`);
    } finally {
      this.entered = !1;
    }
  }
  decodeArrayStream(e) {
    return this.decodeMultiAsync(e, !0);
  }
  decodeStream(e) {
    return this.decodeMultiAsync(e, !1);
  }
  async *decodeMultiAsync(e, t) {
    if (this.entered) {
      yield* this.clone().decodeMultiAsync(e, t);
      return;
    }
    try {
      this.entered = !0;
      let n = t, s = -1;
      for await (const i of e) {
        if (t && s === 0)
          throw this.createExtraByteError(this.totalPos);
        this.appendBuffer(i), n && (s = this.readArraySize(), n = !1, this.complete());
        try {
          for (; yield this.doDecodeSync(), --s !== 0; )
            ;
        } catch (o) {
          if (!(o instanceof RangeError))
            throw o;
        }
        this.totalPos += this.pos;
      }
    } finally {
      this.entered = !1;
    }
  }
  doDecodeSync() {
    e: for (; ; ) {
      const e = this.readHeadByte();
      let t;
      if (e >= 224)
        t = e - 256;
      else if (e < 192)
        if (e < 128)
          t = e;
        else if (e < 144) {
          const s = e - 128;
          if (s !== 0) {
            this.pushMapState(s), this.complete();
            continue e;
          } else
            t = {};
        } else if (e < 160) {
          const s = e - 144;
          if (s !== 0) {
            this.pushArrayState(s), this.complete();
            continue e;
          } else
            t = [];
        } else {
          const s = e - 160;
          t = this.decodeString(s, 0);
        }
      else if (e === 192)
        t = null;
      else if (e === 194)
        t = !1;
      else if (e === 195)
        t = !0;
      else if (e === 202)
        t = this.readF32();
      else if (e === 203)
        t = this.readF64();
      else if (e === 204)
        t = this.readU8();
      else if (e === 205)
        t = this.readU16();
      else if (e === 206)
        t = this.readU32();
      else if (e === 207)
        this.useBigInt64 ? t = this.readU64AsBigInt() : t = this.readU64();
      else if (e === 208)
        t = this.readI8();
      else if (e === 209)
        t = this.readI16();
      else if (e === 210)
        t = this.readI32();
      else if (e === 211)
        this.useBigInt64 ? t = this.readI64AsBigInt() : t = this.readI64();
      else if (e === 217) {
        const s = this.lookU8();
        t = this.decodeString(s, 1);
      } else if (e === 218) {
        const s = this.lookU16();
        t = this.decodeString(s, 2);
      } else if (e === 219) {
        const s = this.lookU32();
        t = this.decodeString(s, 4);
      } else if (e === 220) {
        const s = this.readU16();
        if (s !== 0) {
          this.pushArrayState(s), this.complete();
          continue e;
        } else
          t = [];
      } else if (e === 221) {
        const s = this.readU32();
        if (s !== 0) {
          this.pushArrayState(s), this.complete();
          continue e;
        } else
          t = [];
      } else if (e === 222) {
        const s = this.readU16();
        if (s !== 0) {
          this.pushMapState(s), this.complete();
          continue e;
        } else
          t = {};
      } else if (e === 223) {
        const s = this.readU32();
        if (s !== 0) {
          this.pushMapState(s), this.complete();
          continue e;
        } else
          t = {};
      } else if (e === 196) {
        const s = this.lookU8();
        t = this.decodeBinary(s, 1);
      } else if (e === 197) {
        const s = this.lookU16();
        t = this.decodeBinary(s, 2);
      } else if (e === 198) {
        const s = this.lookU32();
        t = this.decodeBinary(s, 4);
      } else if (e === 212)
        t = this.decodeExtension(1, 0);
      else if (e === 213)
        t = this.decodeExtension(2, 0);
      else if (e === 214)
        t = this.decodeExtension(4, 0);
      else if (e === 215)
        t = this.decodeExtension(8, 0);
      else if (e === 216)
        t = this.decodeExtension(16, 0);
      else if (e === 199) {
        const s = this.lookU8();
        t = this.decodeExtension(s, 1);
      } else if (e === 200) {
        const s = this.lookU16();
        t = this.decodeExtension(s, 2);
      } else if (e === 201) {
        const s = this.lookU32();
        t = this.decodeExtension(s, 4);
      } else
        throw new An(`Unrecognized type byte: ${Gm(e)}`);
      this.complete();
      const n = this.stack;
      for (; n.length > 0; ) {
        const s = n.top();
        if (s.type === hy)
          if (s.array[s.position] = t, s.position++, s.position === s.size)
            t = s.array, n.release(s);
          else
            continue e;
        else if (s.type === Bh) {
          if (t === "__proto__")
            throw new An("The key __proto__ is not allowed");
          s.key = this.mapKeyConverter(t), s.type = wI;
          continue e;
        } else if (s.map[s.key] = t, s.readCount++, s.readCount === s.size)
          t = s.map, n.release(s);
        else {
          s.key = null, s.type = Bh;
          continue e;
        }
      }
      return t;
    }
  }
  readHeadByte() {
    return this.headByte === ih && (this.headByte = this.readU8()), this.headByte;
  }
  complete() {
    this.headByte = ih;
  }
  readArraySize() {
    const e = this.readHeadByte();
    switch (e) {
      case 220:
        return this.readU16();
      case 221:
        return this.readU32();
      default: {
        if (e < 160)
          return e - 144;
        throw new An(`Unrecognized array type byte: ${Gm(e)}`);
      }
    }
  }
  pushMapState(e) {
    if (e > this.maxMapLength)
      throw new An(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);
    this.stack.pushMapState(e);
  }
  pushArrayState(e) {
    if (e > this.maxArrayLength)
      throw new An(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);
    this.stack.pushArrayState(e);
  }
  decodeString(e, t) {
    return !this.rawStrings || this.stateIsMapKey() ? this.decodeUtf8String(e, t) : this.decodeBinary(e, t);
  }
  /**
   * @throws {@link RangeError}
   */
  decodeUtf8String(e, t) {
    var i;
    if (e > this.maxStrLength)
      throw new An(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);
    if (this.bytes.byteLength < this.pos + t + e)
      throw uv;
    const n = this.pos + t;
    let s;
    return this.stateIsMapKey() && ((i = this.keyDecoder) != null && i.canBeCached(e)) ? s = this.keyDecoder.decode(this.bytes, n, e) : s = ZU(this.bytes, n, e), this.pos += t + e, s;
  }
  stateIsMapKey() {
    return this.stack.length > 0 ? this.stack.top().type === Bh : !1;
  }
  /**
   * @throws {@link RangeError}
   */
  decodeBinary(e, t) {
    if (e > this.maxBinLength)
      throw new An(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);
    if (!this.hasRemaining(e + t))
      throw uv;
    const n = this.pos + t, s = this.bytes.subarray(n, n + e);
    return this.pos += t + e, s;
  }
  decodeExtension(e, t) {
    if (e > this.maxExtLength)
      throw new An(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);
    const n = this.view.getInt8(this.pos + t), s = this.decodeBinary(
      e,
      t + 1
      /* extType */
    );
    return this.extensionCodec.decode(s, n, this.context);
  }
  lookU8() {
    return this.view.getUint8(this.pos);
  }
  lookU16() {
    return this.view.getUint16(this.pos);
  }
  lookU32() {
    return this.view.getUint32(this.pos);
  }
  readU8() {
    const e = this.view.getUint8(this.pos);
    return this.pos++, e;
  }
  readI8() {
    const e = this.view.getInt8(this.pos);
    return this.pos++, e;
  }
  readU16() {
    const e = this.view.getUint16(this.pos);
    return this.pos += 2, e;
  }
  readI16() {
    const e = this.view.getInt16(this.pos);
    return this.pos += 2, e;
  }
  readU32() {
    const e = this.view.getUint32(this.pos);
    return this.pos += 4, e;
  }
  readI32() {
    const e = this.view.getInt32(this.pos);
    return this.pos += 4, e;
  }
  readU64() {
    const e = e8(this.view, this.pos);
    return this.pos += 8, e;
  }
  readI64() {
    const e = gI(this.view, this.pos);
    return this.pos += 8, e;
  }
  readU64AsBigInt() {
    const e = this.view.getBigUint64(this.pos);
    return this.pos += 8, e;
  }
  readI64AsBigInt() {
    const e = this.view.getBigInt64(this.pos);
    return this.pos += 8, e;
  }
  readF32() {
    const e = this.view.getFloat32(this.pos);
    return this.pos += 4, e;
  }
  readF64() {
    const e = this.view.getFloat64(this.pos);
    return this.pos += 8, e;
  }
};
function C8(r, e) {
  return new A8(e).decode(r);
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function _8(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function bI(r, e) {
  return Array.isArray(e) ? e.length === 0 ? !0 : r ? e.every((t) => typeof t == "string") : e.every((t) => Number.isSafeInteger(t)) : !1;
}
function Xp(r, e) {
  if (typeof e != "string")
    throw new Error(`${r}: string expected`);
  return !0;
}
function Z0(r) {
  if (!Number.isSafeInteger(r))
    throw new Error(`invalid integer: ${r}`);
}
function dy(r) {
  if (!Array.isArray(r))
    throw new Error("array expected");
}
function eg(r, e) {
  if (!bI(!0, e))
    throw new Error(`${r}: array of strings expected`);
}
function I8(r, e) {
  if (!bI(!1, e))
    throw new Error(`${r}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function S8(...r) {
  const e = (i) => i, t = (i, o) => (a) => i(o(a)), n = r.map((i) => i.encode).reduceRight(t, e), s = r.map((i) => i.decode).reduce(t, e);
  return { encode: n, decode: s };
}
// @__NO_SIDE_EFFECTS__
function N8(r) {
  const e = typeof r == "string" ? r.split("") : r, t = e.length;
  eg("alphabet", e);
  const n = new Map(e.map((s, i) => [s, i]));
  return {
    encode: (s) => (dy(s), s.map((i) => {
      if (!Number.isSafeInteger(i) || i < 0 || i >= t)
        throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${r}`);
      return e[i];
    })),
    decode: (s) => (dy(s), s.map((i) => {
      Xp("alphabet.decode", i);
      const o = n.get(i);
      if (o === void 0)
        throw new Error(`Unknown letter: "${i}". Allowed: ${r}`);
      return o;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function T8(r = "") {
  return Xp("join", r), {
    encode: (e) => (eg("join.decode", e), e.join(r)),
    decode: (e) => (Xp("join.decode", e), e.split(r))
  };
}
// @__NO_SIDE_EFFECTS__
function x8(r, e = "=") {
  return Z0(r), Xp("padding", e), {
    encode(t) {
      for (eg("padding.encode", t); t.length * r % 8; )
        t.push(e);
      return t;
    },
    decode(t) {
      eg("padding.decode", t);
      let n = t.length;
      if (n * r % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; n > 0 && t[n - 1] === e; n--)
        if ((n - 1) * r % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      return t.slice(0, n);
    }
  };
}
const EI = (r, e) => e === 0 ? r : EI(e, r % e), tg = /* @__NO_SIDE_EFFECTS__ */ (r, e) => r + (e - EI(r, e)), Km = /* @__PURE__ */ (() => {
  let r = [];
  for (let e = 0; e < 40; e++)
    r.push(2 ** e);
  return r;
})();
function hv(r, e, t, n) {
  if (dy(r), e <= 0 || e > 32)
    throw new Error(`convertRadix2: wrong from=${e}`);
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong to=${t}`);
  if (/* @__PURE__ */ tg(e, t) > 32)
    throw new Error(`convertRadix2: carry overflow from=${e} to=${t} carryBits=${/* @__PURE__ */ tg(e, t)}`);
  let s = 0, i = 0;
  const o = Km[e], a = Km[t] - 1, c = [];
  for (const l of r) {
    if (Z0(l), l >= o)
      throw new Error(`convertRadix2: invalid data word=${l} from=${e}`);
    if (s = s << e | l, i + e > 32)
      throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);
    for (i += e; i >= t; i -= t)
      c.push((s >> i - t & a) >>> 0);
    const u = Km[i];
    if (u === void 0)
      throw new Error("invalid carry");
    s &= u - 1;
  }
  if (s = s << t - i & a, !n && i >= e)
    throw new Error("Excess padding");
  if (!n && s > 0)
    throw new Error(`Non-zero padding: ${s}`);
  return n && i > 0 && c.push(s >>> 0), c;
}
// @__NO_SIDE_EFFECTS__
function O8(r, e = !1) {
  if (Z0(r), r <= 0 || r > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ tg(8, r) > 32 || /* @__PURE__ */ tg(r, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (t) => {
      if (!_8(t))
        throw new Error("radix2.encode input should be Uint8Array");
      return hv(Array.from(t), 8, r, !e);
    },
    decode: (t) => (I8("radix2.decode", t), Uint8Array.from(hv(t, r, 8, e)))
  };
}
const P8 = /* @__PURE__ */ S8(/* @__PURE__ */ O8(5), /* @__PURE__ */ N8("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ x8(5), /* @__PURE__ */ T8(""));
function X0(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function vI(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? X0(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function Lh(r, e) {
  e || (e = r.reduce((s, i) => s + i.length, 0));
  const t = vI(e);
  let n = 0;
  for (const s of r)
    t.set(s, n), n += s.length;
  return X0(t);
}
function R8(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++)
    t[n] = 255;
  for (var s = 0; s < r.length; s++) {
    var i = r.charAt(s), o = i.charCodeAt(0);
    if (t[o] !== 255)
      throw new TypeError(i + " is ambiguous");
    t[o] = s;
  }
  var a = r.length, c = r.charAt(0), l = Math.log(a) / Math.log(256), u = Math.log(256) / Math.log(a);
  function h(g) {
    if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (g.length === 0)
      return "";
    for (var p = 0, w = 0, E = 0, I = g.length; E !== I && g[E] === 0; )
      E++, p++;
    for (var A = (I - E) * u + 1 >>> 0, C = new Uint8Array(A); E !== I; ) {
      for (var N = g[E], x = 0, O = A - 1; (N !== 0 || x < w) && O !== -1; O--, x++)
        N += 256 * C[O] >>> 0, C[O] = N % a >>> 0, N = N / a >>> 0;
      if (N !== 0)
        throw new Error("Non-zero carry");
      w = x, E++;
    }
    for (var k = A - w; k !== A && C[k] === 0; )
      k++;
    for (var P = c.repeat(p); k < A; ++k)
      P += r.charAt(C[k]);
    return P;
  }
  function d(g) {
    if (typeof g != "string")
      throw new TypeError("Expected String");
    if (g.length === 0)
      return new Uint8Array();
    var p = 0;
    if (g[p] !== " ") {
      for (var w = 0, E = 0; g[p] === c; )
        w++, p++;
      for (var I = (g.length - p) * l + 1 >>> 0, A = new Uint8Array(I); g[p]; ) {
        var C = t[g.charCodeAt(p)];
        if (C === 255)
          return;
        for (var N = 0, x = I - 1; (C !== 0 || N < E) && x !== -1; x--, N++)
          C += a * A[x] >>> 0, A[x] = C % 256 >>> 0, C = C / 256 >>> 0;
        if (C !== 0)
          throw new Error("Non-zero carry");
        E = N, p++;
      }
      if (g[p] !== " ") {
        for (var O = I - E; O !== I && A[O] === 0; )
          O++;
        for (var k = new Uint8Array(w + (I - O)), P = w; O !== I; )
          k[P++] = A[O++];
        return k;
      }
    }
  }
  function f(g) {
    var p = d(g);
    if (p)
      return p;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: h,
    decodeUnsafe: d,
    decode: f
  };
}
var D8 = R8, k8 = D8;
const U8 = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
}, B8 = (r) => new TextEncoder().encode(r), L8 = (r) => new TextDecoder().decode(r);
class F8 {
  constructor(e, t, n) {
    this.name = e, this.prefix = t, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class $8 {
  constructor(e, t, n) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return AI(this, e);
  }
}
class M8 {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return AI(this, e);
  }
  decode(e) {
    const t = e[0], n = this.decoders[t];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const AI = (r, e) => new M8({
  ...r.decoders || { [r.prefix]: r },
  ...e.decoders || { [e.prefix]: e }
});
class j8 {
  constructor(e, t, n, s) {
    this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new F8(e, t, n), this.decoder = new $8(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Gg = ({ name: r, prefix: e, encode: t, decode: n }) => new j8(r, e, t, n), Ef = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: n, decode: s } = k8(t, e);
  return Gg({
    prefix: r,
    name: e,
    encode: n,
    decode: (i) => U8(s(i))
  });
}, H8 = (r, e, t, n) => {
  const s = {};
  for (let u = 0; u < e.length; ++u)
    s[e[u]] = u;
  let i = r.length;
  for (; r[i - 1] === "="; )
    --i;
  const o = new Uint8Array(i * t / 8 | 0);
  let a = 0, c = 0, l = 0;
  for (let u = 0; u < i; ++u) {
    const h = s[r[u]];
    if (h === void 0)
      throw new SyntaxError(`Non-${n} character`);
    c = c << t | h, a += t, a >= 8 && (a -= 8, o[l++] = 255 & c >> a);
  }
  if (a >= t || 255 & c << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, z8 = (r, e, t) => {
  const n = e[e.length - 1] === "=", s = (1 << t) - 1;
  let i = "", o = 0, a = 0;
  for (let c = 0; c < r.length; ++c)
    for (a = a << 8 | r[c], o += 8; o > t; )
      o -= t, i += e[s & a >> o];
  if (o && (i += e[s & a << t - o]), n)
    for (; i.length * t & 7; )
      i += "=";
  return i;
}, gr = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => Gg({
  prefix: e,
  name: r,
  encode(s) {
    return z8(s, n, t);
  },
  decode(s) {
    return H8(s, n, t, r);
  }
}), q8 = Gg({
  prefix: "\0",
  name: "identity",
  encode: (r) => L8(r),
  decode: (r) => B8(r)
}), W8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: q8
}, Symbol.toStringTag, { value: "Module" })), V8 = gr({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), G8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: V8
}, Symbol.toStringTag, { value: "Module" })), K8 = gr({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), J8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: K8
}, Symbol.toStringTag, { value: "Module" })), Y8 = Ef({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), Q8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: Y8
}, Symbol.toStringTag, { value: "Module" })), Z8 = gr({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), X8 = gr({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), e5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: Z8,
  base16upper: X8
}, Symbol.toStringTag, { value: "Module" })), t5 = gr({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), r5 = gr({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), n5 = gr({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), s5 = gr({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), i5 = gr({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), o5 = gr({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), a5 = gr({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), c5 = gr({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), l5 = gr({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), u5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: t5,
  base32hex: i5,
  base32hexpad: a5,
  base32hexpadupper: c5,
  base32hexupper: o5,
  base32pad: n5,
  base32padupper: s5,
  base32upper: r5,
  base32z: l5
}, Symbol.toStringTag, { value: "Module" })), h5 = Ef({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), d5 = Ef({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), f5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: h5,
  base36upper: d5
}, Symbol.toStringTag, { value: "Module" })), p5 = Ef({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), g5 = Ef({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), m5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: p5,
  base58flickr: g5
}, Symbol.toStringTag, { value: "Module" })), w5 = gr({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), y5 = gr({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), b5 = gr({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), E5 = gr({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), v5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: w5,
  base64pad: y5,
  base64url: b5,
  base64urlpad: E5
}, Symbol.toStringTag, { value: "Module" })), CI = Array.from(""), A5 = CI.reduce((r, e, t) => (r[t] = e, r), []), C5 = CI.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function _5(r) {
  return r.reduce((e, t) => (e += A5[t], e), "");
}
function I5(r) {
  const e = [];
  for (const t of r) {
    const n = C5[t.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const S5 = Gg({
  prefix: "",
  name: "base256emoji",
  encode: _5,
  decode: I5
}), N5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: S5
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const dv = {
  ...W8,
  ...G8,
  ...J8,
  ...Q8,
  ...e5,
  ...u5,
  ...f5,
  ...m5,
  ...v5,
  ...N5
};
function _I(r, e, t, n) {
  return {
    name: r,
    prefix: e,
    encoder: {
      name: r,
      prefix: e,
      encode: t
    },
    decoder: { decode: n }
  };
}
const fv = _I("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1))), Jm = _I("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = vI(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
}), II = {
  utf8: fv,
  "utf-8": fv,
  hex: dv.base16,
  latin1: Jm,
  ascii: Jm,
  binary: Jm,
  ...dv
};
function qn(r, e = "utf8") {
  const t = II[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? X0(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
function cn(r, e = "utf8") {
  const t = II[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1);
}
const T5 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, x5 = "Input must be an string, Buffer or Uint8Array";
function O5(r) {
  let e;
  if (r instanceof Uint8Array)
    e = r;
  else if (typeof r == "string")
    e = new TextEncoder().encode(r);
  else
    throw new Error(x5);
  return e;
}
function P5(r) {
  return Array.prototype.map.call(r, function(e) {
    return (e < 16 ? "0" : "") + e.toString(16);
  }).join("");
}
function Zf(r) {
  return (4294967296 + r).toString(16).substring(1);
}
function R5(r, e, t) {
  let n = `
` + r + " = ";
  for (let s = 0; s < e.length; s += 2) {
    if (t === 32)
      n += Zf(e[s]).toUpperCase(), n += " ", n += Zf(e[s + 1]).toUpperCase();
    else if (t === 64)
      n += Zf(e[s + 1]).toUpperCase(), n += Zf(e[s]).toUpperCase();
    else throw new Error("Invalid size " + t);
    s % 6 === 4 ? n += `
` + new Array(r.length + 4).join(" ") : s < e.length - 2 && (n += " ");
  }
  console.log(n);
}
function D5(r, e, t) {
  let n = (/* @__PURE__ */ new Date()).getTime();
  const s = new Uint8Array(e);
  for (let o = 0; o < e; o++)
    s[o] = o % 256;
  const i = (/* @__PURE__ */ new Date()).getTime();
  console.log("Generated random input in " + (i - n) + "ms"), n = i;
  for (let o = 0; o < t; o++) {
    const a = r(s), c = (/* @__PURE__ */ new Date()).getTime(), l = c - n;
    n = c, console.log("Hashed in " + l + "ms: " + a.substring(0, 20) + "..."), console.log(
      Math.round(e / (1 << 20) / (l / 1e3) * 100) / 100 + " MB PER SECOND"
    );
  }
}
var SI = {
  normalizeInput: O5,
  toHex: P5,
  debugPrint: R5,
  testSpeed: D5
};
const Sp = SI;
function Xf(r, e, t) {
  const n = r[e] + r[t];
  let s = r[e + 1] + r[t + 1];
  n >= 4294967296 && s++, r[e] = n, r[e + 1] = s;
}
function pv(r, e, t, n) {
  let s = r[e] + t;
  t < 0 && (s += 4294967296);
  let i = r[e + 1] + n;
  s >= 4294967296 && i++, r[e] = s, r[e + 1] = i;
}
function NI(r, e) {
  return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24;
}
function Yi(r, e, t, n, s, i) {
  const o = Ch[s], a = Ch[s + 1], c = Ch[i], l = Ch[i + 1];
  Xf(Pe, r, e), pv(Pe, r, o, a);
  let u = Pe[n] ^ Pe[r], h = Pe[n + 1] ^ Pe[r + 1];
  Pe[n] = h, Pe[n + 1] = u, Xf(Pe, t, n), u = Pe[e] ^ Pe[t], h = Pe[e + 1] ^ Pe[t + 1], Pe[e] = u >>> 24 ^ h << 8, Pe[e + 1] = h >>> 24 ^ u << 8, Xf(Pe, r, e), pv(Pe, r, c, l), u = Pe[n] ^ Pe[r], h = Pe[n + 1] ^ Pe[r + 1], Pe[n] = u >>> 16 ^ h << 16, Pe[n + 1] = h >>> 16 ^ u << 16, Xf(Pe, t, n), u = Pe[e] ^ Pe[t], h = Pe[e + 1] ^ Pe[t + 1], Pe[e] = h >>> 31 ^ u << 1, Pe[e + 1] = u >>> 31 ^ h << 1;
}
const TI = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), k5 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
], wr = new Uint8Array(
  k5.map(function(r) {
    return r * 2;
  })
), Pe = new Uint32Array(32), Ch = new Uint32Array(32);
function xI(r, e) {
  let t = 0;
  for (t = 0; t < 16; t++)
    Pe[t] = r.h[t], Pe[t + 16] = TI[t];
  for (Pe[24] = Pe[24] ^ r.t, Pe[25] = Pe[25] ^ r.t / 4294967296, e && (Pe[28] = ~Pe[28], Pe[29] = ~Pe[29]), t = 0; t < 32; t++)
    Ch[t] = NI(r.b, 4 * t);
  for (t = 0; t < 12; t++)
    Yi(0, 8, 16, 24, wr[t * 16 + 0], wr[t * 16 + 1]), Yi(2, 10, 18, 26, wr[t * 16 + 2], wr[t * 16 + 3]), Yi(4, 12, 20, 28, wr[t * 16 + 4], wr[t * 16 + 5]), Yi(6, 14, 22, 30, wr[t * 16 + 6], wr[t * 16 + 7]), Yi(0, 10, 20, 30, wr[t * 16 + 8], wr[t * 16 + 9]), Yi(2, 12, 22, 24, wr[t * 16 + 10], wr[t * 16 + 11]), Yi(4, 14, 16, 26, wr[t * 16 + 12], wr[t * 16 + 13]), Yi(6, 8, 18, 28, wr[t * 16 + 14], wr[t * 16 + 15]);
  for (t = 0; t < 16; t++)
    r.h[t] = r.h[t] ^ Pe[t] ^ Pe[t + 16];
}
const Qi = new Uint8Array([
  0,
  0,
  0,
  0,
  //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0,
  //  4: leaf length, sequential mode
  0,
  0,
  0,
  0,
  //  8: node offset
  0,
  0,
  0,
  0,
  // 12: node offset
  0,
  0,
  0,
  0,
  // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0,
  // 20: rfu
  0,
  0,
  0,
  0,
  // 24: rfu
  0,
  0,
  0,
  0,
  // 28: rfu
  0,
  0,
  0,
  0,
  // 32: salt
  0,
  0,
  0,
  0,
  // 36: salt
  0,
  0,
  0,
  0,
  // 40: salt
  0,
  0,
  0,
  0,
  // 44: salt
  0,
  0,
  0,
  0,
  // 48: personal
  0,
  0,
  0,
  0,
  // 52: personal
  0,
  0,
  0,
  0,
  // 56: personal
  0,
  0,
  0,
  0
  // 60: personal
]);
function OI(r, e, t, n) {
  if (r === 0 || r > 64)
    throw new Error("Illegal output length, expected 0 < length <= 64");
  if (e && e.length > 64)
    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
  if (t && t.length !== 16)
    throw new Error("Illegal salt, expected Uint8Array with length is 16");
  if (n && n.length !== 16)
    throw new Error("Illegal personal, expected Uint8Array with length is 16");
  const s = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0,
    // input count
    c: 0,
    // pointer within buffer
    outlen: r
    // output length in bytes
  };
  Qi.fill(0), Qi[0] = r, e && (Qi[1] = e.length), Qi[2] = 1, Qi[3] = 1, t && Qi.set(t, 32), n && Qi.set(n, 48);
  for (let i = 0; i < 16; i++)
    s.h[i] = TI[i] ^ NI(Qi, i * 4);
  return e && (eb(s, e), s.c = 128), s;
}
function eb(r, e) {
  for (let t = 0; t < e.length; t++)
    r.c === 128 && (r.t += r.c, xI(r, !1), r.c = 0), r.b[r.c++] = e[t];
}
function PI(r) {
  for (r.t += r.c; r.c < 128; )
    r.b[r.c++] = 0;
  xI(r, !0);
  const e = new Uint8Array(r.outlen);
  for (let t = 0; t < r.outlen; t++)
    e[t] = r.h[t >> 2] >> 8 * (t & 3);
  return e;
}
function RI(r, e, t, n, s) {
  t = t || 64, r = Sp.normalizeInput(r), n && (n = Sp.normalizeInput(n)), s && (s = Sp.normalizeInput(s));
  const i = OI(t, e, n, s);
  return eb(i, r), PI(i);
}
function U5(r, e, t, n, s) {
  const i = RI(r, e, t, n, s);
  return Sp.toHex(i);
}
var B5 = {
  blake2b: RI,
  blake2bHex: U5,
  blake2bInit: OI,
  blake2bUpdate: eb,
  blake2bFinal: PI
};
const DI = SI;
function L5(r, e) {
  return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24;
}
function Zi(r, e, t, n, s, i) {
  Qe[r] = Qe[r] + Qe[e] + s, Qe[n] = ep(Qe[n] ^ Qe[r], 16), Qe[t] = Qe[t] + Qe[n], Qe[e] = ep(Qe[e] ^ Qe[t], 12), Qe[r] = Qe[r] + Qe[e] + i, Qe[n] = ep(Qe[n] ^ Qe[r], 8), Qe[t] = Qe[t] + Qe[n], Qe[e] = ep(Qe[e] ^ Qe[t], 7);
}
function ep(r, e) {
  return r >>> e ^ r << 32 - e;
}
const kI = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), yr = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0
]), Qe = new Uint32Array(16), nr = new Uint32Array(16);
function UI(r, e) {
  let t = 0;
  for (t = 0; t < 8; t++)
    Qe[t] = r.h[t], Qe[t + 8] = kI[t];
  for (Qe[12] ^= r.t, Qe[13] ^= r.t / 4294967296, e && (Qe[14] = ~Qe[14]), t = 0; t < 16; t++)
    nr[t] = L5(r.b, 4 * t);
  for (t = 0; t < 10; t++)
    Zi(0, 4, 8, 12, nr[yr[t * 16 + 0]], nr[yr[t * 16 + 1]]), Zi(1, 5, 9, 13, nr[yr[t * 16 + 2]], nr[yr[t * 16 + 3]]), Zi(2, 6, 10, 14, nr[yr[t * 16 + 4]], nr[yr[t * 16 + 5]]), Zi(3, 7, 11, 15, nr[yr[t * 16 + 6]], nr[yr[t * 16 + 7]]), Zi(0, 5, 10, 15, nr[yr[t * 16 + 8]], nr[yr[t * 16 + 9]]), Zi(1, 6, 11, 12, nr[yr[t * 16 + 10]], nr[yr[t * 16 + 11]]), Zi(2, 7, 8, 13, nr[yr[t * 16 + 12]], nr[yr[t * 16 + 13]]), Zi(3, 4, 9, 14, nr[yr[t * 16 + 14]], nr[yr[t * 16 + 15]]);
  for (t = 0; t < 8; t++)
    r.h[t] ^= Qe[t] ^ Qe[t + 8];
}
function BI(r, e) {
  if (!(r > 0 && r <= 32))
    throw new Error("Incorrect output length, should be in [1, 32]");
  const t = e ? e.length : 0;
  if (e && !(t > 0 && t <= 32))
    throw new Error("Incorrect key length, should be in [1, 32]");
  const n = {
    h: new Uint32Array(kI),
    // hash state
    b: new Uint8Array(64),
    // input block
    c: 0,
    // pointer within block
    t: 0,
    // input count
    outlen: r
    // output length in bytes
  };
  return n.h[0] ^= 16842752 ^ t << 8 ^ r, t > 0 && (tb(n, e), n.c = 64), n;
}
function tb(r, e) {
  for (let t = 0; t < e.length; t++)
    r.c === 64 && (r.t += r.c, UI(r, !1), r.c = 0), r.b[r.c++] = e[t];
}
function LI(r) {
  for (r.t += r.c; r.c < 64; )
    r.b[r.c++] = 0;
  UI(r, !0);
  const e = new Uint8Array(r.outlen);
  for (let t = 0; t < r.outlen; t++)
    e[t] = r.h[t >> 2] >> 8 * (t & 3) & 255;
  return e;
}
function FI(r, e, t) {
  t = t || 32, r = DI.normalizeInput(r);
  const n = BI(t, e);
  return tb(n, r), LI(n);
}
function F5(r, e, t) {
  const n = FI(r, e, t);
  return DI.toHex(n);
}
var $5 = {
  blake2s: FI,
  blake2sHex: F5,
  blake2sInit: BI,
  blake2sUpdate: tb,
  blake2sFinal: LI
};
const oh = B5, ah = $5;
var M5 = {
  blake2b: oh.blake2b,
  blake2bHex: oh.blake2bHex,
  blake2bInit: oh.blake2bInit,
  blake2bUpdate: oh.blake2bUpdate,
  blake2bFinal: oh.blake2bFinal,
  blake2s: ah.blake2s,
  blake2sHex: ah.blake2sHex,
  blake2sInit: ah.blake2sInit,
  blake2sUpdate: ah.blake2sUpdate,
  blake2sFinal: ah.blake2sFinal
};
const j5 = ":";
function vl(r) {
  const [e, t] = r.split(j5);
  return { namespace: e, reference: t };
}
function $I(r, e) {
  return r.includes(":") ? [r] : e.chains || [];
}
var H5 = Object.defineProperty, z5 = Object.defineProperties, q5 = Object.getOwnPropertyDescriptors, gv = Object.getOwnPropertySymbols, W5 = Object.prototype.hasOwnProperty, V5 = Object.prototype.propertyIsEnumerable, mv = (r, e, t) => e in r ? H5(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, wv = (r, e) => {
  for (var t in e || (e = {})) W5.call(e, t) && mv(r, t, e[t]);
  if (gv) for (var t of gv(e)) V5.call(e, t) && mv(r, t, e[t]);
  return r;
}, G5 = (r, e) => z5(r, q5(e));
const K5 = "ReactNative", _n = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, J5 = "js";
function rg() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ta() {
  return !uc() && !!J0() && navigator.product === K5;
}
function Y5() {
  return ta() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Q5() {
  return ta() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function qu() {
  return !rg() && !!J0() && !!uc();
}
function vf() {
  return ta() ? _n.reactNative : rg() ? _n.node : qu() ? _n.browser : _n.unknown;
}
function yv() {
  var r;
  try {
    return ta() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (r = global.Application) == null ? void 0 : r.applicationId : void 0;
  } catch {
    return;
  }
}
function Z5(r, e) {
  const t = new URLSearchParams(r);
  for (const n of Object.keys(e).sort()) if (e.hasOwnProperty(n)) {
    const s = e[n];
    s !== void 0 && t.set(n, s);
  }
  return t.toString();
}
function X5(r) {
  var e, t;
  const n = MI();
  try {
    return r != null && r.url && n.url && new URL(r.url).host !== new URL(n.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${r.url} differs from the actual page url:${n.url}. This is probably unintended and can lead to issues.`), r.url = n.url), (e = r == null ? void 0 : r.icons) != null && e.length && r.icons.length > 0 && (r.icons = r.icons.filter((s) => s !== "")), G5(wv(wv({}, n), r), { url: (r == null ? void 0 : r.url) || n.url, name: (r == null ? void 0 : r.name) || n.name, description: (r == null ? void 0 : r.description) || n.description, icons: (t = r == null ? void 0 : r.icons) != null && t.length && r.icons.length > 0 ? r.icons : n.icons });
  } catch (s) {
    return console.warn("Error populating app metadata", s), r || n;
  }
}
function MI() {
  return sI() || { name: "", description: "", url: "", icons: [""] };
}
function e4() {
  if (vf() === _n.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: n } = global.Platform;
    return [t, n].join("-");
  }
  const r = iU();
  if (r === null) return "unknown";
  const e = r.os ? r.os.replace(" ", "").toLowerCase() : "unknown";
  return r.type === "browser" ? [e, r.name, r.version].join("-") : [e, r.version].join("-");
}
function t4() {
  var r;
  const e = vf();
  return e === _n.browser ? [e, ((r = nI()) == null ? void 0 : r.host) || "unknown"].join(":") : e;
}
function jI(r, e, t) {
  const n = e4(), s = t4();
  return [[r, e].join("-"), [J5, t].join("-"), n, s].join("/");
}
function r4({ protocol: r, version: e, relayUrl: t, sdkVersion: n, auth: s, projectId: i, useOnCloseEvent: o, bundleId: a, packageName: c }) {
  const l = t.split("?"), u = jI(r, e, n), h = { auth: s, ua: u, projectId: i, useOnCloseEvent: o, packageName: c || void 0, bundleId: a || void 0 }, d = Z5(l[1] || "", h);
  return l[0] + "?" + d;
}
function Sa(r, e) {
  return r.filter((t) => e.includes(t)).length === r.length;
}
function fy(r) {
  return Object.fromEntries(r.entries());
}
function py(r) {
  return new Map(Object.entries(r));
}
function pa(r = Q.FIVE_MINUTES, e) {
  const t = Q.toMiliseconds(r || Q.FIVE_MINUTES);
  let n, s, i, o;
  return { resolve: (a) => {
    i && n && (clearTimeout(i), n(a), o = Promise.resolve(a));
  }, reject: (a) => {
    i && s && (clearTimeout(i), s(a));
  }, done: () => new Promise((a, c) => {
    if (o) return a(o);
    i = setTimeout(() => {
      const l = new Error(e);
      o = Promise.reject(l), c(l);
    }, t), n = a, s = c;
  }) };
}
function Lo(r, e, t) {
  return new Promise(async (n, s) => {
    const i = setTimeout(() => s(new Error(t)), e);
    try {
      const o = await r;
      n(o);
    } catch (o) {
      s(o);
    }
    clearTimeout(i);
  });
}
function HI(r, e) {
  if (typeof e == "string" && e.startsWith(`${r}:`)) return e;
  if (r.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (r.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${r}`);
}
function n4(r) {
  return HI("topic", r);
}
function s4(r) {
  return HI("id", r);
}
function zI(r) {
  const [e, t] = r.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof t == "string") n.topic = t;
  else if (e === "id" && Number.isInteger(Number(t))) n.id = Number(t);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);
  return n;
}
function Ht(r, e) {
  return Q.fromMiliseconds(Date.now() + Q.toMiliseconds(r));
}
function ho(r) {
  return Date.now() >= Q.toMiliseconds(r);
}
function rt(r, e) {
  return `${r}${e ? `:${e}` : ""}`;
}
function Qs(r = [], e = []) {
  return [.../* @__PURE__ */ new Set([...r, ...e])];
}
async function i4({ id: r, topic: e, wcDeepLink: t }) {
  var n;
  try {
    if (!t) return;
    const s = typeof t == "string" ? JSON.parse(t) : t, i = s == null ? void 0 : s.href;
    if (typeof i != "string") return;
    const o = o4(i, r, e), a = vf();
    if (a === _n.browser) {
      if (!((n = uc()) != null && n.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      a4(o);
    } else a === _n.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o);
  } catch (s) {
    console.error(s);
  }
}
function o4(r, e, t) {
  const n = `requestId=${e}&sessionTopic=${t}`;
  r.endsWith("/") && (r = r.slice(0, -1));
  let s = `${r}`;
  if (r.startsWith("https://t.me")) {
    const i = r.includes("?") ? "&startapp=" : "?startapp=";
    s = `${s}${i}${h4(n, !0)}`;
  } else s = `${s}/wc?${n}`;
  return s;
}
function a4(r) {
  let e = "_self";
  u4() ? e = "_top" : (l4() || r.startsWith("https://") || r.startsWith("http://")) && (e = "_blank"), window.open(r, e, "noreferrer noopener");
}
async function c4(r, e) {
  let t = "";
  try {
    if (qu() && (t = localStorage.getItem(e), t)) return t;
    t = await r.getItem(e);
  } catch (n) {
    console.error(n);
  }
  return t;
}
function bv(r, e) {
  if (!r.includes(e)) return null;
  const t = r.split(/([&,?,=])/), n = t.indexOf(e);
  return t[n + 2];
}
function Ev() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (r) => {
    const e = Math.random() * 16 | 0;
    return (r === "x" ? e : e & 3 | 8).toString(16);
  });
}
function rb() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function l4() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function u4() {
  try {
    return window.self !== window.top;
  } catch {
    return !1;
  }
}
function h4(r, e = !1) {
  const t = Buffer.from(r).toString("base64");
  return e ? t.replace(/[=]/g, "") : t;
}
function qI(r) {
  return Buffer.from(r, "base64").toString("utf-8");
}
function d4(r) {
  return new Promise((e) => setTimeout(e, r));
}
const tp = BigInt(2 ** 32 - 1), vv = BigInt(32);
function WI(r, e = !1) {
  return e ? { h: Number(r & tp), l: Number(r >> vv & tp) } : { h: Number(r >> vv & tp) | 0, l: Number(r & tp) | 0 };
}
function VI(r, e = !1) {
  const t = r.length;
  let n = new Uint32Array(t), s = new Uint32Array(t);
  for (let i = 0; i < t; i++) {
    const { h: o, l: a } = WI(r[i], e);
    [n[i], s[i]] = [o, a];
  }
  return [n, s];
}
const Av = (r, e, t) => r >>> t, Cv = (r, e, t) => r << 32 - t | e >>> t, fo = (r, e, t) => r >>> t | e << 32 - t, po = (r, e, t) => r << 32 - t | e >>> t, _h = (r, e, t) => r << 64 - t | e >>> t - 32, Ih = (r, e, t) => r >>> t - 32 | e << 64 - t, f4 = (r, e) => e, p4 = (r, e) => r, g4 = (r, e, t) => r << t | e >>> 32 - t, m4 = (r, e, t) => e << t | r >>> 32 - t, w4 = (r, e, t) => e << t - 32 | r >>> 64 - t, y4 = (r, e, t) => r << t - 32 | e >>> 64 - t;
function es(r, e, t, n) {
  const s = (e >>> 0) + (n >>> 0);
  return { h: r + t + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const nb = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0), sb = (r, e, t, n) => e + t + n + (r / 2 ** 32 | 0) | 0, b4 = (r, e, t, n) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0), E4 = (r, e, t, n, s) => e + t + n + s + (r / 2 ** 32 | 0) | 0, v4 = (r, e, t, n, s) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0), A4 = (r, e, t, n, s, i) => e + t + n + s + i + (r / 2 ** 32 | 0) | 0, Mc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function C4(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Mi(r) {
  if (!Number.isSafeInteger(r) || r < 0) throw new Error("positive integer expected, got " + r);
}
function Vo(r, ...e) {
  if (!C4(r)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function ib(r) {
  if (typeof r != "function" || typeof r.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  Mi(r.outputLen), Mi(r.blockLen);
}
function Go(r, e = !0) {
  if (r.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function ob(r, e) {
  Vo(r);
  const t = e.outputLen;
  if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
function Ad(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function Wn(...r) {
  for (let e = 0; e < r.length; e++) r[e].fill(0);
}
function Ym(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function Is(r, e) {
  return r << 32 - e | r >>> e;
}
const GI = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function KI(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
const hi = GI ? (r) => r : (r) => KI(r);
function _4(r) {
  for (let e = 0; e < r.length; e++) r[e] = KI(r[e]);
  return r;
}
const go = GI ? (r) => r : _4;
function I4(r) {
  if (typeof r != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function ms(r) {
  return typeof r == "string" && (r = I4(r)), Vo(r), r;
}
function S4(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    Vo(s), e += s.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    t.set(i, s), s += i.length;
  }
  return t;
}
let Kg = class {
};
function Af(r) {
  const e = (n) => r().update(ms(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function N4(r) {
  const e = (n, s) => r(s).update(ms(n)).digest(), t = r({});
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (n) => r(n), e;
}
function Wu(r = 32) {
  if (Mc && typeof Mc.getRandomValues == "function") return Mc.getRandomValues(new Uint8Array(r));
  if (Mc && typeof Mc.randomBytes == "function") return Uint8Array.from(Mc.randomBytes(r));
  throw new Error("crypto.getRandomValues must be defined");
}
const T4 = BigInt(0), ch = BigInt(1), x4 = BigInt(2), O4 = BigInt(7), P4 = BigInt(256), R4 = BigInt(113), JI = [], YI = [], QI = [];
for (let r = 0, e = ch, t = 1, n = 0; r < 24; r++) {
  [t, n] = [n, (2 * t + 3 * n) % 5], JI.push(2 * (5 * n + t)), YI.push((r + 1) * (r + 2) / 2 % 64);
  let s = T4;
  for (let i = 0; i < 7; i++) e = (e << ch ^ (e >> O4) * R4) % P4, e & x4 && (s ^= ch << (ch << BigInt(i)) - ch);
  QI.push(s);
}
const ZI = VI(QI, !0), D4 = ZI[0], k4 = ZI[1], _v = (r, e, t) => t > 32 ? w4(r, e, t) : g4(r, e, t), Iv = (r, e, t) => t > 32 ? y4(r, e, t) : m4(r, e, t);
function U4(r, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++) t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, l = t[c], u = t[c + 1], h = _v(l, u, 1) ^ t[a], d = Iv(l, u, 1) ^ t[a + 1];
      for (let f = 0; f < 50; f += 10) r[o + f] ^= h, r[o + f + 1] ^= d;
    }
    let s = r[2], i = r[3];
    for (let o = 0; o < 24; o++) {
      const a = YI[o], c = _v(s, i, a), l = Iv(s, i, a), u = JI[o];
      s = r[u], i = r[u + 1], r[u] = c, r[u + 1] = l;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) t[a] = r[o + a];
      for (let a = 0; a < 10; a++) r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    r[0] ^= D4[n], r[1] ^= k4[n];
  }
  Wn(t);
}
let B4 = class XI extends Kg {
  constructor(e, t, n, s = !1, i = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = s, this.rounds = i, Mi(n), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = Ad(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    go(this.state32), U4(this.state32, this.rounds), go(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Go(this), e = ms(e), Vo(e);
    const { blockLen: t, state: n } = this, s = e.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(t - this.pos, s - i);
      for (let a = 0; a < o; a++) n[this.pos++] ^= e[i++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: t, pos: n, blockLen: s } = this;
    e[n] ^= t, t & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Go(this, !1), Vo(e), this.finish();
    const t = this.state, { blockLen: n } = this;
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - s);
      e.set(t.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Mi(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (ob(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, Wn(this.state);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
    return e || (e = new XI(t, n, s, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
};
const L4 = (r, e, t) => Af(() => new B4(e, r, t)), F4 = L4(1, 136, 256 / 8);
function $4(r, e, t, n) {
  if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), c = n ? 4 : 0, l = n ? 0 : 4;
  r.setUint32(e + c, o, n), r.setUint32(e + l, a, n);
}
function M4(r, e, t) {
  return r & e ^ ~r & t;
}
function j4(r, e, t) {
  return r & e ^ r & t ^ e & t;
}
let e2 = class extends Kg {
  constructor(e, t, n, s) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.buffer = new Uint8Array(e), this.view = Ym(this.buffer);
  }
  update(e) {
    Go(this), e = ms(e), Vo(e);
    const { view: t, buffer: n, blockLen: s } = this, i = e.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o);
      if (a === s) {
        const c = Ym(e);
        for (; s <= i - o; o += s) this.process(c, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Go(this), ob(e, this), this.finished = !0;
    const { buffer: t, view: n, blockLen: s, isLE: i } = this;
    let { pos: o } = this;
    t[o++] = 128, Wn(this.buffer.subarray(o)), this.padOffset > s - o && (this.process(n, 0), o = 0);
    for (let h = o; h < s; h++) t[h] = 0;
    $4(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Ym(e), c = this.outputLen;
    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = c / 4, u = this.get();
    if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < l; h++) a.setUint32(4 * h, u[h], i);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
    return e.destroyed = o, e.finished = i, e.length = s, e.pos = a, s % t && e.buffer.set(n), e;
  }
  clone() {
    return this._cloneInto();
  }
};
const Xi = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), br = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]), Er = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]), H4 = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), eo = new Uint32Array(64);
class z4 extends e2 {
  constructor(e = 32) {
    super(64, e, 8, !1), this.A = Xi[0] | 0, this.B = Xi[1] | 0, this.C = Xi[2] | 0, this.D = Xi[3] | 0, this.E = Xi[4] | 0, this.F = Xi[5] | 0, this.G = Xi[6] | 0, this.H = Xi[7] | 0;
  }
  get() {
    const { A: e, B: t, C: n, D: s, E: i, F: o, G: a, H: c } = this;
    return [e, t, n, s, i, o, a, c];
  }
  set(e, t, n, s, i, o, a, c) {
    this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(e, t) {
    for (let h = 0; h < 16; h++, t += 4) eo[h] = e.getUint32(t, !1);
    for (let h = 16; h < 64; h++) {
      const d = eo[h - 15], f = eo[h - 2], g = Is(d, 7) ^ Is(d, 18) ^ d >>> 3, p = Is(f, 17) ^ Is(f, 19) ^ f >>> 10;
      eo[h] = p + eo[h - 7] + g + eo[h - 16] | 0;
    }
    let { A: n, B: s, C: i, D: o, E: a, F: c, G: l, H: u } = this;
    for (let h = 0; h < 64; h++) {
      const d = Is(a, 6) ^ Is(a, 11) ^ Is(a, 25), f = u + d + M4(a, c, l) + H4[h] + eo[h] | 0, g = (Is(n, 2) ^ Is(n, 13) ^ Is(n, 22)) + j4(n, s, i) | 0;
      u = l, l = c, c = a, a = o + f | 0, o = i, i = s, s = n, n = f + g | 0;
    }
    n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(n, s, i, o, a, c, l, u);
  }
  roundClean() {
    Wn(eo);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Wn(this.buffer);
  }
}
const t2 = VI(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((r) => BigInt(r))), q4 = t2[0], W4 = t2[1], to = new Uint32Array(80), ro = new Uint32Array(80);
let ab = class extends e2 {
  constructor(e = 64) {
    super(128, e, 16, !1), this.Ah = Er[0] | 0, this.Al = Er[1] | 0, this.Bh = Er[2] | 0, this.Bl = Er[3] | 0, this.Ch = Er[4] | 0, this.Cl = Er[5] | 0, this.Dh = Er[6] | 0, this.Dl = Er[7] | 0, this.Eh = Er[8] | 0, this.El = Er[9] | 0, this.Fh = Er[10] | 0, this.Fl = Er[11] | 0, this.Gh = Er[12] | 0, this.Gl = Er[13] | 0, this.Hh = Er[14] | 0, this.Hl = Er[15] | 0;
  }
  get() {
    const { Ah: e, Al: t, Bh: n, Bl: s, Ch: i, Cl: o, Dh: a, Dl: c, Eh: l, El: u, Fh: h, Fl: d, Gh: f, Gl: g, Hh: p, Hl: w } = this;
    return [e, t, n, s, i, o, a, c, l, u, h, d, f, g, p, w];
  }
  set(e, t, n, s, i, o, a, c, l, u, h, d, f, g, p, w) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = u | 0, this.Fh = h | 0, this.Fl = d | 0, this.Gh = f | 0, this.Gl = g | 0, this.Hh = p | 0, this.Hl = w | 0;
  }
  process(e, t) {
    for (let A = 0; A < 16; A++, t += 4) to[A] = e.getUint32(t), ro[A] = e.getUint32(t += 4);
    for (let A = 16; A < 80; A++) {
      const C = to[A - 15] | 0, N = ro[A - 15] | 0, x = fo(C, N, 1) ^ fo(C, N, 8) ^ Av(C, N, 7), O = po(C, N, 1) ^ po(C, N, 8) ^ Cv(C, N, 7), k = to[A - 2] | 0, P = ro[A - 2] | 0, $ = fo(k, P, 19) ^ _h(k, P, 61) ^ Av(k, P, 6), U = po(k, P, 19) ^ Ih(k, P, 61) ^ Cv(k, P, 6), j = b4(O, U, ro[A - 7], ro[A - 16]), H = E4(j, x, $, to[A - 7], to[A - 16]);
      to[A] = H | 0, ro[A] = j | 0;
    }
    let { Ah: n, Al: s, Bh: i, Bl: o, Ch: a, Cl: c, Dh: l, Dl: u, Eh: h, El: d, Fh: f, Fl: g, Gh: p, Gl: w, Hh: E, Hl: I } = this;
    for (let A = 0; A < 80; A++) {
      const C = fo(h, d, 14) ^ fo(h, d, 18) ^ _h(h, d, 41), N = po(h, d, 14) ^ po(h, d, 18) ^ Ih(h, d, 41), x = h & f ^ ~h & p, O = d & g ^ ~d & w, k = v4(I, N, O, W4[A], ro[A]), P = A4(k, E, C, x, q4[A], to[A]), $ = k | 0, U = fo(n, s, 28) ^ _h(n, s, 34) ^ _h(n, s, 39), j = po(n, s, 28) ^ Ih(n, s, 34) ^ Ih(n, s, 39), H = n & i ^ n & a ^ i & a, ee = s & o ^ s & c ^ o & c;
      E = p | 0, I = w | 0, p = f | 0, w = g | 0, f = h | 0, g = d | 0, { h, l: d } = es(l | 0, u | 0, P | 0, $ | 0), l = a | 0, u = c | 0, a = i | 0, c = o | 0, i = n | 0, o = s | 0;
      const y = nb($, j, ee);
      n = sb(y, P, U, H), s = y | 0;
    }
    ({ h: n, l: s } = es(this.Ah | 0, this.Al | 0, n | 0, s | 0)), { h: i, l: o } = es(this.Bh | 0, this.Bl | 0, i | 0, o | 0), { h: a, l: c } = es(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: l, l: u } = es(this.Dh | 0, this.Dl | 0, l | 0, u | 0), { h, l: d } = es(this.Eh | 0, this.El | 0, h | 0, d | 0), { h: f, l: g } = es(this.Fh | 0, this.Fl | 0, f | 0, g | 0), { h: p, l: w } = es(this.Gh | 0, this.Gl | 0, p | 0, w | 0), { h: E, l: I } = es(this.Hh | 0, this.Hl | 0, E | 0, I | 0), this.set(n, s, i, o, a, c, l, u, h, d, f, g, p, w, E, I);
  }
  roundClean() {
    Wn(to, ro);
  }
  destroy() {
    Wn(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
class V4 extends ab {
  constructor() {
    super(48), this.Ah = br[0] | 0, this.Al = br[1] | 0, this.Bh = br[2] | 0, this.Bl = br[3] | 0, this.Ch = br[4] | 0, this.Cl = br[5] | 0, this.Dh = br[6] | 0, this.Dl = br[7] | 0, this.Eh = br[8] | 0, this.El = br[9] | 0, this.Fh = br[10] | 0, this.Fl = br[11] | 0, this.Gh = br[12] | 0, this.Gl = br[13] | 0, this.Hh = br[14] | 0, this.Hl = br[15] | 0;
  }
}
const vr = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
class G4 extends ab {
  constructor() {
    super(32), this.Ah = vr[0] | 0, this.Al = vr[1] | 0, this.Bh = vr[2] | 0, this.Bl = vr[3] | 0, this.Ch = vr[4] | 0, this.Cl = vr[5] | 0, this.Dh = vr[6] | 0, this.Dl = vr[7] | 0, this.Eh = vr[8] | 0, this.El = vr[9] | 0, this.Fh = vr[10] | 0, this.Fl = vr[11] | 0, this.Gh = vr[12] | 0, this.Gl = vr[13] | 0, this.Hh = vr[14] | 0, this.Hl = vr[15] | 0;
  }
}
const Jg = Af(() => new z4()), K4 = Af(() => new ab()), J4 = Af(() => new V4()), Y4 = Af(() => new G4()), Q4 = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]), jt = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]), ie = new Uint32Array(32);
function no(r, e, t, n, s, i) {
  const o = s[i], a = s[i + 1];
  let c = ie[2 * r], l = ie[2 * r + 1], u = ie[2 * e], h = ie[2 * e + 1], d = ie[2 * t], f = ie[2 * t + 1], g = ie[2 * n], p = ie[2 * n + 1], w = nb(c, u, o);
  l = sb(w, l, h, a), c = w | 0, { Dh: p, Dl: g } = { Dh: p ^ l, Dl: g ^ c }, { Dh: p, Dl: g } = { Dh: f4(p, g), Dl: p4(p) }, { h: f, l: d } = es(f, d, p, g), { Bh: h, Bl: u } = { Bh: h ^ f, Bl: u ^ d }, { Bh: h, Bl: u } = { Bh: fo(h, u, 24), Bl: po(h, u, 24) }, ie[2 * r] = c, ie[2 * r + 1] = l, ie[2 * e] = u, ie[2 * e + 1] = h, ie[2 * t] = d, ie[2 * t + 1] = f, ie[2 * n] = g, ie[2 * n + 1] = p;
}
function so(r, e, t, n, s, i) {
  const o = s[i], a = s[i + 1];
  let c = ie[2 * r], l = ie[2 * r + 1], u = ie[2 * e], h = ie[2 * e + 1], d = ie[2 * t], f = ie[2 * t + 1], g = ie[2 * n], p = ie[2 * n + 1], w = nb(c, u, o);
  l = sb(w, l, h, a), c = w | 0, { Dh: p, Dl: g } = { Dh: p ^ l, Dl: g ^ c }, { Dh: p, Dl: g } = { Dh: fo(p, g, 16), Dl: po(p, g, 16) }, { h: f, l: d } = es(f, d, p, g), { Bh: h, Bl: u } = { Bh: h ^ f, Bl: u ^ d }, { Bh: h, Bl: u } = { Bh: _h(h, u, 63), Bl: Ih(h, u, 63) }, ie[2 * r] = c, ie[2 * r + 1] = l, ie[2 * e] = u, ie[2 * e + 1] = h, ie[2 * t] = d, ie[2 * t + 1] = f, ie[2 * n] = g, ie[2 * n + 1] = p;
}
function Z4(r, e = {}, t, n, s) {
  if (Mi(t), r < 0 || r > t) throw new Error("outputLen bigger than keyLen");
  const { key: i, salt: o, personalization: a } = e;
  if (i !== void 0 && (i.length < 1 || i.length > t)) throw new Error("key length must be undefined or 1.." + t);
  if (o !== void 0 && o.length !== n) throw new Error("salt must be undefined or " + n);
  if (a !== void 0 && a.length !== s) throw new Error("personalization must be undefined or " + s);
}
class X4 extends Kg {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, this.length = 0, this.pos = 0, Mi(e), Mi(t), this.blockLen = e, this.outputLen = t, this.buffer = new Uint8Array(e), this.buffer32 = Ad(this.buffer);
  }
  update(e) {
    Go(this), e = ms(e), Vo(e);
    const { blockLen: t, buffer: n, buffer32: s } = this, i = e.length, o = e.byteOffset, a = e.buffer;
    for (let c = 0; c < i; ) {
      this.pos === t && (go(s), this.compress(s, 0, !1), go(s), this.pos = 0);
      const l = Math.min(t - this.pos, i - c), u = o + c;
      if (l === t && !(u % 4) && c + l < i) {
        const h = new Uint32Array(a, u, Math.floor((i - c) / 4));
        go(h);
        for (let d = 0; c + t < i; d += s.length, c += t) this.length += t, this.compress(h, d, !1);
        go(h);
        continue;
      }
      n.set(e.subarray(c, c + l), this.pos), this.pos += l, this.length += l, c += l;
    }
    return this;
  }
  digestInto(e) {
    Go(this), ob(e, this);
    const { pos: t, buffer32: n } = this;
    this.finished = !0, Wn(this.buffer.subarray(t)), go(n), this.compress(n, 0, !0), go(n);
    const s = Ad(e);
    this.get().forEach((i, o) => s[o] = hi(i));
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    const { buffer: t, length: n, finished: s, destroyed: i, outputLen: o, pos: a } = this;
    return e || (e = new this.constructor({ dkLen: o })), e.set(...this.get()), e.buffer.set(t), e.destroyed = i, e.finished = s, e.length = n, e.pos = a, e.outputLen = o, e;
  }
  clone() {
    return this._cloneInto();
  }
}
class eB extends X4 {
  constructor(e = {}) {
    const t = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, t), this.v0l = jt[0] | 0, this.v0h = jt[1] | 0, this.v1l = jt[2] | 0, this.v1h = jt[3] | 0, this.v2l = jt[4] | 0, this.v2h = jt[5] | 0, this.v3l = jt[6] | 0, this.v3h = jt[7] | 0, this.v4l = jt[8] | 0, this.v4h = jt[9] | 0, this.v5l = jt[10] | 0, this.v5h = jt[11] | 0, this.v6l = jt[12] | 0, this.v6h = jt[13] | 0, this.v7l = jt[14] | 0, this.v7h = jt[15] | 0, Z4(t, e, 64, 16, 16);
    let { key: n, personalization: s, salt: i } = e, o = 0;
    if (n !== void 0 && (n = ms(n), o = n.length), this.v0l ^= this.outputLen | o << 8 | 65536 | 1 << 24, i !== void 0) {
      i = ms(i);
      const a = Ad(i);
      this.v4l ^= hi(a[0]), this.v4h ^= hi(a[1]), this.v5l ^= hi(a[2]), this.v5h ^= hi(a[3]);
    }
    if (s !== void 0) {
      s = ms(s);
      const a = Ad(s);
      this.v6l ^= hi(a[0]), this.v6h ^= hi(a[1]), this.v7l ^= hi(a[2]), this.v7h ^= hi(a[3]);
    }
    if (n !== void 0) {
      const a = new Uint8Array(this.blockLen);
      a.set(n), this.update(a);
    }
  }
  get() {
    let { v0l: e, v0h: t, v1l: n, v1h: s, v2l: i, v2h: o, v3l: a, v3h: c, v4l: l, v4h: u, v5l: h, v5h: d, v6l: f, v6h: g, v7l: p, v7h: w } = this;
    return [e, t, n, s, i, o, a, c, l, u, h, d, f, g, p, w];
  }
  set(e, t, n, s, i, o, a, c, l, u, h, d, f, g, p, w) {
    this.v0l = e | 0, this.v0h = t | 0, this.v1l = n | 0, this.v1h = s | 0, this.v2l = i | 0, this.v2h = o | 0, this.v3l = a | 0, this.v3h = c | 0, this.v4l = l | 0, this.v4h = u | 0, this.v5l = h | 0, this.v5h = d | 0, this.v6l = f | 0, this.v6h = g | 0, this.v7l = p | 0, this.v7h = w | 0;
  }
  compress(e, t, n) {
    this.get().forEach((c, l) => ie[l] = c), ie.set(jt, 16);
    let { h: s, l: i } = WI(BigInt(this.length));
    ie[24] = jt[8] ^ i, ie[25] = jt[9] ^ s, n && (ie[28] = ~ie[28], ie[29] = ~ie[29]);
    let o = 0;
    const a = Q4;
    for (let c = 0; c < 12; c++) no(0, 4, 8, 12, e, t + 2 * a[o++]), so(0, 4, 8, 12, e, t + 2 * a[o++]), no(1, 5, 9, 13, e, t + 2 * a[o++]), so(1, 5, 9, 13, e, t + 2 * a[o++]), no(2, 6, 10, 14, e, t + 2 * a[o++]), so(2, 6, 10, 14, e, t + 2 * a[o++]), no(3, 7, 11, 15, e, t + 2 * a[o++]), so(3, 7, 11, 15, e, t + 2 * a[o++]), no(0, 5, 10, 15, e, t + 2 * a[o++]), so(0, 5, 10, 15, e, t + 2 * a[o++]), no(1, 6, 11, 12, e, t + 2 * a[o++]), so(1, 6, 11, 12, e, t + 2 * a[o++]), no(2, 7, 8, 13, e, t + 2 * a[o++]), so(2, 7, 8, 13, e, t + 2 * a[o++]), no(3, 4, 9, 14, e, t + 2 * a[o++]), so(3, 4, 9, 14, e, t + 2 * a[o++]);
    this.v0l ^= ie[0] ^ ie[16], this.v0h ^= ie[1] ^ ie[17], this.v1l ^= ie[2] ^ ie[18], this.v1h ^= ie[3] ^ ie[19], this.v2l ^= ie[4] ^ ie[20], this.v2h ^= ie[5] ^ ie[21], this.v3l ^= ie[6] ^ ie[22], this.v3h ^= ie[7] ^ ie[23], this.v4l ^= ie[8] ^ ie[24], this.v4h ^= ie[9] ^ ie[25], this.v5l ^= ie[10] ^ ie[26], this.v5h ^= ie[11] ^ ie[27], this.v6l ^= ie[12] ^ ie[28], this.v6h ^= ie[13] ^ ie[29], this.v7l ^= ie[14] ^ ie[30], this.v7h ^= ie[15] ^ ie[31], Wn(ie);
  }
  destroy() {
    this.destroyed = !0, Wn(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const tB = N4((r) => new eB(r)), rB = "https://rpc.walletconnect.org/v1";
function r2(r) {
  const e = `Ethereum Signed Message:
${r.length}`, t = new TextEncoder().encode(e + r);
  return "0x" + Buffer.from(F4(t)).toString("hex");
}
async function nB(r, e, t, n, s, i) {
  switch (t.t) {
    case "eip191":
      return await sB(r, e, t.s);
    case "eip1271":
      return await iB(r, e, t.s, n, s, i);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`);
  }
}
async function sB(r, e, t) {
  return (await $U({ hash: r2(e), signature: t })).toLowerCase() === r.toLowerCase();
}
async function iB(r, e, t, n, s, i) {
  const o = vl(n);
  if (!o.namespace || !o.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`);
  try {
    const a = "0x1626ba7e", c = "0000000000000000000000000000000000000000000000000000000000000040", l = "0000000000000000000000000000000000000000000000000000000000000041", u = t.substring(2), h = r2(e).substring(2), d = a + h + c + l + u, f = await fetch(`${i || rB}/?chainId=${n}&projectId=${s}`, { method: "POST", body: JSON.stringify({ id: oB(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: d }, "latest"] }) }), { result: g } = await f.json();
    return g ? g.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), !1;
  }
}
function oB() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function aB(r) {
  const e = atob(r), t = new Uint8Array(e.length);
  for (let o = 0; o < e.length; o++) t[o] = e.charCodeAt(o);
  const n = t[0];
  if (n === 0) throw new Error("No signatures found");
  const s = 1 + n * 64;
  if (t.length < s) throw new Error("Transaction data too short for claimed signature count");
  if (t.length < 100) throw new Error("Transaction too short");
  const i = Buffer.from(r, "base64").slice(1, 65);
  return zu.encode(i);
}
function cB(r) {
  const e = new Uint8Array(Buffer.from(r, "base64")), t = Array.from("TransactionData::").map((i) => i.charCodeAt(0)), n = new Uint8Array(t.length + e.length);
  n.set(t), n.set(e, t.length);
  const s = tB(n, { dkLen: 32 });
  return zu.encode(s);
}
function Sv(r) {
  const e = new Uint8Array(Jg(lB(r)));
  return zu.encode(e);
}
function lB(r) {
  if (r instanceof Uint8Array) return r;
  if (Array.isArray(r)) return new Uint8Array(r);
  if (typeof r == "object" && r != null && r.data) return new Uint8Array(Object.values(r.data));
  if (typeof r == "object" && r) return new Uint8Array(Object.values(r));
  throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function Nv(r) {
  const e = Buffer.from(r, "base64"), t = C8(e).txn;
  if (!t) throw new Error("Invalid signed transaction: missing 'txn' field");
  const n = p8(t), s = Buffer.from("TX"), i = Buffer.concat([s, Buffer.from(n)]), o = Y4(i);
  return P8.encode(o).replace(/=+$/, "");
}
function Qm(r) {
  const e = [];
  let t = BigInt(r);
  for (; t >= BigInt(128); ) e.push(Number(t & BigInt(127) | BigInt(128))), t >>= BigInt(7);
  return e.push(Number(t)), Buffer.from(e);
}
function uB(r) {
  const e = Buffer.from(r.signed.bodyBytes, "base64"), t = Buffer.from(r.signed.authInfoBytes, "base64"), n = Buffer.from(r.signature.signature, "base64"), s = [];
  s.push(Buffer.from([10])), s.push(Qm(e.length)), s.push(e), s.push(Buffer.from([18])), s.push(Qm(t.length)), s.push(t), s.push(Buffer.from([26])), s.push(Qm(n.length)), s.push(n);
  const i = Buffer.concat(s), o = Jg(i);
  return Buffer.from(o).toString("hex").toUpperCase();
}
var hB = Object.defineProperty, dB = Object.defineProperties, fB = Object.getOwnPropertyDescriptors, Tv = Object.getOwnPropertySymbols, pB = Object.prototype.hasOwnProperty, gB = Object.prototype.propertyIsEnumerable, xv = (r, e, t) => e in r ? hB(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, mB = (r, e) => {
  for (var t in e || (e = {})) pB.call(e, t) && xv(r, t, e[t]);
  if (Tv) for (var t of Tv(e)) gB.call(e, t) && xv(r, t, e[t]);
  return r;
}, wB = (r, e) => dB(r, fB(e));
const yB = "did:pkh:", cb = (r) => r == null ? void 0 : r.split(":"), bB = (r) => {
  const e = r && cb(r);
  if (e) return r.includes(yB) ? e[3] : e[1];
}, gy = (r) => {
  const e = r && cb(r);
  if (e) return e[2] + ":" + e[3];
}, ng = (r) => {
  const e = r && cb(r);
  if (e) return e.pop();
};
async function Ov(r) {
  const { cacao: e, projectId: t } = r, { s: n, p: s } = e, i = n2(s, s.iss), o = ng(s.iss);
  return await nB(o, i, n, gy(s.iss), t);
}
const n2 = (r, e) => {
  const t = `${r.domain} wants you to sign in with your Ethereum account:`, n = ng(e);
  if (!r.aud && !r.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let s = r.statement || void 0;
  const i = `URI: ${r.aud || r.uri}`, o = `Version: ${r.version}`, a = `Chain ID: ${bB(e)}`, c = `Nonce: ${r.nonce}`, l = `Issued At: ${r.iat}`, u = r.exp ? `Expiration Time: ${r.exp}` : void 0, h = r.nbf ? `Not Before: ${r.nbf}` : void 0, d = r.requestId ? `Request ID: ${r.requestId}` : void 0, f = r.resources ? `Resources:${r.resources.map((p) => `
- ${p}`).join("")}` : void 0, g = Np(r.resources);
  if (g) {
    const p = Cd(g);
    s = TB(s, p);
  }
  return [t, n, "", s, "", i, o, a, c, l, u, h, d, f].filter((p) => p != null).join(`
`);
};
function EB(r) {
  return Buffer.from(JSON.stringify(r)).toString("base64");
}
function vB(r) {
  return JSON.parse(Buffer.from(r, "base64").toString("utf-8"));
}
function dc(r) {
  if (!r) throw new Error("No recap provided, value is undefined");
  if (!r.att) throw new Error("No `att` property found");
  const e = Object.keys(r.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((t) => {
    const n = r.att[t];
    if (Array.isArray(n)) throw new Error(`Resource must be an object: ${t}`);
    if (typeof n != "object") throw new Error(`Resource must be an object: ${t}`);
    if (!Object.keys(n).length) throw new Error(`Resource object is empty: ${t}`);
    Object.keys(n).forEach((s) => {
      const i = n[s];
      if (!Array.isArray(i)) throw new Error(`Ability limits ${s} must be an array of objects, found: ${i}`);
      if (!i.length) throw new Error(`Value of ${s} is empty array, must be an array with objects`);
      i.forEach((o) => {
        if (typeof o != "object") throw new Error(`Ability limits (${s}) must be an array of objects, found: ${o}`);
      });
    });
  });
}
function AB(r, e, t, n = {}) {
  return t == null || t.sort((s, i) => s.localeCompare(i)), { att: { [r]: CB(e, t, n) } };
}
function CB(r, e, t = {}) {
  e = e == null ? void 0 : e.sort((s, i) => s.localeCompare(i));
  const n = e.map((s) => ({ [`${r}/${s}`]: [t] }));
  return Object.assign({}, ...n);
}
function s2(r) {
  return dc(r), `urn:recap:${EB(r).replace(/=/g, "")}`;
}
function Cd(r) {
  const e = vB(r.replace("urn:recap:", ""));
  return dc(e), e;
}
function _B(r, e, t) {
  const n = AB(r, e, t);
  return s2(n);
}
function IB(r) {
  return r && r.includes("urn:recap:");
}
function SB(r, e) {
  const t = Cd(r), n = Cd(e), s = NB(t, n);
  return s2(s);
}
function NB(r, e) {
  dc(r), dc(e);
  const t = Object.keys(r.att).concat(Object.keys(e.att)).sort((s, i) => s.localeCompare(i)), n = { att: {} };
  return t.forEach((s) => {
    var i, o;
    Object.keys(((i = r.att) == null ? void 0 : i[s]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[s]) || {})).sort((a, c) => a.localeCompare(c)).forEach((a) => {
      var c, l;
      n.att[s] = wB(mB({}, n.att[s]), { [a]: ((c = r.att[s]) == null ? void 0 : c[a]) || ((l = e.att[s]) == null ? void 0 : l[a]) });
    });
  }), n;
}
function TB(r = "", e) {
  dc(e);
  const t = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (r.includes(t)) return r;
  const n = [];
  let s = 0;
  Object.keys(e.att).forEach((a) => {
    const c = Object.keys(e.att[a]).map((h) => ({ ability: h.split("/")[0], action: h.split("/")[1] }));
    c.sort((h, d) => h.action.localeCompare(d.action));
    const l = {};
    c.forEach((h) => {
      l[h.ability] || (l[h.ability] = []), l[h.ability].push(h.action);
    });
    const u = Object.keys(l).map((h) => (s++, `(${s}) '${h}': '${l[h].join("', '")}' for '${a}'.`));
    n.push(u.join(", ").replace(".,", "."));
  });
  const i = n.join(" "), o = `${t}${i}`;
  return `${r ? r + " " : ""}${o}`;
}
function Pv(r) {
  var e;
  const t = Cd(r);
  dc(t);
  const n = (e = t.att) == null ? void 0 : e.eip155;
  return n ? Object.keys(n).map((s) => s.split("/")[1]) : [];
}
function Rv(r) {
  const e = Cd(r);
  dc(e);
  const t = [];
  return Object.values(e.att).forEach((n) => {
    Object.values(n).forEach((s) => {
      var i;
      (i = s == null ? void 0 : s[0]) != null && i.chains && t.push(s[0].chains);
    });
  }), [...new Set(t.flat())];
}
function Np(r) {
  if (!r) return;
  const e = r == null ? void 0 : r[r.length - 1];
  return IB(e) ? e : void 0;
}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
function i2(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function my(r) {
  if (typeof r != "boolean") throw new Error(`boolean expected, not ${r}`);
}
function Zm(r) {
  if (!Number.isSafeInteger(r) || r < 0) throw new Error("positive integer expected, got " + r);
}
function rn(r, ...e) {
  if (!i2(r)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function Dv(r, e = !0) {
  if (r.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function xB(r, e) {
  rn(r);
  const t = e.outputLen;
  if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
function $o(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function Iu(...r) {
  for (let e = 0; e < r.length; e++) r[e].fill(0);
}
function OB(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
const PB = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function RB(r) {
  if (typeof r != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function wy(r) {
  if (typeof r == "string") r = RB(r);
  else if (i2(r)) r = yy(r);
  else throw new Error("Uint8Array expected, got " + typeof r);
  return r;
}
function DB(r, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(r, e);
}
function kB(r, e) {
  if (r.length !== e.length) return !1;
  let t = 0;
  for (let n = 0; n < r.length; n++) t |= r[n] ^ e[n];
  return t === 0;
}
const UB = (r, e) => {
  function t(n, ...s) {
    if (rn(n), !PB) throw new Error("Non little-endian hardware is not yet supported");
    if (r.nonceLength !== void 0) {
      const l = s[0];
      if (!l) throw new Error("nonce / iv required");
      r.varSizeNonce ? rn(l) : rn(l, r.nonceLength);
    }
    const i = r.tagLength;
    i && s[1] !== void 0 && rn(s[1]);
    const o = e(n, ...s), a = (l, u) => {
      if (u !== void 0) {
        if (l !== 2) throw new Error("cipher output not supported");
        rn(u);
      }
    };
    let c = !1;
    return { encrypt(l, u) {
      if (c) throw new Error("cannot encrypt() twice with same key + nonce");
      return c = !0, rn(l), a(o.encrypt.length, u), o.encrypt(l, u);
    }, decrypt(l, u) {
      if (rn(l), i && l.length < i) throw new Error("invalid ciphertext length: smaller than tagLength=" + i);
      return a(o.decrypt.length, u), o.decrypt(l, u);
    } };
  }
  return Object.assign(t, r), t;
};
function kv(r, e, t = !0) {
  if (e === void 0) return new Uint8Array(r);
  if (e.length !== r) throw new Error("invalid output length, expected " + r + ", got: " + e.length);
  if (t && !LB(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function Uv(r, e, t, n) {
  if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i);
  r.setUint32(e + 4, o, n), r.setUint32(e + 0, a, n);
}
function BB(r, e, t) {
  my(t);
  const n = new Uint8Array(16), s = OB(n);
  return Uv(s, 0, BigInt(e), t), Uv(s, 8, BigInt(r), t), n;
}
function LB(r) {
  return r.byteOffset % 4 === 0;
}
function yy(r) {
  return Uint8Array.from(r);
}
const o2 = (r) => Uint8Array.from(r.split("").map((e) => e.charCodeAt(0))), FB = o2("expand 16-byte k"), $B = o2("expand 32-byte k"), MB = $o(FB), jB = $o($B);
function Ke(r, e) {
  return r << e | r >>> 32 - e;
}
function by(r) {
  return r.byteOffset % 4 === 0;
}
const rp = 64, HB = 16, a2 = 2 ** 32 - 1, Bv = new Uint32Array();
function zB(r, e, t, n, s, i, o, a) {
  const c = s.length, l = new Uint8Array(rp), u = $o(l), h = by(s) && by(i), d = h ? $o(s) : Bv, f = h ? $o(i) : Bv;
  for (let g = 0; g < c; o++) {
    if (r(e, t, n, u, o, a), o >= a2) throw new Error("arx: counter overflow");
    const p = Math.min(rp, c - g);
    if (h && p === rp) {
      const w = g / 4;
      if (g % 4 !== 0) throw new Error("arx: invalid block position");
      for (let E = 0, I; E < HB; E++) I = w + E, f[I] = d[I] ^ u[E];
      g += rp;
      continue;
    }
    for (let w = 0, E; w < p; w++) E = g + w, i[E] = s[E] ^ l[w];
    g += p;
  }
}
function qB(r, e) {
  const { allowShortKeys: t, extendNonceFn: n, counterLength: s, counterRight: i, rounds: o } = DB({ allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 }, e);
  if (typeof r != "function") throw new Error("core must be a function");
  return Zm(s), Zm(o), my(i), my(t), (a, c, l, u, h = 0) => {
    rn(a), rn(c), rn(l);
    const d = l.length;
    if (u === void 0 && (u = new Uint8Array(d)), rn(u), Zm(h), h < 0 || h >= a2) throw new Error("arx: counter overflow");
    if (u.length < d) throw new Error(`arx: output (${u.length}) is shorter than data (${d})`);
    const f = [];
    let g = a.length, p, w;
    if (g === 32) f.push(p = yy(a)), w = jB;
    else if (g === 16 && t) p = new Uint8Array(32), p.set(a), p.set(a, 16), w = MB, f.push(p);
    else throw new Error(`arx: invalid 32-byte key, got length=${g}`);
    by(c) || f.push(c = yy(c));
    const E = $o(p);
    if (n) {
      if (c.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      n(w, E, $o(c.subarray(0, 16)), E), c = c.subarray(16);
    }
    const I = 16 - s;
    if (I !== c.length) throw new Error(`arx: nonce must be ${I} or 16 bytes`);
    if (I !== 12) {
      const C = new Uint8Array(12);
      C.set(c, i ? 0 : 12 - c.length), c = C, f.push(c);
    }
    const A = $o(c);
    return zB(r, w, E, A, l, u, h, o), Iu(...f), u;
  };
}
const sr = (r, e) => r[e++] & 255 | (r[e++] & 255) << 8;
class WB {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = wy(e), rn(e, 32);
    const t = sr(e, 0), n = sr(e, 2), s = sr(e, 4), i = sr(e, 6), o = sr(e, 8), a = sr(e, 10), c = sr(e, 12), l = sr(e, 14);
    this.r[0] = t & 8191, this.r[1] = (t >>> 13 | n << 3) & 8191, this.r[2] = (n >>> 10 | s << 6) & 7939, this.r[3] = (s >>> 7 | i << 9) & 8191, this.r[4] = (i >>> 4 | o << 12) & 255, this.r[5] = o >>> 1 & 8190, this.r[6] = (o >>> 14 | a << 2) & 8191, this.r[7] = (a >>> 11 | c << 5) & 8065, this.r[8] = (c >>> 8 | l << 8) & 8191, this.r[9] = l >>> 5 & 127;
    for (let u = 0; u < 8; u++) this.pad[u] = sr(e, 16 + 2 * u);
  }
  process(e, t, n = !1) {
    const s = n ? 0 : 2048, { h: i, r: o } = this, a = o[0], c = o[1], l = o[2], u = o[3], h = o[4], d = o[5], f = o[6], g = o[7], p = o[8], w = o[9], E = sr(e, t + 0), I = sr(e, t + 2), A = sr(e, t + 4), C = sr(e, t + 6), N = sr(e, t + 8), x = sr(e, t + 10), O = sr(e, t + 12), k = sr(e, t + 14);
    let P = i[0] + (E & 8191), $ = i[1] + ((E >>> 13 | I << 3) & 8191), U = i[2] + ((I >>> 10 | A << 6) & 8191), j = i[3] + ((A >>> 7 | C << 9) & 8191), H = i[4] + ((C >>> 4 | N << 12) & 8191), ee = i[5] + (N >>> 1 & 8191), y = i[6] + ((N >>> 14 | x << 2) & 8191), b = i[7] + ((x >>> 11 | O << 5) & 8191), T = i[8] + ((O >>> 8 | k << 8) & 8191), B = i[9] + (k >>> 5 | s), R = 0, L = R + P * a + $ * (5 * w) + U * (5 * p) + j * (5 * g) + H * (5 * f);
    R = L >>> 13, L &= 8191, L += ee * (5 * d) + y * (5 * h) + b * (5 * u) + T * (5 * l) + B * (5 * c), R += L >>> 13, L &= 8191;
    let q = R + P * c + $ * a + U * (5 * w) + j * (5 * p) + H * (5 * g);
    R = q >>> 13, q &= 8191, q += ee * (5 * f) + y * (5 * d) + b * (5 * h) + T * (5 * u) + B * (5 * l), R += q >>> 13, q &= 8191;
    let Y = R + P * l + $ * c + U * a + j * (5 * w) + H * (5 * p);
    R = Y >>> 13, Y &= 8191, Y += ee * (5 * g) + y * (5 * f) + b * (5 * d) + T * (5 * h) + B * (5 * u), R += Y >>> 13, Y &= 8191;
    let de = R + P * u + $ * l + U * c + j * a + H * (5 * w);
    R = de >>> 13, de &= 8191, de += ee * (5 * p) + y * (5 * g) + b * (5 * f) + T * (5 * d) + B * (5 * h), R += de >>> 13, de &= 8191;
    let ne = R + P * h + $ * u + U * l + j * c + H * a;
    R = ne >>> 13, ne &= 8191, ne += ee * (5 * w) + y * (5 * p) + b * (5 * g) + T * (5 * f) + B * (5 * d), R += ne >>> 13, ne &= 8191;
    let we = R + P * d + $ * h + U * u + j * l + H * c;
    R = we >>> 13, we &= 8191, we += ee * a + y * (5 * w) + b * (5 * p) + T * (5 * g) + B * (5 * f), R += we >>> 13, we &= 8191;
    let ke = R + P * f + $ * d + U * h + j * u + H * l;
    R = ke >>> 13, ke &= 8191, ke += ee * c + y * a + b * (5 * w) + T * (5 * p) + B * (5 * g), R += ke >>> 13, ke &= 8191;
    let xe = R + P * g + $ * f + U * d + j * h + H * u;
    R = xe >>> 13, xe &= 8191, xe += ee * l + y * c + b * a + T * (5 * w) + B * (5 * p), R += xe >>> 13, xe &= 8191;
    let Ve = R + P * p + $ * g + U * f + j * d + H * h;
    R = Ve >>> 13, Ve &= 8191, Ve += ee * u + y * l + b * c + T * a + B * (5 * w), R += Ve >>> 13, Ve &= 8191;
    let Ne = R + P * w + $ * p + U * g + j * f + H * d;
    R = Ne >>> 13, Ne &= 8191, Ne += ee * h + y * u + b * l + T * c + B * a, R += Ne >>> 13, Ne &= 8191, R = (R << 2) + R | 0, R = R + L | 0, L = R & 8191, R = R >>> 13, q += R, i[0] = L, i[1] = q, i[2] = Y, i[3] = de, i[4] = ne, i[5] = we, i[6] = ke, i[7] = xe, i[8] = Ve, i[9] = Ne;
  }
  finalize() {
    const { h: e, pad: t } = this, n = new Uint16Array(10);
    let s = e[1] >>> 13;
    e[1] &= 8191;
    for (let a = 2; a < 10; a++) e[a] += s, s = e[a] >>> 13, e[a] &= 8191;
    e[0] += s * 5, s = e[0] >>> 13, e[0] &= 8191, e[1] += s, s = e[1] >>> 13, e[1] &= 8191, e[2] += s, n[0] = e[0] + 5, s = n[0] >>> 13, n[0] &= 8191;
    for (let a = 1; a < 10; a++) n[a] = e[a] + s, s = n[a] >>> 13, n[a] &= 8191;
    n[9] -= 8192;
    let i = (s ^ 1) - 1;
    for (let a = 0; a < 10; a++) n[a] &= i;
    i = ~i;
    for (let a = 0; a < 10; a++) e[a] = e[a] & i | n[a];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let o = e[0] + t[0];
    e[0] = o & 65535;
    for (let a = 1; a < 8; a++) o = (e[a] + t[a] | 0) + (o >>> 16) | 0, e[a] = o & 65535;
    Iu(n);
  }
  update(e) {
    Dv(this), e = wy(e), rn(e);
    const { buffer: t, blockLen: n } = this, s = e.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(n - this.pos, s - i);
      if (o === n) {
        for (; n <= s - i; i += n) this.process(e, i);
        continue;
      }
      t.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === n && (this.process(t, 0, !1), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Iu(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    Dv(this), xB(e, this), this.finished = !0;
    const { buffer: t, h: n } = this;
    let { pos: s } = this;
    if (s) {
      for (t[s++] = 1; s < 16; s++) t[s] = 0;
      this.process(t, 0, !0);
    }
    this.finalize();
    let i = 0;
    for (let o = 0; o < 8; o++) e[i++] = n[o] >>> 0, e[i++] = n[o] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
}
function VB(r) {
  const e = (n, s) => r(s).update(wy(n)).digest(), t = r(new Uint8Array(32));
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (n) => r(n), e;
}
const GB = VB((r) => new WB(r));
function KB(r, e, t, n, s, i = 20) {
  let o = r[0], a = r[1], c = r[2], l = r[3], u = e[0], h = e[1], d = e[2], f = e[3], g = e[4], p = e[5], w = e[6], E = e[7], I = s, A = t[0], C = t[1], N = t[2], x = o, O = a, k = c, P = l, $ = u, U = h, j = d, H = f, ee = g, y = p, b = w, T = E, B = I, R = A, L = C, q = N;
  for (let de = 0; de < i; de += 2) x = x + $ | 0, B = Ke(B ^ x, 16), ee = ee + B | 0, $ = Ke($ ^ ee, 12), x = x + $ | 0, B = Ke(B ^ x, 8), ee = ee + B | 0, $ = Ke($ ^ ee, 7), O = O + U | 0, R = Ke(R ^ O, 16), y = y + R | 0, U = Ke(U ^ y, 12), O = O + U | 0, R = Ke(R ^ O, 8), y = y + R | 0, U = Ke(U ^ y, 7), k = k + j | 0, L = Ke(L ^ k, 16), b = b + L | 0, j = Ke(j ^ b, 12), k = k + j | 0, L = Ke(L ^ k, 8), b = b + L | 0, j = Ke(j ^ b, 7), P = P + H | 0, q = Ke(q ^ P, 16), T = T + q | 0, H = Ke(H ^ T, 12), P = P + H | 0, q = Ke(q ^ P, 8), T = T + q | 0, H = Ke(H ^ T, 7), x = x + U | 0, q = Ke(q ^ x, 16), b = b + q | 0, U = Ke(U ^ b, 12), x = x + U | 0, q = Ke(q ^ x, 8), b = b + q | 0, U = Ke(U ^ b, 7), O = O + j | 0, B = Ke(B ^ O, 16), T = T + B | 0, j = Ke(j ^ T, 12), O = O + j | 0, B = Ke(B ^ O, 8), T = T + B | 0, j = Ke(j ^ T, 7), k = k + H | 0, R = Ke(R ^ k, 16), ee = ee + R | 0, H = Ke(H ^ ee, 12), k = k + H | 0, R = Ke(R ^ k, 8), ee = ee + R | 0, H = Ke(H ^ ee, 7), P = P + $ | 0, L = Ke(L ^ P, 16), y = y + L | 0, $ = Ke($ ^ y, 12), P = P + $ | 0, L = Ke(L ^ P, 8), y = y + L | 0, $ = Ke($ ^ y, 7);
  let Y = 0;
  n[Y++] = o + x | 0, n[Y++] = a + O | 0, n[Y++] = c + k | 0, n[Y++] = l + P | 0, n[Y++] = u + $ | 0, n[Y++] = h + U | 0, n[Y++] = d + j | 0, n[Y++] = f + H | 0, n[Y++] = g + ee | 0, n[Y++] = p + y | 0, n[Y++] = w + b | 0, n[Y++] = E + T | 0, n[Y++] = I + B | 0, n[Y++] = A + R | 0, n[Y++] = C + L | 0, n[Y++] = N + q | 0;
}
const JB = qB(KB, { counterRight: !1, counterLength: 4, allowShortKeys: !1 }), YB = new Uint8Array(16), Lv = (r, e) => {
  r.update(e);
  const t = e.length % 16;
  t && r.update(YB.subarray(t));
}, QB = new Uint8Array(32);
function Fv(r, e, t, n, s) {
  const i = r(e, t, QB), o = GB.create(i);
  s && Lv(o, s), Lv(o, n);
  const a = BB(n.length, s ? s.length : 0, !0);
  o.update(a);
  const c = o.digest();
  return Iu(i, a), c;
}
const ZB = (r) => (e, t, n) => ({ encrypt(s, i) {
  const o = s.length;
  i = kv(o + 16, i, !1), i.set(s);
  const a = i.subarray(0, -16);
  r(e, t, a, a, 1);
  const c = Fv(r, e, t, a, n);
  return i.set(c, o), Iu(c), i;
}, decrypt(s, i) {
  i = kv(s.length - 16, i, !1);
  const o = s.subarray(0, -16), a = s.subarray(-16), c = Fv(r, e, t, o, n);
  if (!kB(a, c)) throw new Error("invalid tag");
  return i.set(s.subarray(0, -16)), r(e, t, i, i, 1), Iu(c), i;
} }), c2 = UB({ blockSize: 64, nonceLength: 12, tagLength: 16 }, ZB(JB));
let l2 = class extends Kg {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, ib(e);
    const n = ms(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(n.length > s ? e.create().update(n).digest() : n);
    for (let o = 0; o < i.length; o++) i[o] ^= 54;
    this.iHash.update(i), this.oHash = e.create();
    for (let o = 0; o < i.length; o++) i[o] ^= 106;
    this.oHash.update(i), Wn(i);
  }
  update(e) {
    return Go(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Go(this), Vo(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: n, finished: s, destroyed: i, blockLen: o, outputLen: a } = this;
    return e = e, e.finished = s, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const Yg = (r, e, t) => new l2(r, e).update(t).digest();
Yg.create = (r, e) => new l2(r, e);
function XB(r, e, t) {
  return ib(r), t === void 0 && (t = new Uint8Array(r.outputLen)), Yg(r, ms(t), ms(e));
}
const Xm = Uint8Array.from([0]), $v = Uint8Array.of();
function e6(r, e, t, n = 32) {
  ib(r), Mi(n);
  const s = r.outputLen;
  if (n > 255 * s) throw new Error("Length should be <= 255*HashLen");
  const i = Math.ceil(n / s);
  t === void 0 && (t = $v);
  const o = new Uint8Array(i * s), a = Yg.create(r, e), c = a._cloneInto(), l = new Uint8Array(a.outputLen);
  for (let u = 0; u < i; u++) Xm[0] = u + 1, c.update(u === 0 ? $v : l).update(t).update(Xm).digestInto(l), o.set(l, s * u), a._cloneInto(c);
  return a.destroy(), c.destroy(), Wn(l, Xm), o.slice(0, n);
}
const t6 = (r, e, t, n, s) => e6(r, XB(r, e, t), n, s), Qg = Jg;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const lb = BigInt(0), Ey = BigInt(1);
function Cf(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function ub(r) {
  if (!Cf(r)) throw new Error("Uint8Array expected");
}
function _d(r, e) {
  if (typeof e != "boolean") throw new Error(r + " boolean expected, got " + e);
}
function np(r) {
  const e = r.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function u2(r) {
  if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
  return r === "" ? lb : BigInt("0x" + r);
}
const h2 = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", r6 = Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function Id(r) {
  if (ub(r), h2) return r.toHex();
  let e = "";
  for (let t = 0; t < r.length; t++) e += r6[r[t]];
  return e;
}
const ci = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Mv(r) {
  if (r >= ci._0 && r <= ci._9) return r - ci._0;
  if (r >= ci.A && r <= ci.F) return r - (ci.A - 10);
  if (r >= ci.a && r <= ci.f) return r - (ci.a - 10);
}
function sg(r) {
  if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
  if (h2) return Uint8Array.fromHex(r);
  const e = r.length, t = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(t);
  for (let s = 0, i = 0; s < t; s++, i += 2) {
    const o = Mv(r.charCodeAt(i)), a = Mv(r.charCodeAt(i + 1));
    if (o === void 0 || a === void 0) {
      const c = r[i] + r[i + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + i);
    }
    n[s] = o * 16 + a;
  }
  return n;
}
function rc(r) {
  return u2(Id(r));
}
function ig(r) {
  return ub(r), u2(Id(Uint8Array.from(r).reverse()));
}
function _f(r, e) {
  return sg(r.toString(16).padStart(e * 2, "0"));
}
function hb(r, e) {
  return _f(r, e).reverse();
}
function en(r, e, t) {
  let n;
  if (typeof e == "string") try {
    n = sg(e);
  } catch (i) {
    throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
  }
  else if (Cf(e)) n = Uint8Array.from(e);
  else throw new Error(r + " must be hex string or Uint8Array");
  const s = n.length;
  if (typeof t == "number" && s !== t) throw new Error(r + " of length " + t + " expected, got " + s);
  return n;
}
function og(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    ub(s), e += s.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    t.set(i, s), s += i.length;
  }
  return t;
}
const ew = (r) => typeof r == "bigint" && lb <= r;
function db(r, e, t) {
  return ew(r) && ew(e) && ew(t) && e <= r && r < t;
}
function Mo(r, e, t, n) {
  if (!db(e, t, n)) throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function n6(r) {
  let e;
  for (e = 0; r > lb; r >>= Ey, e += 1) ;
  return e;
}
const Zg = (r) => (Ey << BigInt(r)) - Ey, tw = (r) => new Uint8Array(r), jv = (r) => Uint8Array.from(r);
function s6(r, e, t) {
  if (typeof r != "number" || r < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof t != "function") throw new Error("hmacFn must be a function");
  let n = tw(r), s = tw(r), i = 0;
  const o = () => {
    n.fill(1), s.fill(0), i = 0;
  }, a = (...u) => t(s, n, ...u), c = (u = tw(0)) => {
    s = a(jv([0]), u), n = a(), u.length !== 0 && (s = a(jv([1]), u), n = a());
  }, l = () => {
    if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let u = 0;
    const h = [];
    for (; u < e; ) {
      n = a();
      const d = n.slice();
      h.push(d), u += n.length;
    }
    return og(...h);
  };
  return (u, h) => {
    o(), c(u);
    let d;
    for (; !(d = h(l())); ) c();
    return o(), d;
  };
}
const i6 = { bigint: (r) => typeof r == "bigint", function: (r) => typeof r == "function", boolean: (r) => typeof r == "boolean", string: (r) => typeof r == "string", stringOrUint8Array: (r) => typeof r == "string" || Cf(r), isSafeInteger: (r) => Number.isSafeInteger(r), array: (r) => Array.isArray(r), field: (r, e) => e.Fp.isValid(r), hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen) };
function If(r, e, t = {}) {
  const n = (s, i, o) => {
    const a = i6[i];
    if (typeof a != "function") throw new Error("invalid validator function");
    const c = r[s];
    if (!(o && c === void 0) && !a(c, r)) throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + c);
  };
  for (const [s, i] of Object.entries(e)) n(s, i, !1);
  for (const [s, i] of Object.entries(t)) n(s, i, !0);
  return r;
}
function Hv(r) {
  const e = /* @__PURE__ */ new WeakMap();
  return (t, ...n) => {
    const s = e.get(t);
    if (s !== void 0) return s;
    const i = r(t, ...n);
    return e.set(t, i), i;
  };
}
const an = BigInt(0), Fr = BigInt(1), Na = BigInt(2), o6 = BigInt(3), d2 = BigInt(4), f2 = BigInt(5), p2 = BigInt(8);
function nn(r, e) {
  const t = r % e;
  return t >= an ? t : e + t;
}
function Xn(r, e, t) {
  let n = r;
  for (; e-- > an; ) n *= n, n %= t;
  return n;
}
function vy(r, e) {
  if (r === an) throw new Error("invert: expected non-zero number");
  if (e <= an) throw new Error("invert: expected positive modulus, got " + e);
  let t = nn(r, e), n = e, s = an, i = Fr;
  for (; t !== an; ) {
    const o = n / t, a = n % t, c = s - i * o;
    n = t, t = a, s = i, i = c;
  }
  if (n !== Fr) throw new Error("invert: does not exist");
  return nn(s, e);
}
function g2(r, e) {
  const t = (r.ORDER + Fr) / d2, n = r.pow(e, t);
  if (!r.eql(r.sqr(n), e)) throw new Error("Cannot find square root");
  return n;
}
function a6(r, e) {
  const t = (r.ORDER - f2) / p2, n = r.mul(e, Na), s = r.pow(n, t), i = r.mul(e, s), o = r.mul(r.mul(i, Na), s), a = r.mul(i, r.sub(o, r.ONE));
  if (!r.eql(r.sqr(a), e)) throw new Error("Cannot find square root");
  return a;
}
function c6(r) {
  if (r < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e = r - Fr, t = 0;
  for (; e % Na === an; ) e /= Na, t++;
  let n = Na;
  const s = Sf(r);
  for (; zv(s, n) === 1; ) if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (t === 1) return g2;
  let i = s.pow(n, e);
  const o = (e + Fr) / Na;
  return function(a, c) {
    if (a.is0(c)) return c;
    if (zv(a, c) !== 1) throw new Error("Cannot find square root");
    let l = t, u = a.mul(a.ONE, i), h = a.pow(c, e), d = a.pow(c, o);
    for (; !a.eql(h, a.ONE); ) {
      if (a.is0(h)) return a.ZERO;
      let f = 1, g = a.sqr(h);
      for (; !a.eql(g, a.ONE); ) if (f++, g = a.sqr(g), f === l) throw new Error("Cannot find square root");
      const p = Fr << BigInt(l - f - 1), w = a.pow(u, p);
      l = f, u = a.sqr(w), h = a.mul(h, u), d = a.mul(d, w);
    }
    return d;
  };
}
function l6(r) {
  return r % d2 === o6 ? g2 : r % p2 === f2 ? a6 : c6(r);
}
const u6 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function h6(r) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, t = u6.reduce((n, s) => (n[s] = "function", n), e);
  return If(r, t);
}
function d6(r, e, t) {
  if (t < an) throw new Error("invalid exponent, negatives unsupported");
  if (t === an) return r.ONE;
  if (t === Fr) return e;
  let n = r.ONE, s = e;
  for (; t > an; ) t & Fr && (n = r.mul(n, s)), s = r.sqr(s), t >>= Fr;
  return n;
}
function m2(r, e, t = !1) {
  const n = new Array(e.length).fill(t ? r.ZERO : void 0), s = e.reduce((o, a, c) => r.is0(a) ? o : (n[c] = o, r.mul(o, a)), r.ONE), i = r.inv(s);
  return e.reduceRight((o, a, c) => r.is0(a) ? o : (n[c] = r.mul(o, n[c]), r.mul(o, a)), i), n;
}
function zv(r, e) {
  const t = (r.ORDER - Fr) / Na, n = r.pow(e, t), s = r.eql(n, r.ONE), i = r.eql(n, r.ZERO), o = r.eql(n, r.neg(r.ONE));
  if (!s && !i && !o) throw new Error("invalid Legendre symbol result");
  return s ? 1 : i ? 0 : -1;
}
function w2(r, e) {
  e !== void 0 && Mi(e);
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function Sf(r, e, t = !1, n = {}) {
  if (r <= an) throw new Error("invalid field: expected ORDER > 0, got " + r);
  const { nBitLength: s, nByteLength: i } = w2(r, e);
  if (i > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o;
  const a = Object.freeze({ ORDER: r, isLE: t, BITS: s, BYTES: i, MASK: Zg(s), ZERO: an, ONE: Fr, create: (c) => nn(c, r), isValid: (c) => {
    if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
    return an <= c && c < r;
  }, is0: (c) => c === an, isOdd: (c) => (c & Fr) === Fr, neg: (c) => nn(-c, r), eql: (c, l) => c === l, sqr: (c) => nn(c * c, r), add: (c, l) => nn(c + l, r), sub: (c, l) => nn(c - l, r), mul: (c, l) => nn(c * l, r), pow: (c, l) => d6(a, c, l), div: (c, l) => nn(c * vy(l, r), r), sqrN: (c) => c * c, addN: (c, l) => c + l, subN: (c, l) => c - l, mulN: (c, l) => c * l, inv: (c) => vy(c, r), sqrt: n.sqrt || ((c) => (o || (o = l6(r)), o(a, c))), toBytes: (c) => t ? hb(c, i) : _f(c, i), fromBytes: (c) => {
    if (c.length !== i) throw new Error("Field.fromBytes: expected " + i + " bytes, got " + c.length);
    return t ? ig(c) : rc(c);
  }, invertBatch: (c) => m2(a, c), cmov: (c, l, u) => u ? l : c });
  return Object.freeze(a);
}
function y2(r) {
  if (typeof r != "bigint") throw new Error("field order must be bigint");
  const e = r.toString(2).length;
  return Math.ceil(e / 8);
}
function b2(r) {
  const e = y2(r);
  return e + Math.ceil(e / 2);
}
function f6(r, e, t = !1) {
  const n = r.length, s = y2(e), i = b2(e);
  if (n < 16 || n < i || n > 1024) throw new Error("expected " + i + "-1024 bytes of input, got " + n);
  const o = t ? ig(r) : rc(r), a = nn(o, e - Fr) + Fr;
  return t ? hb(a, s) : _f(a, s);
}
const qv = BigInt(0), Ay = BigInt(1);
function rw(r, e) {
  const t = e.negate();
  return r ? t : e;
}
function E2(r, e) {
  if (!Number.isSafeInteger(r) || r <= 0 || r > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function nw(r, e) {
  E2(r, e);
  const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1), s = 2 ** r, i = Zg(r), o = BigInt(r);
  return { windows: t, windowSize: n, mask: i, maxNumber: s, shiftBy: o };
}
function Wv(r, e, t) {
  const { windowSize: n, mask: s, maxNumber: i, shiftBy: o } = t;
  let a = Number(r & s), c = r >> o;
  a > n && (a -= i, c += Ay);
  const l = e * n, u = l + Math.abs(a) - 1, h = a === 0, d = a < 0, f = e % 2 !== 0;
  return { nextN: c, offset: u, isZero: h, isNeg: d, isNegF: f, offsetF: l };
}
function p6(r, e) {
  if (!Array.isArray(r)) throw new Error("array expected");
  r.forEach((t, n) => {
    if (!(t instanceof e)) throw new Error("invalid point at index " + n);
  });
}
function g6(r, e) {
  if (!Array.isArray(r)) throw new Error("array of scalars expected");
  r.forEach((t, n) => {
    if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
  });
}
const sw = /* @__PURE__ */ new WeakMap(), v2 = /* @__PURE__ */ new WeakMap();
function iw(r) {
  return v2.get(r) || 1;
}
function m6(r, e) {
  return { constTimeNegate: rw, hasPrecomputes(t) {
    return iw(t) !== 1;
  }, unsafeLadder(t, n, s = r.ZERO) {
    let i = t;
    for (; n > qv; ) n & Ay && (s = s.add(i)), i = i.double(), n >>= Ay;
    return s;
  }, precomputeWindow(t, n) {
    const { windows: s, windowSize: i } = nw(n, e), o = [];
    let a = t, c = a;
    for (let l = 0; l < s; l++) {
      c = a, o.push(c);
      for (let u = 1; u < i; u++) c = c.add(a), o.push(c);
      a = c.double();
    }
    return o;
  }, wNAF(t, n, s) {
    let i = r.ZERO, o = r.BASE;
    const a = nw(t, e);
    for (let c = 0; c < a.windows; c++) {
      const { nextN: l, offset: u, isZero: h, isNeg: d, isNegF: f, offsetF: g } = Wv(s, c, a);
      s = l, h ? o = o.add(rw(f, n[g])) : i = i.add(rw(d, n[u]));
    }
    return { p: i, f: o };
  }, wNAFUnsafe(t, n, s, i = r.ZERO) {
    const o = nw(t, e);
    for (let a = 0; a < o.windows && s !== qv; a++) {
      const { nextN: c, offset: l, isZero: u, isNeg: h } = Wv(s, a, o);
      if (s = c, !u) {
        const d = n[l];
        i = i.add(h ? d.negate() : d);
      }
    }
    return i;
  }, getPrecomputes(t, n, s) {
    let i = sw.get(n);
    return i || (i = this.precomputeWindow(n, t), t !== 1 && sw.set(n, s(i))), i;
  }, wNAFCached(t, n, s) {
    const i = iw(t);
    return this.wNAF(i, this.getPrecomputes(i, t, s), n);
  }, wNAFCachedUnsafe(t, n, s, i) {
    const o = iw(t);
    return o === 1 ? this.unsafeLadder(t, n, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, s), n, i);
  }, setWindowSize(t, n) {
    E2(n, e), v2.set(t, n), sw.delete(t);
  } };
}
function w6(r, e, t, n) {
  p6(t, r), g6(n, e);
  const s = t.length, i = n.length;
  if (s !== i) throw new Error("arrays of points and scalars must have equal length");
  const o = r.ZERO, a = n6(BigInt(s));
  let c = 1;
  a > 12 ? c = a - 3 : a > 4 ? c = a - 2 : a > 0 && (c = 2);
  const l = Zg(c), u = new Array(Number(l) + 1).fill(o), h = Math.floor((e.BITS - 1) / c) * c;
  let d = o;
  for (let f = h; f >= 0; f -= c) {
    u.fill(o);
    for (let p = 0; p < i; p++) {
      const w = n[p], E = Number(w >> BigInt(f) & l);
      u[E] = u[E].add(t[p]);
    }
    let g = o;
    for (let p = u.length - 1, w = o; p > 0; p--) w = w.add(u[p]), g = g.add(w);
    if (d = d.add(g), f !== 0) for (let p = 0; p < c; p++) d = d.double();
  }
  return d;
}
function A2(r) {
  return h6(r.Fp), If(r, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...w2(r.n, r.nBitLength), ...r, p: r.Fp.ORDER });
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
const lh = BigInt(0), jc = BigInt(1), sp = BigInt(2);
function y6(r) {
  return If(r, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...r });
}
function b6(r) {
  const e = y6(r), { P: t, type: n, adjustScalarBytes: s, powPminus2: i } = e, o = n === "x25519";
  if (!o && n !== "x448") throw new Error("invalid type");
  const a = o ? 255 : 448, c = o ? 32 : 56, l = BigInt(o ? 9 : 5), u = BigInt(o ? 121665 : 39081), h = o ? sp ** BigInt(254) : sp ** BigInt(447), d = o ? BigInt(8) * sp ** BigInt(251) - jc : BigInt(4) * sp ** BigInt(445) - jc, f = h + d + jc, g = (O) => nn(O, t), p = w(l);
  function w(O) {
    return hb(g(O), c);
  }
  function E(O) {
    const k = en("u coordinate", O, c);
    return o && (k[31] &= 127), g(ig(k));
  }
  function I(O) {
    return ig(s(en("scalar", O, c)));
  }
  function A(O, k) {
    const P = x(E(k), I(O));
    if (P === lh) throw new Error("invalid private or public key received");
    return w(P);
  }
  function C(O) {
    return A(O, p);
  }
  function N(O, k, P) {
    const $ = g(O * (k - P));
    return k = g(k - $), P = g(P + $), { x_2: k, x_3: P };
  }
  function x(O, k) {
    Mo("u", O, lh, t), Mo("scalar", k, h, f);
    const P = k, $ = O;
    let U = jc, j = lh, H = O, ee = jc, y = lh;
    for (let T = BigInt(a - 1); T >= lh; T--) {
      const B = P >> T & jc;
      y ^= B, { x_2: U, x_3: H } = N(y, U, H), { x_2: j, x_3: ee } = N(y, j, ee), y = B;
      const R = U + j, L = g(R * R), q = U - j, Y = g(q * q), de = L - Y, ne = H + ee, we = H - ee, ke = g(we * R), xe = g(ne * q), Ve = ke + xe, Ne = ke - xe;
      H = g(Ve * Ve), ee = g($ * g(Ne * Ne)), U = g(L * Y), j = g(de * (L + g(u * de)));
    }
    ({ x_2: U, x_3: H } = N(y, U, H)), { x_2: j, x_3: ee } = N(y, j, ee);
    const b = i(j);
    return g(U * b);
  }
  return { scalarMult: A, scalarMultBase: C, getSharedSecret: (O, k) => A(O, k), getPublicKey: (O) => C(O), utils: { randomPrivateKey: () => e.randomBytes(c) }, GuBytes: p.slice() };
}
const Cy = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
const E6 = BigInt(1), Vv = BigInt(2), v6 = BigInt(3), A6 = BigInt(5);
BigInt(8);
function C6(r) {
  const e = BigInt(10), t = BigInt(20), n = BigInt(40), s = BigInt(80), i = Cy, o = r * r % i * r % i, a = Xn(o, Vv, i) * o % i, c = Xn(a, E6, i) * r % i, l = Xn(c, A6, i) * c % i, u = Xn(l, e, i) * l % i, h = Xn(u, t, i) * u % i, d = Xn(h, n, i) * h % i, f = Xn(d, s, i) * d % i, g = Xn(f, s, i) * d % i, p = Xn(g, e, i) * l % i;
  return { pow_p_5_8: Xn(p, Vv, i) * r % i, b2: o };
}
function _6(r) {
  return r[0] &= 248, r[31] &= 127, r[31] |= 64, r;
}
const _y = b6({ P: Cy, type: "x25519", powPminus2: (r) => {
  const e = Cy, { pow_p_5_8: t, b2: n } = C6(r);
  return nn(Xn(t, v6, e) * n, e);
}, adjustScalarBytes: _6, randomBytes: Wu });
function Gv(r) {
  r.lowS !== void 0 && _d("lowS", r.lowS), r.prehash !== void 0 && _d("prehash", r.prehash);
}
function I6(r) {
  const e = A2(r);
  If(e, { a: "field", b: "field" }, { allowInfinityPoint: "boolean", allowedPrivateKeyLengths: "array", clearCofactor: "function", fromBytes: "function", isTorsionFree: "function", toBytes: "function", wrapPrivateKey: "boolean" });
  const { endo: t, Fp: n, a: s } = e;
  if (t) {
    if (!n.eql(s, n.ZERO)) throw new Error("invalid endo: CURVE.a must be 0");
    if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function") throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  }
  return Object.freeze({ ...e });
}
class S6 extends Error {
  constructor(e = "") {
    super(e);
  }
}
const mi = { Err: S6, _tlv: { encode: (r, e) => {
  const { Err: t } = mi;
  if (r < 0 || r > 256) throw new t("tlv.encode: wrong tag");
  if (e.length & 1) throw new t("tlv.encode: unpadded data");
  const n = e.length / 2, s = np(n);
  if (s.length / 2 & 128) throw new t("tlv.encode: long form length too big");
  const i = n > 127 ? np(s.length / 2 | 128) : "";
  return np(r) + i + s + e;
}, decode(r, e) {
  const { Err: t } = mi;
  let n = 0;
  if (r < 0 || r > 256) throw new t("tlv.encode: wrong tag");
  if (e.length < 2 || e[n++] !== r) throw new t("tlv.decode: wrong tlv");
  const s = e[n++], i = !!(s & 128);
  let o = 0;
  if (!i) o = s;
  else {
    const c = s & 127;
    if (!c) throw new t("tlv.decode(long): indefinite length not supported");
    if (c > 4) throw new t("tlv.decode(long): byte length is too big");
    const l = e.subarray(n, n + c);
    if (l.length !== c) throw new t("tlv.decode: length bytes not complete");
    if (l[0] === 0) throw new t("tlv.decode(long): zero leftmost byte");
    for (const u of l) o = o << 8 | u;
    if (n += c, o < 128) throw new t("tlv.decode(long): not minimal encoding");
  }
  const a = e.subarray(n, n + o);
  if (a.length !== o) throw new t("tlv.decode: wrong value length");
  return { v: a, l: e.subarray(n + o) };
} }, _int: { encode(r) {
  const { Err: e } = mi;
  if (r < Oi) throw new e("integer: negative integers are not allowed");
  let t = np(r);
  if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return t;
}, decode(r) {
  const { Err: e } = mi;
  if (r[0] & 128) throw new e("invalid signature integer: negative");
  if (r[0] === 0 && !(r[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return rc(r);
} }, toSig(r) {
  const { Err: e, _int: t, _tlv: n } = mi, s = en("signature", r), { v: i, l: o } = n.decode(48, s);
  if (o.length) throw new e("invalid signature: left bytes after parsing");
  const { v: a, l: c } = n.decode(2, i), { v: l, l: u } = n.decode(2, c);
  if (u.length) throw new e("invalid signature: left bytes after parsing");
  return { r: t.decode(a), s: t.decode(l) };
}, hexFromSig(r) {
  const { _tlv: e, _int: t } = mi, n = e.encode(2, t.encode(r.r)), s = e.encode(2, t.encode(r.s)), i = n + s;
  return e.encode(48, i);
} };
function ow(r, e) {
  return Id(_f(r, e));
}
const Oi = BigInt(0), Yt = BigInt(1);
BigInt(2);
const aw = BigInt(3), N6 = BigInt(4);
function T6(r) {
  const e = I6(r), { Fp: t } = e, n = Sf(e.n, e.nBitLength), s = e.toBytes || ((A, C, N) => {
    const x = C.toAffine();
    return og(Uint8Array.from([4]), t.toBytes(x.x), t.toBytes(x.y));
  }), i = e.fromBytes || ((A) => {
    const C = A.subarray(1), N = t.fromBytes(C.subarray(0, t.BYTES)), x = t.fromBytes(C.subarray(t.BYTES, 2 * t.BYTES));
    return { x: N, y: x };
  });
  function o(A) {
    const { a: C, b: N } = e, x = t.sqr(A), O = t.mul(x, A);
    return t.add(t.add(O, t.mul(A, C)), N);
  }
  function a(A, C) {
    const N = t.sqr(C), x = o(A);
    return t.eql(N, x);
  }
  if (!a(e.Gx, e.Gy)) throw new Error("bad curve params: generator point");
  const c = t.mul(t.pow(e.a, aw), N6), l = t.mul(t.sqr(e.b), BigInt(27));
  if (t.is0(t.add(c, l))) throw new Error("bad curve params: a or b");
  function u(A) {
    return db(A, Yt, e.n);
  }
  function h(A) {
    const { allowedPrivateKeyLengths: C, nByteLength: N, wrapPrivateKey: x, n: O } = e;
    if (C && typeof A != "bigint") {
      if (Cf(A) && (A = Id(A)), typeof A != "string" || !C.includes(A.length)) throw new Error("invalid private key");
      A = A.padStart(N * 2, "0");
    }
    let k;
    try {
      k = typeof A == "bigint" ? A : rc(en("private key", A, N));
    } catch {
      throw new Error("invalid private key, expected hex or " + N + " bytes, got " + typeof A);
    }
    return x && (k = nn(k, O)), Mo("private key", k, Yt, O), k;
  }
  function d(A) {
    if (!(A instanceof p)) throw new Error("ProjectivePoint expected");
  }
  const f = Hv((A, C) => {
    const { px: N, py: x, pz: O } = A;
    if (t.eql(O, t.ONE)) return { x: N, y: x };
    const k = A.is0();
    C == null && (C = k ? t.ONE : t.inv(O));
    const P = t.mul(N, C), $ = t.mul(x, C), U = t.mul(O, C);
    if (k) return { x: t.ZERO, y: t.ZERO };
    if (!t.eql(U, t.ONE)) throw new Error("invZ was invalid");
    return { x: P, y: $ };
  }), g = Hv((A) => {
    if (A.is0()) {
      if (e.allowInfinityPoint && !t.is0(A.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: C, y: N } = A.toAffine();
    if (!t.isValid(C) || !t.isValid(N)) throw new Error("bad point: x or y not FE");
    if (!a(C, N)) throw new Error("bad point: equation left != right");
    if (!A.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class p {
    constructor(C, N, x) {
      if (C == null || !t.isValid(C)) throw new Error("x required");
      if (N == null || !t.isValid(N) || t.is0(N)) throw new Error("y required");
      if (x == null || !t.isValid(x)) throw new Error("z required");
      this.px = C, this.py = N, this.pz = x, Object.freeze(this);
    }
    static fromAffine(C) {
      const { x: N, y: x } = C || {};
      if (!C || !t.isValid(N) || !t.isValid(x)) throw new Error("invalid affine point");
      if (C instanceof p) throw new Error("projective point not allowed");
      const O = (k) => t.eql(k, t.ZERO);
      return O(N) && O(x) ? p.ZERO : new p(N, x, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(C) {
      const N = m2(t, C.map((x) => x.pz));
      return C.map((x, O) => x.toAffine(N[O])).map(p.fromAffine);
    }
    static fromHex(C) {
      const N = p.fromAffine(i(en("pointHex", C)));
      return N.assertValidity(), N;
    }
    static fromPrivateKey(C) {
      return p.BASE.multiply(h(C));
    }
    static msm(C, N) {
      return w6(p, n, C, N);
    }
    _setWindowSize(C) {
      I.setWindowSize(this, C);
    }
    assertValidity() {
      g(this);
    }
    hasEvenY() {
      const { y: C } = this.toAffine();
      if (t.isOdd) return !t.isOdd(C);
      throw new Error("Field doesn't support isOdd");
    }
    equals(C) {
      d(C);
      const { px: N, py: x, pz: O } = this, { px: k, py: P, pz: $ } = C, U = t.eql(t.mul(N, $), t.mul(k, O)), j = t.eql(t.mul(x, $), t.mul(P, O));
      return U && j;
    }
    negate() {
      return new p(this.px, t.neg(this.py), this.pz);
    }
    double() {
      const { a: C, b: N } = e, x = t.mul(N, aw), { px: O, py: k, pz: P } = this;
      let $ = t.ZERO, U = t.ZERO, j = t.ZERO, H = t.mul(O, O), ee = t.mul(k, k), y = t.mul(P, P), b = t.mul(O, k);
      return b = t.add(b, b), j = t.mul(O, P), j = t.add(j, j), $ = t.mul(C, j), U = t.mul(x, y), U = t.add($, U), $ = t.sub(ee, U), U = t.add(ee, U), U = t.mul($, U), $ = t.mul(b, $), j = t.mul(x, j), y = t.mul(C, y), b = t.sub(H, y), b = t.mul(C, b), b = t.add(b, j), j = t.add(H, H), H = t.add(j, H), H = t.add(H, y), H = t.mul(H, b), U = t.add(U, H), y = t.mul(k, P), y = t.add(y, y), H = t.mul(y, b), $ = t.sub($, H), j = t.mul(y, ee), j = t.add(j, j), j = t.add(j, j), new p($, U, j);
    }
    add(C) {
      d(C);
      const { px: N, py: x, pz: O } = this, { px: k, py: P, pz: $ } = C;
      let U = t.ZERO, j = t.ZERO, H = t.ZERO;
      const ee = e.a, y = t.mul(e.b, aw);
      let b = t.mul(N, k), T = t.mul(x, P), B = t.mul(O, $), R = t.add(N, x), L = t.add(k, P);
      R = t.mul(R, L), L = t.add(b, T), R = t.sub(R, L), L = t.add(N, O);
      let q = t.add(k, $);
      return L = t.mul(L, q), q = t.add(b, B), L = t.sub(L, q), q = t.add(x, O), U = t.add(P, $), q = t.mul(q, U), U = t.add(T, B), q = t.sub(q, U), H = t.mul(ee, L), U = t.mul(y, B), H = t.add(U, H), U = t.sub(T, H), H = t.add(T, H), j = t.mul(U, H), T = t.add(b, b), T = t.add(T, b), B = t.mul(ee, B), L = t.mul(y, L), T = t.add(T, B), B = t.sub(b, B), B = t.mul(ee, B), L = t.add(L, B), b = t.mul(T, L), j = t.add(j, b), b = t.mul(q, L), U = t.mul(R, U), U = t.sub(U, b), b = t.mul(R, T), H = t.mul(q, H), H = t.add(H, b), new p(U, j, H);
    }
    subtract(C) {
      return this.add(C.negate());
    }
    is0() {
      return this.equals(p.ZERO);
    }
    wNAF(C) {
      return I.wNAFCached(this, C, p.normalizeZ);
    }
    multiplyUnsafe(C) {
      const { endo: N, n: x } = e;
      Mo("scalar", C, Oi, x);
      const O = p.ZERO;
      if (C === Oi) return O;
      if (this.is0() || C === Yt) return this;
      if (!N || I.hasPrecomputes(this)) return I.wNAFCachedUnsafe(this, C, p.normalizeZ);
      let { k1neg: k, k1: P, k2neg: $, k2: U } = N.splitScalar(C), j = O, H = O, ee = this;
      for (; P > Oi || U > Oi; ) P & Yt && (j = j.add(ee)), U & Yt && (H = H.add(ee)), ee = ee.double(), P >>= Yt, U >>= Yt;
      return k && (j = j.negate()), $ && (H = H.negate()), H = new p(t.mul(H.px, N.beta), H.py, H.pz), j.add(H);
    }
    multiply(C) {
      const { endo: N, n: x } = e;
      Mo("scalar", C, Yt, x);
      let O, k;
      if (N) {
        const { k1neg: P, k1: $, k2neg: U, k2: j } = N.splitScalar(C);
        let { p: H, f: ee } = this.wNAF($), { p: y, f: b } = this.wNAF(j);
        H = I.constTimeNegate(P, H), y = I.constTimeNegate(U, y), y = new p(t.mul(y.px, N.beta), y.py, y.pz), O = H.add(y), k = ee.add(b);
      } else {
        const { p: P, f: $ } = this.wNAF(C);
        O = P, k = $;
      }
      return p.normalizeZ([O, k])[0];
    }
    multiplyAndAddUnsafe(C, N, x) {
      const O = p.BASE, k = ($, U) => U === Oi || U === Yt || !$.equals(O) ? $.multiplyUnsafe(U) : $.multiply(U), P = k(this, N).add(k(C, x));
      return P.is0() ? void 0 : P;
    }
    toAffine(C) {
      return f(this, C);
    }
    isTorsionFree() {
      const { h: C, isTorsionFree: N } = e;
      if (C === Yt) return !0;
      if (N) return N(p, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: C, clearCofactor: N } = e;
      return C === Yt ? this : N ? N(p, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(C = !0) {
      return _d("isCompressed", C), this.assertValidity(), s(p, this, C);
    }
    toHex(C = !0) {
      return _d("isCompressed", C), Id(this.toRawBytes(C));
    }
  }
  p.BASE = new p(e.Gx, e.Gy, t.ONE), p.ZERO = new p(t.ZERO, t.ONE, t.ZERO);
  const { endo: w, nBitLength: E } = e, I = m6(p, w ? Math.ceil(E / 2) : E);
  return { CURVE: e, ProjectivePoint: p, normPrivateKeyToScalar: h, weierstrassEquation: o, isWithinCurveOrder: u };
}
function x6(r) {
  const e = A2(r);
  return If(e, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: !0, ...e });
}
function O6(r) {
  const e = x6(r), { Fp: t, n, nByteLength: s, nBitLength: i } = e, o = t.BYTES + 1, a = 2 * t.BYTES + 1;
  function c(y) {
    return nn(y, n);
  }
  function l(y) {
    return vy(y, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: h, weierstrassEquation: d, isWithinCurveOrder: f } = T6({ ...e, toBytes(y, b, T) {
    const B = b.toAffine(), R = t.toBytes(B.x), L = og;
    return _d("isCompressed", T), T ? L(Uint8Array.from([b.hasEvenY() ? 2 : 3]), R) : L(Uint8Array.from([4]), R, t.toBytes(B.y));
  }, fromBytes(y) {
    const b = y.length, T = y[0], B = y.subarray(1);
    if (b === o && (T === 2 || T === 3)) {
      const R = rc(B);
      if (!db(R, Yt, t.ORDER)) throw new Error("Point is not on curve");
      const L = d(R);
      let q;
      try {
        q = t.sqrt(L);
      } catch (de) {
        const ne = de instanceof Error ? ": " + de.message : "";
        throw new Error("Point is not on curve" + ne);
      }
      const Y = (q & Yt) === Yt;
      return (T & 1) === 1 !== Y && (q = t.neg(q)), { x: R, y: q };
    } else if (b === a && T === 4) {
      const R = t.fromBytes(B.subarray(0, t.BYTES)), L = t.fromBytes(B.subarray(t.BYTES, 2 * t.BYTES));
      return { x: R, y: L };
    } else {
      const R = o, L = a;
      throw new Error("invalid Point, expected length of " + R + ", or uncompressed " + L + ", got " + b);
    }
  } });
  function g(y) {
    const b = n >> Yt;
    return y > b;
  }
  function p(y) {
    return g(y) ? c(-y) : y;
  }
  const w = (y, b, T) => rc(y.slice(b, T));
  class E {
    constructor(b, T, B) {
      Mo("r", b, Yt, n), Mo("s", T, Yt, n), this.r = b, this.s = T, B != null && (this.recovery = B), Object.freeze(this);
    }
    static fromCompact(b) {
      const T = s;
      return b = en("compactSignature", b, T * 2), new E(w(b, 0, T), w(b, T, 2 * T));
    }
    static fromDER(b) {
      const { r: T, s: B } = mi.toSig(en("DER", b));
      return new E(T, B);
    }
    assertValidity() {
    }
    addRecoveryBit(b) {
      return new E(this.r, this.s, b);
    }
    recoverPublicKey(b) {
      const { r: T, s: B, recovery: R } = this, L = O(en("msgHash", b));
      if (R == null || ![0, 1, 2, 3].includes(R)) throw new Error("recovery id invalid");
      const q = R === 2 || R === 3 ? T + e.n : T;
      if (q >= t.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const Y = R & 1 ? "03" : "02", de = u.fromHex(Y + ow(q, t.BYTES)), ne = l(q), we = c(-L * ne), ke = c(B * ne), xe = u.BASE.multiplyAndAddUnsafe(de, we, ke);
      if (!xe) throw new Error("point at infinify");
      return xe.assertValidity(), xe;
    }
    hasHighS() {
      return g(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new E(this.r, c(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return sg(this.toDERHex());
    }
    toDERHex() {
      return mi.hexFromSig(this);
    }
    toCompactRawBytes() {
      return sg(this.toCompactHex());
    }
    toCompactHex() {
      const b = s;
      return ow(this.r, b) + ow(this.s, b);
    }
  }
  const I = { isValidPrivateKey(y) {
    try {
      return h(y), !0;
    } catch {
      return !1;
    }
  }, normPrivateKeyToScalar: h, randomPrivateKey: () => {
    const y = b2(e.n);
    return f6(e.randomBytes(y), e.n);
  }, precompute(y = 8, b = u.BASE) {
    return b._setWindowSize(y), b.multiply(BigInt(3)), b;
  } };
  function A(y, b = !0) {
    return u.fromPrivateKey(y).toRawBytes(b);
  }
  function C(y) {
    if (typeof y == "bigint") return !1;
    if (y instanceof u) return !0;
    const b = en("key", y).length, T = t.BYTES, B = T + 1, R = 2 * T + 1;
    if (!(e.allowedPrivateKeyLengths || s === B)) return b === B || b === R;
  }
  function N(y, b, T = !0) {
    if (C(y) === !0) throw new Error("first arg must be private key");
    if (C(b) === !1) throw new Error("second arg must be public key");
    return u.fromHex(b).multiply(h(y)).toRawBytes(T);
  }
  const x = e.bits2int || function(y) {
    if (y.length > 8192) throw new Error("input is too large");
    const b = rc(y), T = y.length * 8 - i;
    return T > 0 ? b >> BigInt(T) : b;
  }, O = e.bits2int_modN || function(y) {
    return c(x(y));
  }, k = Zg(i);
  function P(y) {
    return Mo("num < 2^" + i, y, Oi, k), _f(y, s);
  }
  function $(y, b, T = U) {
    if (["recovered", "canonical"].some((Ne) => Ne in T)) throw new Error("sign() legacy options not supported");
    const { hash: B, randomBytes: R } = e;
    let { lowS: L, prehash: q, extraEntropy: Y } = T;
    L == null && (L = !0), y = en("msgHash", y), Gv(T), q && (y = en("prehashed msgHash", B(y)));
    const de = O(y), ne = h(b), we = [P(ne), P(de)];
    if (Y != null && Y !== !1) {
      const Ne = Y === !0 ? R(t.BYTES) : Y;
      we.push(en("extraEntropy", Ne));
    }
    const ke = og(...we), xe = de;
    function Ve(Ne) {
      const yt = x(Ne);
      if (!f(yt)) return;
      const Wt = l(yt), Bt = u.BASE.multiply(yt).toAffine(), It = c(Bt.x);
      if (It === Oi) return;
      const Rt = c(Wt * c(xe + It * ne));
      if (Rt === Oi) return;
      let Tn = (Bt.x === It ? 0 : 2) | Number(Bt.y & Yt), na = Rt;
      return L && g(Rt) && (na = p(Rt), Tn ^= 1), new E(It, na, Tn);
    }
    return { seed: ke, k2sig: Ve };
  }
  const U = { lowS: e.lowS, prehash: !1 }, j = { lowS: e.lowS, prehash: !1 };
  function H(y, b, T = U) {
    const { seed: B, k2sig: R } = $(y, b, T), L = e;
    return s6(L.hash.outputLen, L.nByteLength, L.hmac)(B, R);
  }
  u.BASE._setWindowSize(8);
  function ee(y, b, T, B = j) {
    var Rt;
    const R = y;
    b = en("msgHash", b), T = en("publicKey", T);
    const { lowS: L, prehash: q, format: Y } = B;
    if (Gv(B), "strict" in B) throw new Error("options.strict was renamed to lowS");
    if (Y !== void 0 && Y !== "compact" && Y !== "der") throw new Error("format must be compact or der");
    const de = typeof R == "string" || Cf(R), ne = !de && !Y && typeof R == "object" && R !== null && typeof R.r == "bigint" && typeof R.s == "bigint";
    if (!de && !ne) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let we, ke;
    try {
      if (ne && (we = new E(R.r, R.s)), de) {
        try {
          Y !== "compact" && (we = E.fromDER(R));
        } catch (Tn) {
          if (!(Tn instanceof mi.Err)) throw Tn;
        }
        !we && Y !== "der" && (we = E.fromCompact(R));
      }
      ke = u.fromHex(T);
    } catch {
      return !1;
    }
    if (!we || L && we.hasHighS()) return !1;
    q && (b = e.hash(b));
    const { r: xe, s: Ve } = we, Ne = O(b), yt = l(Ve), Wt = c(Ne * yt), Bt = c(xe * yt), It = (Rt = u.BASE.multiplyAndAddUnsafe(ke, Wt, Bt)) == null ? void 0 : Rt.toAffine();
    return It ? c(It.x) === xe : !1;
  }
  return { CURVE: e, getPublicKey: A, getSharedSecret: N, sign: H, verify: ee, ProjectivePoint: u, Signature: E, utils: I };
}
function P6(r) {
  return { hash: r, hmac: (e, ...t) => Yg(r, e, S4(...t)), randomBytes: Wu };
}
function fb(r, e) {
  const t = (n) => O6({ ...r, ...P6(n) });
  return { ...t(e), create: t };
}
const C2 = Sf(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")), R6 = C2.create(BigInt("-3")), D6 = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), k6 = fb({ a: R6, b: D6, Fp: C2, n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"), h: BigInt(1), lowS: !1 }, Jg), _2 = Sf(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff")), U6 = _2.create(BigInt("-3")), B6 = BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");
fb({ a: U6, b: B6, Fp: _2, n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"), h: BigInt(1), lowS: !1 }, J4);
const I2 = Sf(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")), L6 = I2.create(BigInt("-3")), F6 = BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");
fb({ a: L6, b: F6, Fp: I2, n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"), h: BigInt(1), lowS: !1, allowedPrivateKeyLengths: [130, 131, 132] }, K4);
const $6 = k6, S2 = "base10", $r = "base16", ps = "base64pad", wo = "base64url", Nf = "utf8", N2 = 0, Ui = 1, Tf = 2, M6 = 0, Kv = 1, Fh = 12, pb = 32;
function j6() {
  const r = _y.utils.randomPrivateKey(), e = _y.getPublicKey(r);
  return { privateKey: cn(r, $r), publicKey: cn(e, $r) };
}
function Iy() {
  const r = Wu(pb);
  return cn(r, $r);
}
function H6(r, e) {
  const t = _y.getSharedSecret(qn(r, $r), qn(e, $r)), n = t6(Qg, t, void 0, void 0, pb);
  return cn(n, $r);
}
function Tp(r) {
  const e = Qg(qn(r, $r));
  return cn(e, $r);
}
function zs(r) {
  const e = Qg(qn(r, Nf));
  return cn(e, $r);
}
function T2(r) {
  return qn(`${r}`, S2);
}
function fc(r) {
  return Number(cn(r, S2));
}
function x2(r) {
  return r.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function O2(r) {
  const e = r.replace(/-/g, "+").replace(/_/g, "/"), t = (4 - e.length % 4) % 4;
  return e + "=".repeat(t);
}
function z6(r) {
  const e = T2(typeof r.type < "u" ? r.type : N2);
  if (fc(e) === Ui && typeof r.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof r.senderPublicKey < "u" ? qn(r.senderPublicKey, $r) : void 0, n = typeof r.iv < "u" ? qn(r.iv, $r) : Wu(Fh), s = qn(r.symKey, $r), i = c2(s, n).encrypt(qn(r.message, Nf)), o = P2({ type: e, sealed: i, iv: n, senderPublicKey: t });
  return r.encoding === wo ? x2(o) : o;
}
function q6(r) {
  const e = qn(r.symKey, $r), { sealed: t, iv: n } = Sd({ encoded: r.encoded, encoding: r.encoding }), s = c2(e, n).decrypt(t);
  if (s === null) throw new Error("Failed to decrypt");
  return cn(s, Nf);
}
function W6(r, e) {
  const t = T2(Tf), n = Wu(Fh), s = qn(r, Nf), i = P2({ type: t, sealed: s, iv: n });
  return e === wo ? x2(i) : i;
}
function V6(r, e) {
  const { sealed: t } = Sd({ encoded: r, encoding: e });
  return cn(t, Nf);
}
function P2(r) {
  if (fc(r.type) === Tf) return cn(Lh([r.type, r.sealed]), ps);
  if (fc(r.type) === Ui) {
    if (typeof r.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return cn(Lh([r.type, r.senderPublicKey, r.iv, r.sealed]), ps);
  }
  return cn(Lh([r.type, r.iv, r.sealed]), ps);
}
function Sd(r) {
  const e = (r.encoding || ps) === wo ? O2(r.encoded) : r.encoded, t = qn(e, ps), n = t.slice(M6, Kv), s = Kv;
  if (fc(n) === Ui) {
    const c = s + pb, l = c + Fh, u = t.slice(s, c), h = t.slice(c, l), d = t.slice(l);
    return { type: n, sealed: d, iv: h, senderPublicKey: u };
  }
  if (fc(n) === Tf) {
    const c = t.slice(s), l = Wu(Fh);
    return { type: n, sealed: c, iv: l };
  }
  const i = s + Fh, o = t.slice(s, i), a = t.slice(i);
  return { type: n, sealed: a, iv: o };
}
function G6(r, e) {
  const t = Sd({ encoded: r, encoding: e == null ? void 0 : e.encoding });
  return R2({ type: fc(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? cn(t.senderPublicKey, $r) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function R2(r) {
  const e = (r == null ? void 0 : r.type) || N2;
  if (e === Ui) {
    if (typeof (r == null ? void 0 : r.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (r == null ? void 0 : r.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: r == null ? void 0 : r.senderPublicKey, receiverPublicKey: r == null ? void 0 : r.receiverPublicKey };
}
function Jv(r) {
  return r.type === Ui && typeof r.senderPublicKey == "string" && typeof r.receiverPublicKey == "string";
}
function Yv(r) {
  return r.type === Tf;
}
function K6(r) {
  const e = Buffer.from(r.x, "base64"), t = Buffer.from(r.y, "base64");
  return Lh([new Uint8Array([4]), e, t]);
}
function J6(r, e) {
  const [t, n, s] = r.split("."), i = Buffer.from(O2(s), "base64");
  if (i.length !== 64) throw new Error("Invalid signature length");
  const o = i.slice(0, 32), a = i.slice(32, 64), c = `${t}.${n}`, l = Qg(c), u = K6(e);
  if (!$6.verify(Lh([o, a]), l, u)) throw new Error("Invalid signature");
  return oy(r).payload;
}
const Y6 = "irn";
function ag(r) {
  return (r == null ? void 0 : r.relay) || { protocol: Y6 };
}
function Sh(r) {
  const e = T5[r];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${r}`);
  return e;
}
function Q6(r, e = "-") {
  const t = {}, n = "relay" + e;
  return Object.keys(r).forEach((s) => {
    if (s.startsWith(n)) {
      const i = s.replace(n, ""), o = r[s];
      t[i] = o;
    }
  }), t;
}
function Qv(r) {
  if (!r.includes("wc:")) {
    const l = qI(r);
    l != null && l.includes("wc:") && (r = l);
  }
  r = r.includes("wc://") ? r.replace("wc://", "") : r, r = r.includes("wc:") ? r.replace("wc:", "") : r;
  const e = r.indexOf(":"), t = r.indexOf("?") !== -1 ? r.indexOf("?") : void 0, n = r.substring(0, e), s = r.substring(e + 1, t).split("@"), i = typeof t < "u" ? r.substring(t) : "", o = new URLSearchParams(i), a = {};
  o.forEach((l, u) => {
    a[u] = l;
  });
  const c = typeof a.methods == "string" ? a.methods.split(",") : void 0;
  return { protocol: n, topic: Z6(s[0]), version: parseInt(s[1], 10), symKey: a.symKey, relay: Q6(a), methods: c, expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0 };
}
function Z6(r) {
  return r.startsWith("//") ? r.substring(2) : r;
}
function X6(r, e = "-") {
  const t = "relay", n = {};
  return Object.keys(r).forEach((s) => {
    const i = s, o = t + e + i;
    r[i] && (n[o] = r[i]);
  }), n;
}
function Zv(r) {
  const e = new URLSearchParams(), t = X6(r.relay);
  Object.keys(t).sort().forEach((s) => {
    e.set(s, t[s]);
  }), e.set("symKey", r.symKey), r.expiryTimestamp && e.set("expiryTimestamp", r.expiryTimestamp.toString()), r.methods && e.set("methods", r.methods.join(","));
  const n = e.toString();
  return `${r.protocol}:${r.topic}@${r.version}?${n}`;
}
function ip(r, e, t) {
  return `${r}?wc_ev=${t}&topic=${e}`;
}
var eL = Object.defineProperty, tL = Object.defineProperties, rL = Object.getOwnPropertyDescriptors, Xv = Object.getOwnPropertySymbols, nL = Object.prototype.hasOwnProperty, sL = Object.prototype.propertyIsEnumerable, e1 = (r, e, t) => e in r ? eL(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, iL = (r, e) => {
  for (var t in e || (e = {})) nL.call(e, t) && e1(r, t, e[t]);
  if (Xv) for (var t of Xv(e)) sL.call(e, t) && e1(r, t, e[t]);
  return r;
}, oL = (r, e) => tL(r, rL(e));
function Vu(r) {
  const e = [];
  return r.forEach((t) => {
    const [n, s] = t.split(":");
    e.push(`${n}:${s}`);
  }), e;
}
function aL(r) {
  const e = [];
  return Object.values(r).forEach((t) => {
    e.push(...Vu(t.accounts));
  }), e;
}
function cL(r, e) {
  const t = [];
  return Object.values(r).forEach((n) => {
    Vu(n.accounts).includes(e) && t.push(...n.methods);
  }), t;
}
function lL(r, e) {
  const t = [];
  return Object.values(r).forEach((n) => {
    Vu(n.accounts).includes(e) && t.push(...n.events);
  }), t;
}
function Xg(r) {
  return r.includes(":");
}
function dl(r) {
  return Xg(r) ? r.split(":")[0] : r;
}
function t1(r) {
  var e, t, n;
  const s = {};
  if (!jo(r)) return s;
  for (const [i, o] of Object.entries(r)) {
    const a = Xg(i) ? [i] : o.chains, c = o.methods || [], l = o.events || [], u = dl(i);
    s[u] = oL(iL({}, s[u]), { chains: Qs(a, (e = s[u]) == null ? void 0 : e.chains), methods: Qs(c, (t = s[u]) == null ? void 0 : t.methods), events: Qs(l, (n = s[u]) == null ? void 0 : n.events) });
  }
  return s;
}
function uL(r) {
  const e = {};
  return r == null || r.forEach((t) => {
    var n;
    const [s, i] = t.split(":");
    e[s] || (e[s] = { accounts: [], chains: [], events: [], methods: [] }), e[s].accounts.push(t), (n = e[s].chains) == null || n.push(`${s}:${i}`);
  }), e;
}
function r1(r, e) {
  e = e.map((n) => n.replace("did:pkh:", ""));
  const t = uL(e);
  for (const [n, s] of Object.entries(t)) s.methods ? s.methods = Qs(s.methods, r) : s.methods = r, s.events = ["chainChanged", "accountsChanged"];
  return t;
}
function hL(r, e) {
  var t, n, s, i, o, a;
  const c = t1(r), l = t1(e), u = {}, h = Object.keys(c).concat(Object.keys(l));
  for (const d of h) u[d] = { chains: Qs((t = c[d]) == null ? void 0 : t.chains, (n = l[d]) == null ? void 0 : n.chains), methods: Qs((s = c[d]) == null ? void 0 : s.methods, (i = l[d]) == null ? void 0 : i.methods), events: Qs((o = c[d]) == null ? void 0 : o.events, (a = l[d]) == null ? void 0 : a.events) };
  return u;
}
const dL = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, fL = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function Z(r, e) {
  const { message: t, code: n } = fL[r];
  return { message: e ? `${t} ${e}` : t, code: n };
}
function dt(r, e) {
  const { message: t, code: n } = dL[r];
  return { message: e ? `${t} ${e}` : t, code: n };
}
function Bi(r, e) {
  return !!Array.isArray(r);
}
function jo(r) {
  return Object.getPrototypeOf(r) === Object.prototype && Object.keys(r).length;
}
function lr(r) {
  return typeof r > "u";
}
function Ft(r, e) {
  return e && lr(r) ? !0 : typeof r == "string" && !!r.trim().length;
}
function gb(r, e) {
  return e && lr(r) ? !0 : typeof r == "number" && !isNaN(r);
}
function pL(r, e) {
  const { requiredNamespaces: t } = e, n = Object.keys(r.namespaces), s = Object.keys(t);
  let i = !0;
  return Sa(s, n) ? (n.forEach((o) => {
    const { accounts: a, methods: c, events: l } = r.namespaces[o], u = Vu(a), h = t[o];
    (!Sa($I(o, h), u) || !Sa(h.methods, c) || !Sa(h.events, l)) && (i = !1);
  }), i) : !1;
}
function cg(r) {
  return Ft(r, !1) && r.includes(":") ? r.split(":").length === 2 : !1;
}
function gL(r) {
  if (Ft(r, !1) && r.includes(":")) {
    const e = r.split(":");
    if (e.length === 3) {
      const t = e[0] + ":" + e[1];
      return !!e[2] && cg(t);
    }
  }
  return !1;
}
function mL(r) {
  function e(t) {
    try {
      return typeof new URL(t) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (Ft(r, !1)) {
      if (e(r)) return !0;
      const t = qI(r);
      return e(t);
    }
  } catch {
  }
  return !1;
}
function wL(r) {
  var e;
  return (e = r == null ? void 0 : r.proposer) == null ? void 0 : e.publicKey;
}
function yL(r) {
  return r == null ? void 0 : r.topic;
}
function bL(r, e) {
  let t = null;
  return Ft(r == null ? void 0 : r.publicKey, !1) || (t = Z("MISSING_OR_INVALID", `${e} controller public key should be a string`)), t;
}
function n1(r) {
  let e = !0;
  return Bi(r) ? r.length && (e = r.every((t) => Ft(t, !1))) : e = !1, e;
}
function EL(r, e, t) {
  let n = null;
  return Bi(e) && e.length ? e.forEach((s) => {
    n || cg(s) || (n = dt("UNSUPPORTED_CHAINS", `${t}, chain ${s} should be a string and conform to "namespace:chainId" format`));
  }) : cg(r) || (n = dt("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function vL(r, e, t) {
  let n = null;
  return Object.entries(r).forEach(([s, i]) => {
    if (n) return;
    const o = EL(s, $I(s, i), `${e} ${t}`);
    o && (n = o);
  }), n;
}
function AL(r, e) {
  let t = null;
  return Bi(r) ? r.forEach((n) => {
    t || gL(n) || (t = dt("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = dt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function CL(r, e) {
  let t = null;
  return Object.values(r).forEach((n) => {
    if (t) return;
    const s = AL(n == null ? void 0 : n.accounts, `${e} namespace`);
    s && (t = s);
  }), t;
}
function _L(r, e) {
  let t = null;
  return n1(r == null ? void 0 : r.methods) ? n1(r == null ? void 0 : r.events) || (t = dt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : t = dt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), t;
}
function D2(r, e) {
  let t = null;
  return Object.values(r).forEach((n) => {
    if (t) return;
    const s = _L(n, `${e}, namespace`);
    s && (t = s);
  }), t;
}
function IL(r, e, t) {
  let n = null;
  if (r && jo(r)) {
    const s = D2(r, e);
    s && (n = s);
    const i = vL(r, e, t);
    i && (n = i);
  } else n = Z("MISSING_OR_INVALID", `${e}, ${t} should be an object with data`);
  return n;
}
function cw(r, e) {
  let t = null;
  if (r && jo(r)) {
    const n = D2(r, e);
    n && (t = n);
    const s = CL(r, e);
    s && (t = s);
  } else t = Z("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return t;
}
function k2(r) {
  return Ft(r.protocol, !0);
}
function SL(r, e) {
  let t = !1;
  return r ? r && Bi(r) && r.length && r.forEach((n) => {
    t = k2(n);
  }) : t = !0, t;
}
function NL(r) {
  return typeof r == "number";
}
function Jr(r) {
  return typeof r < "u" && typeof r !== null;
}
function TL(r) {
  return !(!r || typeof r != "object" || !r.code || !gb(r.code, !1) || !r.message || !Ft(r.message, !1));
}
function xL(r) {
  return !(lr(r) || !Ft(r.method, !1));
}
function OL(r) {
  return !(lr(r) || lr(r.result) && lr(r.error) || !gb(r.id, !1) || !Ft(r.jsonrpc, !1));
}
function PL(r) {
  return !(lr(r) || !Ft(r.name, !1));
}
function s1(r, e) {
  return !(!cg(e) || !aL(r).includes(e));
}
function RL(r, e, t) {
  return Ft(t, !1) ? cL(r, e).includes(t) : !1;
}
function DL(r, e, t) {
  return Ft(t, !1) ? lL(r, e).includes(t) : !1;
}
function i1(r, e, t) {
  let n = null;
  const s = kL(r), i = UL(e), o = Object.keys(s), a = Object.keys(i), c = o1(Object.keys(r)), l = o1(Object.keys(e)), u = c.filter((h) => !l.includes(h));
  return u.length && (n = Z("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(e).toString()}`)), Sa(o, a) || (n = Z("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((h) => {
    if (!h.includes(":") || n) return;
    const d = Vu(e[h].accounts);
    d.includes(h) || (n = Z("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${h}
        Required: ${h}
        Approved: ${d.toString()}`));
  }), o.forEach((h) => {
    n || (Sa(s[h].methods, i[h].methods) ? Sa(s[h].events, i[h].events) || (n = Z("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${h}`)) : n = Z("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${h}`));
  }), n;
}
function kL(r) {
  const e = {};
  return Object.keys(r).forEach((t) => {
    var n;
    t.includes(":") ? e[t] = r[t] : (n = r[t].chains) == null || n.forEach((s) => {
      e[s] = { methods: r[t].methods, events: r[t].events };
    });
  }), e;
}
function o1(r) {
  return [...new Set(r.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function UL(r) {
  const e = {};
  return Object.keys(r).forEach((t) => {
    if (t.includes(":")) e[t] = r[t];
    else {
      const n = Vu(r[t].accounts);
      n == null || n.forEach((s) => {
        e[s] = { accounts: r[t].accounts.filter((i) => i.includes(`${s}:`)), methods: r[t].methods, events: r[t].events };
      });
    }
  }), e;
}
function BL(r, e) {
  return gb(r, !1) && r <= e.max && r >= e.min;
}
function a1() {
  const r = vf();
  return new Promise((e) => {
    switch (r) {
      case _n.browser:
        e(LL());
        break;
      case _n.reactNative:
        e(FL());
        break;
      case _n.node:
        e($L());
        break;
      default:
        e(!0);
    }
  });
}
function LL() {
  return qu() && (navigator == null ? void 0 : navigator.onLine);
}
async function FL() {
  if (ta() && typeof global < "u" && global != null && global.NetInfo) {
    const r = await (global == null ? void 0 : global.NetInfo.fetch());
    return r == null ? void 0 : r.isConnected;
  }
  return !0;
}
function $L() {
  return !0;
}
function ML(r) {
  switch (vf()) {
    case _n.browser:
      jL(r);
      break;
    case _n.reactNative:
      HL(r);
      break;
  }
}
function jL(r) {
  !ta() && qu() && (window.addEventListener("online", () => r(!0)), window.addEventListener("offline", () => r(!1)));
}
function HL(r) {
  ta() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => r(e == null ? void 0 : e.isConnected)));
}
function zL() {
  var r;
  return qu() && uc() ? ((r = uc()) == null ? void 0 : r.visibilityState) === "visible" : !0;
}
const lw = {};
class uh {
  static get(e) {
    return lw[e];
  }
  static set(e, t) {
    lw[e] = t;
  }
  static delete(e) {
    delete lw[e];
  }
}
function qL(r) {
  const e = zu.decode(r);
  if (e.length < 33) throw new Error("Too short to contain a public key");
  return e.slice(1, 33);
}
function WL({ publicKey: r, signature: e, payload: t }) {
  var n;
  const s = Sy(t.method), i = 128 | parseInt(((n = t.version) == null ? void 0 : n.toString()) || "4"), o = KL(t.address), a = t.era === "00" ? new Uint8Array([0]) : Sy(t.era);
  if (a.length !== 1 && a.length !== 2) throw new Error("Invalid era length");
  const c = parseInt(t.nonce, 16), l = new Uint8Array([c & 255, c >> 8 & 255]), u = BigInt(`0x${GL(t.tip)}`), h = YL(u), d = new Uint8Array([0, ...r, o, ...e, ...a, ...l, ...h, ...s]), f = JL(d.length + 1);
  return new Uint8Array([...f, i, ...d]);
}
function VL(r) {
  const e = Sy(r), t = M5.blake2b(e, void 0, 32);
  return "0x" + Buffer.from(t).toString("hex");
}
function Sy(r) {
  return new Uint8Array(r.replace(/^0x/, "").match(/.{1,2}/g).map((e) => parseInt(e, 16)));
}
function GL(r) {
  return r.startsWith("0x") ? r.slice(2) : r;
}
function KL(r) {
  const e = zu.decode(r)[0];
  return e === 42 ? 0 : e === 60 ? 2 : 1;
}
function JL(r) {
  if (r < 64) return new Uint8Array([r << 2]);
  if (r < 16384) {
    const e = r << 2 | 1;
    return new Uint8Array([e & 255, e >> 8 & 255]);
  } else if (r < 1 << 30) {
    const e = r << 2 | 2;
    return new Uint8Array([e & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function YL(r) {
  if (r < BigInt(1) << BigInt(6)) return new Uint8Array([Number(r << BigInt(2))]);
  if (r < BigInt(1) << BigInt(14)) {
    const e = r << BigInt(2) | BigInt(1);
    return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255))]);
  } else if (r < BigInt(1) << BigInt(30)) {
    const e = r << BigInt(2) | BigInt(2);
    return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255)), Number(e >> BigInt(16) & BigInt(255)), Number(e >> BigInt(24) & BigInt(255))]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function QL(r) {
  const e = Uint8Array.from(Buffer.from(r.signature, "hex")), t = qL(r.transaction.address), n = WL({ publicKey: t, signature: e, payload: r.transaction }), s = Buffer.from(n).toString("hex");
  return VL(s);
}
const ZL = "PARSE_ERROR", XL = "INVALID_REQUEST", eF = "METHOD_NOT_FOUND", tF = "INVALID_PARAMS", U2 = "INTERNAL_ERROR", mb = "SERVER_ERROR", rF = [-32700, -32600, -32601, -32602, -32603], $h = {
  [ZL]: { code: -32700, message: "Parse error" },
  [XL]: { code: -32600, message: "Invalid Request" },
  [eF]: { code: -32601, message: "Method not found" },
  [tF]: { code: -32602, message: "Invalid params" },
  [U2]: { code: -32603, message: "Internal error" },
  [mb]: { code: -32e3, message: "Server error" }
}, B2 = mb;
function nF(r) {
  return rF.includes(r);
}
function c1(r) {
  return Object.keys($h).includes(r) ? $h[r] : $h[B2];
}
function sF(r) {
  const e = Object.values($h).find((t) => t.code === r);
  return e || $h[B2];
}
function L2(r, e, t) {
  return r.message.includes("getaddrinfo ENOTFOUND") || r.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${t} RPC url at ${e}`) : r;
}
var F2 = {}, li = {}, l1;
function iF() {
  if (l1) return li;
  l1 = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.isBrowserCryptoAvailable = li.getSubtleCrypto = li.getBrowerCrypto = void 0;
  function r() {
    return (js == null ? void 0 : js.crypto) || (js == null ? void 0 : js.msCrypto) || {};
  }
  li.getBrowerCrypto = r;
  function e() {
    const n = r();
    return n.subtle || n.webkitSubtle;
  }
  li.getSubtleCrypto = e;
  function t() {
    return !!r() && !!e();
  }
  return li.isBrowserCryptoAvailable = t, li;
}
var ui = {}, u1;
function oF() {
  if (u1) return ui;
  u1 = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.isBrowser = ui.isNode = ui.isReactNative = void 0;
  function r() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  ui.isReactNative = r;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  ui.isNode = e;
  function t() {
    return !r() && !e();
  }
  return ui.isBrowser = t, ui;
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  const e = gf;
  e.__exportStar(iF(), r), e.__exportStar(oF(), r);
})(F2);
function Os(r = 3) {
  const e = Date.now() * Math.pow(10, r), t = Math.floor(Math.random() * Math.pow(10, r));
  return e + t;
}
function Ta(r = 6) {
  return BigInt(Os(r));
}
function Fo(r, e, t) {
  return {
    id: t || Os(),
    jsonrpc: "2.0",
    method: r,
    params: e
  };
}
function em(r, e) {
  return {
    id: r,
    jsonrpc: "2.0",
    result: e
  };
}
function tm(r, e, t) {
  return {
    id: r,
    jsonrpc: "2.0",
    error: aF(e)
  };
}
function aF(r, e) {
  return typeof r > "u" ? c1(U2) : (typeof r == "string" && (r = Object.assign(Object.assign({}, c1(mb)), { message: r })), nF(r.code) && (r = sF(r.code)), r);
}
let cF = class {
}, lF = class extends cF {
  constructor() {
    super();
  }
}, uF = class extends lF {
  constructor(e) {
    super();
  }
};
const hF = "^https?:", dF = "^wss?:";
function fF(r) {
  const e = r.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function $2(r, e) {
  const t = fF(r);
  return typeof t > "u" ? !1 : new RegExp(e).test(t);
}
function h1(r) {
  return $2(r, hF);
}
function d1(r) {
  return $2(r, dF);
}
function pF(r) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(r);
}
function M2(r) {
  return typeof r == "object" && "id" in r && "jsonrpc" in r && r.jsonrpc === "2.0";
}
function wb(r) {
  return M2(r) && "method" in r;
}
function rm(r) {
  return M2(r) && (Ps(r) || Hn(r));
}
function Ps(r) {
  return "result" in r;
}
function Hn(r) {
  return "error" in r;
}
let Gn = class extends uF {
  constructor(e) {
    super(e), this.events = new Vn.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async request(e, t) {
    return this.requestStrict(Fo(e.method, e.params || [], e.id || Ta().toString()), t);
  }
  async requestStrict(e, t) {
    return new Promise(async (n, s) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (i) {
        s(i);
      }
      this.events.on(`${e.id}`, (i) => {
        Hn(i) ? s(i.error) : n(i.result);
      });
      try {
        await this.connection.send(e, t);
      } catch (i) {
        s(i);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), rm(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const gF = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), mF = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", f1 = (r) => r.split("?")[0], p1 = 10, wF = gF();
let yF = class {
  constructor(e) {
    if (this.url = e, this.events = new Vn.EventEmitter(), this.registering = !1, !d1(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send($i(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!d1(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n, s) => {
        this.events.once("register_error", (i) => {
          this.resetMaxListeners(), s(i);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return s(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((t, n) => {
      const s = F2.isReactNative() ? void 0 : { rejectUnauthorized: !pF(e) }, i = new wF(e, [], s);
      mF() ? i.onerror = (o) => {
        const a = o;
        n(this.emitError(a.error));
      } : i.on("error", (o) => {
        n(this.emitError(o));
      }), i.onopen = () => {
        this.onOpen(i), t(i);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? lc(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n = this.parseError(t), s = n.message || n.toString(), i = tm(e, s);
    this.events.emit("payload", i);
  }
  parseError(e, t = this.url) {
    return L2(e, f1(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > p1 && this.events.setMaxListeners(p1);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${f1(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};
const j2 = "wc", H2 = 2, Ny = "core", ei = `${j2}@2:${Ny}:`, bF = { logger: "error" }, EF = { database: ":memory:" }, vF = "crypto", g1 = "client_ed25519_seed", AF = Q.ONE_DAY, CF = "keychain", _F = "0.3", IF = "messages", SF = "0.3", m1 = Q.SIX_HOURS, NF = "publisher", z2 = "irn", TF = "error", q2 = "wss://relay.walletconnect.org", xF = "relayer", Zt = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, OF = "_subscription", Pn = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, PF = 0.1, Ty = "2.21.2", Ct = { link_mode: "link_mode", relay: "relay" }, xp = { inbound: "inbound", outbound: "outbound" }, RF = "0.3", DF = "WALLETCONNECT_CLIENT_ID", w1 = "WALLETCONNECT_LINK_MODE_APPS", mn = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, kF = "subscription", UF = "0.3", BF = "pairing", LF = "0.3", hh = { wc_pairingDelete: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 0 } } }, ya = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, Yn = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, FF = "history", $F = "0.3", MF = "expirer", Un = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, jF = "0.3", HF = "verify-api", zF = "https://verify.walletconnect.com", W2 = "https://verify.walletconnect.org", Mh = W2, qF = `${Mh}/v3`, WF = [zF, W2], VF = "echo", GF = "https://echo.walletconnect.com", xs = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" }, di = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" }, Qn = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, aa = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, ca = { authenticated_session_approve_started: "authenticated_session_approve_started", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve" }, dh = { no_internet_connection: "no_internet_connection", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, KF = 0.1, JF = "event-client", YF = 86400, QF = "https://pulse.walletconnect.org/batch";
function ZF(r, e) {
  if (r.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var s = 0; s < r.length; s++) {
    var i = r.charAt(s), o = i.charCodeAt(0);
    if (t[o] !== 255) throw new TypeError(i + " is ambiguous");
    t[o] = s;
  }
  var a = r.length, c = r.charAt(0), l = Math.log(a) / Math.log(256), u = Math.log(256) / Math.log(a);
  function h(g) {
    if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (g.length === 0) return "";
    for (var p = 0, w = 0, E = 0, I = g.length; E !== I && g[E] === 0; ) E++, p++;
    for (var A = (I - E) * u + 1 >>> 0, C = new Uint8Array(A); E !== I; ) {
      for (var N = g[E], x = 0, O = A - 1; (N !== 0 || x < w) && O !== -1; O--, x++) N += 256 * C[O] >>> 0, C[O] = N % a >>> 0, N = N / a >>> 0;
      if (N !== 0) throw new Error("Non-zero carry");
      w = x, E++;
    }
    for (var k = A - w; k !== A && C[k] === 0; ) k++;
    for (var P = c.repeat(p); k < A; ++k) P += r.charAt(C[k]);
    return P;
  }
  function d(g) {
    if (typeof g != "string") throw new TypeError("Expected String");
    if (g.length === 0) return new Uint8Array();
    var p = 0;
    if (g[p] !== " ") {
      for (var w = 0, E = 0; g[p] === c; ) w++, p++;
      for (var I = (g.length - p) * l + 1 >>> 0, A = new Uint8Array(I); g[p]; ) {
        var C = t[g.charCodeAt(p)];
        if (C === 255) return;
        for (var N = 0, x = I - 1; (C !== 0 || N < E) && x !== -1; x--, N++) C += a * A[x] >>> 0, A[x] = C % 256 >>> 0, C = C / 256 >>> 0;
        if (C !== 0) throw new Error("Non-zero carry");
        E = N, p++;
      }
      if (g[p] !== " ") {
        for (var O = I - E; O !== I && A[O] === 0; ) O++;
        for (var k = new Uint8Array(w + (I - O)), P = w; O !== I; ) k[P++] = A[O++];
        return k;
      }
    }
  }
  function f(g) {
    var p = d(g);
    if (p) return p;
    throw new Error(`Non-${e} character`);
  }
  return { encode: h, decodeUnsafe: d, decode: f };
}
var XF = ZF, e$ = XF;
const V2 = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array") return r;
  if (r instanceof ArrayBuffer) return new Uint8Array(r);
  if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
}, t$ = (r) => new TextEncoder().encode(r), r$ = (r) => new TextDecoder().decode(r);
class n$ {
  constructor(e, t, n) {
    this.name = e, this.prefix = t, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class s$ {
  constructor(e, t, n) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return G2(this, e);
  }
}
class i$ {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return G2(this, e);
  }
  decode(e) {
    const t = e[0], n = this.decoders[t];
    if (n) return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const G2 = (r, e) => new i$({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
class o$ {
  constructor(e, t, n, s) {
    this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new n$(e, t, n), this.decoder = new s$(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const nm = ({ name: r, prefix: e, encode: t, decode: n }) => new o$(r, e, t, n), xf = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: n, decode: s } = e$(t, e);
  return nm({ prefix: r, name: e, encode: n, decode: (i) => V2(s(i)) });
}, a$ = (r, e, t, n) => {
  const s = {};
  for (let u = 0; u < e.length; ++u) s[e[u]] = u;
  let i = r.length;
  for (; r[i - 1] === "="; ) --i;
  const o = new Uint8Array(i * t / 8 | 0);
  let a = 0, c = 0, l = 0;
  for (let u = 0; u < i; ++u) {
    const h = s[r[u]];
    if (h === void 0) throw new SyntaxError(`Non-${n} character`);
    c = c << t | h, a += t, a >= 8 && (a -= 8, o[l++] = 255 & c >> a);
  }
  if (a >= t || 255 & c << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o;
}, c$ = (r, e, t) => {
  const n = e[e.length - 1] === "=", s = (1 << t) - 1;
  let i = "", o = 0, a = 0;
  for (let c = 0; c < r.length; ++c) for (a = a << 8 | r[c], o += 8; o > t; ) o -= t, i += e[s & a >> o];
  if (o && (i += e[s & a << t - o]), n) for (; i.length * t & 7; ) i += "=";
  return i;
}, mr = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => nm({ prefix: e, name: r, encode(s) {
  return c$(s, n, t);
}, decode(s) {
  return a$(s, n, t, r);
} }), l$ = nm({ prefix: "\0", name: "identity", encode: (r) => r$(r), decode: (r) => t$(r) });
var u$ = Object.freeze({ __proto__: null, identity: l$ });
const h$ = mr({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var d$ = Object.freeze({ __proto__: null, base2: h$ });
const f$ = mr({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var p$ = Object.freeze({ __proto__: null, base8: f$ });
const g$ = xf({ prefix: "9", name: "base10", alphabet: "0123456789" });
var m$ = Object.freeze({ __proto__: null, base10: g$ });
const w$ = mr({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), y$ = mr({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var b$ = Object.freeze({ __proto__: null, base16: w$, base16upper: y$ });
const E$ = mr({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), v$ = mr({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), A$ = mr({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), C$ = mr({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), _$ = mr({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), I$ = mr({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), S$ = mr({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), N$ = mr({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), T$ = mr({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var x$ = Object.freeze({ __proto__: null, base32: E$, base32upper: v$, base32pad: A$, base32padupper: C$, base32hex: _$, base32hexupper: I$, base32hexpad: S$, base32hexpadupper: N$, base32z: T$ });
const O$ = xf({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), P$ = xf({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var R$ = Object.freeze({ __proto__: null, base36: O$, base36upper: P$ });
const D$ = xf({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), k$ = xf({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var U$ = Object.freeze({ __proto__: null, base58btc: D$, base58flickr: k$ });
const B$ = mr({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), L$ = mr({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), F$ = mr({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), $$ = mr({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var M$ = Object.freeze({ __proto__: null, base64: B$, base64pad: L$, base64url: F$, base64urlpad: $$ });
const K2 = Array.from(""), j$ = K2.reduce((r, e, t) => (r[t] = e, r), []), H$ = K2.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function z$(r) {
  return r.reduce((e, t) => (e += j$[t], e), "");
}
function q$(r) {
  const e = [];
  for (const t of r) {
    const n = H$[t.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const W$ = nm({ prefix: "", name: "base256emoji", encode: z$, decode: q$ });
var V$ = Object.freeze({ __proto__: null, base256emoji: W$ }), G$ = J2, y1 = 128, K$ = -128, J$ = Math.pow(2, 31);
function J2(r, e, t) {
  e = e || [], t = t || 0;
  for (var n = t; r >= J$; ) e[t++] = r & 255 | y1, r /= 128;
  for (; r & K$; ) e[t++] = r & 255 | y1, r >>>= 7;
  return e[t] = r | 0, J2.bytes = t - n + 1, e;
}
var Y$ = xy, Q$ = 128, b1 = 127;
function xy(r, n) {
  var t = 0, n = n || 0, s = 0, i = n, o, a = r.length;
  do {
    if (i >= a) throw xy.bytes = 0, new RangeError("Could not decode varint");
    o = r[i++], t += s < 28 ? (o & b1) << s : (o & b1) * Math.pow(2, s), s += 7;
  } while (o >= Q$);
  return xy.bytes = i - n, t;
}
var Z$ = Math.pow(2, 7), X$ = Math.pow(2, 14), eM = Math.pow(2, 21), tM = Math.pow(2, 28), rM = Math.pow(2, 35), nM = Math.pow(2, 42), sM = Math.pow(2, 49), iM = Math.pow(2, 56), oM = Math.pow(2, 63), aM = function(r) {
  return r < Z$ ? 1 : r < X$ ? 2 : r < eM ? 3 : r < tM ? 4 : r < rM ? 5 : r < nM ? 6 : r < sM ? 7 : r < iM ? 8 : r < oM ? 9 : 10;
}, cM = { encode: G$, decode: Y$, encodingLength: aM }, Y2 = cM;
const E1 = (r, e, t = 0) => (Y2.encode(r, e, t), e), v1 = (r) => Y2.encodingLength(r), Oy = (r, e) => {
  const t = e.byteLength, n = v1(r), s = n + v1(t), i = new Uint8Array(s + t);
  return E1(r, i, 0), E1(t, i, n), i.set(e, s), new lM(r, t, e, i);
};
class lM {
  constructor(e, t, n, s) {
    this.code = e, this.size = t, this.digest = n, this.bytes = s;
  }
}
const Q2 = ({ name: r, code: e, encode: t }) => new uM(r, e, t);
class uM {
  constructor(e, t, n) {
    this.name = e, this.code = t, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Oy(this.code, t) : t.then((n) => Oy(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
}
const Z2 = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e)), hM = Q2({ name: "sha2-256", code: 18, encode: Z2("SHA-256") }), dM = Q2({ name: "sha2-512", code: 19, encode: Z2("SHA-512") });
var fM = Object.freeze({ __proto__: null, sha256: hM, sha512: dM });
const X2 = 0, pM = "identity", eS = V2, gM = (r) => Oy(X2, eS(r)), mM = { code: X2, name: pM, encode: eS, digest: gM };
var wM = Object.freeze({ __proto__: null, identity: mM });
new TextEncoder(), new TextDecoder();
const A1 = { ...u$, ...d$, ...p$, ...m$, ...b$, ...x$, ...R$, ...U$, ...M$, ...V$ };
({ ...fM, ...wM });
function tS(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function yM(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? tS(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function rS(r, e, t, n) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: n } };
}
const C1 = rS("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1))), uw = rS("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = yM(r.length);
  for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);
  return e;
}), bM = { utf8: C1, "utf-8": C1, hex: A1.base16, latin1: uw, ascii: uw, binary: uw, ...A1 };
function EM(r, e = "utf8") {
  const t = bM[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? tS(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var vM = Object.defineProperty, AM = (r, e, t) => e in r ? vM(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Ss = (r, e, t) => AM(r, typeof e != "symbol" ? e + "" : e, t);
class CM {
  constructor(e, t) {
    this.core = e, this.logger = t, Ss(this, "keychain", /* @__PURE__ */ new Map()), Ss(this, "name", CF), Ss(this, "version", _F), Ss(this, "initialized", !1), Ss(this, "storagePrefix", ei), Ss(this, "init", async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }), Ss(this, "has", (n) => (this.isInitialized(), this.keychain.has(n))), Ss(this, "set", async (n, s) => {
      this.isInitialized(), this.keychain.set(n, s), await this.persist();
    }), Ss(this, "get", (n) => {
      this.isInitialized();
      const s = this.keychain.get(n);
      if (typeof s > "u") {
        const { message: i } = Z("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(i);
      }
      return s;
    }), Ss(this, "del", async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }), this.core = e, this.logger = xr(t, this.name);
  }
  get context() {
    return dn(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, fy(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? py(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var _M = Object.defineProperty, IM = (r, e, t) => e in r ? _M(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, ir = (r, e, t) => IM(r, typeof e != "symbol" ? e + "" : e, t);
class SM {
  constructor(e, t, n) {
    this.core = e, this.logger = t, ir(this, "name", vF), ir(this, "keychain"), ir(this, "randomSessionIdentifier", Iy()), ir(this, "initialized", !1), ir(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }), ir(this, "hasKeys", (s) => (this.isInitialized(), this.keychain.has(s))), ir(this, "getClientId", async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), i = nv(s);
      return rI(i.publicKey);
    }), ir(this, "generateKeyPair", () => {
      this.isInitialized();
      const s = j6();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }), ir(this, "signJWT", async (s) => {
      this.isInitialized();
      const i = await this.getClientSeed(), o = nv(i), a = this.randomSessionIdentifier;
      return await Yk(a, s, AF, o);
    }), ir(this, "generateSharedKey", (s, i, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(s), c = H6(a, i);
      return this.setSymKey(c, o);
    }), ir(this, "setSymKey", async (s, i) => {
      this.isInitialized();
      const o = i || Tp(s);
      return await this.keychain.set(o, s), o;
    }), ir(this, "deleteKeyPair", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), ir(this, "deleteSymKey", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), ir(this, "encode", async (s, i, o) => {
      this.isInitialized();
      const a = R2(o), c = $i(i);
      if (Yv(a)) return W6(c, o == null ? void 0 : o.encoding);
      if (Jv(a)) {
        const d = a.senderPublicKey, f = a.receiverPublicKey;
        s = await this.generateSharedKey(d, f);
      }
      const l = this.getSymKey(s), { type: u, senderPublicKey: h } = a;
      return z6({ type: u, symKey: l, message: c, senderPublicKey: h, encoding: o == null ? void 0 : o.encoding });
    }), ir(this, "decode", async (s, i, o) => {
      this.isInitialized();
      const a = G6(i, o);
      if (Yv(a)) {
        const c = V6(i, o == null ? void 0 : o.encoding);
        return lc(c);
      }
      if (Jv(a)) {
        const c = a.receiverPublicKey, l = a.senderPublicKey;
        s = await this.generateSharedKey(c, l);
      }
      try {
        const c = this.getSymKey(s), l = q6({ symKey: c, encoded: i, encoding: o == null ? void 0 : o.encoding });
        return lc(l);
      } catch (c) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(c);
      }
    }), ir(this, "getPayloadType", (s, i = ps) => {
      const o = Sd({ encoded: s, encoding: i });
      return fc(o.type);
    }), ir(this, "getPayloadSenderPublicKey", (s, i = ps) => {
      const o = Sd({ encoded: s, encoding: i });
      return o.senderPublicKey ? cn(o.senderPublicKey, $r) : void 0;
    }), this.core = e, this.logger = xr(t, this.name), this.keychain = n || new CM(this.core, this.logger);
  }
  get context() {
    return dn(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(g1);
    } catch {
      e = Iy(), await this.keychain.set(g1, e);
    }
    return EM(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var NM = Object.defineProperty, TM = Object.defineProperties, xM = Object.getOwnPropertyDescriptors, _1 = Object.getOwnPropertySymbols, OM = Object.prototype.hasOwnProperty, PM = Object.prototype.propertyIsEnumerable, Py = (r, e, t) => e in r ? NM(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, RM = (r, e) => {
  for (var t in e || (e = {})) OM.call(e, t) && Py(r, t, e[t]);
  if (_1) for (var t of _1(e)) PM.call(e, t) && Py(r, t, e[t]);
  return r;
}, DM = (r, e) => TM(r, xM(e)), pn = (r, e, t) => Py(r, typeof e != "symbol" ? e + "" : e, t);
class kM extends KR {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, pn(this, "messages", /* @__PURE__ */ new Map()), pn(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), pn(this, "name", IF), pn(this, "version", SF), pn(this, "initialized", !1), pn(this, "storagePrefix", ei), pn(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n);
          const s = await this.getRelayerMessagesWithoutClientAck();
          typeof s < "u" && (this.messagesWithoutClientAck = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }), pn(this, "set", async (n, s, i) => {
      this.isInitialized();
      const o = zs(s);
      let a = this.messages.get(n);
      if (typeof a > "u" && (a = {}), typeof a[o] < "u") return o;
      if (a[o] = s, this.messages.set(n, a), i === xp.inbound) {
        const c = this.messagesWithoutClientAck.get(n) || {};
        this.messagesWithoutClientAck.set(n, DM(RM({}, c), { [o]: s }));
      }
      return await this.persist(), o;
    }), pn(this, "get", (n) => {
      this.isInitialized();
      let s = this.messages.get(n);
      return typeof s > "u" && (s = {}), s;
    }), pn(this, "getWithoutAck", (n) => {
      this.isInitialized();
      const s = {};
      for (const i of n) {
        const o = this.messagesWithoutClientAck.get(i) || {};
        s[i] = Object.values(o);
      }
      return s;
    }), pn(this, "has", (n, s) => {
      this.isInitialized();
      const i = this.get(n), o = zs(s);
      return typeof i[o] < "u";
    }), pn(this, "ack", async (n, s) => {
      this.isInitialized();
      const i = this.messagesWithoutClientAck.get(n);
      if (typeof i > "u") return;
      const o = zs(s);
      delete i[o], Object.keys(i).length === 0 ? this.messagesWithoutClientAck.delete(n) : this.messagesWithoutClientAck.set(n, i), await this.persist();
    }), pn(this, "del", async (n) => {
      this.isInitialized(), this.messages.delete(n), this.messagesWithoutClientAck.delete(n), await this.persist();
    }), this.logger = xr(e, this.name), this.core = t;
  }
  get context() {
    return dn(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, fy(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, fy(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? py(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? py(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var UM = Object.defineProperty, BM = Object.defineProperties, LM = Object.getOwnPropertyDescriptors, I1 = Object.getOwnPropertySymbols, FM = Object.prototype.hasOwnProperty, $M = Object.prototype.propertyIsEnumerable, Ry = (r, e, t) => e in r ? UM(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, op = (r, e) => {
  for (var t in e || (e = {})) FM.call(e, t) && Ry(r, t, e[t]);
  if (I1) for (var t of I1(e)) $M.call(e, t) && Ry(r, t, e[t]);
  return r;
}, hw = (r, e) => BM(r, LM(e)), Zn = (r, e, t) => Ry(r, typeof e != "symbol" ? e + "" : e, t);
class MM extends JR {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, Zn(this, "events", new Vn.EventEmitter()), Zn(this, "name", NF), Zn(this, "queue", /* @__PURE__ */ new Map()), Zn(this, "publishTimeout", Q.toMiliseconds(Q.ONE_MINUTE)), Zn(this, "initialPublishTimeout", Q.toMiliseconds(Q.ONE_SECOND * 15)), Zn(this, "needsTransportRestart", !1), Zn(this, "publish", async (n, s, i) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: s, opts: i } });
      const a = (i == null ? void 0 : i.ttl) || m1, c = ag(i), l = (i == null ? void 0 : i.prompt) || !1, u = (i == null ? void 0 : i.tag) || 0, h = (i == null ? void 0 : i.id) || Ta().toString(), d = { topic: n, message: s, opts: { ttl: a, relay: c, prompt: l, tag: u, id: h, attestation: i == null ? void 0 : i.attestation, tvf: i == null ? void 0 : i.tvf } }, f = `Failed to publish payload, please try again. id:${h} tag:${u}`;
      try {
        const g = new Promise(async (p) => {
          const w = ({ id: I }) => {
            d.opts.id === I && (this.removeRequestFromQueue(I), this.relayer.events.removeListener(Zt.publish, w), p(d));
          };
          this.relayer.events.on(Zt.publish, w);
          const E = Lo(new Promise((I, A) => {
            this.rpcPublish({ topic: n, message: s, ttl: a, prompt: l, tag: u, id: h, attestation: i == null ? void 0 : i.attestation, tvf: i == null ? void 0 : i.tvf }).then(I).catch((C) => {
              this.logger.warn(C, C == null ? void 0 : C.message), A(C);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${h} tag:${u}`);
          try {
            await E, this.events.removeListener(Zt.publish, w);
          } catch (I) {
            this.queue.set(h, hw(op({}, d), { attempt: 1 })), this.logger.warn(I, I == null ? void 0 : I.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: h, topic: n, message: s, opts: i } }), await Lo(g, this.publishTimeout, f);
      } catch (g) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(g), (o = i == null ? void 0 : i.internal) != null && o.throwOnFailedPublish) throw g;
      } finally {
        this.queue.delete(h);
      }
    }), Zn(this, "on", (n, s) => {
      this.events.on(n, s);
    }), Zn(this, "once", (n, s) => {
      this.events.once(n, s);
    }), Zn(this, "off", (n, s) => {
      this.events.off(n, s);
    }), Zn(this, "removeListener", (n, s) => {
      this.events.removeListener(n, s);
    }), this.relayer = e, this.logger = xr(t, this.name), this.registerEventListeners();
  }
  get context() {
    return dn(this.logger);
  }
  async rpcPublish(e) {
    var t, n, s, i;
    const { topic: o, message: a, ttl: c = m1, prompt: l, tag: u, id: h, attestation: d, tvf: f } = e, g = { method: Sh(ag().protocol).publish, params: op({ topic: o, message: a, ttl: c, prompt: l, tag: u, attestation: d }, f), id: h };
    lr((t = g.params) == null ? void 0 : t.prompt) && ((n = g.params) == null || delete n.prompt), lr((s = g.params) == null ? void 0 : s.tag) && ((i = g.params) == null || delete i.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: g });
    const p = await this.relayer.request(g);
    return this.relayer.events.emit(Zt.publish, e), this.logger.debug("Successfully Published Payload"), p;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const n = e.attempt + 1;
      this.queue.set(t, hw(op({}, e), { attempt: n }));
      const { topic: s, message: i, opts: o, attestation: a } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${n}`), await this.rpcPublish(hw(op({}, e), { topic: s, message: i, ttl: o.ttl, prompt: o.prompt, tag: o.tag, id: o.id, attestation: a, tvf: o.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Nc.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(Zt.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(Zt.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
var jM = Object.defineProperty, HM = (r, e, t) => e in r ? jM(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Hc = (r, e, t) => HM(r, typeof e != "symbol" ? e + "" : e, t);
class zM {
  constructor() {
    Hc(this, "map", /* @__PURE__ */ new Map()), Hc(this, "set", (e, t) => {
      const n = this.get(e);
      this.exists(e, t) || this.map.set(e, [...n, t]);
    }), Hc(this, "get", (e) => this.map.get(e) || []), Hc(this, "exists", (e, t) => this.get(e).includes(t)), Hc(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const n = this.get(e);
      if (!this.exists(e, t)) return;
      const s = n.filter((i) => i !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }), Hc(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var qM = Object.defineProperty, WM = Object.defineProperties, VM = Object.getOwnPropertyDescriptors, S1 = Object.getOwnPropertySymbols, GM = Object.prototype.hasOwnProperty, KM = Object.prototype.propertyIsEnumerable, Dy = (r, e, t) => e in r ? qM(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, fh = (r, e) => {
  for (var t in e || (e = {})) GM.call(e, t) && Dy(r, t, e[t]);
  if (S1) for (var t of S1(e)) KM.call(e, t) && Dy(r, t, e[t]);
  return r;
}, dw = (r, e) => WM(r, VM(e)), mt = (r, e, t) => Dy(r, typeof e != "symbol" ? e + "" : e, t);
class JM extends ZR {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, mt(this, "subscriptions", /* @__PURE__ */ new Map()), mt(this, "topicMap", new zM()), mt(this, "events", new Vn.EventEmitter()), mt(this, "name", kF), mt(this, "version", UF), mt(this, "pending", /* @__PURE__ */ new Map()), mt(this, "cached", []), mt(this, "initialized", !1), mt(this, "storagePrefix", ei), mt(this, "subscribeTimeout", Q.toMiliseconds(Q.ONE_MINUTE)), mt(this, "initialSubscribeTimeout", Q.toMiliseconds(Q.ONE_SECOND * 15)), mt(this, "clientId"), mt(this, "batchSubscribeTopicsLimit", 500), mt(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = !0;
    }), mt(this, "subscribe", async (n, s) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: s } });
      try {
        const i = ag(s), o = { topic: n, relay: i, transportType: s == null ? void 0 : s.transportType };
        this.pending.set(n, o);
        const a = await this.rpcSubscribe(n, i, s);
        return typeof a == "string" && (this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: s } })), a;
      } catch (i) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(i), i;
      }
    }), mt(this, "unsubscribe", async (n, s) => {
      this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(n, s.id, s) : await this.unsubscribeByTopic(n, s);
    }), mt(this, "isSubscribed", (n) => new Promise((s) => {
      s(this.topicMap.topics.includes(n));
    })), mt(this, "isKnownTopic", (n) => new Promise((s) => {
      s(this.topicMap.topics.includes(n) || this.pending.has(n) || this.cached.some((i) => i.topic === n));
    })), mt(this, "on", (n, s) => {
      this.events.on(n, s);
    }), mt(this, "once", (n, s) => {
      this.events.once(n, s);
    }), mt(this, "off", (n, s) => {
      this.events.off(n, s);
    }), mt(this, "removeListener", (n, s) => {
      this.events.removeListener(n, s);
    }), mt(this, "start", async () => {
      await this.onConnect();
    }), mt(this, "stop", async () => {
      await this.onDisconnect();
    }), mt(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), mt(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const n = [];
      this.pending.forEach((s) => {
        n.push(s);
      }), await this.batchSubscribe(n);
    }), mt(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(Nc.pulse, async () => {
        await this.checkPending();
      }), this.events.on(mn.created, async (n) => {
        const s = mn.created;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: n }), await this.persist();
      }), this.events.on(mn.deleted, async (n) => {
        const s = mn.deleted;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: n }), await this.persist();
      });
    }), this.relayer = e, this.logger = xr(t, this.name), this.clientId = "";
  }
  get context() {
    return dn(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === t;
    } catch {
    }
    return n;
  }
  reset() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: n } });
    try {
      const s = ag(n);
      await this.restartToComplete({ topic: e, id: t, relay: s }), await this.rpcUnsubscribe(e, t, s);
      const i = dt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, i), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: n } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t, n) {
    var s;
    (!n || (n == null ? void 0 : n.transportType) === Ct.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const i = { method: Sh(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i });
    const o = (s = n == null ? void 0 : n.internal) == null ? void 0 : s.throwOnFailedPublish;
    try {
      const a = await this.getSubscriptionId(e);
      if ((n == null ? void 0 : n.transportType) === Ct.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(i).catch((u) => this.logger.warn(u));
      }, Q.toMiliseconds(Q.ONE_SECOND)), a;
      const c = new Promise(async (u) => {
        const h = (d) => {
          d.topic === e && (this.events.removeListener(mn.created, h), u(d.id));
        };
        this.events.on(mn.created, h);
        try {
          const d = await Lo(new Promise((f, g) => {
            this.relayer.request(i).catch((p) => {
              this.logger.warn(p, p == null ? void 0 : p.message), g(p);
            }).then(f);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener(mn.created, h), u(d);
        } catch {
        }
      }), l = await Lo(c, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!l && o) throw new Error(`Subscribing to ${e} failed, please try again`);
      return l ? a : null;
    } catch (a) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(Zt.connection_stalled), o) throw a;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, n = { method: Sh(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      await await Lo(new Promise((s) => {
        this.relayer.request(n).catch((i) => this.logger.warn(i)).then(s);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(Zt.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, n = { method: Sh(t.protocol).batchFetchMessages, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    let s;
    try {
      s = await await Lo(new Promise((i, o) => {
        this.relayer.request(n).catch((a) => {
          this.logger.warn(a), o(a);
        }).then(i);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(Zt.connection_stalled);
    }
    return s;
  }
  rpcUnsubscribe(e, t, n) {
    const s = { method: Sh(n.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, dw(fh({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, fh({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, n) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, fh({}, t)), this.topicMap.set(t.topic, e), this.events.emit(mn.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: n } = Z("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(mn.deleted, dw(fh({}, n), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(mn.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let n = 0; n < t; n++) {
        const s = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s);
      }
    }
    this.events.emit(mn.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = Z("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => dw(fh({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await d4(Q.toMiliseconds(Q.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return zs(e + await this.getClientId());
  }
}
var YM = Object.defineProperty, N1 = Object.getOwnPropertySymbols, QM = Object.prototype.hasOwnProperty, ZM = Object.prototype.propertyIsEnumerable, ky = (r, e, t) => e in r ? YM(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, T1 = (r, e) => {
  for (var t in e || (e = {})) QM.call(e, t) && ky(r, t, e[t]);
  if (N1) for (var t of N1(e)) ZM.call(e, t) && ky(r, t, e[t]);
  return r;
}, Je = (r, e, t) => ky(r, typeof e != "symbol" ? e + "" : e, t);
class XM extends YR {
  constructor(e) {
    super(e), Je(this, "protocol", "wc"), Je(this, "version", 2), Je(this, "core"), Je(this, "logger"), Je(this, "events", new Vn.EventEmitter()), Je(this, "provider"), Je(this, "messages"), Je(this, "subscriber"), Je(this, "publisher"), Je(this, "name", xF), Je(this, "transportExplicitlyClosed", !1), Je(this, "initialized", !1), Je(this, "connectionAttemptInProgress", !1), Je(this, "relayUrl"), Je(this, "projectId"), Je(this, "packageName"), Je(this, "bundleId"), Je(this, "hasExperiencedNetworkDisruption", !1), Je(this, "pingTimeout"), Je(this, "heartBeatTimeout", Q.toMiliseconds(Q.THIRTY_SECONDS + Q.FIVE_SECONDS)), Je(this, "reconnectTimeout"), Je(this, "connectPromise"), Je(this, "reconnectInProgress", !1), Je(this, "requestsInFlight", []), Je(this, "connectTimeout", Q.toMiliseconds(Q.ONE_SECOND * 15)), Je(this, "request", async (t) => {
      var n, s;
      this.logger.debug("Publishing Request Payload");
      const i = t.id || Ta().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: i, method: t.method, topic: (n = t.params) == null ? void 0 : n.topic }, "relayer.request - publishing...");
        const o = `${i}:${((s = t.params) == null ? void 0 : s.tag) || ""}`;
        this.requestsInFlight.push(o);
        const a = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c) => c !== o), a;
      } catch (o) {
        throw this.logger.debug(`Failed to Publish Request: ${i}`), o;
      }
    }), Je(this, "resetPingTimeout", () => {
      rg() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, n, s, i;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (i = (s = (n = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : n.socket) == null ? void 0 : s.terminate) == null || i.call(s);
        } catch (o) {
          this.logger.warn(o, o == null ? void 0 : o.message);
        }
      }, this.heartBeatTimeout));
    }), Je(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), Je(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(Zt.connect);
    }), Je(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), Je(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(Zt.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), Je(this, "registerProviderListeners", () => {
      this.provider.on(Pn.payload, this.onPayloadHandler), this.provider.on(Pn.connect, this.onConnectHandler), this.provider.on(Pn.disconnect, this.onDisconnectHandler), this.provider.on(Pn.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? xr(e.logger, this.name) : wf(Fu({ level: e.logger || TF })), this.messages = new kM(this.logger, e.core), this.subscriber = new JM(this, this.logger), this.publisher = new MM(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || q2, this.projectId = e.projectId, Y5() ? this.packageName = yv() : Q5() && (this.bundleId = yv()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e, e == null ? void 0 : e.message);
    }
  }
  get context() {
    return dn(this.logger);
  }
  get connected() {
    var e, t, n;
    return ((n = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : n.readyState) === 1 || !1;
  }
  get connecting() {
    var e, t, n;
    return ((n = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : n.readyState) === 0 || this.connectPromise !== void 0 || !1;
  }
  async publish(e, t, n) {
    this.isInitialized(), await this.publisher.publish(e, t, n), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Ct.relay }, xp.outbound);
  }
  async subscribe(e, t) {
    var n, s, i;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o = typeof ((n = t == null ? void 0 : t.internal) == null ? void 0 : n.throwOnFailedPublish) > "u" ? !0 : (s = t == null ? void 0 : t.internal) == null ? void 0 : s.throwOnFailedPublish;
    let a = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || "", c;
    const l = (u) => {
      u.topic === e && (this.subscriber.off(mn.created, l), c());
    };
    return await Promise.all([new Promise((u) => {
      c = u, this.subscriber.on(mn.created, l);
    }), new Promise(async (u, h) => {
      a = await this.subscriber.subscribe(e, T1({ internal: { throwOnFailedPublish: o } }, t)).catch((d) => {
        o && h(d);
      }) || a, u();
    })]), a;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await Lo(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, n) => {
      await this.connect(e).then(t).catch(n).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await a1()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((n, s) => n.publishedAt - s.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const n of t) try {
      await this.onMessageEvent(n);
    } catch (s) {
      this.logger.warn(s, "Error while processing batch message event: " + (s == null ? void 0 : s.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: n } = e;
    if (!t.sessionExists) {
      const s = Ht(Q.FIVE_MINUTES), i = { topic: n, expiry: s, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(n, i);
    }
    this.events.emit(Zt.message, e), await this.recordMessageEvent(e, xp.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (n, s) => {
          const i = () => {
            s(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(Pn.disconnect, i), await Lo(new Promise((o, a) => {
            this.provider.connect().then(o).catch(a);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o) => {
            s(o);
          }).finally(() => {
            this.provider.off(Pn.disconnect, i), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o, a) => {
            const c = () => {
              a(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(Pn.disconnect, c), await this.subscriber.start().then(o).catch(a).finally(() => {
              this.provider.off(Pn.disconnect, c);
            });
          }), this.hasExperiencedNetworkDisruption = !1, n();
        });
      } catch (n) {
        await this.subscriber.stop();
        const s = n;
        this.logger.warn({}, s.message), this.hasExperiencedNetworkDisruption = !0;
      } finally {
        this.connectionAttemptInProgress = !1;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((n) => setTimeout(n, Q.toMiliseconds(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, n, s, i;
    if (rg()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((i = (s = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : s.socket) == null || i.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o) {
      this.logger.warn(o, o == null ? void 0 : o.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new Gn(new yF(r4({ sdkVersion: Ty, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: n, message: s } = e;
    await this.messages.set(n, s, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: n } = e;
    if (!n || n.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${n}`), !0;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), !0;
    const s = this.messages.has(t, n);
    return s && this.logger.warn(`Ignoring duplicate message: ${n}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), wb(e)) {
      if (!e.method.endsWith(OF)) return;
      const t = e.params, { topic: n, message: s, publishedAt: i, attestation: o } = t.data, a = { topic: n, message: s, publishedAt: i, transportType: Ct.relay, attestation: o };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(T1({ type: "event", event: t.id }, a)), this.events.emit(t.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else rm(e) && this.events.emit(Zt.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, xp.inbound), this.events.emit(Zt.message, e));
  }
  async acknowledgePayload(e) {
    const t = em(e.id, !0);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(Pn.payload, this.onPayloadHandler), this.provider.off(Pn.connect, this.onConnectHandler), this.provider.off(Pn.disconnect, this.onDisconnectHandler), this.provider.off(Pn.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await a1();
    ML(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((n) => this.logger.error(n, n == null ? void 0 : n.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    }), this.core.heartbeat.on(Nc.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && zL()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t) {
        this.logger.warn(t, t == null ? void 0 : t.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(Zt.disconnect), this.connectionAttemptInProgress = !1, !this.reconnectInProgress && (this.reconnectInProgress = !0, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = !1;
    }, Q.toMiliseconds(PF)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
}
function e9(r, e) {
  return r === e || Number.isNaN(r) && Number.isNaN(e);
}
function x1(r) {
  return Object.getOwnPropertySymbols(r).filter((e) => Object.prototype.propertyIsEnumerable.call(r, e));
}
function O1(r) {
  return r == null ? r === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r);
}
const t9 = "[object RegExp]", r9 = "[object String]", n9 = "[object Number]", s9 = "[object Boolean]", P1 = "[object Arguments]", i9 = "[object Symbol]", o9 = "[object Date]", a9 = "[object Map]", c9 = "[object Set]", l9 = "[object Array]", u9 = "[object Function]", h9 = "[object ArrayBuffer]", fw = "[object Object]", d9 = "[object Error]", f9 = "[object DataView]", p9 = "[object Uint8Array]", g9 = "[object Uint8ClampedArray]", m9 = "[object Uint16Array]", w9 = "[object Uint32Array]", y9 = "[object BigUint64Array]", b9 = "[object Int8Array]", E9 = "[object Int16Array]", v9 = "[object Int32Array]", A9 = "[object BigInt64Array]", C9 = "[object Float32Array]", _9 = "[object Float64Array]";
function R1(r) {
  if (!r || typeof r != "object") return !1;
  const e = Object.getPrototypeOf(r);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r) === "[object Object]" : !1;
}
function I9(r, e, t) {
  return Nh(r, e, void 0, void 0, void 0, void 0, t);
}
function Nh(r, e, t, n, s, i, o) {
  const a = o(r, e, t, n, s, i);
  if (a !== void 0) return a;
  if (typeof r == typeof e) switch (typeof r) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r === e;
    case "number":
      return r === e || Object.is(r, e);
    case "function":
      return r === e;
    case "object":
      return jh(r, e, i, o);
  }
  return jh(r, e, i, o);
}
function jh(r, e, t, n) {
  if (Object.is(r, e)) return !0;
  let s = O1(r), i = O1(e);
  if (s === P1 && (s = fw), i === P1 && (i = fw), s !== i) return !1;
  switch (s) {
    case r9:
      return r.toString() === e.toString();
    case n9: {
      const c = r.valueOf(), l = e.valueOf();
      return e9(c, l);
    }
    case s9:
    case o9:
    case i9:
      return Object.is(r.valueOf(), e.valueOf());
    case t9:
      return r.source === e.source && r.flags === e.flags;
    case u9:
      return r === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o = t.get(r), a = t.get(e);
  if (o != null && a != null) return o === e;
  t.set(r, e), t.set(e, r);
  try {
    switch (s) {
      case a9: {
        if (r.size !== e.size) return !1;
        for (const [c, l] of r.entries()) if (!e.has(c) || !Nh(l, e.get(c), c, r, e, t, n)) return !1;
        return !0;
      }
      case c9: {
        if (r.size !== e.size) return !1;
        const c = Array.from(r.values()), l = Array.from(e.values());
        for (let u = 0; u < c.length; u++) {
          const h = c[u], d = l.findIndex((f) => Nh(h, f, void 0, r, e, t, n));
          if (d === -1) return !1;
          l.splice(d, 1);
        }
        return !0;
      }
      case l9:
      case p9:
      case g9:
      case m9:
      case w9:
      case y9:
      case b9:
      case E9:
      case v9:
      case A9:
      case C9:
      case _9: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r) !== Buffer.isBuffer(e) || r.length !== e.length) return !1;
        for (let c = 0; c < r.length; c++) if (!Nh(r[c], e[c], c, r, e, t, n)) return !1;
        return !0;
      }
      case h9:
        return r.byteLength !== e.byteLength ? !1 : jh(new Uint8Array(r), new Uint8Array(e), t, n);
      case f9:
        return r.byteLength !== e.byteLength || r.byteOffset !== e.byteOffset ? !1 : jh(new Uint8Array(r), new Uint8Array(e), t, n);
      case d9:
        return r.name === e.name && r.message === e.message;
      case fw: {
        if (!(jh(r.constructor, e.constructor, t, n) || R1(r) && R1(e))) return !1;
        const c = [...Object.keys(r), ...x1(r)], l = [...Object.keys(e), ...x1(e)];
        if (c.length !== l.length) return !1;
        for (let u = 0; u < c.length; u++) {
          const h = c[u], d = r[h];
          if (!Object.hasOwn(e, h)) return !1;
          const f = e[h];
          if (!Nh(d, f, h, r, e, t, n)) return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    t.delete(r), t.delete(e);
  }
}
function S9() {
}
function N9(r, e) {
  return I9(r, e, S9);
}
var T9 = Object.defineProperty, D1 = Object.getOwnPropertySymbols, x9 = Object.prototype.hasOwnProperty, O9 = Object.prototype.propertyIsEnumerable, Uy = (r, e, t) => e in r ? T9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, k1 = (r, e) => {
  for (var t in e || (e = {})) x9.call(e, t) && Uy(r, t, e[t]);
  if (D1) for (var t of D1(e)) O9.call(e, t) && Uy(r, t, e[t]);
  return r;
}, Wr = (r, e, t) => Uy(r, typeof e != "symbol" ? e + "" : e, t);
class Oc extends QR {
  constructor(e, t, n, s = ei, i = void 0) {
    super(e, t, n, s), this.core = e, this.logger = t, this.name = n, Wr(this, "map", /* @__PURE__ */ new Map()), Wr(this, "version", RF), Wr(this, "cached", []), Wr(this, "initialized", !1), Wr(this, "getKey"), Wr(this, "storagePrefix", ei), Wr(this, "recentlyDeleted", []), Wr(this, "recentlyDeletedLimit", 200), Wr(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !lr(o) ? this.map.set(this.getKey(o), o) : wL(o) ? this.map.set(o.id, o) : yL(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = !0);
    }), Wr(this, "set", async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a }), this.map.set(o, a), await this.persist());
    }), Wr(this, "get", (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o))), Wr(this, "getAll", (o) => (this.isInitialized(), o ? this.values.filter((a) => Object.keys(o).every((c) => N9(a[c], o[c]))) : this.values)), Wr(this, "update", async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a });
      const c = k1(k1({}, this.getData(o)), a);
      this.map.set(o, c), await this.persist();
    }), Wr(this, "delete", async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
    }), this.logger = xr(t, this.name), this.storagePrefix = s, this.getKey = i;
  }
  get context() {
    return dn(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s } = Z("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s), new Error(s);
      }
      const { message: n } = Z("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = Z("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var P9 = Object.defineProperty, R9 = (r, e, t) => e in r ? P9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Me = (r, e, t) => R9(r, typeof e != "symbol" ? e + "" : e, t);
class D9 {
  constructor(e, t) {
    this.core = e, this.logger = t, Me(this, "name", BF), Me(this, "version", LF), Me(this, "events", new $0()), Me(this, "pairings"), Me(this, "initialized", !1), Me(this, "storagePrefix", ei), Me(this, "ignoredPayloadTypes", [Ui]), Me(this, "registeredMethods", []), Me(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }), Me(this, "register", ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }), Me(this, "create", async (n) => {
      this.isInitialized();
      const s = Iy(), i = await this.core.crypto.setSymKey(s), o = Ht(Q.FIVE_MINUTES), a = { protocol: z2 }, c = { topic: i, expiry: o, relay: a, active: !1, methods: n == null ? void 0 : n.methods }, l = Zv({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: s, relay: a, expiryTimestamp: o, methods: n == null ? void 0 : n.methods });
      return this.events.emit(ya.create, c), this.core.expirer.set(i, o), await this.pairings.set(i, c), await this.core.relayer.subscribe(i, { transportType: n == null ? void 0 : n.transportType }), { topic: i, uri: l };
    }), Me(this, "pair", async (n) => {
      this.isInitialized();
      const s = this.core.eventClient.createEvent({ properties: { topic: n == null ? void 0 : n.uri, trace: [xs.pairing_started] } });
      this.isValidPair(n, s);
      const { topic: i, symKey: o, relay: a, expiryTimestamp: c, methods: l } = Qv(n.uri);
      s.props.properties.topic = i, s.addTrace(xs.pairing_uri_validation_success), s.addTrace(xs.pairing_uri_not_expired);
      let u;
      if (this.pairings.keys.includes(i)) {
        if (u = this.pairings.get(i), s.addTrace(xs.existing_pairing), u.active) throw s.setError(di.active_pairing_already_exists), new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
        s.addTrace(xs.pairing_not_expired);
      }
      const h = c || Ht(Q.FIVE_MINUTES), d = { topic: i, relay: a, expiry: h, active: !1, methods: l };
      this.core.expirer.set(i, h), await this.pairings.set(i, d), s.addTrace(xs.store_new_pairing), n.activatePairing && await this.activate({ topic: i }), this.events.emit(ya.create, d), s.addTrace(xs.emit_inactive_pairing), this.core.crypto.keychain.has(i) || await this.core.crypto.setSymKey(o, i), s.addTrace(xs.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s.setError(di.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(i, { relay: a });
      } catch (f) {
        throw s.setError(di.subscribe_pairing_topic_failure), f;
      }
      return s.addTrace(xs.subscribe_pairing_topic_success), d;
    }), Me(this, "activate", async ({ topic: n }) => {
      this.isInitialized();
      const s = Ht(Q.FIVE_MINUTES);
      this.core.expirer.set(n, s), await this.pairings.update(n, { active: !0, expiry: s });
    }), Me(this, "ping", async (n) => {
      this.isInitialized(), await this.isValidPing(n), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s } = n;
      if (this.pairings.keys.includes(s)) {
        const i = await this.sendRequest(s, "wc_pairingPing", {}), { done: o, resolve: a, reject: c } = pa();
        this.events.once(rt("pairing_ping", i), ({ error: l }) => {
          l ? c(l) : a();
        }), await o();
      }
    }), Me(this, "updateExpiry", async ({ topic: n, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: s });
    }), Me(this, "updateMetadata", async ({ topic: n, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: s });
    }), Me(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), Me(this, "disconnect", async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: s } = n;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", dt("USER_DISCONNECTED")), await this.deletePairing(s));
    }), Me(this, "formatUriFromPairing", (n) => {
      this.isInitialized();
      const { topic: s, relay: i, expiry: o, methods: a } = n, c = this.core.crypto.keychain.get(s);
      return Zv({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: c, relay: i, expiryTimestamp: o, methods: a });
    }), Me(this, "sendRequest", async (n, s, i) => {
      const o = Fo(s, i), a = await this.core.crypto.encode(n, o), c = hh[s].req;
      return this.core.history.set(n, o), this.core.relayer.publish(n, a, c), o.id;
    }), Me(this, "sendResult", async (n, s, i) => {
      const o = em(n, i), a = await this.core.crypto.encode(s, o), c = (await this.core.history.get(s, n)).request.method, l = hh[c].res;
      await this.core.relayer.publish(s, a, l), await this.core.history.resolve(o);
    }), Me(this, "sendError", async (n, s, i) => {
      const o = tm(n, i), a = await this.core.crypto.encode(s, o), c = (await this.core.history.get(s, n)).request.method, l = hh[c] ? hh[c].res : hh.unregistered_method.res;
      await this.core.relayer.publish(s, a, l), await this.core.history.resolve(o);
    }), Me(this, "deletePairing", async (n, s) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, dt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), s ? Promise.resolve() : this.core.expirer.del(n)]);
    }), Me(this, "cleanup", async () => {
      const n = this.pairings.getAll().filter((s) => ho(s.expiry));
      await Promise.all(n.map((s) => this.deletePairing(s.topic)));
    }), Me(this, "onRelayEventRequest", async (n) => {
      const { topic: s, payload: i } = n;
      switch (i.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s, i);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s, i);
        default:
          return await this.onUnknownRpcMethodRequest(s, i);
      }
    }), Me(this, "onRelayEventResponse", async (n) => {
      const { topic: s, payload: i } = n, o = (await this.core.history.get(s, i.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, i);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }), Me(this, "onPairingPingRequest", async (n, s) => {
      const { id: i } = s;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(i, n, !0), this.events.emit(ya.ping, { id: i, topic: n });
      } catch (o) {
        await this.sendError(i, n, o), this.logger.error(o);
      }
    }), Me(this, "onPairingPingResponse", (n, s) => {
      const { id: i } = s;
      setTimeout(() => {
        Ps(s) ? this.events.emit(rt("pairing_ping", i), {}) : Hn(s) && this.events.emit(rt("pairing_ping", i), { error: s.error });
      }, 500);
    }), Me(this, "onPairingDeleteRequest", async (n, s) => {
      const { id: i } = s;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(ya.delete, { id: i, topic: n });
      } catch (o) {
        await this.sendError(i, n, o), this.logger.error(o);
      }
    }), Me(this, "onUnknownRpcMethodRequest", async (n, s) => {
      const { id: i, method: o } = s;
      try {
        if (this.registeredMethods.includes(o)) return;
        const a = dt("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(i, n, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(i, n, a), this.logger.error(a);
      }
    }), Me(this, "onUnknownRpcMethodResponse", (n) => {
      this.registeredMethods.includes(n) || this.logger.error(dt("WC_METHOD_UNSUPPORTED", n));
    }), Me(this, "isValidPair", (n, s) => {
      var i;
      if (!Jr(n)) {
        const { message: a } = Z("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw s.setError(di.malformed_pairing_uri), new Error(a);
      }
      if (!mL(n.uri)) {
        const { message: a } = Z("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw s.setError(di.malformed_pairing_uri), new Error(a);
      }
      const o = Qv(n == null ? void 0 : n.uri);
      if (!((i = o == null ? void 0 : o.relay) != null && i.protocol)) {
        const { message: a } = Z("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s.setError(di.malformed_pairing_uri), new Error(a);
      }
      if (!(o != null && o.symKey)) {
        const { message: a } = Z("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s.setError(di.malformed_pairing_uri), new Error(a);
      }
      if (o != null && o.expiryTimestamp && Q.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()) {
        s.setError(di.pairing_expired);
        const { message: a } = Z("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }), Me(this, "isValidPing", async (n) => {
      if (!Jr(n)) {
        const { message: i } = Z("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(i);
      }
      const { topic: s } = n;
      await this.isValidPairingTopic(s);
    }), Me(this, "isValidDisconnect", async (n) => {
      if (!Jr(n)) {
        const { message: i } = Z("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(i);
      }
      const { topic: s } = n;
      await this.isValidPairingTopic(s);
    }), Me(this, "isValidPairingTopic", async (n) => {
      if (!Ft(n, !1)) {
        const { message: s } = Z("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: s } = Z("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(s);
      }
      if (ho(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: s } = Z("EXPIRED", `pairing topic: ${n}`);
        throw new Error(s);
      }
    }), this.core = e, this.logger = xr(t, this.name), this.pairings = new Oc(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return dn(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(Zt.message, async (e) => {
      const { topic: t, message: n, transportType: s } = e;
      if (this.pairings.keys.includes(t) && s !== Ct.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))) try {
        const i = await this.core.crypto.decode(t, n);
        wb(i) ? (this.core.history.set(t, i), await this.onRelayEventRequest({ topic: t, payload: i })) : rm(i) && (await this.core.history.resolve(i), await this.onRelayEventResponse({ topic: t, payload: i }), this.core.history.delete(t, i.id)), await this.core.relayer.messages.ack(t, n);
      } catch (i) {
        this.logger.error(i);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(Un.expired, async (e) => {
      const { topic: t } = zI(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(ya.expire, { topic: t }));
    });
  }
}
var k9 = Object.defineProperty, U9 = (r, e, t) => e in r ? k9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, or = (r, e, t) => U9(r, typeof e != "symbol" ? e + "" : e, t);
class B9 extends GR {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, or(this, "records", /* @__PURE__ */ new Map()), or(this, "events", new Vn.EventEmitter()), or(this, "name", FF), or(this, "version", $F), or(this, "cached", []), or(this, "initialized", !1), or(this, "storagePrefix", ei), or(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }), or(this, "set", (n, s, i) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: s, chainId: i }), this.records.has(s.id)) return;
      const o = { id: s.id, topic: n, request: { method: s.method, params: s.params || null }, chainId: i, expiry: Ht(Q.THIRTY_DAYS) };
      this.records.set(o.id, o), this.persist(), this.events.emit(Yn.created, o);
    }), or(this, "resolve", async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id)) return;
      const s = await this.getRecord(n.id);
      typeof s.response > "u" && (s.response = Hn(n) ? { error: n.error } : { result: n.result }, this.records.set(s.id, s), this.persist(), this.events.emit(Yn.updated, s));
    }), or(this, "get", async (n, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: s }), await this.getRecord(s))), or(this, "delete", (n, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((i) => {
        if (i.topic === n) {
          if (typeof s < "u" && i.id !== s) return;
          this.records.delete(i.id), this.events.emit(Yn.deleted, i);
        }
      }), this.persist();
    }), or(this, "exists", async (n, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === n : !1)), or(this, "on", (n, s) => {
      this.events.on(n, s);
    }), or(this, "once", (n, s) => {
      this.events.once(n, s);
    }), or(this, "off", (n, s) => {
      this.events.off(n, s);
    }), or(this, "removeListener", (n, s) => {
      this.events.removeListener(n, s);
    }), this.logger = xr(t, this.name);
  }
  get context() {
    return dn(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const n = { topic: t.topic, request: Fo(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: n } = Z("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(Yn.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = Z("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(Yn.created, (e) => {
      const t = Yn.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(Yn.updated, (e) => {
      const t = Yn.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(Yn.deleted, (e) => {
      const t = Yn.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(Nc.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((t) => {
        Q.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(Yn.deleted, t, !1), e = !0);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var L9 = Object.defineProperty, F9 = (r, e, t) => e in r ? L9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Ar = (r, e, t) => F9(r, typeof e != "symbol" ? e + "" : e, t);
class $9 extends XR {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, Ar(this, "expirations", /* @__PURE__ */ new Map()), Ar(this, "events", new Vn.EventEmitter()), Ar(this, "name", MF), Ar(this, "version", jF), Ar(this, "cached", []), Ar(this, "initialized", !1), Ar(this, "storagePrefix", ei), Ar(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }), Ar(this, "has", (n) => {
      try {
        const s = this.formatTarget(n);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return !1;
      }
    }), Ar(this, "set", (n, s) => {
      this.isInitialized();
      const i = this.formatTarget(n), o = { target: i, expiry: s };
      this.expirations.set(i, o), this.checkExpiry(i, o), this.events.emit(Un.created, { target: i, expiration: o });
    }), Ar(this, "get", (n) => {
      this.isInitialized();
      const s = this.formatTarget(n);
      return this.getExpiration(s);
    }), Ar(this, "del", (n) => {
      if (this.isInitialized(), this.has(n)) {
        const s = this.formatTarget(n), i = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(Un.deleted, { target: s, expiration: i });
      }
    }), Ar(this, "on", (n, s) => {
      this.events.on(n, s);
    }), Ar(this, "once", (n, s) => {
      this.events.once(n, s);
    }), Ar(this, "off", (n, s) => {
      this.events.off(n, s);
    }), Ar(this, "removeListener", (n, s) => {
      this.events.removeListener(n, s);
    }), this.logger = xr(t, this.name);
  }
  get context() {
    return dn(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return n4(e);
    if (typeof e == "number") return s4(e);
    const { message: t } = Z("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(Un.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = Z("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: n } = Z("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(n), new Error(n);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: n } = t;
    Q.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(Un.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(Nc.pulse, () => this.checkExpirations()), this.events.on(Un.created, (e) => {
      const t = Un.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(Un.expired, (e) => {
      const t = Un.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(Un.deleted, (e) => {
      const t = Un.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var M9 = Object.defineProperty, j9 = (r, e, t) => e in r ? M9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Lt = (r, e, t) => j9(r, typeof e != "symbol" ? e + "" : e, t);
class H9 extends e3 {
  constructor(e, t, n) {
    super(e, t, n), this.core = e, this.logger = t, this.store = n, Lt(this, "name", HF), Lt(this, "abortController"), Lt(this, "isDevEnv"), Lt(this, "verifyUrlV3", qF), Lt(this, "storagePrefix", ei), Lt(this, "version", H2), Lt(this, "publicKey"), Lt(this, "fetchPromise"), Lt(this, "init", async () => {
      var s;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && Q.toMiliseconds((s = this.publicKey) == null ? void 0 : s.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), Lt(this, "register", async (s) => {
      if (!qu() || this.isDevEnv) return;
      const i = window.location.origin, { id: o, decryptedId: a } = s, c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${i}&id=${o}&decryptedId=${a}`;
      try {
        const l = uc(), u = this.startAbortTimer(Q.ONE_SECOND * 5), h = await new Promise((d, f) => {
          const g = () => {
            window.removeEventListener("message", w), l.body.removeChild(p), f("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", g);
          const p = l.createElement("iframe");
          p.src = c, p.style.display = "none", p.addEventListener("error", g, { signal: this.abortController.signal });
          const w = (E) => {
            if (E.data && typeof E.data == "string") try {
              const I = JSON.parse(E.data);
              if (I.type === "verify_attestation") {
                if (oy(I.attestation).payload.id !== o) return;
                clearInterval(u), l.body.removeChild(p), this.abortController.signal.removeEventListener("abort", g), window.removeEventListener("message", w), d(I.attestation === null ? "" : I.attestation);
              }
            } catch (I) {
              this.logger.warn(I);
            }
          };
          l.body.appendChild(p), window.addEventListener("message", w, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", h), h;
      } catch (l) {
        this.logger.warn(l);
      }
      return "";
    }), Lt(this, "resolve", async (s) => {
      if (this.isDevEnv) return "";
      const { attestationId: i, hash: o, encryptedId: a } = s;
      if (i === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (i) {
        if (oy(i).payload.id !== a) return;
        const l = await this.isValidJwtAttestation(i);
        if (l) {
          if (!l.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return l;
        }
      }
      if (!o) return;
      const c = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl);
      return this.fetchAttestation(o, c);
    }), Lt(this, "fetchAttestation", async (s, i) => {
      this.logger.debug(`resolving attestation: ${s} from url: ${i}`);
      const o = this.startAbortTimer(Q.ONE_SECOND * 5), a = await fetch(`${i}/attestation/${s}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
    }), Lt(this, "getVerifyUrl", (s) => {
      let i = s || Mh;
      return WF.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${Mh}`), i = Mh), i;
    }), Lt(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s = this.startAbortTimer(Q.FIVE_SECONDS), i = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s), await i.json();
      } catch (s) {
        this.logger.warn(s);
      }
    }), Lt(this, "persistPublicKey", async (s) => {
      this.logger.debug("persisting public key to local storage", s), await this.store.setItem(this.storeKey, s), this.publicKey = s;
    }), Lt(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), Lt(this, "isValidJwtAttestation", async (s) => {
      const i = await this.getPublicKey();
      try {
        if (i) return this.validateAttestation(s, i);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
      const o = await this.fetchAndPersistPublicKey();
      try {
        if (o) return this.validateAttestation(s, o);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
    }), Lt(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), Lt(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (i) => {
        const o = await this.fetchPublicKey();
        o && (await this.persistPublicKey(o), i(o));
      });
      const s = await this.fetchPromise;
      return this.fetchPromise = void 0, s;
    }), Lt(this, "validateAttestation", (s, i) => {
      const o = J6(s, i.publicKey), a = { hasExpired: Q.toMiliseconds(o.exp) < Date.now(), payload: o };
      if (a.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a.payload.origin, isScam: a.payload.isScam, isVerified: a.payload.isVerified };
    }), this.logger = xr(t, this.name), this.abortController = new AbortController(), this.isDevEnv = rb(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return dn(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), Q.toMiliseconds(e));
  }
}
var z9 = Object.defineProperty, q9 = (r, e, t) => e in r ? z9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, U1 = (r, e, t) => q9(r, typeof e != "symbol" ? e + "" : e, t);
class W9 extends t3 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, U1(this, "context", VF), U1(this, "registerDeviceToken", async (n) => {
      const { clientId: s, token: i, notificationType: o, enableEncrypted: a = !1 } = n, c = `${GF}/${this.projectId}/clients`;
      await fetch(c, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s, type: o, token: i, always_raw: a }) });
    }), this.logger = xr(t, this.context);
  }
}
var V9 = Object.defineProperty, B1 = Object.getOwnPropertySymbols, G9 = Object.prototype.hasOwnProperty, K9 = Object.prototype.propertyIsEnumerable, By = (r, e, t) => e in r ? V9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, ph = (r, e) => {
  for (var t in e || (e = {})) G9.call(e, t) && By(r, t, e[t]);
  if (B1) for (var t of B1(e)) K9.call(e, t) && By(r, t, e[t]);
  return r;
}, Vt = (r, e, t) => By(r, typeof e != "symbol" ? e + "" : e, t);
class J9 extends r3 {
  constructor(e, t, n = !0) {
    super(e, t, n), this.core = e, this.logger = t, Vt(this, "context", JF), Vt(this, "storagePrefix", ei), Vt(this, "storageVersion", KF), Vt(this, "events", /* @__PURE__ */ new Map()), Vt(this, "shouldPersist", !1), Vt(this, "init", async () => {
      if (!rb()) try {
        const s = { eventId: Ev(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: jI(this.core.relayer.protocol, this.core.relayer.version, Ty) } } };
        await this.sendEvent([s]);
      } catch (s) {
        this.logger.warn(s);
      }
    }), Vt(this, "createEvent", (s) => {
      const { event: i = "ERROR", type: o = "", properties: { topic: a, trace: c } } = s, l = Ev(), u = this.core.projectId || "", h = Date.now(), d = ph({ eventId: l, timestamp: h, props: { event: i, type: o, properties: { topic: a, trace: c } }, bundleId: u, domain: this.getAppDomain() }, this.setMethods(l));
      return this.telemetryEnabled && (this.events.set(l, d), this.shouldPersist = !0), d;
    }), Vt(this, "getEvent", (s) => {
      const { eventId: i, topic: o } = s;
      if (i) return this.events.get(i);
      const a = Array.from(this.events.values()).find((c) => c.props.properties.topic === o);
      if (a) return ph(ph({}, a), this.setMethods(a.eventId));
    }), Vt(this, "deleteEvent", (s) => {
      const { eventId: i } = s;
      this.events.delete(i), this.shouldPersist = !0;
    }), Vt(this, "setEventListeners", () => {
      this.core.heartbeat.on(Nc.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s) => {
          Q.fromMiliseconds(Date.now()) - Q.fromMiliseconds(s.timestamp) > YF && (this.events.delete(s.eventId), this.shouldPersist = !0);
        });
      });
    }), Vt(this, "setMethods", (s) => ({ addTrace: (i) => this.addTrace(s, i), setError: (i) => this.setError(s, i) })), Vt(this, "addTrace", (s, i) => {
      const o = this.events.get(s);
      o && (o.props.properties.trace.push(i), this.events.set(s, o), this.shouldPersist = !0);
    }), Vt(this, "setError", (s, i) => {
      const o = this.events.get(s);
      o && (o.props.type = i, o.timestamp = Date.now(), this.events.set(s, o), this.shouldPersist = !0);
    }), Vt(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }), Vt(this, "restore", async () => {
      try {
        const s = await this.core.storage.getItem(this.storageKey) || [];
        if (!s.length) return;
        s.forEach((i) => {
          this.events.set(i.eventId, ph(ph({}, i), this.setMethods(i.eventId)));
        });
      } catch (s) {
        this.logger.warn(s);
      }
    }), Vt(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s = [];
      for (const [i, o] of this.events) o.props.type && s.push(o);
      if (s.length !== 0) try {
        if ((await this.sendEvent(s)).ok) for (const i of s) this.events.delete(i.eventId), this.shouldPersist = !0;
      } catch (i) {
        this.logger.warn(i);
      }
    }), Vt(this, "sendEvent", async (s) => {
      const i = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${QF}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Ty}${i}`, { method: "POST", body: JSON.stringify(s) });
    }), Vt(this, "getAppDomain", () => MI().url), this.logger = xr(t, this.context), this.telemetryEnabled = n, n ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var Y9 = Object.defineProperty, L1 = Object.getOwnPropertySymbols, Q9 = Object.prototype.hasOwnProperty, Z9 = Object.prototype.propertyIsEnumerable, Ly = (r, e, t) => e in r ? Y9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, F1 = (r, e) => {
  for (var t in e || (e = {})) Q9.call(e, t) && Ly(r, t, e[t]);
  if (L1) for (var t of L1(e)) Z9.call(e, t) && Ly(r, t, e[t]);
  return r;
}, Et = (r, e, t) => Ly(r, typeof e != "symbol" ? e + "" : e, t);
let X9 = class nS extends zR {
  constructor(e) {
    var t;
    super(e), Et(this, "protocol", j2), Et(this, "version", H2), Et(this, "name", Ny), Et(this, "relayUrl"), Et(this, "projectId"), Et(this, "customStoragePrefix"), Et(this, "events", new Vn.EventEmitter()), Et(this, "logger"), Et(this, "heartbeat"), Et(this, "relayer"), Et(this, "crypto"), Et(this, "storage"), Et(this, "history"), Et(this, "expirer"), Et(this, "pairing"), Et(this, "verify"), Et(this, "echoClient"), Et(this, "linkModeSupportedApps"), Et(this, "eventClient"), Et(this, "initialized", !1), Et(this, "logChunkController"), Et(this, "on", (a, c) => this.events.on(a, c)), Et(this, "once", (a, c) => this.events.once(a, c)), Et(this, "off", (a, c) => this.events.off(a, c)), Et(this, "removeListener", (a, c) => this.events.removeListener(a, c)), Et(this, "dispatchEnvelope", ({ topic: a, message: c, sessionExists: l }) => {
      if (!a || !c) return;
      const u = { topic: a, message: c, publishedAt: Date.now(), transportType: Ct.link_mode };
      this.relayer.onLinkMessageEvent(u, { sessionExists: l });
    });
    const n = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
    if (n) try {
      return this.customStoragePrefix = n.customStoragePrefix, this.logger = n.logger, this.heartbeat = n.heartbeat, this.crypto = n.crypto, this.history = n.history, this.expirer = n.expirer, this.storage = n.storage, this.relayer = n.relayer, this.pairing = n.pairing, this.verify = n.verify, this.echoClient = n.echoClient, this.linkModeSupportedApps = n.linkModeSupportedApps, this.eventClient = n.eventClient, this.initialized = n.initialized, this.logChunkController = n.logChunkController, n;
    } catch (a) {
      console.warn("Failed to copy global core", a);
    }
    this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || q2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s = Fu({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : bF.logger, name: Ny }), { logger: i, chunkLoggerController: o } = j0({ opts: s, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = o, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a, c;
      (a = this.logChunkController) != null && a.downloadLogsBlobInBrowser && ((c = this.logChunkController) == null || c.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = xr(i, this.name), this.heartbeat = new PP(), this.crypto = new SM(this, this.logger, e == null ? void 0 : e.keychain), this.history = new B9(this, this.logger), this.expirer = new $9(this, this.logger), this.storage = e != null && e.storage ? e.storage : new fR(F1(F1({}, EF), e == null ? void 0 : e.storageOptions)), this.relayer = new XM({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new D9(this, this.logger), this.verify = new H9(this, this.logger, this.storage), this.echoClient = new W9(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new J9(this, this.logger, e == null ? void 0 : e.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new nS(e);
    await t.initialize();
    const n = await t.crypto.getClientId();
    return await t.storage.setItem(DF, n), t;
  }
  get context() {
    return dn(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(w1, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(w1) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`, n = `${t}_count`;
      return globalThis[n] = (globalThis[n] || 0) + 1, globalThis[n] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[n]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const n = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[n] = e;
    } catch (n) {
      console.warn("Failed to set global WalletConnect core", n);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return !0;
    }
  }
};
const e7 = X9, sS = "wc", iS = 2, oS = "client", yb = `${sS}@${iS}:${oS}:`, pw = { name: oS, logger: "error" }, $1 = "WALLETCONNECT_DEEPLINK_CHOICE", t7 = "proposal", M1 = "Proposal expired", r7 = "session", zc = Q.SEVEN_DAYS, n7 = "engine", Gt = { wc_sessionPropose: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: Q.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: Q.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, gw = { min: Q.FIVE_MINUTES, max: Q.SEVEN_DAYS }, Ns = { idle: "IDLE", active: "ACTIVE" }, s7 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } }, i7 = "request", o7 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], a7 = "wc", c7 = "auth", l7 = "authKeys", u7 = "pairingTopics", h7 = "requests", sm = `${a7}@${1.5}:${c7}:`, Op = `${sm}:PUB_KEY`;
var d7 = Object.defineProperty, f7 = Object.defineProperties, p7 = Object.getOwnPropertyDescriptors, j1 = Object.getOwnPropertySymbols, g7 = Object.prototype.hasOwnProperty, m7 = Object.prototype.propertyIsEnumerable, Fy = (r, e, t) => e in r ? d7(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, At = (r, e) => {
  for (var t in e || (e = {})) g7.call(e, t) && Fy(r, t, e[t]);
  if (j1) for (var t of j1(e)) m7.call(e, t) && Fy(r, t, e[t]);
  return r;
}, Vr = (r, e) => f7(r, p7(e)), G = (r, e, t) => Fy(r, typeof e != "symbol" ? e + "" : e, t);
class w7 extends o3 {
  constructor(e) {
    super(e), G(this, "name", n7), G(this, "events", new $0()), G(this, "initialized", !1), G(this, "requestQueue", { state: Ns.idle, queue: [] }), G(this, "sessionRequestQueue", { state: Ns.idle, queue: [] }), G(this, "requestQueueDelay", Q.ONE_SECOND), G(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), G(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), G(this, "recentlyDeletedLimit", 200), G(this, "relayMessageCache", []), G(this, "pendingSessions", /* @__PURE__ */ new Map()), G(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(Gt) }), this.initialized = !0, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, Q.toMiliseconds(this.requestQueueDelay)));
    }), G(this, "connect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const n = Vr(At({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });
      await this.isValidConnect(n), n.optionalNamespaces = hL(n.requiredNamespaces, n.optionalNamespaces), n.requiredNamespaces = {};
      const { pairingTopic: s, requiredNamespaces: i, optionalNamespaces: o, sessionProperties: a, scopedProperties: c, relays: l } = n;
      let u = s, h, d = !1;
      try {
        if (u) {
          const x = this.client.core.pairing.pairings.get(u);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), d = x.active;
        }
      } catch (x) {
        throw this.client.logger.error(`connect() -> pairing.get(${u}) failed`), x;
      }
      if (!u || !d) {
        const { topic: x, uri: O } = await this.client.core.pairing.create();
        u = x, h = O;
      }
      if (!u) {
        const { message: x } = Z("NO_MATCHING_KEY", `connect() pairing topic: ${u}`);
        throw new Error(x);
      }
      const f = await this.client.core.crypto.generateKeyPair(), g = Gt.wc_sessionPropose.req.ttl || Q.FIVE_MINUTES, p = Ht(g), w = Vr(At(At({ requiredNamespaces: i, optionalNamespaces: o, relays: l ?? [{ protocol: z2 }], proposer: { publicKey: f, metadata: this.client.metadata }, expiryTimestamp: p, pairingTopic: u }, a && { sessionProperties: a }), c && { scopedProperties: c }), { id: Os() }), E = rt("session_connect", w.id), { reject: I, resolve: A, done: C } = pa(g, M1), N = ({ id: x }) => {
        x === w.id && (this.client.events.off("proposal_expire", N), this.pendingSessions.delete(w.id), this.events.emit(E, { error: { message: M1, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", N), this.events.once(E, ({ error: x, session: O }) => {
        this.client.events.off("proposal_expire", N), x ? I(x) : O && A(O);
      }), await this.sendRequest({ topic: u, method: "wc_sessionPropose", params: w, throwOnFailedPublish: !0, clientRpcId: w.id }), await this.setProposal(w.id, w), { uri: h, approval: C };
    }), G(this, "pair", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(t);
      } catch (n) {
        throw this.client.logger.error("pair() failed"), n;
      }
    }), G(this, "approve", async (t) => {
      var n, s, i;
      const o = this.client.core.eventClient.createEvent({ properties: { topic: (n = t == null ? void 0 : t.id) == null ? void 0 : n.toString(), trace: [Qn.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (P) {
        throw o.setError(aa.no_internet_connection), P;
      }
      try {
        await this.isValidProposalId(t == null ? void 0 : t.id);
      } catch (P) {
        throw this.client.logger.error(`approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`), o.setError(aa.proposal_not_found), P;
      }
      try {
        await this.isValidApprove(t);
      } catch (P) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), o.setError(aa.session_approve_namespace_validation_failure), P;
      }
      const { id: a, relayProtocol: c, namespaces: l, sessionProperties: u, scopedProperties: h, sessionConfig: d } = t, f = this.client.proposal.get(a);
      this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
      const { pairingTopic: g, proposer: p, requiredNamespaces: w, optionalNamespaces: E } = f;
      let I = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: g });
      I || (I = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({ type: Qn.session_approve_started, properties: { topic: g, trace: [Qn.session_approve_started, Qn.session_namespaces_validation_success] } }));
      const A = await this.client.core.crypto.generateKeyPair(), C = p.publicKey, N = await this.client.core.crypto.generateSharedKey(A, C), x = At(At(At({ relay: { protocol: c ?? "irn" }, namespaces: l, controller: { publicKey: A, metadata: this.client.metadata }, expiry: Ht(zc) }, u && { sessionProperties: u }), h && { scopedProperties: h }), d && { sessionConfig: d }), O = Ct.relay;
      I.addTrace(Qn.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(N, { transportType: O });
      } catch (P) {
        throw I.setError(aa.subscribe_session_topic_failure), P;
      }
      I.addTrace(Qn.subscribe_session_topic_success);
      const k = Vr(At({}, x), { topic: N, requiredNamespaces: w, optionalNamespaces: E, pairingTopic: g, acknowledged: !1, self: x.controller, peer: { publicKey: p.publicKey, metadata: p.metadata }, controller: A, transportType: Ct.relay });
      await this.client.session.set(N, k), I.addTrace(Qn.store_session);
      try {
        I.addTrace(Qn.publishing_session_settle), await this.sendRequest({ topic: N, method: "wc_sessionSettle", params: x, throwOnFailedPublish: !0 }).catch((P) => {
          throw I == null || I.setError(aa.session_settle_publish_failure), P;
        }), I.addTrace(Qn.session_settle_publish_success), I.addTrace(Qn.publishing_session_approve), await this.sendResult({ id: a, topic: g, result: { relay: { protocol: c ?? "irn" }, responderPublicKey: A }, throwOnFailedPublish: !0 }).catch((P) => {
          throw I == null || I.setError(aa.session_approve_publish_failure), P;
        }), I.addTrace(Qn.session_approve_publish_success);
      } catch (P) {
        throw this.client.logger.error(P), this.client.session.delete(N, dt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(N), P;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: I.eventId }), await this.client.core.pairing.updateMetadata({ topic: g, metadata: p.metadata }), await this.client.proposal.delete(a, dt("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: g }), await this.setExpiry(N, Ht(zc)), { topic: N, acknowledged: () => Promise.resolve(this.client.session.get(N)) };
    }), G(this, "reject", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(t);
      } catch (o) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), o;
      }
      const { id: n, reason: s } = t;
      let i;
      try {
        i = this.client.proposal.get(n).pairingTopic;
      } catch (o) {
        throw this.client.logger.error(`reject() -> proposal.get(${n}) failed`), o;
      }
      i && (await this.sendError({ id: n, topic: i, error: s, rpcOpts: Gt.wc_sessionPropose.reject }), await this.client.proposal.delete(n, dt("USER_DISCONNECTED")));
    }), G(this, "update", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(t);
      } catch (h) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h;
      }
      const { topic: n, namespaces: s } = t, { done: i, resolve: o, reject: a } = pa(), c = Os(), l = Ta().toString(), u = this.client.session.get(n).namespaces;
      return this.events.once(rt("session_update", c), ({ error: h }) => {
        h ? a(h) : o();
      }), await this.client.session.update(n, { namespaces: s }), await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: s }, throwOnFailedPublish: !0, clientRpcId: c, relayRpcId: l }).catch((h) => {
        this.client.logger.error(h), this.client.session.update(n, { namespaces: u }), a(h);
      }), { acknowledged: i };
    }), G(this, "extend", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(t);
      } catch (c) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), c;
      }
      const { topic: n } = t, s = Os(), { done: i, resolve: o, reject: a } = pa();
      return this.events.once(rt("session_extend", s), ({ error: c }) => {
        c ? a(c) : o();
      }), await this.setExpiry(n, Ht(zc)), this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {}, clientRpcId: s, throwOnFailedPublish: !0 }).catch((c) => {
        a(c);
      }), { acknowledged: i };
    }), G(this, "request", async (t) => {
      this.isInitialized();
      try {
        await this.isValidRequest(t);
      } catch (w) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w;
      }
      const { chainId: n, request: s, topic: i, expiry: o = Gt.wc_sessionRequest.req.ttl } = t, a = this.client.session.get(i);
      (a == null ? void 0 : a.transportType) === Ct.relay && await this.confirmOnlineStateOrThrow();
      const c = Os(), l = Ta().toString(), { done: u, resolve: h, reject: d } = pa(o, "Request expired. Please try again.");
      this.events.once(rt("session_request", c), ({ error: w, result: E }) => {
        w ? d(w) : h(E);
      });
      const f = "wc_sessionRequest", g = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
      if (g) return await this.sendRequest({ clientRpcId: c, relayRpcId: l, topic: i, method: f, params: { request: Vr(At({}, s), { expiryTimestamp: Ht(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0, appLink: g }).catch((w) => d(w)), this.client.events.emit("session_request_sent", { topic: i, request: s, chainId: n, id: c }), await u();
      const p = { request: Vr(At({}, s), { expiryTimestamp: Ht(o) }), chainId: n };
      return await Promise.all([new Promise(async (w) => {
        await this.sendRequest({ clientRpcId: c, relayRpcId: l, topic: i, method: f, params: p, expiry: o, throwOnFailedPublish: !0, tvf: this.getTVFParams(c, p) }).catch((E) => d(E)), this.client.events.emit("session_request_sent", { topic: i, request: s, chainId: n, id: c }), w();
      }), new Promise(async (w) => {
        var E;
        if (!((E = a.sessionConfig) != null && E.disableDeepLink)) {
          const I = await c4(this.client.core.storage, $1);
          await i4({ id: c, topic: i, wcDeepLink: I });
        }
        w();
      }), u()]).then((w) => w[2]);
    }), G(this, "respond", async (t) => {
      this.isInitialized(), await this.isValidRespond(t);
      const { topic: n, response: s } = t, { id: i } = s, o = this.client.session.get(n);
      o.transportType === Ct.relay && await this.confirmOnlineStateOrThrow();
      const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
      Ps(s) ? await this.sendResult({ id: i, topic: n, result: s.result, throwOnFailedPublish: !0, appLink: a }) : Hn(s) && await this.sendError({ id: i, topic: n, error: s.error, appLink: a }), this.cleanupAfterResponse(t);
    }), G(this, "ping", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(t);
      } catch (s) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s;
      }
      const { topic: n } = t;
      if (this.client.session.keys.includes(n)) {
        const s = Os(), i = Ta().toString(), { done: o, resolve: a, reject: c } = pa();
        this.events.once(rt("session_ping", s), ({ error: l }) => {
          l ? c(l) : a();
        }), await Promise.all([this.sendRequest({ topic: n, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: s, relayRpcId: i }), o()]);
      } else this.client.core.pairing.pairings.keys.includes(n) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: n }));
    }), G(this, "emit", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t);
      const { topic: n, event: s, chainId: i } = t, o = Ta().toString(), a = Os();
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: s, chainId: i }, throwOnFailedPublish: !0, relayRpcId: o, clientRpcId: a });
    }), G(this, "disconnect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t);
      const { topic: n } = t;
      if (this.client.session.keys.includes(n)) await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: dt("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: n, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(n)) await this.client.core.pairing.disconnect({ topic: n });
      else {
        const { message: s } = Z("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
        throw new Error(s);
      }
    }), G(this, "find", (t) => (this.isInitialized(), this.client.session.getAll().filter((n) => pL(n, t)))), G(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), G(this, "authenticate", async (t, n) => {
      var s;
      this.isInitialized(), this.isValidAuthenticate(t);
      const i = n && this.client.core.linkModeSupportedApps.includes(n) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), o = i ? Ct.link_mode : Ct.relay;
      o === Ct.relay && await this.confirmOnlineStateOrThrow();
      const { chains: a, statement: c = "", uri: l, domain: u, nonce: h, type: d, exp: f, nbf: g, methods: p = [], expiry: w } = t, E = [...t.resources || []], { topic: I, uri: A } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: o });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: I, uri: A } });
      const C = await this.client.core.crypto.generateKeyPair(), N = Tp(C);
      if (await Promise.all([this.client.auth.authKeys.set(Op, { responseTopic: N, publicKey: C }), this.client.auth.pairingTopics.set(N, { topic: N, pairingTopic: I })]), await this.client.core.relayer.subscribe(N, { transportType: o }), this.client.logger.info(`sending request to new pairing topic: ${I}`), p.length > 0) {
        const { namespace: R } = vl(a[0]);
        let L = _B(R, "request", p);
        Np(E) && (L = SB(L, E.pop())), E.push(L);
      }
      const x = w && w > Gt.wc_sessionAuthenticate.req.ttl ? w : Gt.wc_sessionAuthenticate.req.ttl, O = { authPayload: { type: d ?? "caip122", chains: a, statement: c, aud: l, domain: u, version: "1", nonce: h, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: f, nbf: g, resources: E }, requester: { publicKey: C, metadata: this.client.metadata }, expiryTimestamp: Ht(x) }, k = { eip155: { chains: a, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...p])], events: ["chainChanged", "accountsChanged"] } }, P = { requiredNamespaces: {}, optionalNamespaces: k, relays: [{ protocol: "irn" }], pairingTopic: I, proposer: { publicKey: C, metadata: this.client.metadata }, expiryTimestamp: Ht(Gt.wc_sessionPropose.req.ttl), id: Os() }, { done: $, resolve: U, reject: j } = pa(x, "Request expired"), H = Os(), ee = rt("session_connect", P.id), y = rt("session_request", H), b = async ({ error: R, session: L }) => {
        this.events.off(y, T), R ? j(R) : L && U({ session: L });
      }, T = async (R) => {
        var L, q, Y;
        if (await this.deletePendingAuthRequest(H, { message: "fulfilled", code: 0 }), R.error) {
          const Ne = dt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return R.error.code === Ne.code ? void 0 : (this.events.off(ee, b), j(R.error.message));
        }
        await this.deleteProposal(P.id), this.events.off(ee, b);
        const { cacaos: de, responder: ne } = R.result, we = [], ke = [];
        for (const Ne of de) {
          await Ov({ cacao: Ne, projectId: this.client.core.projectId }) || (this.client.logger.error(Ne, "Signature verification failed"), j(dt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: yt } = Ne, Wt = Np(yt.resources), Bt = [gy(yt.iss)], It = ng(yt.iss);
          if (Wt) {
            const Rt = Pv(Wt), Tn = Rv(Wt);
            we.push(...Rt), Bt.push(...Tn);
          }
          for (const Rt of Bt) ke.push(`${Rt}:${It}`);
        }
        const xe = await this.client.core.crypto.generateSharedKey(C, ne.publicKey);
        let Ve;
        we.length > 0 && (Ve = { topic: xe, acknowledged: !0, self: { publicKey: C, metadata: this.client.metadata }, peer: ne, controller: ne.publicKey, expiry: Ht(zc), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: I, namespaces: r1([...new Set(we)], [...new Set(ke)]), transportType: o }, await this.client.core.relayer.subscribe(xe, { transportType: o }), await this.client.session.set(xe, Ve), I && await this.client.core.pairing.updateMetadata({ topic: I, metadata: ne.metadata }), Ve = this.client.session.get(xe)), (L = this.client.metadata.redirect) != null && L.linkMode && (q = ne.metadata.redirect) != null && q.linkMode && (Y = ne.metadata.redirect) != null && Y.universal && n && (this.client.core.addLinkModeSupportedApp(ne.metadata.redirect.universal), this.client.session.update(xe, { transportType: Ct.link_mode })), U({ auths: de, session: Ve });
      };
      this.events.once(ee, b), this.events.once(y, T);
      let B;
      try {
        if (i) {
          const R = Fo("wc_sessionAuthenticate", O, H);
          this.client.core.history.set(I, R);
          const L = await this.client.core.crypto.encode("", R, { type: Tf, encoding: wo });
          B = ip(n, I, L);
        } else await Promise.all([this.sendRequest({ topic: I, method: "wc_sessionAuthenticate", params: O, expiry: t.expiry, throwOnFailedPublish: !0, clientRpcId: H }), this.sendRequest({ topic: I, method: "wc_sessionPropose", params: P, expiry: Gt.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: P.id })]);
      } catch (R) {
        throw this.events.off(ee, b), this.events.off(y, T), R;
      }
      return await this.setProposal(P.id, P), await this.setAuthRequest(H, { request: Vr(At({}, O), { verifyContext: {} }), pairingTopic: I, transportType: o }), { uri: B ?? A, response: $ };
    }), G(this, "approveSessionAuthenticate", async (t) => {
      const { id: n, auths: s } = t, i = this.client.core.eventClient.createEvent({ properties: { topic: n.toString(), trace: [ca.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (w) {
        throw i.setError(dh.no_internet_connection), w;
      }
      const o = this.getPendingAuthRequest(n);
      if (!o) throw i.setError(dh.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${n}`);
      const a = o.transportType || Ct.relay;
      a === Ct.relay && await this.confirmOnlineStateOrThrow();
      const c = o.requester.publicKey, l = await this.client.core.crypto.generateKeyPair(), u = Tp(c), h = { type: Ui, receiverPublicKey: c, senderPublicKey: l }, d = [], f = [];
      for (const w of s) {
        if (!await Ov({ cacao: w, projectId: this.client.core.projectId })) {
          i.setError(dh.invalid_cacao);
          const N = dt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: n, topic: u, error: N, encodeOpts: h }), new Error(N.message);
        }
        i.addTrace(ca.cacaos_verified);
        const { p: E } = w, I = Np(E.resources), A = [gy(E.iss)], C = ng(E.iss);
        if (I) {
          const N = Pv(I), x = Rv(I);
          d.push(...N), A.push(...x);
        }
        for (const N of A) f.push(`${N}:${C}`);
      }
      const g = await this.client.core.crypto.generateSharedKey(l, c);
      i.addTrace(ca.create_authenticated_session_topic);
      let p;
      if ((d == null ? void 0 : d.length) > 0) {
        p = { topic: g, acknowledged: !0, self: { publicKey: l, metadata: this.client.metadata }, peer: { publicKey: c, metadata: o.requester.metadata }, controller: c, expiry: Ht(zc), authentication: s, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: o.pairingTopic, namespaces: r1([...new Set(d)], [...new Set(f)]), transportType: a }, i.addTrace(ca.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(g, { transportType: a });
        } catch (w) {
          throw i.setError(dh.subscribe_authenticated_session_topic_failure), w;
        }
        i.addTrace(ca.subscribe_authenticated_session_topic_success), await this.client.session.set(g, p), i.addTrace(ca.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: o.pairingTopic, metadata: o.requester.metadata });
      }
      i.addTrace(ca.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: u, id: n, result: { cacaos: s, responder: { publicKey: l, metadata: this.client.metadata } }, encodeOpts: h, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(o.requester.metadata, a) });
      } catch (w) {
        throw i.setError(dh.authenticated_session_approve_publish_failure), w;
      }
      return await this.client.auth.requests.delete(n, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: o.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i.eventId }), { session: p };
    }), G(this, "rejectSessionAuthenticate", async (t) => {
      this.isInitialized();
      const { id: n, reason: s } = t, i = this.getPendingAuthRequest(n);
      if (!i) throw new Error(`Could not find pending auth request with id ${n}`);
      i.transportType === Ct.relay && await this.confirmOnlineStateOrThrow();
      const o = i.requester.publicKey, a = await this.client.core.crypto.generateKeyPair(), c = Tp(o), l = { type: Ui, receiverPublicKey: o, senderPublicKey: a };
      await this.sendError({ id: n, topic: c, error: s, encodeOpts: l, rpcOpts: Gt.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType) }), await this.client.auth.requests.delete(n, { message: "rejected", code: 0 }), await this.client.proposal.delete(n, dt("USER_DISCONNECTED"));
    }), G(this, "formatAuthMessage", (t) => {
      this.isInitialized();
      const { request: n, iss: s } = t;
      return n2(n, s);
    }), G(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const t = this.relayMessageCache.shift();
          t && await this.onRelayMessage(t);
        } catch (t) {
          this.client.logger.error(t);
        }
      }, 50);
    }), G(this, "cleanupDuplicatePairings", async (t) => {
      if (t.pairingTopic) try {
        const n = this.client.core.pairing.pairings.get(t.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i) => {
          var o, a;
          return ((o = i.peerMetadata) == null ? void 0 : o.url) && ((a = i.peerMetadata) == null ? void 0 : a.url) === t.peer.metadata.url && i.topic && i.topic !== n.topic;
        });
        if (s.length === 0) return;
        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i) => this.client.core.pairing.disconnect({ topic: i.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (n) {
        this.client.logger.error(n);
      }
    }), G(this, "deleteSession", async (t) => {
      var n;
      const { topic: s, expirerHasDeleted: i = !1, emitEvent: o = !0, id: a = 0 } = t, { self: c } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, dt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(c.publicKey) && await this.client.core.crypto.deleteKeyPair(c.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem($1).catch((l) => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach((l) => {
        l.topic === s && this.deletePendingSessionRequest(l.id, dt("USER_DISCONNECTED"));
      }), s === ((n = this.sessionRequestQueue.queue[0]) == null ? void 0 : n.topic) && (this.sessionRequestQueue.state = Ns.idle), o && this.client.events.emit("session_delete", { id: a, topic: s });
    }), G(this, "deleteProposal", async (t, n) => {
      if (n) try {
        const s = this.client.proposal.get(t), i = this.client.core.eventClient.getEvent({ topic: s.pairingTopic });
        i == null || i.setError(aa.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(t, dt("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "proposal");
    }), G(this, "deletePendingSessionRequest", async (t, n, s = !1) => {
      await Promise.all([this.client.pendingRequest.delete(t, n), s ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i) => i.id !== t), s && (this.sessionRequestQueue.state = Ns.idle, this.client.events.emit("session_request_expire", { id: t }));
    }), G(this, "deletePendingAuthRequest", async (t, n, s = !1) => {
      await Promise.all([this.client.auth.requests.delete(t, n), s ? Promise.resolve() : this.client.core.expirer.del(t)]);
    }), G(this, "setExpiry", async (t, n) => {
      this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, n), await this.client.session.update(t, { expiry: n }));
    }), G(this, "setProposal", async (t, n) => {
      this.client.core.expirer.set(t, Ht(Gt.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, n);
    }), G(this, "setAuthRequest", async (t, n) => {
      const { request: s, pairingTopic: i, transportType: o = Ct.relay } = n;
      this.client.core.expirer.set(t, s.expiryTimestamp), await this.client.auth.requests.set(t, { authPayload: s.authPayload, requester: s.requester, expiryTimestamp: s.expiryTimestamp, id: t, pairingTopic: i, verifyContext: s.verifyContext, transportType: o });
    }), G(this, "setPendingSessionRequest", async (t) => {
      const { id: n, topic: s, params: i, verifyContext: o } = t, a = i.request.expiryTimestamp || Ht(Gt.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(n, a), await this.client.pendingRequest.set(n, { id: n, topic: s, params: i, verifyContext: o });
    }), G(this, "sendRequest", async (t) => {
      const { topic: n, method: s, params: i, expiry: o, relayRpcId: a, clientRpcId: c, throwOnFailedPublish: l, appLink: u, tvf: h } = t, d = Fo(s, i, c);
      let f;
      const g = !!u;
      try {
        const E = g ? wo : ps;
        f = await this.client.core.crypto.encode(n, d, { encoding: E });
      } catch (E) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${n} failed`), E;
      }
      let p;
      if (o7.includes(s)) {
        const E = zs(JSON.stringify(d)), I = zs(f);
        p = await this.client.core.verify.register({ id: I, decryptedId: E });
      }
      const w = Gt[s].req;
      if (w.attestation = p, o && (w.ttl = o), a && (w.id = a), this.client.core.history.set(n, d), g) {
        const E = ip(u, n, f);
        await global.Linking.openURL(E, this.client.name);
      } else {
        const E = Gt[s].req;
        o && (E.ttl = o), a && (E.id = a), E.tvf = Vr(At({}, h), { correlationId: d.id }), l ? (E.internal = Vr(At({}, E.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, f, E)) : this.client.core.relayer.publish(n, f, E).catch((I) => this.client.logger.error(I));
      }
      return d.id;
    }), G(this, "sendResult", async (t) => {
      const { id: n, topic: s, result: i, throwOnFailedPublish: o, encodeOpts: a, appLink: c } = t, l = em(n, i);
      let u;
      const h = c && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const g = h ? wo : ps;
        u = await this.client.core.crypto.encode(s, l, Vr(At({}, a || {}), { encoding: g }));
      } catch (g) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), g;
      }
      let d, f;
      try {
        d = await this.client.core.history.get(s, n);
        const g = d.request;
        try {
          f = this.getTVFParams(n, g.params, i);
        } catch (p) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", p);
        }
      } catch (g) {
        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${n}) failed`), g;
      }
      if (h) {
        const g = ip(c, s, u);
        await global.Linking.openURL(g, this.client.name);
      } else {
        const g = d.request.method, p = Gt[g].res;
        p.tvf = Vr(At({}, f), { correlationId: n }), o ? (p.internal = Vr(At({}, p.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(s, u, p)) : this.client.core.relayer.publish(s, u, p).catch((w) => this.client.logger.error(w));
      }
      await this.client.core.history.resolve(l);
    }), G(this, "sendError", async (t) => {
      const { id: n, topic: s, error: i, encodeOpts: o, rpcOpts: a, appLink: c } = t, l = tm(n, i);
      let u;
      const h = c && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const f = h ? wo : ps;
        u = await this.client.core.crypto.encode(s, l, Vr(At({}, o || {}), { encoding: f }));
      } catch (f) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), f;
      }
      let d;
      try {
        d = await this.client.core.history.get(s, n);
      } catch (f) {
        throw this.client.logger.error(`sendError() -> history.get(${s}, ${n}) failed`), f;
      }
      if (h) {
        const f = ip(c, s, u);
        await global.Linking.openURL(f, this.client.name);
      } else {
        const f = d.request.method, g = a || Gt[f].res;
        this.client.core.relayer.publish(s, u, g);
      }
      await this.client.core.history.resolve(l);
    }), G(this, "cleanup", async () => {
      const t = [], n = [];
      this.client.session.getAll().forEach((s) => {
        let i = !1;
        ho(s.expiry) && (i = !0), this.client.core.crypto.keychain.has(s.topic) || (i = !0), i && t.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        ho(s.expiryTimestamp) && n.push(s.id);
      }), await Promise.all([...t.map((s) => this.deleteSession({ topic: s })), ...n.map((s) => this.deleteProposal(s))]);
    }), G(this, "onProviderMessageEvent", async (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t);
    }), G(this, "onRelayEventRequest", async (t) => {
      this.requestQueue.queue.push(t), await this.processRequestsQueue();
    }), G(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === Ns.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = Ns.active;
        const t = this.requestQueue.queue.shift();
        if (t) try {
          await this.processRequest(t);
        } catch (n) {
          this.client.logger.warn(n);
        }
      }
      this.requestQueue.state = Ns.idle;
    }), G(this, "processRequest", async (t) => {
      const { topic: n, payload: s, attestation: i, transportType: o, encryptedId: a } = t, c = s.method;
      if (!this.shouldIgnorePairingRequest({ topic: n, requestMethod: c })) switch (c) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: n, payload: s, attestation: i, encryptedId: a });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(n, s);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(n, s);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(n, s);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(n, s);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(n, s);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: n, payload: s, attestation: i, encryptedId: a, transportType: o });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(n, s);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: n, payload: s, attestation: i, encryptedId: a, transportType: o });
        default:
          return this.client.logger.info(`Unsupported request method ${c}`);
      }
    }), G(this, "onRelayEventResponse", async (t) => {
      const { topic: n, payload: s, transportType: i } = t, o = (await this.client.core.history.get(n, s.id)).request.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, s, i);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, s);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(n, s);
        default:
          return this.client.logger.info(`Unsupported response method ${o}`);
      }
    }), G(this, "onRelayEventUnknownPayload", (t) => {
      const { topic: n } = t, { message: s } = Z("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }), G(this, "shouldIgnorePairingRequest", (t) => {
      const { topic: n, requestMethod: s } = t, i = this.expectedPairingMethodMap.get(n);
      return !i || i.includes(s) ? !1 : !!(i.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), G(this, "onSessionProposeRequest", async (t) => {
      const { topic: n, payload: s, attestation: i, encryptedId: o } = t, { params: a, id: c } = s;
      try {
        const l = this.client.core.eventClient.getEvent({ topic: n });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l == null || l.setError(di.proposal_listener_not_found)), this.isValidConnect(At({}, s.params));
        const u = a.expiryTimestamp || Ht(Gt.wc_sessionPropose.req.ttl), h = At({ id: c, pairingTopic: n, expiryTimestamp: u }, a);
        await this.setProposal(c, h);
        const d = await this.getVerifyContext({ attestationId: i, hash: zs(JSON.stringify(s)), encryptedId: o, metadata: h.proposer.metadata });
        l == null || l.addTrace(xs.emit_session_proposal), this.client.events.emit("session_proposal", { id: c, params: h, verifyContext: d });
      } catch (l) {
        await this.sendError({ id: c, topic: n, error: l, rpcOpts: Gt.wc_sessionPropose.autoReject }), this.client.logger.error(l);
      }
    }), G(this, "onSessionProposeResponse", async (t, n, s) => {
      const { id: i } = n;
      if (Ps(n)) {
        const { result: o } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: o });
        const a = this.client.proposal.get(i);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const c = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: c });
        const l = o.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l });
        const u = await this.client.core.crypto.generateSharedKey(c, l);
        this.pendingSessions.set(i, { sessionTopic: u, pairingTopic: t, proposalId: i, publicKey: c });
        const h = await this.client.core.relayer.subscribe(u, { transportType: s });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h }), await this.client.core.pairing.activate({ topic: t });
      } else if (Hn(n)) {
        await this.client.proposal.delete(i, dt("USER_DISCONNECTED"));
        const o = rt("session_connect", i);
        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners, 954`);
        this.events.emit(o, { error: n.error });
      }
    }), G(this, "onSessionSettleRequest", async (t, n) => {
      const { id: s, params: i } = n;
      try {
        this.isValidSessionSettleRequest(i);
        const { relay: o, controller: a, expiry: c, namespaces: l, sessionProperties: u, scopedProperties: h, sessionConfig: d } = n.params, f = [...this.pendingSessions.values()].find((w) => w.sessionTopic === t);
        if (!f) return this.client.logger.error(`Pending session not found for topic ${t}`);
        const g = this.client.proposal.get(f.proposalId), p = Vr(At(At(At({ topic: t, relay: o, expiry: c, namespaces: l, acknowledged: !0, pairingTopic: f.pairingTopic, requiredNamespaces: g.requiredNamespaces, optionalNamespaces: g.optionalNamespaces, controller: a.publicKey, self: { publicKey: f.publicKey, metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, u && { sessionProperties: u }), h && { scopedProperties: h }), d && { sessionConfig: d }), { transportType: Ct.relay });
        await this.client.session.set(p.topic, p), await this.setExpiry(p.topic, p.expiry), await this.client.core.pairing.updateMetadata({ topic: f.pairingTopic, metadata: p.peer.metadata }), this.client.events.emit("session_connect", { session: p }), this.events.emit(rt("session_connect", f.proposalId), { session: p }), this.pendingSessions.delete(f.proposalId), this.deleteProposal(f.proposalId, !1), this.cleanupDuplicatePairings(p), await this.sendResult({ id: n.id, topic: t, result: !0, throwOnFailedPublish: !0 });
      } catch (o) {
        await this.sendError({ id: s, topic: t, error: o }), this.client.logger.error(o);
      }
    }), G(this, "onSessionSettleResponse", async (t, n) => {
      const { id: s } = n;
      Ps(n) ? (await this.client.session.update(t, { acknowledged: !0 }), this.events.emit(rt("session_approve", s), {})) : Hn(n) && (await this.client.session.delete(t, dt("USER_DISCONNECTED")), this.events.emit(rt("session_approve", s), { error: n.error }));
    }), G(this, "onSessionUpdateRequest", async (t, n) => {
      const { params: s, id: i } = n;
      try {
        const o = `${t}_session_update`, a = uh.get(o);
        if (a && this.isRequestOutOfSync(a, i)) {
          this.client.logger.warn(`Discarding out of sync request - ${i}`), this.sendError({ id: i, topic: t, error: dt("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(At({ topic: t }, s));
        try {
          uh.set(o, i), await this.client.session.update(t, { namespaces: s.namespaces }), await this.sendResult({ id: i, topic: t, result: !0, throwOnFailedPublish: !0 });
        } catch (c) {
          throw uh.delete(o), c;
        }
        this.client.events.emit("session_update", { id: i, topic: t, params: s });
      } catch (o) {
        await this.sendError({ id: i, topic: t, error: o }), this.client.logger.error(o);
      }
    }), G(this, "isRequestOutOfSync", (t, n) => n.toString().slice(0, -3) < t.toString().slice(0, -3)), G(this, "onSessionUpdateResponse", (t, n) => {
      const { id: s } = n, i = rt("session_update", s);
      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
      Ps(n) ? this.events.emit(rt("session_update", s), {}) : Hn(n) && this.events.emit(rt("session_update", s), { error: n.error });
    }), G(this, "onSessionExtendRequest", async (t, n) => {
      const { id: s } = n;
      try {
        this.isValidExtend({ topic: t }), await this.setExpiry(t, Ht(zc)), await this.sendResult({ id: s, topic: t, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: s, topic: t });
      } catch (i) {
        await this.sendError({ id: s, topic: t, error: i }), this.client.logger.error(i);
      }
    }), G(this, "onSessionExtendResponse", (t, n) => {
      const { id: s } = n, i = rt("session_extend", s);
      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
      Ps(n) ? this.events.emit(rt("session_extend", s), {}) : Hn(n) && this.events.emit(rt("session_extend", s), { error: n.error });
    }), G(this, "onSessionPingRequest", async (t, n) => {
      const { id: s } = n;
      try {
        this.isValidPing({ topic: t }), await this.sendResult({ id: s, topic: t, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: s, topic: t });
      } catch (i) {
        await this.sendError({ id: s, topic: t, error: i }), this.client.logger.error(i);
      }
    }), G(this, "onSessionPingResponse", (t, n) => {
      const { id: s } = n, i = rt("session_ping", s);
      setTimeout(() => {
        if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners 2176`);
        Ps(n) ? this.events.emit(rt("session_ping", s), {}) : Hn(n) && this.events.emit(rt("session_ping", s), { error: n.error });
      }, 500);
    }), G(this, "onSessionDeleteRequest", async (t, n) => {
      const { id: s } = n;
      try {
        this.isValidDisconnect({ topic: t, reason: n.params }), Promise.all([new Promise((i) => {
          this.client.core.relayer.once(Zt.publish, async () => {
            i(await this.deleteSession({ topic: t, id: s }));
          });
        }), this.sendResult({ id: s, topic: t, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: t, error: dt("USER_DISCONNECTED") })]).catch((i) => this.client.logger.error(i));
      } catch (i) {
        this.client.logger.error(i);
      }
    }), G(this, "onSessionRequest", async (t) => {
      var n, s, i;
      const { topic: o, payload: a, attestation: c, encryptedId: l, transportType: u } = t, { id: h, params: d } = a;
      try {
        await this.isValidRequest(At({ topic: o }, d));
        const f = this.client.session.get(o), g = await this.getVerifyContext({ attestationId: c, hash: zs(JSON.stringify(Fo("wc_sessionRequest", d, h))), encryptedId: l, metadata: f.peer.metadata, transportType: u }), p = { id: h, topic: o, params: d, verifyContext: g };
        await this.setPendingSessionRequest(p), u === Ct.link_mode && (n = f.peer.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp((s = f.peer.metadata.redirect) == null ? void 0 : s.universal), (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(p) : (this.addSessionRequestToSessionRequestQueue(p), this.processSessionRequestQueue());
      } catch (f) {
        await this.sendError({ id: h, topic: o, error: f }), this.client.logger.error(f);
      }
    }), G(this, "onSessionRequestResponse", (t, n) => {
      const { id: s } = n, i = rt("session_request", s);
      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
      Ps(n) ? this.events.emit(rt("session_request", s), { result: n.result }) : Hn(n) && this.events.emit(rt("session_request", s), { error: n.error });
    }), G(this, "onSessionEventRequest", async (t, n) => {
      const { id: s, params: i } = n;
      try {
        const o = `${t}_session_event_${i.event.name}`, a = uh.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidEmit(At({ topic: t }, i)), this.client.events.emit("session_event", { id: s, topic: t, params: i }), uh.set(o, s);
      } catch (o) {
        await this.sendError({ id: s, topic: t, error: o }), this.client.logger.error(o);
      }
    }), G(this, "onSessionAuthenticateResponse", (t, n) => {
      const { id: s } = n;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t, payload: n }), Ps(n) ? this.events.emit(rt("session_request", s), { result: n.result }) : Hn(n) && this.events.emit(rt("session_request", s), { error: n.error });
    }), G(this, "onSessionAuthenticateRequest", async (t) => {
      var n;
      const { topic: s, payload: i, attestation: o, encryptedId: a, transportType: c } = t;
      try {
        const { requester: l, authPayload: u, expiryTimestamp: h } = i.params, d = await this.getVerifyContext({ attestationId: o, hash: zs(JSON.stringify(i)), encryptedId: a, metadata: l.metadata, transportType: c }), f = { requester: l, pairingTopic: s, id: i.id, authPayload: u, verifyContext: d, expiryTimestamp: h };
        await this.setAuthRequest(i.id, { request: f, pairingTopic: s, transportType: c }), c === Ct.link_mode && (n = l.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s, params: i.params, id: i.id, verifyContext: d });
      } catch (l) {
        this.client.logger.error(l);
        const u = i.params.requester.publicKey, h = await this.client.core.crypto.generateKeyPair(), d = this.getAppLinkIfEnabled(i.params.requester.metadata, c), f = { type: Ui, receiverPublicKey: u, senderPublicKey: h };
        await this.sendError({ id: i.id, topic: s, error: l, encodeOpts: f, rpcOpts: Gt.wc_sessionAuthenticate.autoReject, appLink: d });
      }
    }), G(this, "addSessionRequestToSessionRequestQueue", (t) => {
      this.sessionRequestQueue.queue.push(t);
    }), G(this, "cleanupAfterResponse", (t) => {
      this.deletePendingSessionRequest(t.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = Ns.idle, this.processSessionRequestQueue();
      }, Q.toMiliseconds(this.requestQueueDelay));
    }), G(this, "cleanupPendingSentRequestsForTopic", ({ topic: t, error: n }) => {
      const s = this.client.core.history.pending;
      s.length > 0 && s.filter((i) => i.topic === t && i.request.method === "wc_sessionRequest").forEach((i) => {
        const o = i.request.id, a = rt("session_request", o);
        if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners`);
        this.events.emit(rt("session_request", i.request.id), { error: n });
      });
    }), G(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === Ns.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t = this.sessionRequestQueue.queue[0];
      if (!t) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = Ns.active, this.emitSessionRequest(t);
      } catch (n) {
        this.client.logger.error(n);
      }
    }), G(this, "emitSessionRequest", (t) => {
      this.client.events.emit("session_request", t);
    }), G(this, "onPairingCreated", (t) => {
      if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active) return;
      const n = this.client.proposal.getAll().find((s) => s.pairingTopic === t.topic);
      n && this.onSessionProposeRequest({ topic: t.topic, payload: Fo("wc_sessionPropose", Vr(At({}, n), { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties, scopedProperties: n.scopedProperties }), n.id) });
    }), G(this, "isValidConnect", async (t) => {
      if (!Jr(t)) {
        const { message: l } = Z("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
        throw new Error(l);
      }
      const { pairingTopic: n, requiredNamespaces: s, optionalNamespaces: i, sessionProperties: o, scopedProperties: a, relays: c } = t;
      if (lr(n) || await this.isValidPairingTopic(n), !SL(c)) {
        const { message: l } = Z("MISSING_OR_INVALID", `connect() relays: ${c}`);
        throw new Error(l);
      }
      if (!lr(s) && jo(s) !== 0) {
        const l = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l) : this.client.logger.warn(l), this.validateNamespaces(s, "requiredNamespaces");
      }
      if (!lr(i) && jo(i) !== 0 && this.validateNamespaces(i, "optionalNamespaces"), lr(o) || this.validateSessionProps(o, "sessionProperties"), !lr(a)) {
        this.validateSessionProps(a, "scopedProperties");
        const l = Object.keys(s || {}).concat(Object.keys(i || {}));
        if (!Object.keys(a).every((u) => l.includes(u))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(l)}`);
      }
    }), G(this, "validateNamespaces", (t, n) => {
      const s = IL(t, "connect()", n);
      if (s) throw new Error(s.message);
    }), G(this, "isValidApprove", async (t) => {
      if (!Jr(t)) throw new Error(Z("MISSING_OR_INVALID", `approve() params: ${t}`).message);
      const { id: n, namespaces: s, relayProtocol: i, sessionProperties: o, scopedProperties: a } = t;
      this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
      const c = this.client.proposal.get(n), l = cw(s, "approve()");
      if (l) throw new Error(l.message);
      const u = i1(c.requiredNamespaces, s, "approve()");
      if (u) throw new Error(u.message);
      if (!Ft(i, !0)) {
        const { message: h } = Z("MISSING_OR_INVALID", `approve() relayProtocol: ${i}`);
        throw new Error(h);
      }
      if (lr(o) || this.validateSessionProps(o, "sessionProperties"), !lr(a)) {
        this.validateSessionProps(a, "scopedProperties");
        const h = new Set(Object.keys(s));
        if (!Object.keys(a).every((d) => h.has(d))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(h).join(", ")}`);
      }
    }), G(this, "isValidReject", async (t) => {
      if (!Jr(t)) {
        const { message: i } = Z("MISSING_OR_INVALID", `reject() params: ${t}`);
        throw new Error(i);
      }
      const { id: n, reason: s } = t;
      if (this.checkRecentlyDeleted(n), await this.isValidProposalId(n), !TL(s)) {
        const { message: i } = Z("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(i);
      }
    }), G(this, "isValidSessionSettleRequest", (t) => {
      if (!Jr(t)) {
        const { message: l } = Z("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
        throw new Error(l);
      }
      const { relay: n, controller: s, namespaces: i, expiry: o } = t;
      if (!k2(n)) {
        const { message: l } = Z("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l);
      }
      const a = bL(s, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      const c = cw(i, "onSessionSettleRequest()");
      if (c) throw new Error(c.message);
      if (ho(o)) {
        const { message: l } = Z("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l);
      }
    }), G(this, "isValidUpdate", async (t) => {
      if (!Jr(t)) {
        const { message: c } = Z("MISSING_OR_INVALID", `update() params: ${t}`);
        throw new Error(c);
      }
      const { topic: n, namespaces: s } = t;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const i = this.client.session.get(n), o = cw(s, "update()");
      if (o) throw new Error(o.message);
      const a = i1(i.requiredNamespaces, s, "update()");
      if (a) throw new Error(a.message);
    }), G(this, "isValidExtend", async (t) => {
      if (!Jr(t)) {
        const { message: s } = Z("MISSING_OR_INVALID", `extend() params: ${t}`);
        throw new Error(s);
      }
      const { topic: n } = t;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
    }), G(this, "isValidRequest", async (t) => {
      if (!Jr(t)) {
        const { message: c } = Z("MISSING_OR_INVALID", `request() params: ${t}`);
        throw new Error(c);
      }
      const { topic: n, request: s, chainId: i, expiry: o } = t;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!s1(a, i)) {
        const { message: c } = Z("MISSING_OR_INVALID", `request() chainId: ${i}`);
        throw new Error(c);
      }
      if (!xL(s)) {
        const { message: c } = Z("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(c);
      }
      if (!RL(a, i, s.method)) {
        const { message: c } = Z("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(c);
      }
      if (o && !BL(o, gw)) {
        const { message: c } = Z("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${gw.min} and ${gw.max}`);
        throw new Error(c);
      }
    }), G(this, "isValidRespond", async (t) => {
      var n;
      if (!Jr(t)) {
        const { message: o } = Z("MISSING_OR_INVALID", `respond() params: ${t}`);
        throw new Error(o);
      }
      const { topic: s, response: i } = t;
      try {
        await this.isValidSessionTopic(s);
      } catch (o) {
        throw (n = t == null ? void 0 : t.response) != null && n.id && this.cleanupAfterResponse(t), o;
      }
      if (!OL(i)) {
        const { message: o } = Z("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i)}`);
        throw new Error(o);
      }
    }), G(this, "isValidPing", async (t) => {
      if (!Jr(t)) {
        const { message: s } = Z("MISSING_OR_INVALID", `ping() params: ${t}`);
        throw new Error(s);
      }
      const { topic: n } = t;
      await this.isValidSessionOrPairingTopic(n);
    }), G(this, "isValidEmit", async (t) => {
      if (!Jr(t)) {
        const { message: a } = Z("MISSING_OR_INVALID", `emit() params: ${t}`);
        throw new Error(a);
      }
      const { topic: n, event: s, chainId: i } = t;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!s1(o, i)) {
        const { message: a } = Z("MISSING_OR_INVALID", `emit() chainId: ${i}`);
        throw new Error(a);
      }
      if (!PL(s)) {
        const { message: a } = Z("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(a);
      }
      if (!DL(o, i, s.name)) {
        const { message: a } = Z("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(a);
      }
    }), G(this, "isValidDisconnect", async (t) => {
      if (!Jr(t)) {
        const { message: s } = Z("MISSING_OR_INVALID", `disconnect() params: ${t}`);
        throw new Error(s);
      }
      const { topic: n } = t;
      await this.isValidSessionOrPairingTopic(n);
    }), G(this, "isValidAuthenticate", (t) => {
      const { chains: n, uri: s, domain: i, nonce: o } = t;
      if (!Array.isArray(n) || n.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!Ft(s, !1)) throw new Error("uri is required parameter");
      if (!Ft(i, !1)) throw new Error("domain is required parameter");
      if (!Ft(o, !1)) throw new Error("nonce is required parameter");
      if ([...new Set(n.map((c) => vl(c).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: a } = vl(n[0]);
      if (a !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), G(this, "getVerifyContext", async (t) => {
      const { attestationId: n, hash: s, encryptedId: i, metadata: o, transportType: a } = t, c = { verified: { verifyUrl: o.verifyUrl || Mh, validation: "UNKNOWN", origin: o.url || "" } };
      try {
        if (a === Ct.link_mode) {
          const u = this.getAppLinkIfEnabled(o, a);
          return c.verified.validation = u && new URL(u).origin === new URL(o.url).origin ? "VALID" : "INVALID", c;
        }
        const l = await this.client.core.verify.resolve({ attestationId: n, hash: s, encryptedId: i, verifyUrl: o.verifyUrl });
        l && (c.verified.origin = l.origin, c.verified.isScam = l.isScam, c.verified.validation = l.origin === new URL(o.url).origin ? "VALID" : "INVALID");
      } catch (l) {
        this.client.logger.warn(l);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`), c;
    }), G(this, "validateSessionProps", (t, n) => {
      Object.values(t).forEach((s, i) => {
        if (s == null) {
          const { message: o } = Z("MISSING_OR_INVALID", `${n} must contain an existing value for each key. Received: ${s} for key ${Object.keys(t)[i]}`);
          throw new Error(o);
        }
      });
    }), G(this, "getPendingAuthRequest", (t) => {
      const n = this.client.auth.requests.get(t);
      return typeof n == "object" ? n : void 0;
    }), G(this, "addToRecentlyDeleted", (t, n) => {
      if (this.recentlyDeletedMap.set(t, n), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s = 0;
        const i = this.recentlyDeletedLimit / 2;
        for (const o of this.recentlyDeletedMap.keys()) {
          if (s++ >= i) break;
          this.recentlyDeletedMap.delete(o);
        }
      }
    }), G(this, "checkRecentlyDeleted", (t) => {
      const n = this.recentlyDeletedMap.get(t);
      if (n) {
        const { message: s } = Z("MISSING_OR_INVALID", `Record was recently deleted - ${n}: ${t}`);
        throw new Error(s);
      }
    }), G(this, "isLinkModeEnabled", (t, n) => {
      var s, i, o, a, c, l, u, h, d;
      return !t || n !== Ct.link_mode ? !1 : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === !0 && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((l = (c = this.client.metadata) == null ? void 0 : c.redirect) == null ? void 0 : l.universal) !== "" && ((u = t == null ? void 0 : t.redirect) == null ? void 0 : u.universal) !== void 0 && ((h = t == null ? void 0 : t.redirect) == null ? void 0 : h.universal) !== "" && ((d = t == null ? void 0 : t.redirect) == null ? void 0 : d.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), G(this, "getAppLinkIfEnabled", (t, n) => {
      var s;
      return this.isLinkModeEnabled(t, n) ? (s = t == null ? void 0 : t.redirect) == null ? void 0 : s.universal : void 0;
    }), G(this, "handleLinkModeMessage", ({ url: t }) => {
      if (!t || !t.includes("wc_ev") || !t.includes("topic")) return;
      const n = bv(t, "topic") || "", s = decodeURIComponent(bv(t, "wc_ev") || ""), i = this.client.session.keys.includes(n);
      i && this.client.session.update(n, { transportType: Ct.link_mode }), this.client.core.dispatchEnvelope({ topic: n, message: s, sessionExists: i });
    }), G(this, "registerLinkModeListeners", async () => {
      var t;
      if (rb() || ta() && (t = this.client.metadata.redirect) != null && t.linkMode) {
        const n = global == null ? void 0 : global.Linking;
        if (typeof n < "u") {
          n.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s = await n.getInitialURL();
          s && setTimeout(() => {
            this.handleLinkModeMessage({ url: s });
          }, 50);
        }
      }
    }), G(this, "getTVFParams", (t, n, s) => {
      var i, o;
      const a = { correlationId: t, rpcMethods: [n.request.method], chainId: n.chainId };
      try {
        const c = this.extractTxHashesFromResult(n.request, s);
        a.txHashes = c, a.contractAddresses = this.isValidContractData(n.request.params) ? [(o = (i = n.request.params) == null ? void 0 : i[0]) == null ? void 0 : o.to] : [];
      } catch (c) {
        this.client.logger.warn("Error getting TVF params", c);
      }
      return a;
    }), G(this, "isValidContractData", (t) => {
      var n;
      if (!t) return !1;
      try {
        const s = (t == null ? void 0 : t.data) || ((n = t == null ? void 0 : t[0]) == null ? void 0 : n.data);
        if (!s.startsWith("0x")) return !1;
        const i = s.slice(2);
        return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : !1;
      } catch {
      }
      return !1;
    }), G(this, "extractTxHashesFromResult", (t, n) => {
      var s;
      try {
        if (!n) return [];
        const i = t.method, o = s7[i];
        if (i === "sui_signTransaction") return [cB(n.transactionBytes)];
        if (i === "near_signTransaction") return [Sv(n)];
        if (i === "near_signTransactions") return n.map((c) => Sv(c));
        if (i === "xrpl_signTransactionFor" || i === "xrpl_signTransaction") return [(s = n.tx_json) == null ? void 0 : s.hash];
        if (i === "polkadot_signTransaction") return [QL({ transaction: t.params.transactionPayload, signature: n.signature })];
        if (i === "algo_signTxn") return Bi(n) ? n.map((c) => Nv(c)) : [Nv(n)];
        if (i === "cosmos_signDirect") return [uB(n)];
        if (typeof n == "string") return [n];
        const a = n[o.key];
        if (Bi(a)) return i === "solana_signAllTransactions" ? a.map((c) => aB(c)) : a;
        if (typeof a == "string") return [a];
      } catch (i) {
        this.client.logger.warn("Error extracting tx hashes from result", i);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const e = this.client.session.keys, t = this.client.core.relayer.messages.getWithoutAck(e);
      for (const [n, s] of Object.entries(t)) for (const i of s) try {
        await this.onProviderMessageEvent({ topic: n, message: i, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${n}, message: ${i}`);
      }
    } catch (e) {
      this.client.logger.warn("processPendingMessageEvents failed", e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Z("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(Zt.message, (e) => {
      this.onProviderMessageEvent(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: t, message: n, attestation: s, transportType: i } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes(Op) ? this.client.auth.authKeys.get(Op) : { publicKey: void 0 };
    try {
      const a = await this.client.core.crypto.decode(t, n, { receiverPublicKey: o, encoding: i === Ct.link_mode ? wo : ps });
      wb(a) ? (this.client.core.history.set(t, a), await this.onRelayEventRequest({ topic: t, payload: a, attestation: s, transportType: i, encryptedId: zs(n) })) : rm(a) ? (await this.client.core.history.resolve(a), await this.onRelayEventResponse({ topic: t, payload: a, transportType: i }), this.client.core.history.delete(t, a.id)) : await this.onRelayEventUnknownPayload({ topic: t, payload: a, transportType: i }), await this.client.core.relayer.messages.ack(t, n);
    } catch (a) {
      this.client.logger.error(a);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(Un.expired, async (e) => {
      const { topic: t, id: n } = zI(e.target);
      if (n && this.client.pendingRequest.keys.includes(n)) return await this.deletePendingSessionRequest(n, Z("EXPIRED"), !0);
      if (n && this.client.auth.requests.keys.includes(n)) return await this.deletePendingAuthRequest(n, Z("EXPIRED"), !0);
      t ? this.client.session.keys.includes(t) && (await this.deleteSession({ topic: t, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: t })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(ya.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(ya.delete, (e) => {
      this.addToRecentlyDeleted(e.topic, "pairing");
    });
  }
  isValidPairingTopic(e) {
    if (!Ft(e, !1)) {
      const { message: t } = Z("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(t);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: t } = Z("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (ho(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: t } = Z("EXPIRED", `pairing topic: ${e}`);
      throw new Error(t);
    }
  }
  async isValidSessionTopic(e) {
    if (!Ft(e, !1)) {
      const { message: t } = Z("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(t);
    }
    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
      const { message: t } = Z("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (ho(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: t } = Z("EXPIRED", `session topic: ${e}`);
      throw new Error(t);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: t } = Z("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(t);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
    else if (Ft(e, !1)) {
      const { message: t } = Z("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(t);
    } else {
      const { message: t } = Z("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(t);
    }
  }
  async isValidProposalId(e) {
    if (!NL(e)) {
      const { message: t } = Z("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(t);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: t } = Z("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (ho(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: t } = Z("EXPIRED", `proposal id: ${e}`);
      throw new Error(t);
    }
  }
}
class y7 extends Oc {
  constructor(e, t) {
    super(e, t, t7, yb), this.core = e, this.logger = t;
  }
}
let b7 = class extends Oc {
  constructor(e, t) {
    super(e, t, r7, yb), this.core = e, this.logger = t;
  }
};
class E7 extends Oc {
  constructor(e, t) {
    super(e, t, i7, yb, (n) => n.id), this.core = e, this.logger = t;
  }
}
class v7 extends Oc {
  constructor(e, t) {
    super(e, t, l7, sm, () => Op), this.core = e, this.logger = t;
  }
}
class A7 extends Oc {
  constructor(e, t) {
    super(e, t, u7, sm), this.core = e, this.logger = t;
  }
}
class C7 extends Oc {
  constructor(e, t) {
    super(e, t, h7, sm, (n) => n.id), this.core = e, this.logger = t;
  }
}
var _7 = Object.defineProperty, I7 = (r, e, t) => e in r ? _7(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, mw = (r, e, t) => I7(r, typeof e != "symbol" ? e + "" : e, t);
class S7 {
  constructor(e, t) {
    this.core = e, this.logger = t, mw(this, "authKeys"), mw(this, "pairingTopics"), mw(this, "requests"), this.authKeys = new v7(this.core, this.logger), this.pairingTopics = new A7(this.core, this.logger), this.requests = new C7(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
var N7 = Object.defineProperty, T7 = (r, e, t) => e in r ? N7(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, je = (r, e, t) => T7(r, typeof e != "symbol" ? e + "" : e, t);
let x7 = class aS extends i3 {
  constructor(e) {
    super(e), je(this, "protocol", sS), je(this, "version", iS), je(this, "name", pw.name), je(this, "metadata"), je(this, "core"), je(this, "logger"), je(this, "events", new Vn.EventEmitter()), je(this, "engine"), je(this, "session"), je(this, "proposal"), je(this, "pendingRequest"), je(this, "auth"), je(this, "signConfig"), je(this, "on", (n, s) => this.events.on(n, s)), je(this, "once", (n, s) => this.events.once(n, s)), je(this, "off", (n, s) => this.events.off(n, s)), je(this, "removeListener", (n, s) => this.events.removeListener(n, s)), je(this, "removeAllListeners", (n) => this.events.removeAllListeners(n)), je(this, "connect", async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "pair", async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "approve", async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "reject", async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "update", async (n) => {
      try {
        return await this.engine.update(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "extend", async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "request", async (n) => {
      try {
        return await this.engine.request(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "respond", async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "ping", async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "emit", async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "disconnect", async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "find", (n) => {
      try {
        return this.engine.find(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }), je(this, "authenticate", async (n, s) => {
      try {
        return await this.engine.authenticate(n, s);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }), je(this, "formatAuthMessage", (n) => {
      try {
        return this.engine.formatAuthMessage(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "approveSessionAuthenticate", async (n) => {
      try {
        return await this.engine.approveSessionAuthenticate(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), je(this, "rejectSessionAuthenticate", async (n) => {
      try {
        return await this.engine.rejectSessionAuthenticate(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), this.name = (e == null ? void 0 : e.name) || pw.name, this.metadata = X5(e == null ? void 0 : e.metadata), this.signConfig = e == null ? void 0 : e.signConfig;
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : wf(Fu({ level: (e == null ? void 0 : e.logger) || pw.logger }));
    this.core = (e == null ? void 0 : e.core) || new e7(e), this.logger = xr(t, this.name), this.session = new b7(this.core, this.logger), this.proposal = new y7(this.core, this.logger), this.pendingRequest = new E7(this.core, this.logger), this.engine = new w7(this), this.auth = new S7(this.core, this.logger);
  }
  static async init(e) {
    const t = new aS(e);
    return await t.initialize(), t;
  }
  get context() {
    return dn(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, Q.toMiliseconds(Q.ONE_SECOND));
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
};
var $y = { exports: {} };
(function(r, e) {
  var t = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof js < "u" && js, n = function() {
    function i() {
      this.fetch = !1, this.DOMException = t.DOMException;
    }
    return i.prototype = t, new i();
  }();
  (function(i) {
    (function(o) {
      var a = typeof i < "u" && i || typeof self < "u" && self || // eslint-disable-next-line no-undef
      typeof js < "u" && js || {}, c = {
        searchParams: "URLSearchParams" in a,
        iterable: "Symbol" in a && "iterator" in Symbol,
        blob: "FileReader" in a && "Blob" in a && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in a,
        arrayBuffer: "ArrayBuffer" in a
      };
      function l(y) {
        return y && DataView.prototype.isPrototypeOf(y);
      }
      if (c.arrayBuffer)
        var u = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], h = ArrayBuffer.isView || function(y) {
          return y && u.indexOf(Object.prototype.toString.call(y)) > -1;
        };
      function d(y) {
        if (typeof y != "string" && (y = String(y)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(y) || y === "")
          throw new TypeError('Invalid character in header field name: "' + y + '"');
        return y.toLowerCase();
      }
      function f(y) {
        return typeof y != "string" && (y = String(y)), y;
      }
      function g(y) {
        var b = {
          next: function() {
            var T = y.shift();
            return { done: T === void 0, value: T };
          }
        };
        return c.iterable && (b[Symbol.iterator] = function() {
          return b;
        }), b;
      }
      function p(y) {
        this.map = {}, y instanceof p ? y.forEach(function(b, T) {
          this.append(T, b);
        }, this) : Array.isArray(y) ? y.forEach(function(b) {
          if (b.length != 2)
            throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + b.length);
          this.append(b[0], b[1]);
        }, this) : y && Object.getOwnPropertyNames(y).forEach(function(b) {
          this.append(b, y[b]);
        }, this);
      }
      p.prototype.append = function(y, b) {
        y = d(y), b = f(b);
        var T = this.map[y];
        this.map[y] = T ? T + ", " + b : b;
      }, p.prototype.delete = function(y) {
        delete this.map[d(y)];
      }, p.prototype.get = function(y) {
        return y = d(y), this.has(y) ? this.map[y] : null;
      }, p.prototype.has = function(y) {
        return this.map.hasOwnProperty(d(y));
      }, p.prototype.set = function(y, b) {
        this.map[d(y)] = f(b);
      }, p.prototype.forEach = function(y, b) {
        for (var T in this.map)
          this.map.hasOwnProperty(T) && y.call(b, this.map[T], T, this);
      }, p.prototype.keys = function() {
        var y = [];
        return this.forEach(function(b, T) {
          y.push(T);
        }), g(y);
      }, p.prototype.values = function() {
        var y = [];
        return this.forEach(function(b) {
          y.push(b);
        }), g(y);
      }, p.prototype.entries = function() {
        var y = [];
        return this.forEach(function(b, T) {
          y.push([T, b]);
        }), g(y);
      }, c.iterable && (p.prototype[Symbol.iterator] = p.prototype.entries);
      function w(y) {
        if (!y._noBody) {
          if (y.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          y.bodyUsed = !0;
        }
      }
      function E(y) {
        return new Promise(function(b, T) {
          y.onload = function() {
            b(y.result);
          }, y.onerror = function() {
            T(y.error);
          };
        });
      }
      function I(y) {
        var b = new FileReader(), T = E(b);
        return b.readAsArrayBuffer(y), T;
      }
      function A(y) {
        var b = new FileReader(), T = E(b), B = /charset=([A-Za-z0-9_-]+)/.exec(y.type), R = B ? B[1] : "utf-8";
        return b.readAsText(y, R), T;
      }
      function C(y) {
        for (var b = new Uint8Array(y), T = new Array(b.length), B = 0; B < b.length; B++)
          T[B] = String.fromCharCode(b[B]);
        return T.join("");
      }
      function N(y) {
        if (y.slice)
          return y.slice(0);
        var b = new Uint8Array(y.byteLength);
        return b.set(new Uint8Array(y)), b.buffer;
      }
      function x() {
        return this.bodyUsed = !1, this._initBody = function(y) {
          this.bodyUsed = this.bodyUsed, this._bodyInit = y, y ? typeof y == "string" ? this._bodyText = y : c.blob && Blob.prototype.isPrototypeOf(y) ? this._bodyBlob = y : c.formData && FormData.prototype.isPrototypeOf(y) ? this._bodyFormData = y : c.searchParams && URLSearchParams.prototype.isPrototypeOf(y) ? this._bodyText = y.toString() : c.arrayBuffer && c.blob && l(y) ? (this._bodyArrayBuffer = N(y.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(y) || h(y)) ? this._bodyArrayBuffer = N(y) : this._bodyText = y = Object.prototype.toString.call(y) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof y == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : c.searchParams && URLSearchParams.prototype.isPrototypeOf(y) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, c.blob && (this.blob = function() {
          var y = w(this);
          if (y)
            return y;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }), this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            var y = w(this);
            return y || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
              this._bodyArrayBuffer.buffer.slice(
                this._bodyArrayBuffer.byteOffset,
                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
              )
            ) : Promise.resolve(this._bodyArrayBuffer));
          } else {
            if (c.blob)
              return this.blob().then(I);
            throw new Error("could not read as ArrayBuffer");
          }
        }, this.text = function() {
          var y = w(this);
          if (y)
            return y;
          if (this._bodyBlob)
            return A(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(C(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, c.formData && (this.formData = function() {
          return this.text().then($);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var O = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
      function k(y) {
        var b = y.toUpperCase();
        return O.indexOf(b) > -1 ? b : y;
      }
      function P(y, b) {
        if (!(this instanceof P))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        b = b || {};
        var T = b.body;
        if (y instanceof P) {
          if (y.bodyUsed)
            throw new TypeError("Already read");
          this.url = y.url, this.credentials = y.credentials, b.headers || (this.headers = new p(y.headers)), this.method = y.method, this.mode = y.mode, this.signal = y.signal, !T && y._bodyInit != null && (T = y._bodyInit, y.bodyUsed = !0);
        } else
          this.url = String(y);
        if (this.credentials = b.credentials || this.credentials || "same-origin", (b.headers || !this.headers) && (this.headers = new p(b.headers)), this.method = k(b.method || this.method || "GET"), this.mode = b.mode || this.mode || null, this.signal = b.signal || this.signal || function() {
          if ("AbortController" in a) {
            var L = new AbortController();
            return L.signal;
          }
        }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && T)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        if (this._initBody(T), (this.method === "GET" || this.method === "HEAD") && (b.cache === "no-store" || b.cache === "no-cache")) {
          var B = /([?&])_=[^&]*/;
          if (B.test(this.url))
            this.url = this.url.replace(B, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
          else {
            var R = /\?/;
            this.url += (R.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
          }
        }
      }
      P.prototype.clone = function() {
        return new P(this, { body: this._bodyInit });
      };
      function $(y) {
        var b = new FormData();
        return y.trim().split("&").forEach(function(T) {
          if (T) {
            var B = T.split("="), R = B.shift().replace(/\+/g, " "), L = B.join("=").replace(/\+/g, " ");
            b.append(decodeURIComponent(R), decodeURIComponent(L));
          }
        }), b;
      }
      function U(y) {
        var b = new p(), T = y.replace(/\r?\n[\t ]+/g, " ");
        return T.split("\r").map(function(B) {
          return B.indexOf(`
`) === 0 ? B.substr(1, B.length) : B;
        }).forEach(function(B) {
          var R = B.split(":"), L = R.shift().trim();
          if (L) {
            var q = R.join(":").trim();
            try {
              b.append(L, q);
            } catch (Y) {
              console.warn("Response " + Y.message);
            }
          }
        }), b;
      }
      x.call(P.prototype);
      function j(y, b) {
        if (!(this instanceof j))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        if (b || (b = {}), this.type = "default", this.status = b.status === void 0 ? 200 : b.status, this.status < 200 || this.status > 599)
          throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
        this.ok = this.status >= 200 && this.status < 300, this.statusText = b.statusText === void 0 ? "" : "" + b.statusText, this.headers = new p(b.headers), this.url = b.url || "", this._initBody(y);
      }
      x.call(j.prototype), j.prototype.clone = function() {
        return new j(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new p(this.headers),
          url: this.url
        });
      }, j.error = function() {
        var y = new j(null, { status: 200, statusText: "" });
        return y.ok = !1, y.status = 0, y.type = "error", y;
      };
      var H = [301, 302, 303, 307, 308];
      j.redirect = function(y, b) {
        if (H.indexOf(b) === -1)
          throw new RangeError("Invalid status code");
        return new j(null, { status: b, headers: { location: y } });
      }, o.DOMException = a.DOMException;
      try {
        new o.DOMException();
      } catch {
        o.DOMException = function(b, T) {
          this.message = b, this.name = T;
          var B = Error(b);
          this.stack = B.stack;
        }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
      }
      function ee(y, b) {
        return new Promise(function(T, B) {
          var R = new P(y, b);
          if (R.signal && R.signal.aborted)
            return B(new o.DOMException("Aborted", "AbortError"));
          var L = new XMLHttpRequest();
          function q() {
            L.abort();
          }
          L.onload = function() {
            var ne = {
              statusText: L.statusText,
              headers: U(L.getAllResponseHeaders() || "")
            };
            R.url.indexOf("file://") === 0 && (L.status < 200 || L.status > 599) ? ne.status = 200 : ne.status = L.status, ne.url = "responseURL" in L ? L.responseURL : ne.headers.get("X-Request-URL");
            var we = "response" in L ? L.response : L.responseText;
            setTimeout(function() {
              T(new j(we, ne));
            }, 0);
          }, L.onerror = function() {
            setTimeout(function() {
              B(new TypeError("Network request failed"));
            }, 0);
          }, L.ontimeout = function() {
            setTimeout(function() {
              B(new TypeError("Network request timed out"));
            }, 0);
          }, L.onabort = function() {
            setTimeout(function() {
              B(new o.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function Y(ne) {
            try {
              return ne === "" && a.location.href ? a.location.href : ne;
            } catch {
              return ne;
            }
          }
          if (L.open(R.method, Y(R.url), !0), R.credentials === "include" ? L.withCredentials = !0 : R.credentials === "omit" && (L.withCredentials = !1), "responseType" in L && (c.blob ? L.responseType = "blob" : c.arrayBuffer && (L.responseType = "arraybuffer")), b && typeof b.headers == "object" && !(b.headers instanceof p || a.Headers && b.headers instanceof a.Headers)) {
            var de = [];
            Object.getOwnPropertyNames(b.headers).forEach(function(ne) {
              de.push(d(ne)), L.setRequestHeader(ne, f(b.headers[ne]));
            }), R.headers.forEach(function(ne, we) {
              de.indexOf(we) === -1 && L.setRequestHeader(we, ne);
            });
          } else
            R.headers.forEach(function(ne, we) {
              L.setRequestHeader(we, ne);
            });
          R.signal && (R.signal.addEventListener("abort", q), L.onreadystatechange = function() {
            L.readyState === 4 && R.signal.removeEventListener("abort", q);
          }), L.send(typeof R._bodyInit > "u" ? null : R._bodyInit);
        });
      }
      return ee.polyfill = !0, a.fetch || (a.fetch = ee, a.Headers = p, a.Request = P, a.Response = j), o.Headers = p, o.Request = P, o.Response = j, o.fetch = ee, Object.defineProperty(o, "__esModule", { value: !0 }), o;
    })({});
  })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
  var s = t.fetch ? t : n;
  e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, r.exports = e;
})($y, $y.exports);
var O7 = $y.exports;
const H1 = /* @__PURE__ */ P0(O7);
var P7 = Object.defineProperty, R7 = Object.defineProperties, D7 = Object.getOwnPropertyDescriptors, z1 = Object.getOwnPropertySymbols, k7 = Object.prototype.hasOwnProperty, U7 = Object.prototype.propertyIsEnumerable, q1 = (r, e, t) => e in r ? P7(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, W1 = (r, e) => {
  for (var t in e || (e = {})) k7.call(e, t) && q1(r, t, e[t]);
  if (z1) for (var t of z1(e)) U7.call(e, t) && q1(r, t, e[t]);
  return r;
}, V1 = (r, e) => R7(r, D7(e));
const B7 = { Accept: "application/json", "Content-Type": "application/json" }, L7 = "POST", G1 = { headers: B7, method: L7 }, K1 = 10;
let As = class {
  constructor(e, t = !1) {
    if (this.url = e, this.disableProviderPing = t, this.events = new Vn.EventEmitter(), this.isAvailable = !1, this.registering = !1, !h1(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    this.url = e, this.disableProviderPing = t;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e) {
    this.isAvailable || await this.register();
    try {
      const t = $i(e), n = await (await H1(this.url, V1(W1({}, G1), { body: t }))).json();
      this.onPayload({ data: n });
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  async register(e = this.url) {
    if (!h1(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n, s) => {
        this.events.once("register_error", (i) => {
          this.resetMaxListeners(), s(i);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return s(new Error("HTTP connection is missing or invalid"));
          n();
        });
      });
    }
    this.url = e, this.registering = !0;
    try {
      if (!this.disableProviderPing) {
        const t = $i({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await H1(e, V1(W1({}, G1), { body: t }));
      }
      this.onOpen();
    } catch (t) {
      const n = this.parseError(t);
      throw this.events.emit("register_error", n), this.onClose(), n;
    }
  }
  onOpen() {
    this.isAvailable = !0, this.registering = !1, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = !1, this.registering = !1, this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? lc(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n = this.parseError(t), s = n.message || n.toString(), i = tm(e, s);
    this.events.emit("payload", i);
  }
  parseError(e, t = this.url) {
    return L2(e, t, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > K1 && this.events.setMaxListeners(K1);
  }
};
const J1 = "error", F7 = "wss://relay.walletconnect.org", $7 = "wc", M7 = "universal_provider", ap = `${$7}@2:${M7}:`, cS = "https://rpc.walletconnect.org/v1/", il = "generic", j7 = `${cS}bundler`, Kn = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function Y1(r) {
  return typeof r == "object" && r !== null;
}
function bb(r) {
  return r == null || typeof r != "object" && typeof r != "function";
}
function lS(r) {
  return Object.getOwnPropertySymbols(r).filter((e) => Object.prototype.propertyIsEnumerable.call(r, e));
}
function uS(r) {
  return r == null ? r === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r);
}
const H7 = "[object RegExp]", hS = "[object String]", dS = "[object Number]", fS = "[object Boolean]", pS = "[object Arguments]", z7 = "[object Symbol]", q7 = "[object Date]", W7 = "[object Map]", V7 = "[object Set]", G7 = "[object Array]", K7 = "[object ArrayBuffer]", J7 = "[object Object]", Y7 = "[object DataView]", Q7 = "[object Uint8Array]", Z7 = "[object Uint8ClampedArray]", X7 = "[object Uint16Array]", ej = "[object Uint32Array]", tj = "[object Int8Array]", rj = "[object Int16Array]", nj = "[object Int32Array]", sj = "[object Float32Array]", ij = "[object Float64Array]";
function Eb(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function oj(r, e) {
  return fl(r, void 0, r, /* @__PURE__ */ new Map(), e);
}
function fl(r, e, t, n = /* @__PURE__ */ new Map(), s = void 0) {
  const i = s == null ? void 0 : s(r, e, t, n);
  if (i != null) return i;
  if (bb(r)) return r;
  if (n.has(r)) return n.get(r);
  if (Array.isArray(r)) {
    const o = new Array(r.length);
    n.set(r, o);
    for (let a = 0; a < r.length; a++) o[a] = fl(r[a], a, t, n, s);
    return Object.hasOwn(r, "index") && (o.index = r.index), Object.hasOwn(r, "input") && (o.input = r.input), o;
  }
  if (r instanceof Date) return new Date(r.getTime());
  if (r instanceof RegExp) {
    const o = new RegExp(r.source, r.flags);
    return o.lastIndex = r.lastIndex, o;
  }
  if (r instanceof Map) {
    const o = /* @__PURE__ */ new Map();
    n.set(r, o);
    for (const [a, c] of r) o.set(a, fl(c, a, t, n, s));
    return o;
  }
  if (r instanceof Set) {
    const o = /* @__PURE__ */ new Set();
    n.set(r, o);
    for (const a of r) o.add(fl(a, void 0, t, n, s));
    return o;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(r)) return r.subarray();
  if (Eb(r)) {
    const o = new (Object.getPrototypeOf(r)).constructor(r.length);
    n.set(r, o);
    for (let a = 0; a < r.length; a++) o[a] = fl(r[a], a, t, n, s);
    return o;
  }
  if (r instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && r instanceof SharedArrayBuffer) return r.slice(0);
  if (r instanceof DataView) {
    const o = new DataView(r.buffer.slice(0), r.byteOffset, r.byteLength);
    return n.set(r, o), ba(o, r, t, n, s), o;
  }
  if (typeof File < "u" && r instanceof File) {
    const o = new File([r], r.name, { type: r.type });
    return n.set(r, o), ba(o, r, t, n, s), o;
  }
  if (r instanceof Blob) {
    const o = new Blob([r], { type: r.type });
    return n.set(r, o), ba(o, r, t, n, s), o;
  }
  if (r instanceof Error) {
    const o = new r.constructor();
    return n.set(r, o), o.message = r.message, o.name = r.name, o.stack = r.stack, o.cause = r.cause, ba(o, r, t, n, s), o;
  }
  if (typeof r == "object" && aj(r)) {
    const o = Object.create(Object.getPrototypeOf(r));
    return n.set(r, o), ba(o, r, t, n, s), o;
  }
  return r;
}
function ba(r, e, t = r, n, s) {
  const i = [...Object.keys(e), ...lS(e)];
  for (let o = 0; o < i.length; o++) {
    const a = i[o], c = Object.getOwnPropertyDescriptor(r, a);
    (c == null || c.writable) && (r[a] = fl(e[a], a, t, n, s));
  }
}
function aj(r) {
  switch (uS(r)) {
    case pS:
    case G7:
    case K7:
    case Y7:
    case fS:
    case q7:
    case sj:
    case ij:
    case tj:
    case rj:
    case nj:
    case W7:
    case dS:
    case J7:
    case H7:
    case V7:
    case hS:
    case z7:
    case Q7:
    case Z7:
    case X7:
    case ej:
      return !0;
    default:
      return !1;
  }
}
function cj(r, e) {
  return oj(r, (t, n, s, i) => {
    if (typeof r == "object") switch (Object.prototype.toString.call(r)) {
      case dS:
      case hS:
      case fS: {
        const o = new r.constructor(r == null ? void 0 : r.valueOf());
        return ba(o, r), o;
      }
      case pS: {
        const o = {};
        return ba(o, r), o.length = r.length, o[Symbol.iterator] = r[Symbol.iterator], o;
      }
      default:
        return;
    }
  });
}
function Q1(r) {
  return cj(r);
}
function Z1(r) {
  return r !== null && typeof r == "object" && uS(r) === "[object Arguments]";
}
function lj(r) {
  return Eb(r);
}
function uj() {
}
function hj(r) {
  if (bb(r)) return r;
  if (Array.isArray(r) || Eb(r) || r instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && r instanceof SharedArrayBuffer) return r.slice(0);
  const e = Object.getPrototypeOf(r), t = e.constructor;
  if (r instanceof Date || r instanceof Map || r instanceof Set) return new t(r);
  if (r instanceof RegExp) {
    const n = new t(r);
    return n.lastIndex = r.lastIndex, n;
  }
  if (r instanceof DataView) return new t(r.buffer.slice(0));
  if (r instanceof Error) {
    const n = new t(r.message);
    return n.stack = r.stack, n.name = r.name, n.cause = r.cause, n;
  }
  if (typeof File < "u" && r instanceof File) return new t([r], r.name, { type: r.type, lastModified: r.lastModified });
  if (typeof r == "object") {
    const n = Object.create(e);
    return Object.assign(n, r);
  }
  return r;
}
function dj(r) {
  var t;
  if (typeof r != "object" || r == null) return !1;
  if (Object.getPrototypeOf(r) === null) return !0;
  if (Object.prototype.toString.call(r) !== "[object Object]") {
    const n = r[Symbol.toStringTag];
    return n == null || !((t = Object.getOwnPropertyDescriptor(r, Symbol.toStringTag)) != null && t.writable) ? !1 : r.toString() === `[object ${n}]`;
  }
  let e = r;
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(r) === e;
}
function fj(r, ...e) {
  const t = e.slice(0, -1), n = e[e.length - 1];
  let s = r;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    s = My(s, o, n, /* @__PURE__ */ new Map());
  }
  return s;
}
function My(r, e, t, n) {
  if (bb(r) && (r = Object(r)), e == null || typeof e != "object") return r;
  if (n.has(e)) return hj(n.get(e));
  if (n.set(e, r), Array.isArray(e)) {
    e = e.slice();
    for (let i = 0; i < e.length; i++) e[i] = e[i] ?? void 0;
  }
  const s = [...Object.keys(e), ...lS(e)];
  for (let i = 0; i < s.length; i++) {
    const o = s[i];
    let a = e[o], c = r[o];
    if (Z1(a) && (a = { ...a }), Z1(c) && (c = { ...c }), typeof Buffer < "u" && Buffer.isBuffer(a) && (a = Q1(a)), Array.isArray(a)) if (typeof c == "object" && c != null) {
      const u = [], h = Reflect.ownKeys(c);
      for (let d = 0; d < h.length; d++) {
        const f = h[d];
        u[f] = c[f];
      }
      c = u;
    } else c = [];
    const l = t(c, a, o, r, e, n);
    l != null ? r[o] = l : Array.isArray(a) || Y1(c) && Y1(a) ? r[o] = My(c, a, t, n) : c == null && dj(a) ? r[o] = My({}, a, t, n) : c == null && lj(a) ? r[o] = Q1(a) : (c === void 0 || a !== void 0) && (r[o] = a);
  }
  return r;
}
function pj(r, ...e) {
  return fj(r, ...e, uj);
}
var gj = Object.defineProperty, mj = Object.defineProperties, wj = Object.getOwnPropertyDescriptors, X1 = Object.getOwnPropertySymbols, yj = Object.prototype.hasOwnProperty, bj = Object.prototype.propertyIsEnumerable, eA = (r, e, t) => e in r ? gj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, cp = (r, e) => {
  for (var t in e || (e = {})) yj.call(e, t) && eA(r, t, e[t]);
  if (X1) for (var t of X1(e)) bj.call(e, t) && eA(r, t, e[t]);
  return r;
}, Ej = (r, e) => mj(r, wj(e));
function In(r, e, t) {
  var n;
  const s = vl(r);
  return ((n = e.rpcMap) == null ? void 0 : n[s.reference]) || `${cS}?chainId=${s.namespace}:${s.reference}&projectId=${t}`;
}
function Pc(r) {
  return r.includes(":") ? r.split(":")[1] : r;
}
function gS(r) {
  return r.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function vj(r, e) {
  const t = Object.keys(e.namespaces).filter((s) => s.includes(r));
  if (!t.length) return [];
  const n = [];
  return t.forEach((s) => {
    const i = e.namespaces[s].accounts;
    n.push(...i);
  }), n;
}
function lp(r = {}, e = {}) {
  const t = tA(r), n = tA(e);
  return pj(t, n);
}
function tA(r) {
  var e, t, n, s, i;
  const o = {};
  if (!jo(r)) return o;
  for (const [a, c] of Object.entries(r)) {
    const l = Xg(a) ? [a] : c.chains, u = c.methods || [], h = c.events || [], d = c.rpcMap || {}, f = dl(a);
    o[f] = Ej(cp(cp({}, o[f]), c), { chains: Qs(l, (e = o[f]) == null ? void 0 : e.chains), methods: Qs(u, (t = o[f]) == null ? void 0 : t.methods), events: Qs(h, (n = o[f]) == null ? void 0 : n.events) }), (jo(d) || jo(((s = o[f]) == null ? void 0 : s.rpcMap) || {})) && (o[f].rpcMap = cp(cp({}, d), (i = o[f]) == null ? void 0 : i.rpcMap));
  }
  return o;
}
function rA(r) {
  return r.includes(":") ? r.split(":")[2] : r;
}
function nA(r) {
  const e = {};
  for (const [t, n] of Object.entries(r)) {
    const s = n.methods || [], i = n.events || [], o = n.accounts || [], a = Xg(t) ? [t] : n.chains ? n.chains : gS(n.accounts);
    e[t] = { chains: a, methods: s, events: i, accounts: o };
  }
  return e;
}
function ww(r) {
  return typeof r == "number" ? r : r.includes("0x") ? parseInt(r, 16) : (r = r.includes(":") ? r.split(":")[1] : r, isNaN(Number(r)) ? r : Number(r));
}
const mS = {}, et = (r) => mS[r], yw = (r, e) => {
  mS[r] = e;
};
var Aj = Object.defineProperty, Cj = (r, e, t) => e in r ? Aj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, qc = (r, e, t) => Cj(r, typeof e != "symbol" ? e + "" : e, t);
class _j {
  constructor(e) {
    qc(this, "name", "polkadot"), qc(this, "client"), qc(this, "httpProviders"), qc(this, "events"), qc(this, "namespace"), qc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const s = Pc(t);
      e[s] = this.createHttpProvider(s, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Gn(new As(n, et("disableProviderPing")));
  }
}
var Ij = Object.defineProperty, Sj = Object.defineProperties, Nj = Object.getOwnPropertyDescriptors, sA = Object.getOwnPropertySymbols, Tj = Object.prototype.hasOwnProperty, xj = Object.prototype.propertyIsEnumerable, jy = (r, e, t) => e in r ? Ij(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, iA = (r, e) => {
  for (var t in e || (e = {})) Tj.call(e, t) && jy(r, t, e[t]);
  if (sA) for (var t of sA(e)) xj.call(e, t) && jy(r, t, e[t]);
  return r;
}, oA = (r, e) => Sj(r, Nj(e)), Wc = (r, e, t) => jy(r, typeof e != "symbol" ? e + "" : e, t);
class Oj {
  constructor(e) {
    Wc(this, "name", "eip155"), Wc(this, "client"), Wc(this, "chainId"), Wc(this, "namespace"), Wc(this, "httpProviders"), Wc(this, "events"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
    }
    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, t) {
    const n = t || In(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Gn(new As(n, et("disableProviderPing")));
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const s = parseInt(Pc(t));
      e[s] = this.createHttpProvider(s, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e = this.chainId, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  async handleSwitchChain(e) {
    var t, n;
    let s = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : "0x0";
    s = s.startsWith("0x") ? s : `0x${s}`;
    const i = parseInt(s, 16);
    if (this.isChainApproved(i)) this.setDefaultChain(`${i}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e.topic, request: { method: e.request.method, params: [{ chainId: s }] }, chainId: (n = this.namespace.chains) == null ? void 0 : n[0] }), this.setDefaultChain(`${i}`);
    else throw new Error(`Failed to switch to chain 'eip155:${i}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var t, n, s, i, o;
    const a = (n = (t = e.request) == null ? void 0 : t.params) == null ? void 0 : n[0], c = ((i = (s = e.request) == null ? void 0 : s.params) == null ? void 0 : i[1]) || [], l = `${a}${c.join(",")}`;
    if (!a) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const u = this.client.session.get(e.topic), h = ((o = u == null ? void 0 : u.sessionProperties) == null ? void 0 : o.capabilities) || {};
    if (h != null && h[l]) return h == null ? void 0 : h[l];
    const d = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, { sessionProperties: oA(iA({}, u.sessionProperties || {}), { capabilities: oA(iA({}, h || {}), { [l]: d }) }) });
    } catch (f) {
      console.warn("Failed to update session with capabilities", f);
    }
    return d;
  }
  async getCallStatus(e) {
    var t, n;
    const s = this.client.session.get(e.topic), i = (t = s.sessionProperties) == null ? void 0 : t.bundler_name;
    if (i) {
      const a = this.getBundlerUrl(e.chainId, i);
      try {
        return await this.getUserOperationReceipt(a, e);
      } catch (c) {
        console.warn("Failed to fetch call status from bundler", c, a);
      }
    }
    const o = (n = s.sessionProperties) == null ? void 0 : n.bundler_url;
    if (o) try {
      return await this.getUserOperationReceipt(o, e);
    } catch (a) {
      console.warn("Failed to fetch call status from custom bundler", a, o);
    }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, t) {
    var n;
    const s = new URL(e), i = await fetch(s, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(Fo("eth_getUserOperationReceipt", [(n = t.request.params) == null ? void 0 : n[0]])) });
    if (!i.ok) throw new Error(`Failed to fetch user operation receipt - ${i.status}`);
    return await i.json();
  }
  getBundlerUrl(e, t) {
    return `${j7}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
  }
}
var Pj = Object.defineProperty, Rj = (r, e, t) => e in r ? Pj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Vc = (r, e, t) => Rj(r, typeof e != "symbol" ? e + "" : e, t);
class Dj {
  constructor(e) {
    Vc(this, "name", "solana"), Vc(this, "client"), Vc(this, "httpProviders"), Vc(this, "events"), Vc(this, "namespace"), Vc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const s = Pc(t);
      e[s] = this.createHttpProvider(s, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Gn(new As(n, et("disableProviderPing")));
  }
}
var kj = Object.defineProperty, Uj = (r, e, t) => e in r ? kj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Gc = (r, e, t) => Uj(r, typeof e != "symbol" ? e + "" : e, t);
class Bj {
  constructor(e) {
    Gc(this, "name", "cosmos"), Gc(this, "client"), Gc(this, "httpProviders"), Gc(this, "events"), Gc(this, "namespace"), Gc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const s = Pc(t);
      e[s] = this.createHttpProvider(s, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Gn(new As(n, et("disableProviderPing")));
  }
}
var Lj = Object.defineProperty, Fj = (r, e, t) => e in r ? Lj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Kc = (r, e, t) => Fj(r, typeof e != "symbol" ? e + "" : e, t);
class $j {
  constructor(e) {
    Kc(this, "name", "algorand"), Kc(this, "client"), Kc(this, "httpProviders"), Kc(this, "events"), Kc(this, "namespace"), Kc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (!this.httpProviders[e]) {
      const n = t || In(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.chainId = e, this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      e[t] = this.createHttpProvider(t, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace, this.client.core.projectId);
    return typeof n > "u" ? void 0 : new Gn(new As(n, et("disableProviderPing")));
  }
}
var Mj = Object.defineProperty, jj = (r, e, t) => e in r ? Mj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Jc = (r, e, t) => jj(r, typeof e != "symbol" ? e + "" : e, t);
class Hj {
  constructor(e) {
    Jc(this, "name", "cip34"), Jc(this, "client"), Jc(this, "httpProviders"), Jc(this, "events"), Jc(this, "namespace"), Jc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      const n = this.getCardanoRPCUrl(t), s = Pc(t);
      e[s] = this.createHttpProvider(s, n);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  getCardanoRPCUrl(e) {
    const t = this.namespace.rpcMap;
    if (t) return t[e];
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || this.getCardanoRPCUrl(e);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Gn(new As(n, et("disableProviderPing")));
  }
}
var zj = Object.defineProperty, qj = (r, e, t) => e in r ? zj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Yc = (r, e, t) => qj(r, typeof e != "symbol" ? e + "" : e, t);
class Wj {
  constructor(e) {
    Yc(this, "name", "elrond"), Yc(this, "client"), Yc(this, "httpProviders"), Yc(this, "events"), Yc(this, "namespace"), Yc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const s = Pc(t);
      e[s] = this.createHttpProvider(s, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Gn(new As(n, et("disableProviderPing")));
  }
}
var Vj = Object.defineProperty, Gj = (r, e, t) => e in r ? Vj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Qc = (r, e, t) => Gj(r, typeof e != "symbol" ? e + "" : e, t);
class Kj {
  constructor(e) {
    Qc(this, "name", "multiversx"), Qc(this, "client"), Qc(this, "httpProviders"), Qc(this, "events"), Qc(this, "namespace"), Qc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const s = Pc(t);
      e[s] = this.createHttpProvider(s, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Gn(new As(n, et("disableProviderPing")));
  }
}
var Jj = Object.defineProperty, Yj = (r, e, t) => e in r ? Jj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Zc = (r, e, t) => Yj(r, typeof e != "symbol" ? e + "" : e, t);
class Qj {
  constructor(e) {
    Zc(this, "name", "near"), Zc(this, "client"), Zc(this, "httpProviders"), Zc(this, "events"), Zc(this, "namespace"), Zc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = t || In(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      e[t] = this.createHttpProvider(t, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace);
    return typeof n > "u" ? void 0 : new Gn(new As(n, et("disableProviderPing")));
  }
}
var Zj = Object.defineProperty, Xj = (r, e, t) => e in r ? Zj(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Xc = (r, e, t) => Xj(r, typeof e != "symbol" ? e + "" : e, t);
class eH {
  constructor(e) {
    Xc(this, "name", "tezos"), Xc(this, "client"), Xc(this, "httpProviders"), Xc(this, "events"), Xc(this, "namespace"), Xc(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = t || In(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      e[t] = this.createHttpProvider(t);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace);
    return typeof n > "u" ? void 0 : new Gn(new As(n));
  }
}
var tH = Object.defineProperty, rH = (r, e, t) => e in r ? tH(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, el = (r, e, t) => rH(r, typeof e != "symbol" ? e + "" : e, t);
class nH {
  constructor(e) {
    el(this, "name", il), el(this, "client"), el(this, "httpProviders"), el(this, "events"), el(this, "namespace"), el(this, "chainId"), this.namespace = e.namespace, this.events = et("events"), this.client = et("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Kn.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e, t;
    const n = {};
    return (t = (e = this.namespace) == null ? void 0 : e.accounts) == null || t.forEach((s) => {
      const i = vl(s);
      n[`${i.namespace}:${i.reference}`] = this.createHttpProvider(s);
    }), n;
  }
  getHttpProvider(e) {
    const t = this.httpProviders[e];
    if (typeof t > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || In(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Gn(new As(n, et("disableProviderPing")));
  }
}
var sH = Object.defineProperty, iH = Object.defineProperties, oH = Object.getOwnPropertyDescriptors, aA = Object.getOwnPropertySymbols, aH = Object.prototype.hasOwnProperty, cH = Object.prototype.propertyIsEnumerable, Hy = (r, e, t) => e in r ? sH(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, up = (r, e) => {
  for (var t in e || (e = {})) aH.call(e, t) && Hy(r, t, e[t]);
  if (aA) for (var t of aA(e)) cH.call(e, t) && Hy(r, t, e[t]);
  return r;
}, bw = (r, e) => iH(r, oH(e)), Rn = (r, e, t) => Hy(r, typeof e != "symbol" ? e + "" : e, t);
let lH = class wS {
  constructor(e) {
    Rn(this, "client"), Rn(this, "namespaces"), Rn(this, "optionalNamespaces"), Rn(this, "sessionProperties"), Rn(this, "scopedProperties"), Rn(this, "events", new $0()), Rn(this, "rpcProviders", {}), Rn(this, "session"), Rn(this, "providerOpts"), Rn(this, "logger"), Rn(this, "uri"), Rn(this, "disableProviderPing", !1), this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : wf(Fu({ level: (e == null ? void 0 : e.logger) || J1 })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1;
  }
  static async init(e) {
    const t = new wS(e);
    return await t.initialize(), t;
  }
  async request(e, t, n) {
    const [s, i] = this.validateChain(t);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(s).request({ request: up({}, e), chainId: `${s}:${i}`, topic: this.session.topic, expiry: n });
  }
  sendAsync(e, t, n, s) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    this.request(e, n, s).then((o) => t(null, em(i, o))).catch((o) => t(o, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: dt("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
  }
  async authenticate(e, t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e), await this.cleanupPendingPairings();
    const { uri: n, response: s } = await this.client.authenticate(e, t);
    n && (this.uri = n, this.events.emit("display_uri", n));
    const i = await s();
    if (this.session = i.session, this.session) {
      const o = nA(this.session.namespaces);
      this.namespaces = lp(this.namespaces, o), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return i;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(e) {
    const { uri: t, approval: n } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    t && (this.uri = t, this.events.emit("display_uri", t));
    const s = await n();
    this.session = s;
    const i = nA(s.namespaces);
    return this.namespaces = lp(this.namespaces, i), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(e, t) {
    try {
      if (!this.session) return;
      const [n, s] = this.validateChain(e), i = this.getProvider(n);
      i.name === il ? i.setDefaultChain(`${n}:${s}`, t) : i.setDefaultChain(s, t);
    } catch (n) {
      if (!/Please call connect/.test(n.message)) throw n;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const t = this.client.pairing.getAll();
    if (Bi(t)) {
      for (const n of t) e.deletePairings ? this.client.core.expirer.set(n.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
      this.logger.info(`Inactive pairings cleared: ${t.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var e, t;
    if (this.client = this.providerOpts.client || await x7.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || J1, relayUrl: this.providerOpts.relayUrl || F7, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (n) {
      throw this.logger.error("Failed to get session", n), new Error(`The provided session: ${(t = (e = this.providerOpts) == null ? void 0 : e.session) == null ? void 0 : t.topic} doesn't exist in the Sign client`);
    }
    else {
      const n = this.client.session.getAll();
      this.session = n[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e = [...new Set(Object.keys(this.session.namespaces).map((t) => dl(t)))];
    yw("client", this.client), yw("events", this.events), yw("disableProviderPing", this.disableProviderPing), e.forEach((t) => {
      if (!this.session) return;
      const n = vj(t, this.session), s = gS(n), i = lp(this.namespaces, this.optionalNamespaces), o = bw(up({}, i[t]), { accounts: n, chains: s });
      switch (t) {
        case "eip155":
          this.rpcProviders[t] = new Oj({ namespace: o });
          break;
        case "algorand":
          this.rpcProviders[t] = new $j({ namespace: o });
          break;
        case "solana":
          this.rpcProviders[t] = new Dj({ namespace: o });
          break;
        case "cosmos":
          this.rpcProviders[t] = new Bj({ namespace: o });
          break;
        case "polkadot":
          this.rpcProviders[t] = new _j({ namespace: o });
          break;
        case "cip34":
          this.rpcProviders[t] = new Hj({ namespace: o });
          break;
        case "elrond":
          this.rpcProviders[t] = new Wj({ namespace: o });
          break;
        case "multiversx":
          this.rpcProviders[t] = new Kj({ namespace: o });
          break;
        case "near":
          this.rpcProviders[t] = new Qj({ namespace: o });
          break;
        case "tezos":
          this.rpcProviders[t] = new eH({ namespace: o });
          break;
        default:
          this.rpcProviders[il] ? this.rpcProviders[il].updateNamespace(o) : this.rpcProviders[il] = new nH({ namespace: o });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      var t;
      const { topic: n } = e;
      n === ((t = this.session) == null ? void 0 : t.topic) && this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      var t;
      const { params: n, topic: s } = e;
      if (s !== ((t = this.session) == null ? void 0 : t.topic)) return;
      const { event: i } = n;
      if (i.name === "accountsChanged") {
        const o = i.data;
        o && Bi(o) && this.events.emit("accountsChanged", o.map(rA));
      } else if (i.name === "chainChanged") {
        const o = n.chainId, a = n.event.data, c = dl(o), l = ww(o) !== ww(a) ? `${c}:${ww(a)}` : o;
        this.onChainChanged(l);
      } else this.events.emit(i.name, i.data);
      this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: t }) => {
      var n, s;
      if (e !== ((n = this.session) == null ? void 0 : n.topic)) return;
      const { namespaces: i } = t, o = (s = this.client) == null ? void 0 : s.session.get(e);
      this.session = bw(up({}, o), { namespaces: i }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: t });
    }), this.client.on("session_delete", async (e) => {
      var t;
      e.topic === ((t = this.session) == null ? void 0 : t.topic) && (await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", bw(up({}, dt("USER_DISCONNECTED")), { data: e.topic })));
    }), this.on(Kn.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(e, !0);
    });
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[il];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var t;
      this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: t = {}, optionalNamespaces: n = {}, sessionProperties: s, scopedProperties: i } = e;
    this.optionalNamespaces = lp(t, n), this.sessionProperties = s, this.scopedProperties = i;
  }
  validateChain(e) {
    const [t, n] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [t, n];
    if (t && !Object.keys(this.namespaces || {}).map((o) => dl(o)).includes(t)) throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);
    if (t && n) return [t, n];
    const s = dl(Object.keys(this.namespaces)[0]), i = this.rpcProviders[s].getDefaultChain();
    return [s, i];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  async onChainChanged(e, t = !1) {
    if (!this.namespaces) return;
    const [n, s] = this.validateChain(e);
    if (!s) return;
    this.updateNamespaceChain(n, s), this.events.emit("chainChanged", s);
    const i = this.getProvider(n).getDefaultChain();
    t || this.getProvider(n).setDefaultChain(s), this.emitAccountsChangedOnChainChange({ namespace: n, previousChainId: i, newChainId: e }), await this.persist("namespaces", this.namespaces);
  }
  emitAccountsChangedOnChainChange({ namespace: e, previousChainId: t, newChainId: n }) {
    var s, i;
    try {
      if (t === n) return;
      const o = (i = (s = this.session) == null ? void 0 : s.namespaces[e]) == null ? void 0 : i.accounts;
      if (!o) return;
      const a = o.filter((c) => c.includes(`${n}:`)).map(rA);
      if (!Bi(a)) return;
      this.events.emit("accountsChanged", a);
    } catch (o) {
      this.logger.warn("Failed to emit accountsChanged on chain change", o);
    }
  }
  updateNamespaceChain(e, t) {
    if (!this.namespaces) return;
    const n = this.namespaces[e] ? e : `${e}:${t}`, s = { chains: [], methods: [], events: [], defaultChain: t };
    this.namespaces[n] ? this.namespaces[n] && (this.namespaces[n].defaultChain = t) : this.namespaces[n] = s;
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: !0 }), await this.cleanupStorage();
  }
  async persist(e, t) {
    var n;
    const s = ((n = this.session) == null ? void 0 : n.topic) || "";
    await this.client.core.storage.setItem(`${ap}/${e}${s}`, t);
  }
  async getFromStore(e) {
    var t;
    const n = ((t = this.session) == null ? void 0 : t.topic) || "";
    return await this.client.core.storage.getItem(`${ap}/${e}${n}`);
  }
  async deleteFromStore(e) {
    var t;
    const n = ((t = this.session) == null ? void 0 : t.topic) || "";
    await this.client.core.storage.removeItem(`${ap}/${e}${n}`);
  }
  async cleanupStorage() {
    var e;
    try {
      if (((e = this.client) == null ? void 0 : e.session.length) > 0) return;
      const t = await this.client.core.storage.getKeys();
      for (const n of t) n.startsWith(ap) && await this.client.core.storage.removeItem(n);
    } catch (t) {
      this.logger.warn("Failed to cleanup storage", t);
    }
  }
};
const Hh = {
  getSIWX() {
    return K.state.siwx;
  },
  async initializeIfEnabled() {
    var i;
    const r = K.state.siwx, e = _.getActiveCaipAddress();
    if (!(r && e))
      return;
    const [t, n, s] = e.split(":");
    if (_.checkIfSupportedNetwork(t))
      try {
        if ((await r.getSessions(`${t}:${n}`, s)).length)
          return;
        await nt.open({
          view: "SIWXSignMessage"
        });
      } catch (o) {
        console.error("SIWXUtil:initializeIfEnabled", o), ct.sendEvent({
          type: "track",
          event: "SIWX_AUTH_ERROR",
          properties: this.getSIWXEventProperties()
        }), await ((i = ue._getClient()) == null ? void 0 : i.disconnect().catch(console.error)), Ce.reset("Connect"), ds.showError("A problem occurred while trying initialize authentication");
      }
  },
  async requestSignMessage() {
    const r = K.state.siwx, e = me.getPlainAddress(_.getActiveCaipAddress()), t = _.getActiveCaipNetwork(), n = ue._getClient();
    if (!r)
      throw new Error("SIWX is not enabled");
    if (!e)
      throw new Error("No ActiveCaipAddress found");
    if (!t)
      throw new Error("No ActiveCaipNetwork or client found");
    if (!n)
      throw new Error("No ConnectionController client found");
    try {
      const s = await r.createMessage({
        chainId: t.caipNetworkId,
        accountAddress: e
      }), i = s.toString();
      re.getConnectorId(t.chainNamespace) === W.CONNECTOR_ID.AUTH && Ce.pushTransactionStack({});
      const a = await n.signMessage(i);
      await r.addSession({
        data: s,
        message: i,
        signature: a
      }), nt.close(), ct.sendEvent({
        type: "track",
        event: "SIWX_AUTH_SUCCESS",
        properties: this.getSIWXEventProperties()
      });
    } catch (s) {
      const i = this.getSIWXEventProperties();
      (!nt.state.open || Ce.state.view === "ApproveTransaction") && await nt.open({
        view: "SIWXSignMessage"
      }), i.isSmartAccount ? ds.showError("This application might not support Smart Accounts") : ds.showError("Signature declined"), ct.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties: i
      }), console.error("SWIXUtil:requestSignMessage", s);
    }
  },
  async cancelSignMessage() {
    var r;
    try {
      const e = this.getSIWX();
      ((r = e == null ? void 0 : e.getRequired) == null ? void 0 : r.call(e)) ? await ue.disconnect() : nt.close(), Ce.reset("Connect"), ct.sendEvent({
        event: "CLICK_CANCEL_SIWX",
        type: "track",
        properties: this.getSIWXEventProperties()
      });
    } catch (e) {
      console.error("SIWXUtil:cancelSignMessage", e);
    }
  },
  async getSessions() {
    const r = K.state.siwx, e = me.getPlainAddress(_.getActiveCaipAddress()), t = _.getActiveCaipNetwork();
    return r && e && t ? r.getSessions(t.caipNetworkId, e) : [];
  },
  async isSIWXCloseDisabled() {
    var e;
    const r = this.getSIWX();
    if (r) {
      const t = Ce.state.view === "ApproveTransaction", n = Ce.state.view === "SIWXSignMessage";
      if (t || n)
        return ((e = r.getRequired) == null ? void 0 : e.call(r)) && (await this.getSessions()).length === 0;
    }
    return !1;
  },
  async universalProviderAuthenticate({ universalProvider: r, chains: e, methods: t }) {
    var a, c, l;
    const n = Hh.getSIWX(), s = new Set(e.map((u) => u.split(":")[0]));
    if (!n || s.size !== 1 || !s.has("eip155"))
      return !1;
    const i = await n.createMessage({
      chainId: ((a = _.getActiveCaipNetwork()) == null ? void 0 : a.caipNetworkId) || "",
      accountAddress: ""
    }), o = await r.authenticate({
      nonce: i.nonce,
      domain: i.domain,
      uri: i.uri,
      exp: i.expirationTime,
      iat: i.issuedAt,
      nbf: i.notBefore,
      requestId: i.requestId,
      version: i.version,
      resources: i.resources,
      statement: i.statement,
      chainId: i.chainId,
      methods: t,
      // The first chainId is what is used for universal provider to build the message
      chains: [i.chainId, ...e.filter((u) => u !== i.chainId)]
    });
    if (ds.showLoading("Authenticating...", { autoClose: !1 }), X.setConnectedWalletInfo({
      ...o.session.peer.metadata,
      name: o.session.peer.metadata.name,
      icon: (c = o.session.peer.metadata.icons) == null ? void 0 : c[0],
      type: "WALLET_CONNECT"
    }, Array.from(s)[0]), (l = o == null ? void 0 : o.auths) != null && l.length) {
      const u = o.auths.map((h) => {
        const d = r.client.formatAuthMessage({
          request: h.p,
          iss: h.p.iss
        });
        return {
          data: {
            ...h.p,
            accountAddress: h.p.iss.split(":").slice(-1).join(""),
            chainId: h.p.iss.split(":").slice(2, 4).join(":"),
            uri: h.p.aud,
            version: h.p.version || i.version,
            expirationTime: h.p.exp,
            issuedAt: h.p.iat,
            notBefore: h.p.nbf
          },
          message: d,
          signature: h.s.s,
          cacao: h
        };
      });
      try {
        await n.setSessions(u), ct.sendEvent({
          type: "track",
          event: "SIWX_AUTH_SUCCESS",
          properties: Hh.getSIWXEventProperties()
        });
      } catch (h) {
        throw console.error("SIWX:universalProviderAuth - failed to set sessions", h), ct.sendEvent({
          type: "track",
          event: "SIWX_AUTH_ERROR",
          properties: Hh.getSIWXEventProperties()
        }), await r.disconnect().catch(console.error), h;
      } finally {
        ds.hide();
      }
    }
    return !0;
  },
  getSIWXEventProperties() {
    var e, t;
    const r = _.state.activeChain;
    return {
      network: ((e = _.state.activeCaipNetwork) == null ? void 0 : e.caipNetworkId) || "",
      isSmartAccount: ((t = X.state.preferredAccountTypes) == null ? void 0 : t[r]) === rr.ACCOUNT_TYPES.SMART_ACCOUNT
    };
  },
  async clearSessions() {
    const r = this.getSIWX();
    r && await r.setSessions([]);
  }
}, ft = {
  METMASK_CONNECTOR_NAME: "MetaMask",
  TRUST_CONNECTOR_NAME: "Trust Wallet",
  SOLFLARE_CONNECTOR_NAME: "Solflare",
  PHANTOM_CONNECTOR_NAME: "Phantom",
  COIN98_CONNECTOR_NAME: "Coin98",
  MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
  BACKPACK_CONNECTOR_NAME: "Backpack",
  BITGET_CONNECTOR_NAME: "Bitget Wallet",
  FRONTIER_CONNECTOR_NAME: "Frontier",
  XVERSE_CONNECTOR_NAME: "Xverse Wallet",
  LEATHER_CONNECTOR_NAME: "Leather",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet",
    coinbaseWalletSDK: "com.coinbase.wallet"
  },
  CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
  CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
  CONNECTOR_TYPE_INJECTED: "INJECTED",
  CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
  CONNECTOR_TYPE_AUTH: "AUTH",
  CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
  CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH"
}, qs = {
  ConnectorExplorerIds: {
    [W.CONNECTOR_ID.COINBASE]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [W.CONNECTOR_ID.COINBASE_SDK]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [W.CONNECTOR_ID.SAFE]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [W.CONNECTOR_ID.LEDGER]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
    [W.CONNECTOR_ID.OKX]: "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
    [ft.METMASK_CONNECTOR_NAME]: "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
    [ft.TRUST_CONNECTOR_NAME]: "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
    [ft.SOLFLARE_CONNECTOR_NAME]: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
    [ft.PHANTOM_CONNECTOR_NAME]: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
    [ft.COIN98_CONNECTOR_NAME]: "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
    [ft.MAGIC_EDEN_CONNECTOR_NAME]: "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
    [ft.BACKPACK_CONNECTOR_NAME]: "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
    [ft.BITGET_CONNECTOR_NAME]: "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
    [ft.FRONTIER_CONNECTOR_NAME]: "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
    [ft.XVERSE_CONNECTOR_NAME]: "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
    [ft.LEATHER_CONNECTOR_NAME]: "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13"
  },
  NetworkImageIds: {
    1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
    42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
    295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
    11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
    84532: "a18a7ecd-e307-4360-4746-283182228e00",
    1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
    130: "2257980a-3463-48c6-cbac-a42d2a956e00",
    10143: "0a728e83-bacb-46db-7844-948f05434900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100",
    2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
    2741: "fc2427d1-5af9-4a9c-8da5-6f94627cd900",
    "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700",
    "000000000019d6689c085ae165831e93": "0b4838db-0161-4ffe-022d-532bf03dba00",
    "000000000933ea01ad0ee984209779ba": "39354064-d79b-420b-065d-f980c4b78200"
  },
  ConnectorImageIds: {
    [W.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [W.CONNECTOR_ID.COINBASE_SDK]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [W.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [W.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [W.CONNECTOR_ID.WALLET_CONNECT]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [W.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [W.CONNECTOR_ID.INJECTED]: "Browser Wallet",
    [W.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
    [W.CONNECTOR_ID.COINBASE]: "Coinbase",
    [W.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
    [W.CONNECTOR_ID.LEDGER]: "Ledger",
    [W.CONNECTOR_ID.SAFE]: "Safe"
  },
  ConnectorTypesMap: {
    [W.CONNECTOR_ID.INJECTED]: "INJECTED",
    [W.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
    [W.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
    [W.CONNECTOR_ID.AUTH]: "AUTH"
  }
}, Nd = {
  getCaipTokens(r) {
    if (!r)
      return;
    const e = {};
    return Object.entries(r).forEach(([t, n]) => {
      e[`${ft.EIP155}:${t}`] = n;
    }), e;
  },
  isLowerCaseMatch(r, e) {
    return (r == null ? void 0 : r.toLowerCase()) === (e == null ? void 0 : e.toLowerCase());
  },
  getActiveNamespaceConnectedToAuth() {
    const r = _.state.activeChain;
    return W.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((e) => re.getConnectorId(e) === W.CONNECTOR_ID.AUTH && e === r);
  }
}, uH = new AbortController(), Rr = {
  EmbeddedWalletAbortController: uH,
  UniversalProviderErrors: {
    UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
      message: "Unauthorized: origin not allowed",
      alertErrorKey: "INVALID_APP_CONFIGURATION"
    },
    JWT_VALIDATION_ERROR: {
      message: "JWT validation error: JWT Token is not yet valid",
      alertErrorKey: "JWT_TOKEN_NOT_VALID"
    },
    INVALID_KEY: {
      message: "Unauthorized: invalid key",
      alertErrorKey: "INVALID_PROJECT_ID"
    }
  },
  ALERT_ERRORS: {
    SWITCH_NETWORK_NOT_FOUND: {
      shortMessage: "Network Not Found",
      longMessage: "Network not found - please make sure it is included in 'networks' array in createAppKit function"
    },
    INVALID_APP_CONFIGURATION: {
      shortMessage: "Invalid App Configuration",
      longMessage: () => `Origin ${hH() ? window.origin : "unknown"} not found on Allowlist - update configuration on cloud.reown.com`
    },
    IFRAME_LOAD_FAILED: {
      shortMessage: "Network Error - Could not load embedded wallet",
      longMessage: () => "There was an issue loading the embedded wallet. Please try again later."
    },
    IFRAME_REQUEST_TIMEOUT: {
      shortMessage: "Embedded Wallet Request Timed Out",
      longMessage: () => "There was an issue doing the request to the embedded wallet. Please try again later."
    },
    UNVERIFIED_DOMAIN: {
      shortMessage: "Invalid App Configuration",
      longMessage: () => "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com"
    },
    JWT_TOKEN_NOT_VALID: {
      shortMessage: "Session Expired",
      longMessage: "Invalid session found on UniversalProvider - please check your time settings and connect again"
    },
    INVALID_PROJECT_ID: {
      shortMessage: "Invalid App Configuration",
      longMessage: "Invalid Project ID - update configuration"
    },
    PROJECT_ID_NOT_CONFIGURED: {
      shortMessage: "Project ID Not Configured",
      longMessage: "Project ID Not Configured - update configuration on cloud.reown.com"
    },
    SERVER_ERROR_APP_CONFIGURATION: {
      shortMessage: "Server Error",
      longMessage: (r) => `Failed to get App Configuration ${r || ""}`
    },
    RATE_LIMITED_APP_CONFIGURATION: {
      shortMessage: "Rate Limited",
      longMessage: "Rate limited when trying to get the App Configuration"
    }
  }
};
function hH() {
  return typeof window < "u";
}
const dH = {
  createLogger(r, e = "error") {
    const t = Fu({
      level: e
    }), { logger: n } = j0({
      opts: t
    });
    return n.error = (...s) => {
      for (const i of s)
        if (i instanceof Error) {
          r(i, ...s);
          return;
        }
      r(void 0, ...s);
    }, n;
  }
}, fH = "rpc.walletconnect.org";
function cA(r, e) {
  const t = new URL("https://rpc.walletconnect.org/v1/");
  return t.searchParams.set("chainId", r), t.searchParams.set("projectId", e), t.toString();
}
const Ew = [
  "near:mainnet",
  "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  "eip155:1101",
  "eip155:56",
  "eip155:42161",
  "eip155:7777777",
  "eip155:59144",
  "eip155:324",
  "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  "eip155:5000",
  "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
  "eip155:80084",
  "eip155:5003",
  "eip155:100",
  "eip155:8453",
  "eip155:42220",
  "eip155:1313161555",
  "eip155:17000",
  "eip155:1",
  "eip155:300",
  "eip155:1313161554",
  "eip155:1329",
  "eip155:84532",
  "eip155:421614",
  "eip155:11155111",
  "eip155:8217",
  "eip155:43114",
  "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  "eip155:999999999",
  "eip155:11155420",
  "eip155:80002",
  "eip155:97",
  "eip155:43113",
  "eip155:137",
  "eip155:10",
  "eip155:1301",
  "bip122:000000000019d6689c085ae165831e93",
  "bip122:000000000933ea01ad0ee984209779ba"
], ol = {
  extendRpcUrlWithProjectId(r, e) {
    let t = !1;
    try {
      t = new URL(r).host === fH;
    } catch {
      t = !1;
    }
    if (t) {
      const n = new URL(r);
      return n.searchParams.has("projectId") || n.searchParams.set("projectId", e), n.toString();
    }
    return r;
  },
  isCaipNetwork(r) {
    return "chainNamespace" in r && "caipNetworkId" in r;
  },
  getChainNamespace(r) {
    return this.isCaipNetwork(r) ? r.chainNamespace : W.CHAIN.EVM;
  },
  getCaipNetworkId(r) {
    return this.isCaipNetwork(r) ? r.caipNetworkId : `${W.CHAIN.EVM}:${r.id}`;
  },
  getDefaultRpcUrl(r, e, t) {
    var s, i, o;
    const n = (o = (i = (s = r.rpcUrls) == null ? void 0 : s.default) == null ? void 0 : i.http) == null ? void 0 : o[0];
    return Ew.includes(e) ? cA(e, t) : n || "";
  },
  extendCaipNetwork(r, { customNetworkImageUrls: e, projectId: t, customRpcUrls: n }) {
    var d, f, g, p, w;
    const s = this.getChainNamespace(r), i = this.getCaipNetworkId(r), o = (d = r.rpcUrls.default.http) == null ? void 0 : d[0], a = this.getDefaultRpcUrl(r, i, t), c = ((p = (g = (f = r == null ? void 0 : r.rpcUrls) == null ? void 0 : f.chainDefault) == null ? void 0 : g.http) == null ? void 0 : p[0]) || o, l = ((w = n == null ? void 0 : n[i]) == null ? void 0 : w.map((E) => E.url)) || [], u = [...l, a], h = [...l];
    return c && !h.includes(c) && h.push(c), {
      ...r,
      chainNamespace: s,
      caipNetworkId: i,
      assets: {
        imageId: qs.NetworkImageIds[r.id],
        imageUrl: e == null ? void 0 : e[r.id]
      },
      rpcUrls: {
        ...r.rpcUrls,
        default: {
          http: u
        },
        chainDefault: {
          http: h
        }
      }
    };
  },
  extendCaipNetworks(r, { customNetworkImageUrls: e, projectId: t, customRpcUrls: n }) {
    return r.map((s) => ol.extendCaipNetwork(s, {
      customNetworkImageUrls: e,
      customRpcUrls: n,
      projectId: t
    }));
  },
  getViemTransport(r, e, t) {
    var s, i, o;
    const n = [];
    return t == null || t.forEach((a) => {
      n.push(qf(a.url, a.config));
    }), Ew.includes(r.caipNetworkId) && n.push(qf(cA(r.caipNetworkId, e), {
      fetchOptions: {
        headers: {
          "Content-Type": "text/plain"
        }
      }
    })), (o = (i = (s = r == null ? void 0 : r.rpcUrls) == null ? void 0 : s.default) == null ? void 0 : i.http) == null || o.forEach((a) => {
      n.push(qf(a));
    }), pE(n);
  },
  extendWagmiTransports(r, e, t) {
    if (Ew.includes(r.caipNetworkId)) {
      const n = this.getDefaultRpcUrl(r, r.caipNetworkId, e);
      return pE([t, qf(n)]);
    }
    return t;
  },
  getUnsupportedNetwork(r) {
    return {
      id: r.split(":")[1],
      caipNetworkId: r,
      name: W.UNSUPPORTED_NETWORK_NAME,
      chainNamespace: r.split(":")[0],
      nativeCurrency: {
        name: "",
        decimals: 0,
        symbol: ""
      },
      rpcUrls: {
        default: {
          http: []
        }
      }
    };
  },
  getCaipNetworkFromStorage(r) {
    var c;
    const e = te.getActiveCaipNetworkId(), t = _.getAllRequestedCaipNetworks(), n = Array.from(((c = _.state.chains) == null ? void 0 : c.keys()) || []), s = e == null ? void 0 : e.split(":")[0], i = s ? n.includes(s) : !1, o = t == null ? void 0 : t.find((l) => l.caipNetworkId === e);
    return i && !o && e ? this.getUnsupportedNetwork(e) : o || r || (t == null ? void 0 : t[0]);
  }
}, lg = {
  eip155: void 0,
  solana: void 0,
  polkadot: void 0,
  bip122: void 0,
  cosmos: void 0
}, Gr = _t({
  providers: { ...lg },
  providerIds: { ...lg }
}), Ze = {
  state: Gr,
  subscribeKey(r, e) {
    return Tr(Gr, r, e);
  },
  subscribe(r) {
    return fr(Gr, () => {
      r(Gr);
    });
  },
  subscribeProviders(r) {
    return fr(Gr.providers, () => r(Gr.providers));
  },
  setProvider(r, e) {
    e && (Gr.providers[r] = ac(e));
  },
  getProvider(r) {
    return Gr.providers[r];
  },
  setProviderId(r, e) {
    e && (Gr.providerIds[r] = e);
  },
  getProviderId(r) {
    if (r)
      return Gr.providerIds[r];
  },
  reset() {
    Gr.providers = { ...lg }, Gr.providerIds = { ...lg };
  },
  resetChain(r) {
    Gr.providers[r] = void 0, Gr.providerIds[r] = void 0;
  }
}, lA = {
  transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
  signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u
}, ar = {
  set(r, e) {
    Cn.isClient && localStorage.setItem(`${pe.STORAGE_KEY}${r}`, e);
  },
  get(r) {
    return Cn.isClient ? localStorage.getItem(`${pe.STORAGE_KEY}${r}`) : null;
  },
  delete(r, e) {
    Cn.isClient && (e ? localStorage.removeItem(r) : localStorage.removeItem(`${pe.STORAGE_KEY}${r}`));
  }
}, hp = 30 * 1e3, Cn = {
  checkIfAllowedToTriggerEmail() {
    const r = ar.get(pe.LAST_EMAIL_LOGIN_TIME);
    if (r) {
      const e = Date.now() - Number(r);
      if (e < hp) {
        const t = Math.ceil((hp - e) / 1e3);
        throw new Error(`Please try again after ${t} seconds`);
      }
    }
  },
  getTimeToNextEmailLogin() {
    const r = ar.get(pe.LAST_EMAIL_LOGIN_TIME);
    if (r) {
      const e = Date.now() - Number(r);
      if (e < hp)
        return Math.ceil((hp - e) / 1e3);
    }
    return 0;
  },
  checkIfRequestExists(r) {
    return rr.NOT_SAFE_RPC_METHODS.includes(r.method) || rr.SAFE_RPC_METHODS.includes(r.method);
  },
  getResponseType(r) {
    return typeof r == "string" && ((r == null ? void 0 : r.match(lA.transactionHash)) || (r == null ? void 0 : r.match(lA.signedMessage))) ? pe.RPC_RESPONSE_TYPE_TX : pe.RPC_RESPONSE_TYPE_OBJECT;
  },
  checkIfRequestIsSafe(r) {
    return rr.SAFE_RPC_METHODS.includes(r.method);
  },
  isClient: typeof window < "u"
};
var Xe;
(function(r) {
  r.assertEqual = (s) => s;
  function e(s) {
  }
  r.assertIs = e;
  function t(s) {
    throw new Error();
  }
  r.assertNever = t, r.arrayToEnum = (s) => {
    const i = {};
    for (const o of s)
      i[o] = o;
    return i;
  }, r.getValidEnumValues = (s) => {
    const i = r.objectKeys(s).filter((a) => typeof s[s[a]] != "number"), o = {};
    for (const a of i)
      o[a] = s[a];
    return r.objectValues(o);
  }, r.objectValues = (s) => r.objectKeys(s).map(function(i) {
    return s[i];
  }), r.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const o in s)
      Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
    return i;
  }, r.find = (s, i) => {
    for (const o of s)
      if (i(o))
        return o;
  }, r.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n(s, i = " | ") {
    return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(i);
  }
  r.joinValues = n, r.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(Xe || (Xe = {}));
var zy;
(function(r) {
  r.mergeShapes = (e, t) => ({
    ...e,
    ...t
    // second overwrites first
  });
})(zy || (zy = {}));
const ae = Xe.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), yo = (r) => {
  switch (typeof r) {
    case "undefined":
      return ae.undefined;
    case "string":
      return ae.string;
    case "number":
      return isNaN(r) ? ae.nan : ae.number;
    case "boolean":
      return ae.boolean;
    case "function":
      return ae.function;
    case "bigint":
      return ae.bigint;
    case "symbol":
      return ae.symbol;
    case "object":
      return Array.isArray(r) ? ae.array : r === null ? ae.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? ae.promise : typeof Map < "u" && r instanceof Map ? ae.map : typeof Set < "u" && r instanceof Set ? ae.set : typeof Date < "u" && r instanceof Date ? ae.date : ae.object;
    default:
      return ae.unknown;
  }
}, J = Xe.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), pH = (r) => JSON.stringify(r, null, 2).replace(/"([^"]+)":/g, "$1:");
class ws extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const t = e || function(i) {
      return i.message;
    }, n = { _errors: [] }, s = (i) => {
      for (const o of i.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(s);
        else if (o.code === "invalid_return_type")
          s(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          s(o.argumentsError);
        else if (o.path.length === 0)
          n._errors.push(t(o));
        else {
          let a = n, c = 0;
          for (; c < o.path.length; ) {
            const l = o.path[c];
            c === o.path.length - 1 ? (a[l] = a[l] || { _errors: [] }, a[l]._errors.push(t(o))) : a[l] = a[l] || { _errors: [] }, a = a[l], c++;
          }
        }
    };
    return s(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Xe.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (t[s.path[0]] = t[s.path[0]] || [], t[s.path[0]].push(e(s))) : n.push(e(s));
    return { formErrors: n, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
ws.create = (r) => new ws(r);
const Td = (r, e) => {
  let t;
  switch (r.code) {
    case J.invalid_type:
      r.received === ae.undefined ? t = "Required" : t = `Expected ${r.expected}, received ${r.received}`;
      break;
    case J.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(r.expected, Xe.jsonStringifyReplacer)}`;
      break;
    case J.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${Xe.joinValues(r.keys, ", ")}`;
      break;
    case J.invalid_union:
      t = "Invalid input";
      break;
    case J.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${Xe.joinValues(r.options)}`;
      break;
    case J.invalid_enum_value:
      t = `Invalid enum value. Expected ${Xe.joinValues(r.options)}, received '${r.received}'`;
      break;
    case J.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case J.invalid_return_type:
      t = "Invalid function return type";
      break;
    case J.invalid_date:
      t = "Invalid date";
      break;
    case J.invalid_string:
      typeof r.validation == "object" ? "includes" in r.validation ? (t = `Invalid input: must include "${r.validation.includes}"`, typeof r.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith" in r.validation ? t = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? t = `Invalid input: must end with "${r.validation.endsWith}"` : Xe.assertNever(r.validation) : r.validation !== "regex" ? t = `Invalid ${r.validation}` : t = "Invalid";
      break;
    case J.too_small:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : t = "Invalid input";
      break;
    case J.too_big:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? t = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : t = "Invalid input";
      break;
    case J.custom:
      t = "Invalid input";
      break;
    case J.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case J.not_multiple_of:
      t = `Number must be a multiple of ${r.multipleOf}`;
      break;
    case J.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, Xe.assertNever(r);
  }
  return { message: t };
};
let yS = Td;
function gH(r) {
  yS = r;
}
function ug() {
  return yS;
}
const hg = (r) => {
  const { data: e, path: t, errorMaps: n, issueData: s } = r, i = [...t, ...s.path || []], o = {
    ...s,
    path: i
  };
  let a = "";
  const c = n.filter((l) => !!l).slice().reverse();
  for (const l of c)
    a = l(o, { data: e, defaultError: a }).message;
  return {
    ...s,
    path: i,
    message: s.message || a
  };
}, mH = [];
function he(r, e) {
  const t = hg({
    issueData: e,
    data: r.data,
    path: r.path,
    errorMaps: [
      r.common.contextualErrorMap,
      r.schemaErrorMap,
      ug(),
      Td
      // then global default map
    ].filter((n) => !!n)
  });
  r.common.issues.push(t);
}
class Nr {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const n = [];
    for (const s of t) {
      if (s.status === "aborted")
        return Te;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, t) {
    const n = [];
    for (const s of t)
      n.push({
        key: await s.key,
        value: await s.value
      });
    return Nr.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, t) {
    const n = {};
    for (const s of t) {
      const { key: i, value: o } = s;
      if (i.status === "aborted" || o.status === "aborted")
        return Te;
      i.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) && (n[i.value] = o.value);
    }
    return { status: e.value, value: n };
  }
}
const Te = Object.freeze({
  status: "aborted"
}), bS = (r) => ({ status: "dirty", value: r }), Mr = (r) => ({ status: "valid", value: r }), qy = (r) => r.status === "aborted", Wy = (r) => r.status === "dirty", xd = (r) => r.status === "valid", dg = (r) => typeof Promise < "u" && r instanceof Promise;
var be;
(function(r) {
  r.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, r.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(be || (be = {}));
class ti {
  constructor(e, t, n, s) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const uA = (r, e) => {
  if (xd(e))
    return { success: !0, data: e.value };
  if (!r.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const t = new ws(r.common.issues);
      return this._error = t, this._error;
    }
  };
};
function Re(r) {
  if (!r)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: n, description: s } = r;
  if (e && (t || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (o, a) => o.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: n ?? a.defaultError } : { message: t ?? a.defaultError }, description: s };
}
class Fe {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return yo(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: yo(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new Nr(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: yo(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (dg(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const n = this.safeParse(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, t) {
    var n;
    const s = {
      common: {
        issues: [],
        async: (n = t == null ? void 0 : t.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: yo(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return uA(s, i);
  }
  async parseAsync(e, t) {
    const n = await this.safeParseAsync(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, t) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: !0
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: yo(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), i = await (dg(s) ? s : Promise.resolve(s));
    return uA(n, i);
  }
  refine(e, t) {
    const n = (s) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(s) : t;
    return this._refinement((s, i) => {
      const o = e(s), a = () => i.addIssue({
        code: J.custom,
        ...n(s)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((n, s) => e(n) ? !0 : (s.addIssue(typeof t == "function" ? t(n, s) : t), !1));
  }
  _refinement(e) {
    return new bs({
      schema: this,
      typeName: Ie.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return Li.create(this, this._def);
  }
  nullable() {
    return mc.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ys.create(this, this._def);
  }
  promise() {
    return Nu.create(this, this._def);
  }
  or(e) {
    return Dd.create([this, e], this._def);
  }
  and(e) {
    return kd.create(this, e, this._def);
  }
  transform(e) {
    return new bs({
      ...Re(this._def),
      schema: this,
      typeName: Ie.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new $d({
      ...Re(this._def),
      innerType: this,
      defaultValue: t,
      typeName: Ie.ZodDefault
    });
  }
  brand() {
    return new vS({
      typeName: Ie.ZodBranded,
      type: this,
      ...Re(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new mg({
      ...Re(this._def),
      innerType: this,
      catchValue: t,
      typeName: Ie.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Of.create(this, e);
  }
  readonly() {
    return yg.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const wH = /^c[^\s-]{8,}$/i, yH = /^[a-z][a-z0-9]*$/, bH = /^[0-9A-HJKMNP-TV-Z]{26}$/, EH = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, vH = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, AH = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let vw;
const CH = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, _H = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, IH = (r) => r.precision ? r.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${r.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${r.precision}}Z$`) : r.precision === 0 ? r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function SH(r, e) {
  return !!((e === "v4" || !e) && CH.test(r) || (e === "v6" || !e) && _H.test(r));
}
class gs extends Fe {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== ae.string) {
      const i = this._getOrReturnCtx(e);
      return he(
        i,
        {
          code: J.invalid_type,
          expected: ae.string,
          received: i.parsedType
        }
        //
      ), Te;
    }
    const n = new Nr();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), he(s, {
          code: J.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), he(s, {
          code: J.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), n.dirty());
      else if (i.kind === "length") {
        const o = e.data.length > i.value, a = e.data.length < i.value;
        (o || a) && (s = this._getOrReturnCtx(e, s), o ? he(s, {
          code: J.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : a && he(s, {
          code: J.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), n.dirty());
      } else if (i.kind === "email")
        vH.test(e.data) || (s = this._getOrReturnCtx(e, s), he(s, {
          validation: "email",
          code: J.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "emoji")
        vw || (vw = new RegExp(AH, "u")), vw.test(e.data) || (s = this._getOrReturnCtx(e, s), he(s, {
          validation: "emoji",
          code: J.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        EH.test(e.data) || (s = this._getOrReturnCtx(e, s), he(s, {
          validation: "uuid",
          code: J.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        wH.test(e.data) || (s = this._getOrReturnCtx(e, s), he(s, {
          validation: "cuid",
          code: J.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid2")
        yH.test(e.data) || (s = this._getOrReturnCtx(e, s), he(s, {
          validation: "cuid2",
          code: J.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "ulid")
        bH.test(e.data) || (s = this._getOrReturnCtx(e, s), he(s, {
          validation: "ulid",
          code: J.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), he(s, {
            validation: "url",
            code: J.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), he(s, {
        validation: "regex",
        code: J.invalid_string,
        message: i.message
      }), n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e, s), he(s, {
        code: J.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), n.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), he(s, {
        code: J.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), he(s, {
        code: J.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), n.dirty()) : i.kind === "datetime" ? IH(i).test(e.data) || (s = this._getOrReturnCtx(e, s), he(s, {
        code: J.invalid_string,
        validation: "datetime",
        message: i.message
      }), n.dirty()) : i.kind === "ip" ? SH(e.data, i.version) || (s = this._getOrReturnCtx(e, s), he(s, {
        validation: "ip",
        code: J.invalid_string,
        message: i.message
      }), n.dirty()) : Xe.assertNever(i);
    return { status: n.value, value: e.data };
  }
  _regex(e, t, n) {
    return this.refinement((s) => e.test(s), {
      validation: t,
      code: J.invalid_string,
      ...be.errToObj(n)
    });
  }
  _addCheck(e) {
    return new gs({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...be.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...be.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...be.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...be.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...be.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...be.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...be.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...be.errToObj(e) });
  }
  datetime(e) {
    var t;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1,
      ...be.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...be.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...be.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...be.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...be.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...be.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...be.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...be.errToObj(t)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e) {
    return this.min(1, be.errToObj(e));
  }
  trim() {
    return new gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
gs.create = (r) => {
  var e;
  return new gs({
    checks: [],
    typeName: Ie.ZodString,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : !1,
    ...Re(r)
  });
};
function NH(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = t > n ? t : n, i = parseInt(r.toFixed(s).replace(".", "")), o = parseInt(e.toFixed(s).replace(".", ""));
  return i % o / Math.pow(10, s);
}
class Ko extends Fe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== ae.number) {
      const i = this._getOrReturnCtx(e);
      return he(i, {
        code: J.invalid_type,
        expected: ae.number,
        received: i.parsedType
      }), Te;
    }
    let n;
    const s = new Nr();
    for (const i of this._def.checks)
      i.kind === "int" ? Xe.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {
        code: J.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), he(n, {
        code: J.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), he(n, {
        code: J.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? NH(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n), he(n, {
        code: J.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {
        code: J.not_finite,
        message: i.message
      }), s.dirty()) : Xe.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, be.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, be.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, be.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, be.toString(t));
  }
  setLimit(e, t, n, s) {
    return new Ko({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: be.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Ko({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: be.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: be.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: be.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: be.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: be.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: be.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: be.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: be.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: be.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Xe.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (t === null || n.value > t) && (t = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
}
Ko.create = (r) => new Ko({
  checks: [],
  typeName: Ie.ZodNumber,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...Re(r)
});
class Jo extends Fe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== ae.bigint) {
      const i = this._getOrReturnCtx(e);
      return he(i, {
        code: J.invalid_type,
        expected: ae.bigint,
        received: i.parsedType
      }), Te;
    }
    let n;
    const s = new Nr();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), he(n, {
        code: J.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), he(n, {
        code: J.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), he(n, {
        code: J.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : Xe.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, be.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, be.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, be.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, be.toString(t));
  }
  setLimit(e, t, n, s) {
    return new Jo({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: be.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Jo({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: be.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: be.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: be.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: be.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: be.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
Jo.create = (r) => {
  var e;
  return new Jo({
    checks: [],
    typeName: Ie.ZodBigInt,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : !1,
    ...Re(r)
  });
};
class Od extends Fe {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== ae.boolean) {
      const n = this._getOrReturnCtx(e);
      return he(n, {
        code: J.invalid_type,
        expected: ae.boolean,
        received: n.parsedType
      }), Te;
    }
    return Mr(e.data);
  }
}
Od.create = (r) => new Od({
  typeName: Ie.ZodBoolean,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...Re(r)
});
class pc extends Fe {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== ae.date) {
      const i = this._getOrReturnCtx(e);
      return he(i, {
        code: J.invalid_type,
        expected: ae.date,
        received: i.parsedType
      }), Te;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return he(i, {
        code: J.invalid_date
      }), Te;
    }
    const n = new Nr();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), he(s, {
        code: J.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), he(s, {
        code: J.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : Xe.assertNever(i);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new pc({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: be.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: be.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
pc.create = (r) => new pc({
  checks: [],
  coerce: (r == null ? void 0 : r.coerce) || !1,
  typeName: Ie.ZodDate,
  ...Re(r)
});
class fg extends Fe {
  _parse(e) {
    if (this._getType(e) !== ae.symbol) {
      const n = this._getOrReturnCtx(e);
      return he(n, {
        code: J.invalid_type,
        expected: ae.symbol,
        received: n.parsedType
      }), Te;
    }
    return Mr(e.data);
  }
}
fg.create = (r) => new fg({
  typeName: Ie.ZodSymbol,
  ...Re(r)
});
class Pd extends Fe {
  _parse(e) {
    if (this._getType(e) !== ae.undefined) {
      const n = this._getOrReturnCtx(e);
      return he(n, {
        code: J.invalid_type,
        expected: ae.undefined,
        received: n.parsedType
      }), Te;
    }
    return Mr(e.data);
  }
}
Pd.create = (r) => new Pd({
  typeName: Ie.ZodUndefined,
  ...Re(r)
});
class Rd extends Fe {
  _parse(e) {
    if (this._getType(e) !== ae.null) {
      const n = this._getOrReturnCtx(e);
      return he(n, {
        code: J.invalid_type,
        expected: ae.null,
        received: n.parsedType
      }), Te;
    }
    return Mr(e.data);
  }
}
Rd.create = (r) => new Rd({
  typeName: Ie.ZodNull,
  ...Re(r)
});
class Su extends Fe {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Mr(e.data);
  }
}
Su.create = (r) => new Su({
  typeName: Ie.ZodAny,
  ...Re(r)
});
class nc extends Fe {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Mr(e.data);
  }
}
nc.create = (r) => new nc({
  typeName: Ie.ZodUnknown,
  ...Re(r)
});
class ji extends Fe {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return he(t, {
      code: J.invalid_type,
      expected: ae.never,
      received: t.parsedType
    }), Te;
  }
}
ji.create = (r) => new ji({
  typeName: Ie.ZodNever,
  ...Re(r)
});
class pg extends Fe {
  _parse(e) {
    if (this._getType(e) !== ae.undefined) {
      const n = this._getOrReturnCtx(e);
      return he(n, {
        code: J.invalid_type,
        expected: ae.void,
        received: n.parsedType
      }), Te;
    }
    return Mr(e.data);
  }
}
pg.create = (r) => new pg({
  typeName: Ie.ZodVoid,
  ...Re(r)
});
class ys extends Fe {
  _parse(e) {
    const { ctx: t, status: n } = this._processInputParams(e), s = this._def;
    if (t.parsedType !== ae.array)
      return he(t, {
        code: J.invalid_type,
        expected: ae.array,
        received: t.parsedType
      }), Te;
    if (s.exactLength !== null) {
      const o = t.data.length > s.exactLength.value, a = t.data.length < s.exactLength.value;
      (o || a) && (he(t, {
        code: o ? J.too_big : J.too_small,
        minimum: a ? s.exactLength.value : void 0,
        maximum: o ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && t.data.length < s.minLength.value && (he(t, {
      code: J.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && t.data.length > s.maxLength.value && (he(t, {
      code: J.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), n.dirty()), t.common.async)
      return Promise.all([...t.data].map((o, a) => s.type._parseAsync(new ti(t, o, t.path, a)))).then((o) => Nr.mergeArray(n, o));
    const i = [...t.data].map((o, a) => s.type._parseSync(new ti(t, o, t.path, a)));
    return Nr.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new ys({
      ...this._def,
      minLength: { value: e, message: be.toString(t) }
    });
  }
  max(e, t) {
    return new ys({
      ...this._def,
      maxLength: { value: e, message: be.toString(t) }
    });
  }
  length(e, t) {
    return new ys({
      ...this._def,
      exactLength: { value: e, message: be.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ys.create = (r, e) => new ys({
  type: r,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Ie.ZodArray,
  ...Re(e)
});
function al(r) {
  if (r instanceof Nt) {
    const e = {};
    for (const t in r.shape) {
      const n = r.shape[t];
      e[t] = Li.create(al(n));
    }
    return new Nt({
      ...r._def,
      shape: () => e
    });
  } else return r instanceof ys ? new ys({
    ...r._def,
    type: al(r.element)
  }) : r instanceof Li ? Li.create(al(r.unwrap())) : r instanceof mc ? mc.create(al(r.unwrap())) : r instanceof ri ? ri.create(r.items.map((e) => al(e))) : r;
}
class Nt extends Fe {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = Xe.objectKeys(e);
    return this._cached = { shape: e, keys: t };
  }
  _parse(e) {
    if (this._getType(e) !== ae.object) {
      const l = this._getOrReturnCtx(e);
      return he(l, {
        code: J.invalid_type,
        expected: ae.object,
        received: l.parsedType
      }), Te;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof ji && this._def.unknownKeys === "strip"))
      for (const l in s.data)
        o.includes(l) || a.push(l);
    const c = [];
    for (const l of o) {
      const u = i[l], h = s.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: u._parse(new ti(s, h, s.path, l)),
        alwaysSet: l in s.data
      });
    }
    if (this._def.catchall instanceof ji) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const u of a)
          c.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: s.data[u] }
          });
      else if (l === "strict")
        a.length > 0 && (he(s, {
          code: J.unrecognized_keys,
          keys: a
        }), n.dirty());
      else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const u of a) {
        const h = s.data[u];
        c.push({
          key: { status: "valid", value: u },
          value: l._parse(
            new ti(s, h, s.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const u of c) {
        const h = await u.key;
        l.push({
          key: h,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return l;
    }).then((l) => Nr.mergeObjectSync(n, l)) : Nr.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return be.errToObj, new Nt({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, n) => {
          var s, i, o, a;
          const c = (o = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, t, n).message) !== null && o !== void 0 ? o : n.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: (a = be.errToObj(e).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new Nt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Nt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new Nt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new Nt({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: Ie.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new Nt({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    return Xe.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (t[n] = this.shape[n]);
    }), new Nt({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    return Xe.objectKeys(this.shape).forEach((n) => {
      e[n] || (t[n] = this.shape[n]);
    }), new Nt({
      ...this._def,
      shape: () => t
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return al(this);
  }
  partial(e) {
    const t = {};
    return Xe.objectKeys(this.shape).forEach((n) => {
      const s = this.shape[n];
      e && !e[n] ? t[n] = s : t[n] = s.optional();
    }), new Nt({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    return Xe.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        t[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof Li; )
          i = i._def.innerType;
        t[n] = i;
      }
    }), new Nt({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return ES(Xe.objectKeys(this.shape));
  }
}
Nt.create = (r, e) => new Nt({
  shape: () => r,
  unknownKeys: "strip",
  catchall: ji.create(),
  typeName: Ie.ZodObject,
  ...Re(e)
});
Nt.strictCreate = (r, e) => new Nt({
  shape: () => r,
  unknownKeys: "strict",
  catchall: ji.create(),
  typeName: Ie.ZodObject,
  ...Re(e)
});
Nt.lazycreate = (r, e) => new Nt({
  shape: r,
  unknownKeys: "strip",
  catchall: ji.create(),
  typeName: Ie.ZodObject,
  ...Re(e)
});
class Dd extends Fe {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = this._def.options;
    function s(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return t.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((a) => new ws(a.ctx.common.issues));
      return he(t, {
        code: J.invalid_union,
        unionErrors: o
      }), Te;
    }
    if (t.common.async)
      return Promise.all(n.map(async (i) => {
        const o = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: t.data,
            path: t.path,
            parent: o
          }),
          ctx: o
        };
      })).then(s);
    {
      let i;
      const o = [];
      for (const c of n) {
        const l = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, u = c._parseSync({
          data: t.data,
          path: t.path,
          parent: l
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !i && (i = { result: u, ctx: l }), l.common.issues.length && o.push(l.common.issues);
      }
      if (i)
        return t.common.issues.push(...i.ctx.common.issues), i.result;
      const a = o.map((c) => new ws(c));
      return he(t, {
        code: J.invalid_union,
        unionErrors: a
      }), Te;
    }
  }
  get options() {
    return this._def.options;
  }
}
Dd.create = (r, e) => new Dd({
  options: r,
  typeName: Ie.ZodUnion,
  ...Re(e)
});
const Pp = (r) => r instanceof Bd ? Pp(r.schema) : r instanceof bs ? Pp(r.innerType()) : r instanceof Ld ? [r.value] : r instanceof Yo ? r.options : r instanceof Fd ? Object.keys(r.enum) : r instanceof $d ? Pp(r._def.innerType) : r instanceof Pd ? [void 0] : r instanceof Rd ? [null] : null;
class im extends Fe {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== ae.object)
      return he(t, {
        code: J.invalid_type,
        expected: ae.object,
        received: t.parsedType
      }), Te;
    const n = this.discriminator, s = t.data[n], i = this.optionsMap.get(s);
    return i ? t.common.async ? i._parseAsync({
      data: t.data,
      path: t.path,
      parent: t
    }) : i._parseSync({
      data: t.data,
      path: t.path,
      parent: t
    }) : (he(t, {
      code: J.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), Te);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, t, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i of t) {
      const o = Pp(i.shape[e]);
      if (!o)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const a of o) {
        if (s.has(a))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
        s.set(a, i);
      }
    }
    return new im({
      typeName: Ie.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: s,
      ...Re(n)
    });
  }
}
function Vy(r, e) {
  const t = yo(r), n = yo(e);
  if (r === e)
    return { valid: !0, data: r };
  if (t === ae.object && n === ae.object) {
    const s = Xe.objectKeys(e), i = Xe.objectKeys(r).filter((a) => s.indexOf(a) !== -1), o = { ...r, ...e };
    for (const a of i) {
      const c = Vy(r[a], e[a]);
      if (!c.valid)
        return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (t === ae.array && n === ae.array) {
    if (r.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < r.length; i++) {
      const o = r[i], a = e[i], c = Vy(o, a);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else return t === ae.date && n === ae.date && +r == +e ? { valid: !0, data: r } : { valid: !1 };
}
class kd extends Fe {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), s = (i, o) => {
      if (qy(i) || qy(o))
        return Te;
      const a = Vy(i.value, o.value);
      return a.valid ? ((Wy(i) || Wy(o)) && t.dirty(), { status: t.value, value: a.data }) : (he(n, {
        code: J.invalid_intersection_types
      }), Te);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, o]) => s(i, o)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
kd.create = (r, e, t) => new kd({
  left: r,
  right: e,
  typeName: Ie.ZodIntersection,
  ...Re(t)
});
class ri extends Fe {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ae.array)
      return he(n, {
        code: J.invalid_type,
        expected: ae.array,
        received: n.parsedType
      }), Te;
    if (n.data.length < this._def.items.length)
      return he(n, {
        code: J.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Te;
    !this._def.rest && n.data.length > this._def.items.length && (he(n, {
      code: J.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), t.dirty());
    const i = [...n.data].map((o, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new ti(n, o, n.path, a)) : null;
    }).filter((o) => !!o);
    return n.common.async ? Promise.all(i).then((o) => Nr.mergeArray(t, o)) : Nr.mergeArray(t, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new ri({
      ...this._def,
      rest: e
    });
  }
}
ri.create = (r, e) => {
  if (!Array.isArray(r))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ri({
    items: r,
    typeName: Ie.ZodTuple,
    rest: null,
    ...Re(e)
  });
};
class Ud extends Fe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ae.object)
      return he(n, {
        code: J.invalid_type,
        expected: ae.object,
        received: n.parsedType
      }), Te;
    const s = [], i = this._def.keyType, o = this._def.valueType;
    for (const a in n.data)
      s.push({
        key: i._parse(new ti(n, a, n.path, a)),
        value: o._parse(new ti(n, n.data[a], n.path, a))
      });
    return n.common.async ? Nr.mergeObjectAsync(t, s) : Nr.mergeObjectSync(t, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, n) {
    return t instanceof Fe ? new Ud({
      keyType: e,
      valueType: t,
      typeName: Ie.ZodRecord,
      ...Re(n)
    }) : new Ud({
      keyType: gs.create(),
      valueType: e,
      typeName: Ie.ZodRecord,
      ...Re(t)
    });
  }
}
class gg extends Fe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ae.map)
      return he(n, {
        code: J.invalid_type,
        expected: ae.map,
        received: n.parsedType
      }), Te;
    const s = this._def.keyType, i = this._def.valueType, o = [...n.data.entries()].map(([a, c], l) => ({
      key: s._parse(new ti(n, a, n.path, [l, "key"])),
      value: i._parse(new ti(n, c, n.path, [l, "value"]))
    }));
    if (n.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const l = await c.key, u = await c.value;
          if (l.status === "aborted" || u.status === "aborted")
            return Te;
          (l.status === "dirty" || u.status === "dirty") && t.dirty(), a.set(l.value, u.value);
        }
        return { status: t.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of o) {
        const l = c.key, u = c.value;
        if (l.status === "aborted" || u.status === "aborted")
          return Te;
        (l.status === "dirty" || u.status === "dirty") && t.dirty(), a.set(l.value, u.value);
      }
      return { status: t.value, value: a };
    }
  }
}
gg.create = (r, e, t) => new gg({
  valueType: e,
  keyType: r,
  typeName: Ie.ZodMap,
  ...Re(t)
});
class gc extends Fe {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== ae.set)
      return he(n, {
        code: J.invalid_type,
        expected: ae.set,
        received: n.parsedType
      }), Te;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (he(n, {
      code: J.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), t.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (he(n, {
      code: J.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), t.dirty());
    const i = this._def.valueType;
    function o(c) {
      const l = /* @__PURE__ */ new Set();
      for (const u of c) {
        if (u.status === "aborted")
          return Te;
        u.status === "dirty" && t.dirty(), l.add(u.value);
      }
      return { status: t.value, value: l };
    }
    const a = [...n.data.values()].map((c, l) => i._parse(new ti(n, c, n.path, l)));
    return n.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
  }
  min(e, t) {
    return new gc({
      ...this._def,
      minSize: { value: e, message: be.toString(t) }
    });
  }
  max(e, t) {
    return new gc({
      ...this._def,
      maxSize: { value: e, message: be.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
gc.create = (r, e) => new gc({
  valueType: r,
  minSize: null,
  maxSize: null,
  typeName: Ie.ZodSet,
  ...Re(e)
});
class Al extends Fe {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== ae.function)
      return he(t, {
        code: J.invalid_type,
        expected: ae.function,
        received: t.parsedType
      }), Te;
    function n(a, c) {
      return hg({
        data: a,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          ug(),
          Td
        ].filter((l) => !!l),
        issueData: {
          code: J.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(a, c) {
      return hg({
        data: a,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          ug(),
          Td
        ].filter((l) => !!l),
        issueData: {
          code: J.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: t.common.contextualErrorMap }, o = t.data;
    if (this._def.returns instanceof Nu) {
      const a = this;
      return Mr(async function(...c) {
        const l = new ws([]), u = await a._def.args.parseAsync(c, i).catch((f) => {
          throw l.addIssue(n(c, f)), l;
        }), h = await Reflect.apply(o, this, u);
        return await a._def.returns._def.type.parseAsync(h, i).catch((f) => {
          throw l.addIssue(s(h, f)), l;
        });
      });
    } else {
      const a = this;
      return Mr(function(...c) {
        const l = a._def.args.safeParse(c, i);
        if (!l.success)
          throw new ws([n(c, l.error)]);
        const u = Reflect.apply(o, this, l.data), h = a._def.returns.safeParse(u, i);
        if (!h.success)
          throw new ws([s(u, h.error)]);
        return h.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Al({
      ...this._def,
      args: ri.create(e).rest(nc.create())
    });
  }
  returns(e) {
    return new Al({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, n) {
    return new Al({
      args: e || ri.create([]).rest(nc.create()),
      returns: t || nc.create(),
      typeName: Ie.ZodFunction,
      ...Re(n)
    });
  }
}
class Bd extends Fe {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
Bd.create = (r, e) => new Bd({
  getter: r,
  typeName: Ie.ZodLazy,
  ...Re(e)
});
class Ld extends Fe {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return he(t, {
        received: t.data,
        code: J.invalid_literal,
        expected: this._def.value
      }), Te;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Ld.create = (r, e) => new Ld({
  value: r,
  typeName: Ie.ZodLiteral,
  ...Re(e)
});
function ES(r, e) {
  return new Yo({
    values: r,
    typeName: Ie.ZodEnum,
    ...Re(e)
  });
}
class Yo extends Fe {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return he(t, {
        expected: Xe.joinValues(n),
        received: t.parsedType,
        code: J.invalid_type
      }), Te;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return he(t, {
        received: t.data,
        code: J.invalid_enum_value,
        options: n
      }), Te;
    }
    return Mr(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e) {
    return Yo.create(e);
  }
  exclude(e) {
    return Yo.create(this.options.filter((t) => !e.includes(t)));
  }
}
Yo.create = ES;
class Fd extends Fe {
  _parse(e) {
    const t = Xe.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== ae.string && n.parsedType !== ae.number) {
      const s = Xe.objectValues(t);
      return he(n, {
        expected: Xe.joinValues(s),
        received: n.parsedType,
        code: J.invalid_type
      }), Te;
    }
    if (t.indexOf(e.data) === -1) {
      const s = Xe.objectValues(t);
      return he(n, {
        received: n.data,
        code: J.invalid_enum_value,
        options: s
      }), Te;
    }
    return Mr(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Fd.create = (r, e) => new Fd({
  values: r,
  typeName: Ie.ZodNativeEnum,
  ...Re(e)
});
class Nu extends Fe {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== ae.promise && t.common.async === !1)
      return he(t, {
        code: J.invalid_type,
        expected: ae.promise,
        received: t.parsedType
      }), Te;
    const n = t.parsedType === ae.promise ? t.data : Promise.resolve(t.data);
    return Mr(n.then((s) => this._def.type.parseAsync(s, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
}
Nu.create = (r, e) => new Nu({
  type: r,
  typeName: Ie.ZodPromise,
  ...Re(e)
});
class bs extends Fe {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ie.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), s = this._def.effect || null, i = {
      addIssue: (o) => {
        he(n, o), o.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "preprocess") {
      const o = s.transform(n.data, i);
      return n.common.issues.length ? {
        status: "dirty",
        value: n.data
      } : n.common.async ? Promise.resolve(o).then((a) => this._def.schema._parseAsync({
        data: a,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: o,
        path: n.path,
        parent: n
      });
    }
    if (s.type === "refinement") {
      const o = (a) => {
        const c = s.refinement(a, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? Te : (a.status === "dirty" && t.dirty(), o(a.value), { status: t.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => a.status === "aborted" ? Te : (a.status === "dirty" && t.dirty(), o(a.value).then(() => ({ status: t.value, value: a.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!xd(o))
          return o;
        const a = s.transform(o.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => xd(o) ? Promise.resolve(s.transform(o.value, i)).then((a) => ({ status: t.value, value: a })) : o);
    Xe.assertNever(s);
  }
}
bs.create = (r, e, t) => new bs({
  schema: r,
  typeName: Ie.ZodEffects,
  effect: e,
  ...Re(t)
});
bs.createWithPreprocess = (r, e, t) => new bs({
  schema: e,
  effect: { type: "preprocess", transform: r },
  typeName: Ie.ZodEffects,
  ...Re(t)
});
class Li extends Fe {
  _parse(e) {
    return this._getType(e) === ae.undefined ? Mr(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Li.create = (r, e) => new Li({
  innerType: r,
  typeName: Ie.ZodOptional,
  ...Re(e)
});
class mc extends Fe {
  _parse(e) {
    return this._getType(e) === ae.null ? Mr(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
mc.create = (r, e) => new mc({
  innerType: r,
  typeName: Ie.ZodNullable,
  ...Re(e)
});
class $d extends Fe {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let n = t.data;
    return t.parsedType === ae.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
$d.create = (r, e) => new $d({
  innerType: r,
  typeName: Ie.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...Re(e)
});
class mg extends Fe {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return dg(s) ? s.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new ws(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new ws(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
mg.create = (r, e) => new mg({
  innerType: r,
  typeName: Ie.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...Re(e)
});
class wg extends Fe {
  _parse(e) {
    if (this._getType(e) !== ae.nan) {
      const n = this._getOrReturnCtx(e);
      return he(n, {
        code: J.invalid_type,
        expected: ae.nan,
        received: n.parsedType
      }), Te;
    }
    return { status: "valid", value: e.data };
  }
}
wg.create = (r) => new wg({
  typeName: Ie.ZodNaN,
  ...Re(r)
});
const TH = Symbol("zod_brand");
class vS extends Fe {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = t.data;
    return this._def.type._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Of extends Fe {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? Te : i.status === "dirty" ? (t.dirty(), bS(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? Te : s.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, t) {
    return new Of({
      in: e,
      out: t,
      typeName: Ie.ZodPipeline
    });
  }
}
class yg extends Fe {
  _parse(e) {
    const t = this._def.innerType._parse(e);
    return xd(t) && (t.value = Object.freeze(t.value)), t;
  }
}
yg.create = (r, e) => new yg({
  innerType: r,
  typeName: Ie.ZodReadonly,
  ...Re(e)
});
const AS = (r, e = {}, t) => r ? Su.create().superRefine((n, s) => {
  var i, o;
  if (!r(n)) {
    const a = typeof e == "function" ? e(n) : typeof e == "string" ? { message: e } : e, c = (o = (i = a.fatal) !== null && i !== void 0 ? i : t) !== null && o !== void 0 ? o : !0, l = typeof a == "string" ? { message: a } : a;
    s.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : Su.create(), xH = {
  object: Nt.lazycreate
};
var Ie;
(function(r) {
  r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodSymbol = "ZodSymbol", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodCatch = "ZodCatch", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded", r.ZodPipeline = "ZodPipeline", r.ZodReadonly = "ZodReadonly";
})(Ie || (Ie = {}));
const OH = (r, e = {
  message: `Input not instance of ${r.name}`
}) => AS((t) => t instanceof r, e), CS = gs.create, _S = Ko.create, PH = wg.create, RH = Jo.create, IS = Od.create, DH = pc.create, kH = fg.create, UH = Pd.create, BH = Rd.create, LH = Su.create, FH = nc.create, $H = ji.create, MH = pg.create, jH = ys.create, HH = Nt.create, zH = Nt.strictCreate, qH = Dd.create, WH = im.create, VH = kd.create, GH = ri.create, KH = Ud.create, JH = gg.create, YH = gc.create, QH = Al.create, ZH = Bd.create, XH = Ld.create, ez = Yo.create, tz = Fd.create, rz = Nu.create, hA = bs.create, nz = Li.create, sz = mc.create, iz = bs.createWithPreprocess, oz = Of.create, az = () => CS().optional(), cz = () => _S().optional(), lz = () => IS().optional(), uz = {
  string: (r) => gs.create({ ...r, coerce: !0 }),
  number: (r) => Ko.create({ ...r, coerce: !0 }),
  boolean: (r) => Od.create({
    ...r,
    coerce: !0
  }),
  bigint: (r) => Jo.create({ ...r, coerce: !0 }),
  date: (r) => pc.create({ ...r, coerce: !0 })
}, hz = Te;
var v = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Td,
  setErrorMap: gH,
  getErrorMap: ug,
  makeIssue: hg,
  EMPTY_PATH: mH,
  addIssueToContext: he,
  ParseStatus: Nr,
  INVALID: Te,
  DIRTY: bS,
  OK: Mr,
  isAborted: qy,
  isDirty: Wy,
  isValid: xd,
  isAsync: dg,
  get util() {
    return Xe;
  },
  get objectUtil() {
    return zy;
  },
  ZodParsedType: ae,
  getParsedType: yo,
  ZodType: Fe,
  ZodString: gs,
  ZodNumber: Ko,
  ZodBigInt: Jo,
  ZodBoolean: Od,
  ZodDate: pc,
  ZodSymbol: fg,
  ZodUndefined: Pd,
  ZodNull: Rd,
  ZodAny: Su,
  ZodUnknown: nc,
  ZodNever: ji,
  ZodVoid: pg,
  ZodArray: ys,
  ZodObject: Nt,
  ZodUnion: Dd,
  ZodDiscriminatedUnion: im,
  ZodIntersection: kd,
  ZodTuple: ri,
  ZodRecord: Ud,
  ZodMap: gg,
  ZodSet: gc,
  ZodFunction: Al,
  ZodLazy: Bd,
  ZodLiteral: Ld,
  ZodEnum: Yo,
  ZodNativeEnum: Fd,
  ZodPromise: Nu,
  ZodEffects: bs,
  ZodTransformer: bs,
  ZodOptional: Li,
  ZodNullable: mc,
  ZodDefault: $d,
  ZodCatch: mg,
  ZodNaN: wg,
  BRAND: TH,
  ZodBranded: vS,
  ZodPipeline: Of,
  ZodReadonly: yg,
  custom: AS,
  Schema: Fe,
  ZodSchema: Fe,
  late: xH,
  get ZodFirstPartyTypeKind() {
    return Ie;
  },
  coerce: uz,
  any: LH,
  array: jH,
  bigint: RH,
  boolean: IS,
  date: DH,
  discriminatedUnion: WH,
  effect: hA,
  enum: ez,
  function: QH,
  instanceof: OH,
  intersection: VH,
  lazy: ZH,
  literal: XH,
  map: JH,
  nan: PH,
  nativeEnum: tz,
  never: $H,
  null: BH,
  nullable: sz,
  number: _S,
  object: HH,
  oboolean: lz,
  onumber: cz,
  optional: nz,
  ostring: az,
  pipeline: oz,
  preprocess: iz,
  promise: rz,
  record: KH,
  set: YH,
  strictObject: zH,
  string: CS,
  symbol: kH,
  transformer: hA,
  tuple: GH,
  undefined: UH,
  union: qH,
  unknown: FH,
  void: MH,
  NEVER: hz,
  ZodIssueCode: J,
  quotelessJson: pH,
  ZodError: ws
});
const xt = v.object({ message: v.string() });
function ce(r) {
  return v.literal(pe[r]);
}
v.object({
  accessList: v.array(v.string()),
  blockHash: v.string().nullable(),
  blockNumber: v.string().nullable(),
  chainId: v.string().or(v.number()),
  from: v.string(),
  gas: v.string(),
  hash: v.string(),
  input: v.string().nullable(),
  maxFeePerGas: v.string(),
  maxPriorityFeePerGas: v.string(),
  nonce: v.string(),
  r: v.string(),
  s: v.string(),
  to: v.string(),
  transactionIndex: v.string().nullable(),
  type: v.string(),
  v: v.string(),
  value: v.string()
});
const dz = v.object({ chainId: v.string().or(v.number()) }), fz = v.object({ email: v.string().email() }), pz = v.object({ otp: v.string() }), gz = v.object({
  uri: v.string(),
  preferredAccountType: v.optional(v.string()),
  chainId: v.optional(v.string().or(v.number()))
}), mz = v.object({
  chainId: v.optional(v.string().or(v.number())),
  preferredAccountType: v.optional(v.string()),
  socialUri: v.optional(v.string())
}), wz = v.object({
  provider: v.enum(["google", "github", "apple", "facebook", "x", "discord"])
}), yz = v.object({ email: v.string().email() }), bz = v.object({ otp: v.string() }), Ez = v.object({ otp: v.string() }), vz = v.object({
  themeMode: v.optional(v.enum(["light", "dark"])),
  themeVariables: v.optional(v.record(v.string(), v.string().or(v.number()))),
  w3mThemeVariables: v.optional(v.record(v.string(), v.string()))
}), Az = v.object({
  metadata: v.object({
    name: v.string(),
    description: v.string(),
    url: v.string(),
    icons: v.array(v.string())
  }).optional(),
  sdkVersion: v.string().optional(),
  sdkType: v.string().optional(),
  projectId: v.string()
}), Cz = v.object({ type: v.string() }), _z = v.object({
  action: v.enum(["VERIFY_DEVICE", "VERIFY_OTP", "CONNECT"])
}), Iz = v.object({
  url: v.string()
}), Sz = v.object({
  userName: v.string()
}), Nz = v.object({
  email: v.string().optional().nullable(),
  address: v.string(),
  chainId: v.string().or(v.number()),
  accounts: v.array(v.object({
    address: v.string(),
    type: v.enum([
      rr.ACCOUNT_TYPES.EOA,
      rr.ACCOUNT_TYPES.SMART_ACCOUNT
    ])
  })).optional(),
  userName: v.string().optional().nullable(),
  preferredAccountType: v.optional(v.string())
}), Tz = v.object({
  action: v.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"])
}), xz = v.object({
  email: v.string().email().optional().nullable(),
  address: v.string(),
  chainId: v.string().or(v.number()),
  smartAccountDeployed: v.optional(v.boolean()),
  accounts: v.array(v.object({
    address: v.string(),
    type: v.enum([
      rr.ACCOUNT_TYPES.EOA,
      rr.ACCOUNT_TYPES.SMART_ACCOUNT
    ])
  })).optional(),
  preferredAccountType: v.optional(v.string())
}), Oz = v.object({ uri: v.string() }), Pz = v.object({ isConnected: v.boolean() }), Rz = v.object({ chainId: v.string().or(v.number()) }), Dz = v.object({ chainId: v.string().or(v.number()) }), kz = v.object({ newEmail: v.string().email() }), Uz = v.object({
  smartAccountEnabledNetworks: v.array(v.number())
});
v.object({
  address: v.string(),
  isDeployed: v.boolean()
});
const Bz = v.object({
  version: v.string().optional()
}), Lz = v.object({ type: v.string(), address: v.string() }), Fz = v.any(), $z = v.object({
  method: v.literal("eth_accounts")
}), Mz = v.object({
  method: v.literal("eth_blockNumber")
}), jz = v.object({
  method: v.literal("eth_call"),
  params: v.array(v.any())
}), Hz = v.object({
  method: v.literal("eth_chainId")
}), zz = v.object({
  method: v.literal("eth_estimateGas"),
  params: v.array(v.any())
}), qz = v.object({
  method: v.literal("eth_feeHistory"),
  params: v.array(v.any())
}), Wz = v.object({
  method: v.literal("eth_gasPrice")
}), Vz = v.object({
  method: v.literal("eth_getAccount"),
  params: v.array(v.any())
}), Gz = v.object({
  method: v.literal("eth_getBalance"),
  params: v.array(v.any())
}), Kz = v.object({
  method: v.literal("eth_getBlockByHash"),
  params: v.array(v.any())
}), Jz = v.object({
  method: v.literal("eth_getBlockByNumber"),
  params: v.array(v.any())
}), Yz = v.object({
  method: v.literal("eth_getBlockReceipts"),
  params: v.array(v.any())
}), Qz = v.object({
  method: v.literal("eth_getBlockTransactionCountByHash"),
  params: v.array(v.any())
}), Zz = v.object({
  method: v.literal("eth_getBlockTransactionCountByNumber"),
  params: v.array(v.any())
}), Xz = v.object({
  method: v.literal("eth_getCode"),
  params: v.array(v.any())
}), eq = v.object({
  method: v.literal("eth_getFilterChanges"),
  params: v.array(v.any())
}), tq = v.object({
  method: v.literal("eth_getFilterLogs"),
  params: v.array(v.any())
}), rq = v.object({
  method: v.literal("eth_getLogs"),
  params: v.array(v.any())
}), nq = v.object({
  method: v.literal("eth_getProof"),
  params: v.array(v.any())
}), sq = v.object({
  method: v.literal("eth_getStorageAt"),
  params: v.array(v.any())
}), iq = v.object({
  method: v.literal("eth_getTransactionByBlockHashAndIndex"),
  params: v.array(v.any())
}), oq = v.object({
  method: v.literal("eth_getTransactionByBlockNumberAndIndex"),
  params: v.array(v.any())
}), aq = v.object({
  method: v.literal("eth_getTransactionByHash"),
  params: v.array(v.any())
}), cq = v.object({
  method: v.literal("eth_getTransactionCount"),
  params: v.array(v.any())
}), lq = v.object({
  method: v.literal("eth_getTransactionReceipt"),
  params: v.array(v.any())
}), uq = v.object({
  method: v.literal("eth_getUncleCountByBlockHash"),
  params: v.array(v.any())
}), hq = v.object({
  method: v.literal("eth_getUncleCountByBlockNumber"),
  params: v.array(v.any())
}), dq = v.object({
  method: v.literal("eth_maxPriorityFeePerGas")
}), fq = v.object({
  method: v.literal("eth_newBlockFilter")
}), pq = v.object({
  method: v.literal("eth_newFilter"),
  params: v.array(v.any())
}), gq = v.object({
  method: v.literal("eth_newPendingTransactionFilter")
}), mq = v.object({
  method: v.literal("eth_sendRawTransaction"),
  params: v.array(v.any())
}), wq = v.object({
  method: v.literal("eth_syncing"),
  params: v.array(v.any())
}), yq = v.object({
  method: v.literal("eth_uninstallFilter"),
  params: v.array(v.any())
}), dA = v.object({
  method: v.literal("personal_sign"),
  params: v.array(v.any())
}), bq = v.object({
  method: v.literal("eth_signTypedData_v4"),
  params: v.array(v.any())
}), Eq = v.object({
  method: v.literal("eth_sendTransaction"),
  params: v.array(v.any())
}), vq = v.object({
  method: v.literal("solana_signMessage"),
  params: v.object({
    message: v.string(),
    pubkey: v.string()
  })
}), Aq = v.object({
  method: v.literal("solana_signTransaction"),
  params: v.object({
    transaction: v.string()
  })
}), Cq = v.object({
  method: v.literal("solana_signAllTransactions"),
  params: v.object({
    transactions: v.array(v.string())
  })
}), _q = v.object({
  method: v.literal("solana_signAndSendTransaction"),
  params: v.object({
    transaction: v.string(),
    options: v.object({
      skipPreflight: v.boolean().optional(),
      preflightCommitment: v.enum([
        "processed",
        "confirmed",
        "finalized",
        "recent",
        "single",
        "singleGossip",
        "root",
        "max"
      ]).optional(),
      maxRetries: v.number().optional(),
      minContextSlot: v.number().optional()
    }).optional()
  })
}), Iq = v.object({
  method: v.literal("wallet_sendCalls"),
  params: v.array(v.object({
    chainId: v.string().or(v.number()).optional(),
    from: v.string().optional(),
    version: v.string().optional(),
    capabilities: v.any().optional(),
    calls: v.array(v.object({
      to: v.string().startsWith("0x"),
      data: v.string().startsWith("0x").optional(),
      value: v.string().optional()
    }))
  }))
}), Sq = v.object({
  method: v.literal("wallet_getCallsStatus"),
  params: v.array(v.string())
}), Nq = v.object({
  method: v.literal("wallet_getCapabilities")
}), Tq = v.object({
  method: v.literal("wallet_grantPermissions"),
  params: v.array(v.any())
}), xq = v.object({
  method: v.literal("wallet_revokePermissions"),
  params: v.any()
}), Oq = v.object({
  method: v.literal("wallet_getAssets"),
  params: v.any()
}), fA = v.object({
  token: v.string()
}), le = v.object({
  id: v.string().optional()
}), gh = {
  appEvent: le.extend({
    type: ce("APP_SWITCH_NETWORK"),
    payload: dz
  }).or(le.extend({
    type: ce("APP_CONNECT_EMAIL"),
    payload: fz
  })).or(le.extend({ type: ce("APP_CONNECT_DEVICE") })).or(le.extend({ type: ce("APP_CONNECT_OTP"), payload: pz })).or(le.extend({
    type: ce("APP_CONNECT_SOCIAL"),
    payload: gz
  })).or(le.extend({ type: ce("APP_GET_FARCASTER_URI") })).or(le.extend({ type: ce("APP_CONNECT_FARCASTER") })).or(le.extend({
    type: ce("APP_GET_USER"),
    payload: v.optional(mz)
  })).or(le.extend({
    type: ce("APP_GET_SOCIAL_REDIRECT_URI"),
    payload: wz
  })).or(le.extend({ type: ce("APP_SIGN_OUT") })).or(le.extend({
    type: ce("APP_IS_CONNECTED"),
    payload: v.optional(fA)
  })).or(le.extend({ type: ce("APP_GET_CHAIN_ID") })).or(le.extend({ type: ce("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })).or(le.extend({ type: ce("APP_INIT_SMART_ACCOUNT") })).or(le.extend({
    type: ce("APP_SET_PREFERRED_ACCOUNT"),
    payload: Cz
  })).or(le.extend({
    type: ce("APP_RPC_REQUEST"),
    payload: dA.or(Oq).or($z).or(Mz).or(jz).or(Hz).or(zz).or(qz).or(Wz).or(Vz).or(Gz).or(Kz).or(Jz).or(Yz).or(Qz).or(Zz).or(Xz).or(eq).or(tq).or(rq).or(nq).or(sq).or(iq).or(oq).or(aq).or(cq).or(lq).or(uq).or(hq).or(dq).or(fq).or(pq).or(gq).or(mq).or(wq).or(yq).or(dA).or(bq).or(Eq).or(vq).or(Aq).or(Cq).or(_q).or(Sq).or(Iq).or(Nq).or(Tq).or(xq)
  })).or(le.extend({ type: ce("APP_UPDATE_EMAIL"), payload: yz })).or(le.extend({
    type: ce("APP_UPDATE_EMAIL_PRIMARY_OTP"),
    payload: bz
  })).or(le.extend({
    type: ce("APP_UPDATE_EMAIL_SECONDARY_OTP"),
    payload: Ez
  })).or(le.extend({ type: ce("APP_SYNC_THEME"), payload: vz })).or(le.extend({
    type: ce("APP_SYNC_DAPP_DATA"),
    payload: Az
  })).or(le.extend({
    type: ce("APP_RELOAD")
  })),
  frameEvent: le.extend({ type: ce("FRAME_SWITCH_NETWORK_ERROR"), payload: xt }).or(le.extend({
    type: ce("FRAME_SWITCH_NETWORK_SUCCESS"),
    payload: Dz
  })).or(le.extend({
    type: ce("FRAME_CONNECT_EMAIL_SUCCESS"),
    payload: _z
  })).or(le.extend({ type: ce("FRAME_CONNECT_EMAIL_ERROR"), payload: xt })).or(le.extend({
    type: ce("FRAME_GET_FARCASTER_URI_SUCCESS"),
    payload: Iz
  })).or(le.extend({ type: ce("FRAME_GET_FARCASTER_URI_ERROR"), payload: xt })).or(le.extend({
    type: ce("FRAME_CONNECT_FARCASTER_SUCCESS"),
    payload: Sz
  })).or(le.extend({ type: ce("FRAME_CONNECT_FARCASTER_ERROR"), payload: xt })).or(le.extend({ type: ce("FRAME_CONNECT_OTP_ERROR"), payload: xt })).or(le.extend({ type: ce("FRAME_CONNECT_OTP_SUCCESS") })).or(le.extend({ type: ce("FRAME_CONNECT_DEVICE_ERROR"), payload: xt })).or(le.extend({ type: ce("FRAME_CONNECT_DEVICE_SUCCESS") })).or(le.extend({
    type: ce("FRAME_CONNECT_SOCIAL_SUCCESS"),
    payload: Nz
  })).or(le.extend({
    type: ce("FRAME_CONNECT_SOCIAL_ERROR"),
    payload: xt
  })).or(le.extend({ type: ce("FRAME_GET_USER_ERROR"), payload: xt })).or(le.extend({
    type: ce("FRAME_GET_USER_SUCCESS"),
    payload: xz
  })).or(le.extend({
    type: ce("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
    payload: xt
  })).or(le.extend({
    type: ce("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
    payload: Oz
  })).or(le.extend({ type: ce("FRAME_SIGN_OUT_ERROR"), payload: xt })).or(le.extend({ type: ce("FRAME_SIGN_OUT_SUCCESS") })).or(le.extend({ type: ce("FRAME_IS_CONNECTED_ERROR"), payload: xt })).or(le.extend({
    type: ce("FRAME_IS_CONNECTED_SUCCESS"),
    payload: Pz
  })).or(le.extend({ type: ce("FRAME_GET_CHAIN_ID_ERROR"), payload: xt })).or(le.extend({
    type: ce("FRAME_GET_CHAIN_ID_SUCCESS"),
    payload: Rz
  })).or(le.extend({ type: ce("FRAME_RPC_REQUEST_ERROR"), payload: xt })).or(le.extend({ type: ce("FRAME_RPC_REQUEST_SUCCESS"), payload: Fz })).or(le.extend({ type: ce("FRAME_SESSION_UPDATE"), payload: fA })).or(le.extend({ type: ce("FRAME_UPDATE_EMAIL_ERROR"), payload: xt })).or(le.extend({
    type: ce("FRAME_UPDATE_EMAIL_SUCCESS"),
    payload: Tz
  })).or(le.extend({
    type: ce("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
    payload: xt
  })).or(le.extend({ type: ce("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })).or(le.extend({
    type: ce("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
    payload: xt
  })).or(le.extend({
    type: ce("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
    payload: kz
  })).or(le.extend({ type: ce("FRAME_SYNC_THEME_ERROR"), payload: xt })).or(le.extend({ type: ce("FRAME_SYNC_THEME_SUCCESS") })).or(le.extend({ type: ce("FRAME_SYNC_DAPP_DATA_ERROR"), payload: xt })).or(le.extend({ type: ce("FRAME_SYNC_DAPP_DATA_SUCCESS") })).or(le.extend({
    type: ce("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
    payload: Uz
  })).or(le.extend({
    type: ce("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
    payload: xt
  })).or(le.extend({ type: ce("FRAME_INIT_SMART_ACCOUNT_ERROR"), payload: xt })).or(le.extend({
    type: ce("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
    payload: Lz
  })).or(le.extend({
    type: ce("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
    payload: xt
  })).or(le.extend({ type: ce("FRAME_READY"), payload: Bz })).or(le.extend({
    type: ce("FRAME_RELOAD_ERROR"),
    payload: xt
  })).or(le.extend({ type: ce("FRAME_RELOAD_SUCCESS") }))
};
function Aw(r, e = {}) {
  var t;
  return typeof (e == null ? void 0 : e.type) == "string" && ((t = e == null ? void 0 : e.type) == null ? void 0 : t.includes(r));
}
class Pq {
  constructor({ projectId: e, isAppClient: t = !1, chainId: n = "eip155:1", enableLogger: s = !0 }) {
    if (this.iframe = null, this.iframeIsReady = !1, this.rpcUrl = W.BLOCKCHAIN_API_RPC_URL, this.initFrame = () => {
      const i = document.getElementById("w3m-iframe");
      this.iframe && !i && document.body.appendChild(this.iframe);
    }, this.events = {
      registerFrameEventHandler: (i, o, a) => {
        function c({ data: l }) {
          if (!Aw(pe.FRAME_EVENT_KEY, l))
            return;
          const u = gh.frameEvent.parse(l);
          u.id === i && (o(u), window.removeEventListener("message", c));
        }
        Cn.isClient && (window.addEventListener("message", c), a.addEventListener("abort", () => {
          window.removeEventListener("message", c);
        }));
      },
      onFrameEvent: (i) => {
        Cn.isClient && window.addEventListener("message", ({ data: o }) => {
          if (!Aw(pe.FRAME_EVENT_KEY, o))
            return;
          const a = gh.frameEvent.parse(o);
          i(a);
        });
      },
      onAppEvent: (i) => {
        Cn.isClient && window.addEventListener("message", ({ data: o }) => {
          if (!Aw(pe.APP_EVENT_KEY, o))
            return;
          const a = gh.appEvent.parse(o);
          i(a);
        });
      },
      postAppEvent: (i) => {
        var o;
        if (Cn.isClient) {
          if (!((o = this.iframe) != null && o.contentWindow))
            throw new Error("W3mFrame: iframe is not set");
          gh.appEvent.parse(i), this.iframe.contentWindow.postMessage(i, "*");
        }
      },
      postFrameEvent: (i) => {
        if (Cn.isClient) {
          if (!parent)
            throw new Error("W3mFrame: parent is not set");
          gh.frameEvent.parse(i), parent.postMessage(i, "*");
        }
      }
    }, this.projectId = e, this.frameLoadPromise = new Promise((i, o) => {
      this.frameLoadPromiseResolver = { resolve: i, reject: o };
    }), t && (this.frameLoadPromise = new Promise((i, o) => {
      this.frameLoadPromiseResolver = { resolve: i, reject: o };
    }), Cn.isClient)) {
      const i = document.createElement("iframe");
      i.id = "w3m-iframe", i.src = `${_x}?projectId=${e}&chainId=${n}&version=${Sx}&enableLogger=${s}`, i.name = "w3m-secure-iframe", i.style.position = "fixed", i.style.zIndex = "999999", i.style.display = "none", i.style.border = "none", i.style.animationDelay = "0s, 50ms", i.style.borderBottomLeftRadius = "clamp(0px, var(--wui-border-radius-l), 44px)", i.style.borderBottomRightRadius = "clamp(0px, var(--wui-border-radius-l), 44px)", this.iframe = i, this.iframe.onerror = () => {
        var o;
        (o = this.frameLoadPromiseResolver) == null || o.reject("Unable to load email login dependency");
      }, this.events.onFrameEvent((o) => {
        var a;
        o.type === "@w3m-frame/READY" && (this.iframeIsReady = !0, (a = this.frameLoadPromiseResolver) == null || a.resolve(void 0));
      });
    }
  }
  get networks() {
    const e = [
      "eip155:1",
      "eip155:5",
      "eip155:11155111",
      "eip155:10",
      "eip155:420",
      "eip155:42161",
      "eip155:421613",
      "eip155:137",
      "eip155:80001",
      "eip155:42220",
      "eip155:1313161554",
      "eip155:1313161555",
      "eip155:56",
      "eip155:97",
      "eip155:43114",
      "eip155:43113",
      "eip155:324",
      "eip155:280",
      "eip155:100",
      "eip155:8453",
      "eip155:84531",
      "eip155:84532",
      "eip155:7777777",
      "eip155:999",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ].map((t) => ({
      [t]: {
        rpcUrl: `${this.rpcUrl}/v1/?chainId=${t}&projectId=${this.projectId}`,
        chainId: t
      }
    }));
    return Object.assign({}, ...e);
  }
}
class Rq {
  constructor(e) {
    var i;
    const t = Fu({
      level: Ix
    }), { logger: n, chunkLoggerController: s } = j0({
      opts: t
    });
    this.logger = xr(n, this.constructor.name), this.chunkLoggerController = s, typeof window < "u" && ((i = this.chunkLoggerController) != null && i.downloadLogsBlobInBrowser) && (window.downloadAppKitLogsBlob || (window.downloadAppKitLogsBlob = {}), window.downloadAppKitLogsBlob.sdk = () => {
      var o;
      (o = this.chunkLoggerController) != null && o.downloadLogsBlobInBrowser && this.chunkLoggerController.downloadLogsBlobInBrowser({
        projectId: e
      });
    });
  }
}
class Dq {
  constructor({ projectId: e, chainId: t, enableLogger: n = !0, onTimeout: s, abortController: i }) {
    this.openRpcRequests = [], this.isInitialized = !1, n && (this.w3mLogger = new Rq(e)), this.abortController = i, this.w3mFrame = new Pq({ projectId: e, isAppClient: !0, chainId: t, enableLogger: n }), this.onTimeout = s, this.getLoginEmailUsed() && this.createFrame();
  }
  async createFrame() {
    this.w3mFrame.initFrame(), this.initPromise = new Promise((e) => {
      this.w3mFrame.events.onFrameEvent((t) => {
        t.type === pe.FRAME_READY && setTimeout(() => {
          e();
        }, 500);
      });
    }), await this.initPromise, this.isInitialized = !0, this.initPromise = void 0;
  }
  async init() {
    if (!this.isInitialized) {
      if (this.initPromise) {
        await this.initPromise;
        return;
      }
      await this.createFrame();
    }
  }
  getLoginEmailUsed() {
    return !!ar.get(pe.EMAIL_LOGIN_USED_KEY);
  }
  getEmail() {
    return ar.get(pe.EMAIL);
  }
  getUsername() {
    return ar.get(pe.SOCIAL_USERNAME);
  }
  async reload() {
    var e;
    try {
      await this.appEvent({
        type: pe.APP_RELOAD
      });
    } catch (t) {
      throw (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error reloading iframe"), t;
    }
  }
  async connectEmail(e) {
    var t;
    try {
      Cn.checkIfAllowedToTriggerEmail(), await this.init();
      const n = await this.appEvent({
        type: pe.APP_CONNECT_EMAIL,
        payload: e
      });
      return this.setNewLastEmailLoginTime(), n;
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error connecting email"), n;
    }
  }
  async connectDevice() {
    var e;
    try {
      return this.appEvent({
        type: pe.APP_CONNECT_DEVICE
      });
    } catch (t) {
      throw (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error connecting device"), t;
    }
  }
  async connectOtp(e) {
    var t;
    try {
      return this.appEvent({
        type: pe.APP_CONNECT_OTP,
        payload: e
      });
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error connecting otp"), n;
    }
  }
  async isConnected() {
    var e;
    try {
      if (!this.getLoginEmailUsed())
        return { isConnected: !1 };
      const t = await this.appEvent({
        type: pe.APP_IS_CONNECTED
      });
      return t != null && t.isConnected || this.deleteAuthLoginCache(), t;
    } catch (t) {
      throw this.deleteAuthLoginCache(), (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error checking connection"), t;
    }
  }
  async getChainId() {
    var e;
    try {
      const t = await this.appEvent({
        type: pe.APP_GET_CHAIN_ID
      });
      return this.setLastUsedChainId(t.chainId), t;
    } catch (t) {
      throw (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error getting chain id"), t;
    }
  }
  async getSocialRedirectUri(e) {
    var t;
    try {
      return await this.init(), this.appEvent({
        type: pe.APP_GET_SOCIAL_REDIRECT_URI,
        payload: e
      });
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error getting social redirect uri"), n;
    }
  }
  async updateEmail(e) {
    var t;
    try {
      const n = await this.appEvent({
        type: pe.APP_UPDATE_EMAIL,
        payload: e
      });
      return this.setNewLastEmailLoginTime(), n;
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error updating email"), n;
    }
  }
  async updateEmailPrimaryOtp(e) {
    var t;
    try {
      return this.appEvent({
        type: pe.APP_UPDATE_EMAIL_PRIMARY_OTP,
        payload: e
      });
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error updating email primary otp"), n;
    }
  }
  async updateEmailSecondaryOtp(e) {
    var t;
    try {
      const n = await this.appEvent({
        type: pe.APP_UPDATE_EMAIL_SECONDARY_OTP,
        payload: e
      });
      return this.setLoginSuccess(n.newEmail), n;
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error updating email secondary otp"), n;
    }
  }
  async syncTheme(e) {
    var t;
    try {
      return this.appEvent({
        type: pe.APP_SYNC_THEME,
        payload: e
      });
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error syncing theme"), n;
    }
  }
  async syncDappData(e) {
    var t;
    try {
      return this.appEvent({
        type: pe.APP_SYNC_DAPP_DATA,
        payload: e
      });
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error syncing dapp data"), n;
    }
  }
  async getSmartAccountEnabledNetworks() {
    var e;
    try {
      const t = await this.appEvent({
        type: pe.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS
      });
      return this.persistSmartAccountEnabledNetworks(t.smartAccountEnabledNetworks), t;
    } catch (t) {
      throw this.persistSmartAccountEnabledNetworks([]), (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error getting smart account enabled networks"), t;
    }
  }
  async setPreferredAccount(e) {
    var t;
    try {
      return this.appEvent({
        type: pe.APP_SET_PREFERRED_ACCOUNT,
        payload: { type: e }
      });
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error setting preferred account"), n;
    }
  }
  async connect(e) {
    var t, n;
    if (e != null && e.socialUri)
      try {
        await this.init();
        const s = await this.appEvent({
          type: pe.APP_CONNECT_SOCIAL,
          payload: {
            uri: e.socialUri,
            preferredAccountType: e.preferredAccountType,
            chainId: e.chainId
          }
        });
        return s.userName && this.setSocialLoginSuccess(s.userName), this.setLoginSuccess(s.email), this.setLastUsedChainId(s.chainId), this.user = s, s;
      } catch (s) {
        throw (t = this.w3mLogger) == null || t.logger.error({ error: s }, "Error connecting social"), s;
      }
    else
      try {
        const s = (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1, i = await this.getUser({
          chainId: s,
          preferredAccountType: e == null ? void 0 : e.preferredAccountType
        });
        return this.setLoginSuccess(i.email), this.setLastUsedChainId(i.chainId), this.user = i, i;
      } catch (s) {
        throw (n = this.w3mLogger) == null || n.logger.error({ error: s }, "Error connecting"), s;
      }
  }
  async getUser(e) {
    var t;
    try {
      await this.init();
      const n = (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1, s = await this.appEvent({
        type: pe.APP_GET_USER,
        payload: { ...e, chainId: n }
      });
      return this.user = s, s;
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error connecting"), n;
    }
  }
  async connectSocial(e) {
    var t;
    try {
      await this.init();
      const n = await this.appEvent({
        type: pe.APP_CONNECT_SOCIAL,
        payload: { uri: e }
      });
      return n.userName && this.setSocialLoginSuccess(n.userName), n;
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error connecting social"), n;
    }
  }
  async getFarcasterUri() {
    var e;
    try {
      return await this.init(), await this.appEvent({
        type: pe.APP_GET_FARCASTER_URI
      });
    } catch (t) {
      throw (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error getting farcaster uri"), t;
    }
  }
  async connectFarcaster() {
    var e;
    try {
      const t = await this.appEvent({
        type: pe.APP_CONNECT_FARCASTER
      });
      return t.userName && this.setSocialLoginSuccess(t.userName), t;
    } catch (t) {
      throw (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error connecting farcaster"), t;
    }
  }
  async switchNetwork(e) {
    var t;
    try {
      const n = await this.appEvent({
        type: pe.APP_SWITCH_NETWORK,
        payload: { chainId: e }
      });
      return this.setLastUsedChainId(n.chainId), n;
    } catch (n) {
      throw (t = this.w3mLogger) == null || t.logger.error({ error: n }, "Error switching network"), n;
    }
  }
  async disconnect() {
    var e;
    try {
      return this.deleteAuthLoginCache(), await new Promise(async (n) => {
        const s = setTimeout(() => {
          n();
        }, 3e3);
        await this.appEvent({
          type: pe.APP_SIGN_OUT
        }), clearTimeout(s), n();
      });
    } catch (t) {
      throw (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error disconnecting"), t;
    }
  }
  async request(e) {
    var t, n, s, i;
    try {
      if (rr.GET_CHAIN_ID === e.method)
        return this.getLastUsedChainId();
      (t = this.rpcRequestHandler) == null || t.call(this, e);
      const o = await this.appEvent({
        type: pe.APP_RPC_REQUEST,
        payload: e
      });
      return (n = this.rpcSuccessHandler) == null || n.call(this, o, e), o;
    } catch (o) {
      throw (s = this.rpcErrorHandler) == null || s.call(this, o, e), (i = this.w3mLogger) == null || i.logger.error({ error: o }, "Error requesting"), o;
    }
  }
  onRpcRequest(e) {
    this.rpcRequestHandler = e;
  }
  onRpcSuccess(e) {
    this.rpcSuccessHandler = e;
  }
  onRpcError(e) {
    this.rpcErrorHandler = e;
  }
  onIsConnected(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === pe.FRAME_IS_CONNECTED_SUCCESS && t.payload.isConnected && e();
    });
  }
  onNotConnected(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === pe.FRAME_IS_CONNECTED_ERROR && e(), t.type === pe.FRAME_IS_CONNECTED_SUCCESS && !t.payload.isConnected && e();
    });
  }
  onConnect(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === pe.FRAME_GET_USER_SUCCESS && e(t.payload);
    });
  }
  onSocialConnected(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === pe.FRAME_CONNECT_SOCIAL_SUCCESS && e(t.payload);
    });
  }
  async getCapabilities() {
    try {
      return await this.request({
        method: "wallet_getCapabilities"
      }) || {};
    } catch {
      return {};
    }
  }
  onSetPreferredAccount(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === pe.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS ? e(t.payload) : t.type === pe.FRAME_SET_PREFERRED_ACCOUNT_ERROR && e({ type: rr.ACCOUNT_TYPES.EOA });
    });
  }
  onGetSmartAccountEnabledNetworks(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === pe.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS ? e(t.payload.smartAccountEnabledNetworks) : t.type === pe.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR && e([]);
    });
  }
  getAvailableChainIds() {
    return Object.keys(this.w3mFrame.networks);
  }
  rejectRpcRequests() {
    var e;
    try {
      this.openRpcRequests.forEach(({ abortController: t, method: n }) => {
        rr.SAFE_RPC_METHODS.includes(n) || t.abort();
      }), this.openRpcRequests = [];
    } catch (t) {
      (e = this.w3mLogger) == null || e.logger.error({ error: t }, "Error aborting RPC request");
    }
  }
  async appEvent(e) {
    let t, n;
    function s(c) {
      return c.replace("@w3m-app/", "");
    }
    const i = [
      pe.APP_SYNC_DAPP_DATA,
      pe.APP_SYNC_THEME,
      pe.APP_SET_PREFERRED_ACCOUNT
    ], o = s(e.type);
    return !this.w3mFrame.iframeIsReady && !i.includes(e.type) && (n = setTimeout(() => {
      var c;
      (c = this.onTimeout) == null || c.call(this, "iframe_load_failed"), this.abortController.abort();
    }, 2e4)), await this.w3mFrame.frameLoadPromise, clearTimeout(n), [
      pe.APP_CONNECT_EMAIL,
      pe.APP_CONNECT_DEVICE,
      pe.APP_CONNECT_OTP,
      pe.APP_CONNECT_SOCIAL,
      pe.APP_GET_SOCIAL_REDIRECT_URI
    ].map(s).includes(o) && (t = setTimeout(() => {
      var c;
      (c = this.onTimeout) == null || c.call(this, "iframe_request_timeout"), this.abortController.abort();
    }, 12e4)), new Promise((c, l) => {
      var f, g, p;
      const u = Math.random().toString(36).substring(7);
      (p = (f = this.w3mLogger) == null ? void 0 : (g = f.logger).info) == null || p.call(g, { event: e, id: u }, "Sending app event"), this.w3mFrame.events.postAppEvent({ ...e, id: u });
      const h = new AbortController();
      if (o === "RPC_REQUEST") {
        const w = e;
        this.openRpcRequests = [...this.openRpcRequests, { ...w.payload, abortController: h }];
      }
      h.signal.addEventListener("abort", () => {
        o === "RPC_REQUEST" ? l(new Error("Request was aborted")) : o !== "GET_FARCASTER_URI" && l(new Error("Something went wrong"));
      });
      function d(w, E) {
        var I, A, C;
        w.id === u && ((A = E == null ? void 0 : (I = E.logger).info) == null || A.call(I, { framEvent: w, id: u }, "Received frame response"), w.type === `@w3m-frame/${o}_SUCCESS` ? (t && clearTimeout(t), n && clearTimeout(n), "payload" in w && c(w.payload), c(void 0)) : w.type === `@w3m-frame/${o}_ERROR` && (t && clearTimeout(t), n && clearTimeout(n), "payload" in w && l(new Error(((C = w.payload) == null ? void 0 : C.message) || "An error occurred")), l(new Error("An error occurred"))));
      }
      this.w3mFrame.events.registerFrameEventHandler(u, (w) => d(w, this.w3mLogger), this.abortController.signal);
    });
  }
  setNewLastEmailLoginTime() {
    ar.set(pe.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
  }
  setSocialLoginSuccess(e) {
    ar.set(pe.SOCIAL_USERNAME, e);
  }
  setLoginSuccess(e) {
    e && ar.set(pe.EMAIL, e), ar.set(pe.EMAIL_LOGIN_USED_KEY, "true"), ar.delete(pe.LAST_EMAIL_LOGIN_TIME);
  }
  deleteAuthLoginCache() {
    ar.delete(pe.EMAIL_LOGIN_USED_KEY), ar.delete(pe.EMAIL), ar.delete(pe.LAST_USED_CHAIN_KEY), ar.delete(pe.SOCIAL_USERNAME);
  }
  setLastUsedChainId(e) {
    e && ar.set(pe.LAST_USED_CHAIN_KEY, String(e));
  }
  getLastUsedChainId() {
    const e = ar.get(pe.LAST_USED_CHAIN_KEY) ?? void 0, t = Number(e);
    return isNaN(t) ? e : t;
  }
  persistSmartAccountEnabledNetworks(e) {
    ar.set(pe.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(","));
  }
}
class zh {
  // eslint-disable-next-line @typescript-eslint/no-empty-function -- This is a singleton
  constructor() {
  }
  static getInstance({ projectId: e, chainId: t, enableLogger: n, onTimeout: s, abortController: i }) {
    return zh.instance || (zh.instance = new Dq({
      projectId: e,
      chainId: t,
      enableLogger: n,
      onTimeout: s,
      abortController: i
    })), zh.instance;
  }
}
const kq = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "NFTs" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: (typeof process < "u" && typeof process.env < "u" ? process.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN : void 0) || "https://secure.walletconnect.org",
  VIEW_DIRECTION: {
    Next: "next",
    Prev: "prev"
  },
  DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
  ANIMATION_DURATIONS: {
    HeaderText: 120,
    ModalHeight: 150,
    ViewTransition: 150
  }
}, Gy = {
  filterOutDuplicatesByRDNS(r) {
    const e = K.state.enableEIP6963 ? re.state.connectors : [], t = te.getRecentWallets(), n = e.map((a) => {
      var c;
      return (c = a.info) == null ? void 0 : c.rdns;
    }).filter(Boolean), s = t.map((a) => a.rdns).filter(Boolean), i = n.concat(s);
    if (i.includes("io.metamask.mobile") && me.isMobile()) {
      const a = i.indexOf("io.metamask.mobile");
      i[a] = "io.metamask";
    }
    return r.filter((a) => !i.includes(String(a == null ? void 0 : a.rdns)));
  },
  filterOutDuplicatesByIds(r) {
    const e = re.state.connectors.filter((a) => a.type === "ANNOUNCED" || a.type === "INJECTED"), t = te.getRecentWallets(), n = e.map((a) => a.explorerId), s = t.map((a) => a.id), i = n.concat(s);
    return r.filter((a) => !i.includes(a == null ? void 0 : a.id));
  },
  filterOutDuplicateWallets(r) {
    const e = this.filterOutDuplicatesByRDNS(r);
    return this.filterOutDuplicatesByIds(e);
  },
  markWalletsAsInstalled(r) {
    const { connectors: e } = re.state, { featuredWalletIds: t } = K.state, n = e.filter((o) => o.type === "ANNOUNCED").reduce((o, a) => {
      var c;
      return (c = a.info) != null && c.rdns && (o[a.info.rdns] = !0), o;
    }, {});
    return r.map((o) => ({
      ...o,
      installed: !!o.rdns && !!n[o.rdns ?? ""]
    })).sort((o, a) => {
      const c = Number(a.installed) - Number(o.installed);
      if (c !== 0)
        return c;
      if (t != null && t.length) {
        const l = t.indexOf(o.id), u = t.indexOf(a.id);
        if (l !== -1 && u !== -1)
          return l - u;
        if (l !== -1)
          return -1;
        if (u !== -1)
          return 1;
      }
      return 0;
    });
  },
  getConnectOrderMethod(r, e) {
    var c;
    const t = (r == null ? void 0 : r.connectMethodsOrder) || ((c = K.state.features) == null ? void 0 : c.connectMethodsOrder), n = e || re.state.connectors;
    if (t)
      return t;
    const { injected: s, announced: i } = Rp.getConnectorsByType(n, ye.state.recommended, ye.state.featured), o = s.filter(Rp.showConnector), a = i.filter(Rp.showConnector);
    return o.length || a.length ? ["wallet", "email", "social"] : kq.DEFAULT_CONNECT_METHOD_ORDER;
  },
  isExcluded(r) {
    const e = !!r.rdns && ye.state.excludedWallets.some((n) => n.rdns === r.rdns), t = !!r.name && ye.state.excludedWallets.some((n) => Nd.isLowerCaseMatch(n.name, r.name));
    return e || t;
  }
}, Rp = {
  getConnectorsByType(r, e, t) {
    const { customWallets: n } = K.state, s = te.getRecentWallets(), i = Gy.filterOutDuplicateWallets(e), o = Gy.filterOutDuplicateWallets(t), a = r.filter((h) => h.type === "MULTI_CHAIN"), c = r.filter((h) => h.type === "ANNOUNCED"), l = r.filter((h) => h.type === "INJECTED"), u = r.filter((h) => h.type === "EXTERNAL");
    return {
      custom: n,
      recent: s,
      external: u,
      multiChain: a,
      announced: c,
      injected: l,
      recommended: i,
      featured: o
    };
  },
  showConnector(r) {
    var s;
    const e = (s = r.info) == null ? void 0 : s.rdns, t = !!e && ye.state.excludedWallets.some((i) => !!i.rdns && i.rdns === e), n = !!r.name && ye.state.excludedWallets.some((i) => Nd.isLowerCaseMatch(i.name, r.name));
    return !(r.type === "INJECTED" && (r.name === "Browser Wallet" && (!me.isMobile() || me.isMobile() && !e && !ue.checkInstalled()) || t || n) || (r.type === "ANNOUNCED" || r.type === "EXTERNAL") && (t || n));
  },
  getIsConnectedWithWC() {
    return Array.from(_.state.chains.values()).some((t) => re.getConnectorId(t.namespace) === W.CONNECTOR_ID.WALLET_CONNECT);
  },
  getConnectorTypeOrder({ recommended: r, featured: e, custom: t, recent: n, announced: s, injected: i, multiChain: o, external: a, overriddenConnectors: c = ((l) => (l = K.state.features) == null ? void 0 : l.connectorTypeOrder)() ?? [] }) {
    const u = Rp.getIsConnectedWithWC(), f = [
      { type: "walletConnect", isEnabled: K.state.enableWalletConnect && !u },
      { type: "recent", isEnabled: n.length > 0 },
      { type: "injected", isEnabled: [...i, ...s, ...o].length > 0 },
      { type: "featured", isEnabled: e.length > 0 },
      { type: "custom", isEnabled: t && t.length > 0 },
      { type: "external", isEnabled: a.length > 0 },
      { type: "recommended", isEnabled: r.length > 0 }
    ].filter((E) => E.isEnabled), g = new Set(f.map((E) => E.type)), p = c.filter((E) => g.has(E)).map((E) => ({ type: E, isEnabled: !0 })), w = f.filter(({ type: E }) => !p.some(({ type: A }) => A === E));
    return Array.from(new Set([...p, ...w].map(({ type: E }) => E)));
  },
  getAuthName({ email: r, socialUsername: e, socialProvider: t }) {
    return e ? t && t === "discord" && e.endsWith("0") ? e.slice(0, -1) : e : r.length > 30 ? `${r.slice(0, -3)}...` : r;
  },
  async fetchProviderData(r) {
    var e, t;
    try {
      if (r.name === "Browser Wallet" && !me.isMobile())
        return { accounts: [], chainId: void 0 };
      if (r.id === W.CONNECTOR_ID.AUTH)
        return { accounts: [], chainId: void 0 };
      const [n, s] = await Promise.all([
        (e = r.provider) == null ? void 0 : e.request({ method: "eth_accounts" }),
        (t = r.provider) == null ? void 0 : t.request({ method: "eth_chainId" }).then((i) => Number(i))
      ]);
      return { accounts: n, chainId: s };
    } catch (n) {
      return console.warn(`Failed to fetch provider data for ${r.name}`, n), { accounts: [], chainId: void 0 };
    }
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Dp = globalThis, vb = Dp.ShadowRoot && (Dp.ShadyCSS === void 0 || Dp.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Ab = Symbol(), pA = /* @__PURE__ */ new WeakMap();
let SS = class {
  constructor(e, t, n) {
    if (this._$cssResult$ = !0, n !== Ab) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (vb && e === void 0) {
      const n = t !== void 0 && t.length === 1;
      n && (e = pA.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), n && pA.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const kn = (r) => new SS(typeof r == "string" ? r : r + "", void 0, Ab), Cl = (r, ...e) => {
  const t = r.length === 1 ? r[0] : e.reduce((n, s, i) => n + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + r[i + 1], r[0]);
  return new SS(t, r, Ab);
}, Uq = (r, e) => {
  if (vb) r.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else for (const t of e) {
    const n = document.createElement("style"), s = Dp.litNonce;
    s !== void 0 && n.setAttribute("nonce", s), n.textContent = t.cssText, r.appendChild(n);
  }
}, gA = vb ? (r) => r : (r) => r instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const n of e.cssRules) t += n.cssText;
  return kn(t);
})(r) : r;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Bq, defineProperty: Lq, getOwnPropertyDescriptor: Fq, getOwnPropertyNames: $q, getOwnPropertySymbols: Mq, getPrototypeOf: jq } = Object, Ho = globalThis, mA = Ho.trustedTypes, Hq = mA ? mA.emptyScript : "", Cw = Ho.reactiveElementPolyfillSupport, qh = (r, e) => r, Ky = { toAttribute(r, e) {
  switch (e) {
    case Boolean:
      r = r ? Hq : null;
      break;
    case Object:
    case Array:
      r = r == null ? r : JSON.stringify(r);
  }
  return r;
}, fromAttribute(r, e) {
  let t = r;
  switch (e) {
    case Boolean:
      t = r !== null;
      break;
    case Number:
      t = r === null ? null : Number(r);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(r);
      } catch {
        t = null;
      }
  }
  return t;
} }, NS = (r, e) => !Bq(r, e), wA = { attribute: !0, type: String, converter: Ky, reflect: !1, useDefault: !1, hasChanged: NS };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Ho.litPropertyMetadata ?? (Ho.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let cl = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = wA) {
    if (t.state && (t.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(e) && ((t = Object.create(t)).wrapped = !0), this.elementProperties.set(e, t), !t.noAccessor) {
      const n = Symbol(), s = this.getPropertyDescriptor(e, n, t);
      s !== void 0 && Lq(this.prototype, e, s);
    }
  }
  static getPropertyDescriptor(e, t, n) {
    const { get: s, set: i } = Fq(this.prototype, e) ?? { get() {
      return this[t];
    }, set(o) {
      this[t] = o;
    } };
    return { get: s, set(o) {
      const a = s == null ? void 0 : s.call(this);
      i == null || i.call(this, o), this.requestUpdate(e, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? wA;
  }
  static _$Ei() {
    if (this.hasOwnProperty(qh("elementProperties"))) return;
    const e = jq(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(qh("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(qh("properties"))) {
      const t = this.properties, n = [...$q(t), ...Mq(t)];
      for (const s of n) this.createProperty(s, t[s]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0) for (const [n, s] of t) this.elementProperties.set(n, s);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, n] of this.elementProperties) {
      const s = this._$Eu(t, n);
      s !== void 0 && this._$Eh.set(s, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const s of n) t.unshift(gA(s));
    } else e !== void 0 && t.push(gA(e));
    return t;
  }
  static _$Eu(e, t) {
    const n = t.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$ES = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$EO) == null || t.delete(e);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const n of t.keys()) this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Uq(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach((t) => {
      var n;
      return (n = t.hostConnected) == null ? void 0 : n.call(t);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null || e.forEach((t) => {
      var n;
      return (n = t.hostDisconnected) == null ? void 0 : n.call(t);
    });
  }
  attributeChangedCallback(e, t, n) {
    this._$AK(e, n);
  }
  _$ET(e, t) {
    var i;
    const n = this.constructor.elementProperties.get(e), s = this.constructor._$Eu(e, n);
    if (s !== void 0 && n.reflect === !0) {
      const o = (((i = n.converter) == null ? void 0 : i.toAttribute) !== void 0 ? n.converter : Ky).toAttribute(t, n.type);
      this._$Em = e, o == null ? this.removeAttribute(s) : this.setAttribute(s, o), this._$Em = null;
    }
  }
  _$AK(e, t) {
    var i, o;
    const n = this.constructor, s = n._$Eh.get(e);
    if (s !== void 0 && this._$Em !== s) {
      const a = n.getPropertyOptions(s), c = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((i = a.converter) == null ? void 0 : i.fromAttribute) !== void 0 ? a.converter : Ky;
      this._$Em = s, this[s] = c.fromAttribute(t, a.type) ?? ((o = this._$Ej) == null ? void 0 : o.get(s)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(e, t, n) {
    var s;
    if (e !== void 0) {
      const i = this.constructor, o = this[e];
      if (n ?? (n = i.getPropertyOptions(e)), !((n.hasChanged ?? NS)(o, t) || n.useDefault && n.reflect && o === ((s = this._$Ej) == null ? void 0 : s.get(e)) && !this.hasAttribute(i._$Eu(e, n)))) return;
      this.C(e, t, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(e, t, { useDefault: n, reflect: s, wrapped: i }, o) {
    n && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(e) && (this._$Ej.set(e, o ?? t ?? this[e]), i !== !0 || o !== void 0) || (this._$AL.has(e) || (this.hasUpdated || n || (t = void 0), this._$AL.set(e, t)), s === !0 && this._$Em !== e && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(e));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [i, o] of this._$Ep) this[i] = o;
        this._$Ep = void 0;
      }
      const s = this.constructor.elementProperties;
      if (s.size > 0) for (const [i, o] of s) {
        const { wrapped: a } = o, c = this[i];
        a !== !0 || this._$AL.has(i) || c === void 0 || this.C(i, void 0, o, c);
      }
    }
    let e = !1;
    const t = this._$AL;
    try {
      e = this.shouldUpdate(t), e ? (this.willUpdate(t), (n = this._$EO) == null || n.forEach((s) => {
        var i;
        return (i = s.hostUpdate) == null ? void 0 : i.call(s);
      }), this.update(t)) : this._$EM();
    } catch (s) {
      throw e = !1, this._$EM(), s;
    }
    e && this._$AE(t);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var t;
    (t = this._$EO) == null || t.forEach((n) => {
      var s;
      return (s = n.hostUpdated) == null ? void 0 : s.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((t) => this._$ET(t, this[t]))), this._$EM();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
cl.elementStyles = [], cl.shadowRootOptions = { mode: "open" }, cl[qh("elementProperties")] = /* @__PURE__ */ new Map(), cl[qh("finalized")] = /* @__PURE__ */ new Map(), Cw == null || Cw({ ReactiveElement: cl }), (Ho.reactiveElementVersions ?? (Ho.reactiveElementVersions = [])).push("2.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Wh = globalThis, bg = Wh.trustedTypes, yA = bg ? bg.createPolicy("lit-html", { createHTML: (r) => r }) : void 0, TS = "$lit$", bo = `lit$${Math.random().toFixed(9).slice(2)}$`, xS = "?" + bo, zq = `<${xS}>`, wc = document, Md = () => wc.createComment(""), jd = (r) => r === null || typeof r != "object" && typeof r != "function", Cb = Array.isArray, qq = (r) => Cb(r) || typeof (r == null ? void 0 : r[Symbol.iterator]) == "function", _w = `[ 	
\f\r]`, mh = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, bA = /-->/g, EA = />/g, la = RegExp(`>|${_w}(?:([^\\s"'>=/]+)(${_w}*=${_w}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), vA = /'/g, AA = /"/g, OS = /^(?:script|style|textarea|title)$/i, PS = (r) => (e, ...t) => ({ _$litType$: r, strings: e, values: t }), KY = PS(1), JY = PS(2), Tu = Symbol.for("lit-noChange"), Xt = Symbol.for("lit-nothing"), CA = /* @__PURE__ */ new WeakMap(), xa = wc.createTreeWalker(wc, 129);
function RS(r, e) {
  if (!Cb(r) || !r.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return yA !== void 0 ? yA.createHTML(e) : e;
}
const Wq = (r, e) => {
  const t = r.length - 1, n = [];
  let s, i = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", o = mh;
  for (let a = 0; a < t; a++) {
    const c = r[a];
    let l, u, h = -1, d = 0;
    for (; d < c.length && (o.lastIndex = d, u = o.exec(c), u !== null); ) d = o.lastIndex, o === mh ? u[1] === "!--" ? o = bA : u[1] !== void 0 ? o = EA : u[2] !== void 0 ? (OS.test(u[2]) && (s = RegExp("</" + u[2], "g")), o = la) : u[3] !== void 0 && (o = la) : o === la ? u[0] === ">" ? (o = s ?? mh, h = -1) : u[1] === void 0 ? h = -2 : (h = o.lastIndex - u[2].length, l = u[1], o = u[3] === void 0 ? la : u[3] === '"' ? AA : vA) : o === AA || o === vA ? o = la : o === bA || o === EA ? o = mh : (o = la, s = void 0);
    const f = o === la && r[a + 1].startsWith("/>") ? " " : "";
    i += o === mh ? c + zq : h >= 0 ? (n.push(l), c.slice(0, h) + TS + c.slice(h) + bo + f) : c + bo + (h === -2 ? a : f);
  }
  return [RS(r, i + (r[t] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), n];
};
class Hd {
  constructor({ strings: e, _$litType$: t }, n) {
    let s;
    this.parts = [];
    let i = 0, o = 0;
    const a = e.length - 1, c = this.parts, [l, u] = Wq(e, t);
    if (this.el = Hd.createElement(l, n), xa.currentNode = this.el.content, t === 2 || t === 3) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (s = xa.nextNode()) !== null && c.length < a; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes()) for (const h of s.getAttributeNames()) if (h.endsWith(TS)) {
          const d = u[o++], f = s.getAttribute(h).split(bo), g = /([.?@])?(.*)/.exec(d);
          c.push({ type: 1, index: i, name: g[2], strings: f, ctor: g[1] === "." ? Gq : g[1] === "?" ? Kq : g[1] === "@" ? Jq : om }), s.removeAttribute(h);
        } else h.startsWith(bo) && (c.push({ type: 6, index: i }), s.removeAttribute(h));
        if (OS.test(s.tagName)) {
          const h = s.textContent.split(bo), d = h.length - 1;
          if (d > 0) {
            s.textContent = bg ? bg.emptyScript : "";
            for (let f = 0; f < d; f++) s.append(h[f], Md()), xa.nextNode(), c.push({ type: 2, index: ++i });
            s.append(h[d], Md());
          }
        }
      } else if (s.nodeType === 8) if (s.data === xS) c.push({ type: 2, index: i });
      else {
        let h = -1;
        for (; (h = s.data.indexOf(bo, h + 1)) !== -1; ) c.push({ type: 7, index: i }), h += bo.length - 1;
      }
      i++;
    }
  }
  static createElement(e, t) {
    const n = wc.createElement("template");
    return n.innerHTML = e, n;
  }
}
function xu(r, e, t = r, n) {
  var o, a;
  if (e === Tu) return e;
  let s = n !== void 0 ? (o = t._$Co) == null ? void 0 : o[n] : t._$Cl;
  const i = jd(e) ? void 0 : e._$litDirective$;
  return (s == null ? void 0 : s.constructor) !== i && ((a = s == null ? void 0 : s._$AO) == null || a.call(s, !1), i === void 0 ? s = void 0 : (s = new i(r), s._$AT(r, t, n)), n !== void 0 ? (t._$Co ?? (t._$Co = []))[n] = s : t._$Cl = s), s !== void 0 && (e = xu(r, s._$AS(r, e.values), s, n)), e;
}
class Vq {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: n } = this._$AD, s = ((e == null ? void 0 : e.creationScope) ?? wc).importNode(t, !0);
    xa.currentNode = s;
    let i = xa.nextNode(), o = 0, a = 0, c = n[0];
    for (; c !== void 0; ) {
      if (o === c.index) {
        let l;
        c.type === 2 ? l = new Pf(i, i.nextSibling, this, e) : c.type === 1 ? l = new c.ctor(i, c.name, c.strings, this, e) : c.type === 6 && (l = new Yq(i, this, e)), this._$AV.push(l), c = n[++a];
      }
      o !== (c == null ? void 0 : c.index) && (i = xa.nextNode(), o++);
    }
    return xa.currentNode = wc, s;
  }
  p(e) {
    let t = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(e, n, t), t += n.strings.length - 2) : n._$AI(e[t])), t++;
  }
}
class Pf {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, t, n, s) {
    this.type = 2, this._$AH = Xt, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = n, this.options = s, this._$Cv = (s == null ? void 0 : s.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = xu(this, e, t), jd(e) ? e === Xt || e == null || e === "" ? (this._$AH !== Xt && this._$AR(), this._$AH = Xt) : e !== this._$AH && e !== Tu && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : qq(e) ? this.k(e) : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
  }
  _(e) {
    this._$AH !== Xt && jd(this._$AH) ? this._$AA.nextSibling.data = e : this.T(wc.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    var i;
    const { values: t, _$litType$: n } = e, s = typeof n == "number" ? this._$AC(e) : (n.el === void 0 && (n.el = Hd.createElement(RS(n.h, n.h[0]), this.options)), n);
    if (((i = this._$AH) == null ? void 0 : i._$AD) === s) this._$AH.p(t);
    else {
      const o = new Vq(s, this), a = o.u(this.options);
      o.p(t), this.T(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let t = CA.get(e.strings);
    return t === void 0 && CA.set(e.strings, t = new Hd(e)), t;
  }
  k(e) {
    Cb(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let n, s = 0;
    for (const i of e) s === t.length ? t.push(n = new Pf(this.O(Md()), this.O(Md()), this, this.options)) : n = t[s], n._$AI(i), s++;
    s < t.length && (this._$AR(n && n._$AB.nextSibling, s), t.length = s);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, t); e && e !== this._$AB; ) {
      const s = e.nextSibling;
      e.remove(), e = s;
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 && (this._$Cv = e, (t = this._$AP) == null || t.call(this, e));
  }
}
class om {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, n, s, i) {
    this.type = 1, this._$AH = Xt, this._$AN = void 0, this.element = e, this.name = t, this._$AM = s, this.options = i, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = Xt;
  }
  _$AI(e, t = this, n, s) {
    const i = this.strings;
    let o = !1;
    if (i === void 0) e = xu(this, e, t, 0), o = !jd(e) || e !== this._$AH && e !== Tu, o && (this._$AH = e);
    else {
      const a = e;
      let c, l;
      for (e = i[0], c = 0; c < i.length - 1; c++) l = xu(this, a[n + c], t, c), l === Tu && (l = this._$AH[c]), o || (o = !jd(l) || l !== this._$AH[c]), l === Xt ? e = Xt : e !== Xt && (e += (l ?? "") + i[c + 1]), this._$AH[c] = l;
    }
    o && !s && this.j(e);
  }
  j(e) {
    e === Xt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}
class Gq extends om {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === Xt ? void 0 : e;
  }
}
class Kq extends om {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== Xt);
  }
}
class Jq extends om {
  constructor(e, t, n, s, i) {
    super(e, t, n, s, i), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = xu(this, e, t, 0) ?? Xt) === Tu) return;
    const n = this._$AH, s = e === Xt && n !== Xt || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive, i = e !== Xt && (n === Xt || s);
    s && this.element.removeEventListener(this.name, this, n), i && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var t;
    typeof this._$AH == "function" ? this._$AH.call(((t = this.options) == null ? void 0 : t.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}
class Yq {
  constructor(e, t, n) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    xu(this, e);
  }
}
const Iw = Wh.litHtmlPolyfillSupport;
Iw == null || Iw(Hd, Pf), (Wh.litHtmlVersions ?? (Wh.litHtmlVersions = [])).push("3.3.0");
const Qq = (r, e, t) => {
  const n = (t == null ? void 0 : t.renderBefore) ?? e;
  let s = n._$litPart$;
  if (s === void 0) {
    const i = (t == null ? void 0 : t.renderBefore) ?? null;
    n._$litPart$ = s = new Pf(e.insertBefore(Md(), i), i, void 0, t ?? {});
  }
  return s._$AI(r), s;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const sc = globalThis;
class kp extends cl {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = Qq(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return Tu;
  }
}
var $C;
kp._$litElement$ = !0, kp.finalized = !0, ($C = sc.litElementHydrateSupport) == null || $C.call(sc, { LitElement: kp });
const Sw = sc.litElementPolyfillSupport;
Sw == null || Sw({ LitElement: kp });
(sc.litElementVersions ?? (sc.litElementVersions = [])).push("4.2.0");
let Vh, zo, qo;
function YY(r, e) {
  Vh = document.createElement("style"), zo = document.createElement("style"), qo = document.createElement("style"), Vh.textContent = _l(r).core.cssText, zo.textContent = _l(r).dark.cssText, qo.textContent = _l(r).light.cssText, document.head.appendChild(Vh), document.head.appendChild(zo), document.head.appendChild(qo), DS(e);
}
function DS(r) {
  zo && qo && (r === "light" ? (zo.removeAttribute("media"), qo.media = "enabled") : (qo.removeAttribute("media"), zo.media = "enabled"));
}
function Zq(r) {
  Vh && zo && qo && (Vh.textContent = _l(r).core.cssText, zo.textContent = _l(r).dark.cssText, qo.textContent = _l(r).light.cssText);
}
function _l(r) {
  return {
    core: Cl`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${kn(r != null && r["--w3m-color-mix-strength"] ? `${r["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${kn((r == null ? void 0 : r["--w3m-font-family"]) || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${kn((r == null ? void 0 : r["--w3m-font-size-master"]) || "10px")};
        --w3m-border-radius-master: ${kn((r == null ? void 0 : r["--w3m-border-radius-master"]) || "4px")};
        --w3m-z-index: ${kn((r == null ? void 0 : r["--w3m-z-index"]) || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
    light: Cl`
      :root {
        --w3m-color-mix: ${kn((r == null ? void 0 : r["--w3m-color-mix"]) || "#fff")};
        --w3m-accent: ${kn(Ri(r, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${kn(Ri(r, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
    dark: Cl`
      :root {
        --w3m-color-mix: ${kn((r == null ? void 0 : r["--w3m-color-mix"]) || "#000")};
        --w3m-accent: ${kn(Ri(r, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${kn(Ri(r, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `
  };
}
const QY = Cl`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`, ZY = Cl`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`, XY = Cl`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`, Di = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603,
  DEFAULT_ALLOWED_ANCESTORS: [
    "http://localhost:*",
    "https://*.pages.dev",
    "https://*.vercel.app",
    "https://*.ngrok-free.app",
    "https://secure-mobile.walletconnect.com",
    "https://secure-mobile.walletconnect.org"
  ]
}, eQ = /* @__PURE__ */ HO({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
function Rf(r) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...r
  };
}
const _A = Rf({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: !1,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
}), IA = Rf({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: !0,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});
Rf({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: !0,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});
Rf({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
Rf({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: !0
});
const Xq = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
}, Up = {
  getMethodsByChainNamespace(r) {
    return Xq[r] || [];
  },
  createDefaultNamespace(r) {
    return {
      methods: this.getMethodsByChainNamespace(r),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(r, e) {
    if (!e)
      return { ...r };
    const t = { ...r }, n = /* @__PURE__ */ new Set();
    if (e.methods && Object.keys(e.methods).forEach((s) => n.add(s)), e.chains && Object.keys(e.chains).forEach((s) => n.add(s)), e.events && Object.keys(e.events).forEach((s) => n.add(s)), e.rpcMap && Object.keys(e.rpcMap).forEach((s) => {
      const [i] = s.split(":");
      i && n.add(i);
    }), n.forEach((s) => {
      t[s] || (t[s] = this.createDefaultNamespace(s));
    }), e.methods && Object.entries(e.methods).forEach(([s, i]) => {
      t[s] && (t[s].methods = i);
    }), e.chains && Object.entries(e.chains).forEach(([s, i]) => {
      t[s] && (t[s].chains = i);
    }), e.events && Object.entries(e.events).forEach(([s, i]) => {
      t[s] && (t[s].events = i);
    }), e.rpcMap) {
      const s = /* @__PURE__ */ new Set();
      Object.entries(e.rpcMap).forEach(([i, o]) => {
        const [a, c] = i.split(":");
        !a || !c || !t[a] || (t[a].rpcMap || (t[a].rpcMap = {}), s.has(a) || (t[a].rpcMap = {}, s.add(a)), t[a].rpcMap[c] = o);
      });
    }
    return t;
  },
  createNamespaces(r, e) {
    const t = r.reduce((n, s) => {
      const { id: i, chainNamespace: o, rpcUrls: a } = s, c = a.default.http[0];
      n[o] || (n[o] = this.createDefaultNamespace(o));
      const l = `${o}:${i}`, u = n[o];
      switch (u.chains.push(l), l) {
        case _A.caipNetworkId:
          u.chains.push(_A.deprecatedCaipNetworkId);
          break;
        case IA.caipNetworkId:
          u.chains.push(IA.deprecatedCaipNetworkId);
          break;
      }
      return u != null && u.rpcMap && c && (u.rpcMap[i] = c), n;
    }, {});
    return this.applyNamespaceOverrides(t, e);
  },
  resolveReownName: async (r) => {
    var n;
    const e = await Uh.resolveName(r);
    return ((n = (Object.values(e == null ? void 0 : e.addresses) || [])[0]) == null ? void 0 : n.address) || !1;
  },
  getChainsFromNamespaces(r = {}) {
    return Object.values(r).flatMap((e) => {
      const t = e.chains || [], n = e.accounts.map((s) => {
        const [i, o] = s.split(":");
        return `${i}:${o}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...t, ...n]));
    });
  },
  isSessionEventData(r) {
    return typeof r == "object" && r !== null && "id" in r && "topic" in r && "params" in r && typeof r.params == "object" && r.params !== null && "chainId" in r.params && "event" in r.params && typeof r.params.event == "object" && r.params.event !== null;
  },
  isOriginAllowed(r, e, t) {
    for (const n of [...e, ...t])
      if (n.includes("*")) {
        const i = `^${n.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&").replace(/\\\*/gu, ".*")}$`;
        if (new RegExp(i, "u").test(r))
          return !0;
      } else
        try {
          if (new URL(n).origin === r)
            return !0;
        } catch {
          if (n === r)
            return !0;
        }
    return !1;
  }
};
class _b {
  constructor({ provider: e, namespace: t }) {
    this.id = W.CONNECTOR_ID.WALLET_CONNECT, this.name = qs.ConnectorNamesMap[W.CONNECTOR_ID.WALLET_CONNECT], this.type = "WALLET_CONNECT", this.imageId = qs.ConnectorImageIds[W.CONNECTOR_ID.WALLET_CONNECT], this.getCaipNetworks = _.getCaipNetworks.bind(_), this.caipNetworks = this.getCaipNetworks(), this.provider = e, this.chain = t;
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    if (!await this.authenticate()) {
      const t = this.getCaipNetworks(), n = K.state.universalProviderConfigOverride, s = Up.createNamespaces(t, n);
      await this.provider.connect({ optionalNamespaces: s });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const e = this.chains.map((t) => t.caipNetworkId);
    return Hh.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains: e,
      methods: eW
    });
  }
}
const eW = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];
class kS {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(e) {
    this.availableConnectors = [], this.eventListeners = /* @__PURE__ */ new Map(), this.getCaipNetworks = (t) => _.getCaipNetworks(t), e && this.construct(e);
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(e) {
    this.projectId = e.projectId, this.namespace = e.namespace, this.adapterType = e.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(e) {
    this.addConnector({
      id: W.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: W.CONNECTOR_NAMES.AUTH,
      provider: e,
      imageId: qs.ConnectorImageIds[W.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...e) {
    const t = /* @__PURE__ */ new Set();
    this.availableConnectors = [...e, ...this.availableConnectors].filter((n) => t.has(n.id) ? !1 : (t.add(n.id), !0)), this.emit("connectors", this.availableConnectors);
  }
  setStatus(e, t) {
    X.setStatus(e, t);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(e, t) {
    var n;
    this.eventListeners.has(e) || this.eventListeners.set(e, /* @__PURE__ */ new Set()), (n = this.eventListeners.get(e)) == null || n.add(t);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(e, t) {
    const n = this.eventListeners.get(e);
    n && n.delete(t);
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((e) => {
      e.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(e, t) {
    const n = this.eventListeners.get(e);
    n && n.forEach((s) => s(t));
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(e) {
    return { clientId: (await this.getWalletConnectConnector().connectWalletConnect()).clientId };
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(e) {
    var i;
    const { caipNetwork: t, providerType: n } = e;
    if (!e.provider)
      return;
    const s = "provider" in e.provider ? e.provider.provider : e.provider;
    if (n === "WALLET_CONNECT") {
      s.setDefaultChain(t.caipNetworkId);
      return;
    }
    if (s && n === "AUTH") {
      const o = s, a = (i = X.state.preferredAccountTypes) == null ? void 0 : i[t.chainNamespace];
      await o.switchNetwork(t.caipNetworkId);
      const c = await o.getUser({
        chainId: t.caipNetworkId,
        preferredAccountType: a
      });
      this.emit("switchNetwork", c);
    }
  }
  getWalletConnectConnector() {
    const e = this.connectors.find((t) => t instanceof _b);
    if (!e)
      throw new Error("WalletConnectConnector not found");
    return e;
  }
}
class tW extends kS {
  setUniversalProvider(e) {
    this.addConnector(new _b({
      provider: e,
      caipNetworks: this.getCaipNetworks(),
      namespace: this.namespace
    }));
  }
  async connect(e) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(e.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      await this.getWalletConnectConnector().disconnect();
    } catch (e) {
      console.warn("UniversalAdapter:disconnect - error", e);
    }
  }
  async getAccounts({ namespace: e }) {
    var s, i, o, a;
    const t = this.provider, n = ((a = (o = (i = (s = t == null ? void 0 : t.session) == null ? void 0 : s.namespaces) == null ? void 0 : i[e]) == null ? void 0 : o.accounts) == null ? void 0 : a.map((c) => {
      const [, , l] = c.split(":");
      return l;
    }).filter((c, l, u) => u.indexOf(c) === l)) || [];
    return Promise.resolve({
      accounts: n.map((c) => me.createAccount(e, c, e === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(e) {
    var i, o, a, c, l;
    if (!(e.caipNetwork && at.BALANCE_SUPPORTED_CHAINS.includes((i = e.caipNetwork) == null ? void 0 : i.chainNamespace)) || (o = e.caipNetwork) != null && o.testnet)
      return {
        balance: "0.00",
        symbol: ((a = e.caipNetwork) == null ? void 0 : a.nativeCurrency.symbol) || ""
      };
    if (X.state.balanceLoading && e.chainId === ((c = _.state.activeCaipNetwork) == null ? void 0 : c.id))
      return {
        balance: X.state.balance || "0.00",
        symbol: X.state.balanceSymbol || ""
      };
    const s = (await X.fetchTokenBalance()).find((u) => {
      var h, d;
      return u.chainId === `${(h = e.caipNetwork) == null ? void 0 : h.chainNamespace}:${e.chainId}` && u.symbol === ((d = e.caipNetwork) == null ? void 0 : d.nativeCurrency.symbol);
    });
    return {
      balance: (s == null ? void 0 : s.quantity.numeric) || "0.00",
      symbol: (s == null ? void 0 : s.symbol) || ((l = e.caipNetwork) == null ? void 0 : l.nativeCurrency.symbol) || ""
    };
  }
  async signMessage(e) {
    var o, a, c;
    const { provider: t, message: n, address: s } = e;
    if (!t)
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    let i = "";
    return ((o = _.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace) === W.CHAIN.SOLANA ? i = (await t.request({
      method: "solana_signMessage",
      params: {
        message: zu.encode(new TextEncoder().encode(n)),
        pubkey: s
      }
    }, (a = _.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId)).signature : i = await t.request({
      method: "personal_sign",
      params: [n, s]
    }, (c = _.state.activeCaipNetwork) == null ? void 0 : c.caipNetworkId), { signature: i };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(e) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(e) {
    var s, i, o, a, c, l;
    const { caipNetwork: t } = e, n = this.getWalletConnectConnector();
    if (t.chainNamespace === W.CHAIN.EVM)
      try {
        await ((s = n.provider) == null ? void 0 : s.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: aE(t.id) }]
        }));
      } catch (u) {
        if (u.code === Di.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || u.code === Di.ERROR_INVALID_CHAIN_ID || u.code === Di.ERROR_CODE_DEFAULT || ((o = (i = u == null ? void 0 : u.data) == null ? void 0 : i.originalError) == null ? void 0 : o.code) === Di.ERROR_CODE_UNRECOGNIZED_CHAIN_ID)
          try {
            await ((l = n.provider) == null ? void 0 : l.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: aE(t.id),
                  rpcUrls: [(a = t == null ? void 0 : t.rpcUrls.chainDefault) == null ? void 0 : a.http],
                  chainName: t.name,
                  nativeCurrency: t.nativeCurrency,
                  blockExplorerUrls: [(c = t.blockExplorers) == null ? void 0 : c.default.url]
                }
              ]
            }));
          } catch {
            throw new Error("Chain is not supported");
          }
      }
    n.provider.setDefaultChain(t.caipNetworkId);
  }
  getWalletConnectProvider() {
    const e = this.connectors.find((n) => n.type === "WALLET_CONNECT");
    return e == null ? void 0 : e.provider;
  }
}
const rW = [
  "email",
  "socials",
  "swaps",
  "onramp",
  "activity",
  "reownBranding"
], dp = {
  email: {
    apiFeatureName: "social_login",
    localFeatureName: "email",
    returnType: !1,
    isLegacy: !1,
    isAvailableOnBasic: !1,
    processApi: (r) => {
      if (!(r != null && r.config))
        return !1;
      const e = r.config;
      return !!r.isEnabled && e.includes("email");
    },
    processFallback: (r) => r === void 0 ? at.DEFAULT_REMOTE_FEATURES.email : !!r
  },
  socials: {
    apiFeatureName: "social_login",
    localFeatureName: "socials",
    returnType: !1,
    isLegacy: !1,
    isAvailableOnBasic: !1,
    processApi: (r) => {
      if (!(r != null && r.config))
        return !1;
      const e = r.config;
      return r.isEnabled && e.length > 0 ? e.filter((t) => t !== "email") : !1;
    },
    processFallback: (r) => r === void 0 ? at.DEFAULT_REMOTE_FEATURES.socials : typeof r == "boolean" ? r ? at.DEFAULT_REMOTE_FEATURES.socials : !1 : r
  },
  swaps: {
    apiFeatureName: "swap",
    localFeatureName: "swaps",
    returnType: !1,
    isLegacy: !1,
    isAvailableOnBasic: !1,
    processApi: (r) => {
      if (!(r != null && r.config))
        return !1;
      const e = r.config;
      return r.isEnabled && e.length > 0 ? e : !1;
    },
    processFallback: (r) => r === void 0 ? at.DEFAULT_REMOTE_FEATURES.swaps : typeof r == "boolean" ? r ? at.DEFAULT_REMOTE_FEATURES.swaps : !1 : r
  },
  onramp: {
    apiFeatureName: "onramp",
    localFeatureName: "onramp",
    returnType: !1,
    isLegacy: !1,
    isAvailableOnBasic: !1,
    processApi: (r) => {
      if (!(r != null && r.config))
        return !1;
      const e = r.config;
      return r.isEnabled && e.length > 0 ? e : !1;
    },
    processFallback: (r) => r === void 0 ? at.DEFAULT_REMOTE_FEATURES.onramp : typeof r == "boolean" ? r ? at.DEFAULT_REMOTE_FEATURES.onramp : !1 : r
  },
  activity: {
    apiFeatureName: "activity",
    localFeatureName: "history",
    returnType: !1,
    isLegacy: !0,
    isAvailableOnBasic: !1,
    processApi: (r) => !!r.isEnabled,
    processFallback: (r) => r === void 0 ? at.DEFAULT_REMOTE_FEATURES.activity : !!r
  },
  reownBranding: {
    apiFeatureName: "reown_branding",
    localFeatureName: "reownBranding",
    returnType: !1,
    isLegacy: !1,
    isAvailableOnBasic: !1,
    processApi: (r) => !!r.isEnabled,
    processFallback: (r) => r === void 0 ? at.DEFAULT_REMOTE_FEATURES.reownBranding : !!r
  }
}, nW = {
  localSettingsOverridden: /* @__PURE__ */ new Set(),
  getApiConfig(r, e) {
    return e == null ? void 0 : e.find((t) => t.id === r);
  },
  addWarning(r, e) {
    if (r !== void 0) {
      const t = dp[e], n = t.isLegacy ? `"features.${t.localFeatureName}" (now "${e}")` : `"features.${e}"`;
      this.localSettingsOverridden.add(n);
    }
  },
  processFeature(r, e, t, n, s) {
    const i = dp[r], o = e[i.localFeatureName];
    if (s && !i.isAvailableOnBasic)
      return !1;
    if (n) {
      const a = this.getApiConfig(i.apiFeatureName, t);
      return (a == null ? void 0 : a.config) === null ? this.processFallbackFeature(r, o) : a != null && a.config ? (o !== void 0 && this.addWarning(o, r), this.processApiFeature(r, a)) : !1;
    }
    return this.processFallbackFeature(r, o);
  },
  processApiFeature(r, e) {
    return dp[r].processApi(e);
  },
  processFallbackFeature(r, e) {
    return dp[r].processFallback(e);
  },
  async fetchRemoteFeatures(r) {
    const e = r.basic ?? !1, t = r.features || {};
    this.localSettingsOverridden.clear();
    let n = null, s = !1;
    try {
      n = await ye.fetchProjectConfig(), s = n != null;
    } catch (o) {
      console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.", o);
    }
    const i = s && !e ? at.DEFAULT_REMOTE_FEATURES : at.DEFAULT_REMOTE_FEATURES_DISABLED;
    try {
      for (const o of rW) {
        const a = this.processFeature(o, t, n, s, e);
        Object.assign(i, { [o]: a });
      }
    } catch (o) {
      return console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.", o), at.DEFAULT_REMOTE_FEATURES;
    }
    if (s && this.localSettingsOverridden.size > 0) {
      const o = `Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
      Zr.open({
        shortMessage: "Local configuration ignored",
        longMessage: `[Reown Config Notice] ${o}`
      }, "warning");
    }
    return i;
  }
};
class sW {
  constructor(e) {
    this.chainNamespaces = [], this.remoteFeatures = {}, this.reportedAlertErrors = {}, this.getCaipNetwork = (t, n) => {
      var s, i, o, a;
      if (t) {
        const c = (i = (s = _.getNetworkData(t)) == null ? void 0 : s.requestedCaipNetworks) == null ? void 0 : i.find((h) => h.id === n);
        if (c)
          return c;
        const l = (o = _.getNetworkData(t)) == null ? void 0 : o.caipNetwork;
        return l || ((a = _.getRequestedCaipNetworks(t).filter((h) => h.chainNamespace === t)) == null ? void 0 : a[0]);
      }
      return _.state.activeCaipNetwork || this.defaultCaipNetwork;
    }, this.getCaipNetworkId = () => {
      const t = this.getCaipNetwork();
      if (t)
        return t.id;
    }, this.getCaipNetworks = (t) => _.getCaipNetworks(t), this.getActiveChainNamespace = () => _.state.activeChain, this.setRequestedCaipNetworks = (t, n) => {
      _.setRequestedCaipNetworks(t, n);
    }, this.getApprovedCaipNetworkIds = () => _.getAllApprovedCaipNetworkIds(), this.getCaipAddress = (t) => _.state.activeChain === t || !t ? _.state.activeCaipAddress : _.getAccountProp("caipAddress", t), this.setClientId = (t) => {
      ve.setClientId(t);
    }, this.getProvider = (t) => Ze.getProvider(t), this.getProviderType = (t) => Ze.getProviderId(t), this.getPreferredAccountType = (t) => {
      var n;
      return (n = X.state.preferredAccountTypes) == null ? void 0 : n[t];
    }, this.setCaipAddress = (t, n) => {
      X.setCaipAddress(t, n), t && K.state.enableEmbedded && this.close();
    }, this.setBalance = (t, n, s) => {
      X.setBalance(t, n, s);
    }, this.setProfileName = (t, n) => {
      X.setProfileName(t, n);
    }, this.setProfileImage = (t, n) => {
      X.setProfileImage(t, n);
    }, this.setUser = (t, n) => {
      X.setUser(t, n);
    }, this.resetAccount = (t) => {
      X.resetAccount(t);
    }, this.setCaipNetwork = (t) => {
      _.setActiveCaipNetwork(t);
    }, this.setCaipNetworkOfNamespace = (t, n) => {
      _.setChainNetworkData(n, { caipNetwork: t });
    }, this.setAllAccounts = (t, n) => {
      X.setAllAccounts(t, n), K.setHasMultipleAddresses((t == null ? void 0 : t.length) > 1);
    }, this.setStatus = (t, n) => {
      X.setStatus(t, n), re.isConnected() ? te.setConnectionStatus("connected") : te.setConnectionStatus("disconnected");
    }, this.getAddressByChainNamespace = (t) => _.getAccountProp("address", t), this.setConnectors = (t) => {
      const n = [...re.state.allConnectors, ...t];
      re.setConnectors(n);
    }, this.setConnections = (t, n) => {
      ue.setConnections(t, n);
    }, this.fetchIdentity = (t) => ve.fetchIdentity(t), this.getReownName = (t) => Uh.getNamesForAddress(t), this.getConnectors = () => re.getConnectors(), this.getConnectorImage = (t) => WC.getConnectorImage(t), this.getConnections = (t) => Qh.getConnectionsData(t).connections, this.getRecentConnections = (t) => Qh.getConnectionsData(t).recentConnections, this.switchConnection = (t) => ue.switchConnection(t), this.deleteConnection = (t) => te.deleteAddressFromConnection(t), this.setConnectedWalletInfo = (t, n) => {
      const s = Ze.getProviderId(n), i = t ? { ...t, type: s } : void 0;
      X.setConnectedWalletInfo(i, n);
    }, this.getIsConnectedState = () => !!_.state.activeCaipAddress, this.addAddressLabel = (t, n, s) => {
      X.addAddressLabel(t, n, s);
    }, this.removeAddressLabel = (t, n) => {
      X.removeAddressLabel(t, n);
    }, this.getAddress = (t) => _.state.activeChain === t || !t ? X.state.address : _.getAccountProp("address", t), this.setApprovedCaipNetworksData = (t) => _.setApprovedCaipNetworksData(t), this.resetNetwork = (t) => {
      _.resetNetwork(t);
    }, this.addConnector = (t) => {
      re.addConnector(t);
    }, this.resetWcConnection = () => {
      ue.resetWcConnection();
    }, this.setAddressExplorerUrl = (t, n) => {
      X.setAddressExplorerUrl(t, n);
    }, this.setSmartAccountDeployed = (t, n) => {
      X.setSmartAccountDeployed(t, n);
    }, this.setSmartAccountEnabledNetworks = (t, n) => {
      _.setSmartAccountEnabledNetworks(t, n);
    }, this.setPreferredAccountType = (t, n) => {
      X.setPreferredAccountType(t, n);
    }, this.setEIP6963Enabled = (t) => {
      K.setEIP6963Enabled(t);
    }, this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty())
          return;
        this.redirect("ApproveTransaction");
      } else
        this.open({ view: "ApproveTransaction" });
    }, this.options = e, this.version = e.sdkVersion, this.caipNetworks = this.extendCaipNetworks(e), this.chainNamespaces = this.getChainNamespacesSet(e.adapters, this.caipNetworks), this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e), this.chainAdapters = this.createAdapters(e.adapters), this.readyPromise = this.initialize(e);
  }
  getChainNamespacesSet(e, t) {
    const n = e == null ? void 0 : e.map((i) => i.namespace).filter((i) => !!i);
    if (n != null && n.length)
      return [...new Set(n)];
    const s = t == null ? void 0 : t.map((i) => i.chainNamespace);
    return [...new Set(s)];
  }
  async initialize(e) {
    var t, n, s;
    this.initializeProjectSettings(e), this.initControllers(e), await this.initChainAdapters(), this.sendInitializeEvent(e), await this.syncExistingConnection(), this.remoteFeatures = await nW.fetchRemoteFeatures(e), K.setRemoteFeatures(this.remoteFeatures), this.remoteFeatures.onramp && Jw.setOnrampProviders(this.remoteFeatures.onramp), ((t = K.state.remoteFeatures) != null && t.email || Array.isArray((n = K.state.remoteFeatures) == null ? void 0 : n.socials) && ((s = K.state.remoteFeatures) == null ? void 0 : s.socials.length) > 0) && await this.checkAllowedOrigins();
  }
  async checkAllowedOrigins() {
    try {
      const e = await ye.fetchAllowedOrigins();
      if (!e || !me.isClient()) {
        Zr.open(Rr.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        return;
      }
      const t = window.location.origin;
      Up.isOriginAllowed(t, e, Di.DEFAULT_ALLOWED_ANCESTORS) || Zr.open(Rr.ALERT_ERRORS.INVALID_APP_CONFIGURATION, "error");
    } catch (e) {
      if (!(e instanceof Error)) {
        Zr.open(Rr.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        return;
      }
      switch (e.message) {
        case "RATE_LIMITED":
          Zr.open(Rr.ALERT_ERRORS.RATE_LIMITED_APP_CONFIGURATION, "error");
          break;
        case "SERVER_ERROR": {
          const t = e.cause instanceof Error ? e.cause : e;
          Zr.open({
            shortMessage: Rr.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.shortMessage,
            longMessage: Rr.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.longMessage(t.message)
          }, "error");
          break;
        }
        default:
          Zr.open(Rr.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      }
    }
  }
  sendInitializeEvent(e) {
    var n;
    const { ...t } = e;
    delete t.adapters, delete t.universalProvider, ct.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...t,
        networks: e.networks.map((s) => s.id),
        siweConfig: {
          options: ((n = e.siweConfig) == null ? void 0 : n.options) || {}
        }
      }
    });
  }
  // -- Controllers initialization ---------------------------------------------------
  initControllers(e) {
    this.initializeOptionsController(e), this.initializeChainController(e), this.initializeThemeController(e), this.initializeConnectionController(e), this.initializeConnectorController();
  }
  initializeThemeController(e) {
    e.themeMode && Xr.setThemeMode(e.themeMode), e.themeVariables && Xr.setThemeVariables(e.themeVariables);
  }
  initializeChainController(e) {
    if (!this.connectionControllerClient || !this.networkControllerClient)
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    _.initialize(e.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const t = this.getDefaultNetwork();
    t && _.setActiveCaipNetwork(t);
  }
  initializeConnectionController(e) {
    ue.initialize(e.adapters ?? []), ue.setWcBasic(e.basic ?? !1);
  }
  initializeConnectorController() {
    re.initialize(this.chainNamespaces);
  }
  initializeProjectSettings(e) {
    K.setProjectId(e.projectId), K.setSdkVersion(e.sdkVersion);
  }
  initializeOptionsController(e) {
    var o;
    K.setDebug(e.debug !== !1), K.setEnableWalletConnect(e.enableWalletConnect !== !1), K.setEnableWalletGuide(e.enableWalletGuide !== !1), K.setEnableWallets(e.enableWallets !== !1), K.setEIP6963Enabled(e.enableEIP6963 !== !1), K.setEnableNetworkSwitch(e.enableNetworkSwitch !== !1), K.setEnableAuthLogger(e.enableAuthLogger !== !1), K.setCustomRpcUrls(e.customRpcUrls), K.setEnableEmbedded(e.enableEmbedded), K.setAllWallets(e.allWallets), K.setIncludeWalletIds(e.includeWalletIds), K.setExcludeWalletIds(e.excludeWalletIds), K.setFeaturedWalletIds(e.featuredWalletIds), K.setTokens(e.tokens), K.setTermsConditionsUrl(e.termsConditionsUrl), K.setPrivacyPolicyUrl(e.privacyPolicyUrl), K.setCustomWallets(e.customWallets), K.setFeatures(e.features), K.setAllowUnsupportedChain(e.allowUnsupportedChain), K.setUniversalProviderConfigOverride(e.universalProviderConfigOverride), K.setPreferUniversalLinks(e.experimental_preferUniversalLinks), K.setDefaultAccountTypes(e.defaultAccountTypes);
    const t = te.getPreferredAccountTypes() || {}, n = { ...K.state.defaultAccountTypes, ...t };
    X.setPreferredAccountTypes(n);
    const s = this.getDefaultMetaData();
    if (!e.metadata && s && (e.metadata = s), K.setMetadata(e.metadata), K.setDisableAppend(e.disableAppend), K.setEnableEmbedded(e.enableEmbedded), K.setSIWX(e.siwx), !e.projectId) {
      Zr.open(Rr.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    if (((o = e.adapters) == null ? void 0 : o.find((a) => a.namespace === W.CHAIN.EVM)) && e.siweConfig) {
      if (e.siwx)
        throw new Error("Cannot set both `siweConfig` and `siwx` options");
      K.setSIWX(e.siweConfig.mapToSIWX());
    }
  }
  getDefaultMetaData() {
    var e, t, n, s;
    return me.isClient() ? {
      name: ((t = (e = document.getElementsByTagName("title")) == null ? void 0 : e[0]) == null ? void 0 : t.textContent) || "",
      description: ((n = document.querySelector('meta[property="og:description"]')) == null ? void 0 : n.content) || "",
      url: window.location.origin,
      icons: [((s = document.querySelector('link[rel~="icon"]')) == null ? void 0 : s.href) || ""]
    } : null;
  }
  // -- Network Initialization ---------------------------------------------------
  setUnsupportedNetwork(e) {
    const t = this.getActiveChainNamespace();
    if (t) {
      const n = ol.getUnsupportedNetwork(`${t}:${e}`);
      _.setActiveCaipNetwork(n);
    }
  }
  getDefaultNetwork() {
    return ol.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(e, t) {
    return ol.extendCaipNetwork(e, {
      customNetworkImageUrls: t.chainImages,
      projectId: t.projectId
    });
  }
  extendCaipNetworks(e) {
    return ol.extendCaipNetworks(e.networks, {
      customNetworkImageUrls: e.chainImages,
      customRpcUrls: e.customRpcUrls,
      projectId: e.projectId
    });
  }
  extendDefaultCaipNetwork(e) {
    const t = e.networks.find((s) => {
      var i;
      return s.id === ((i = e.defaultNetwork) == null ? void 0 : i.id);
    });
    return t ? ol.extendCaipNetwork(t, {
      customNetworkImageUrls: e.chainImages,
      customRpcUrls: e.customRpcUrls,
      projectId: e.projectId
    }) : void 0;
  }
  async disconnectNamespace(e) {
    try {
      const t = this.getAdapter(e), n = Ze.getProvider(e), s = Ze.getProviderId(e), { caipAddress: i } = _.getAccountData(e) || {};
      this.setLoading(!0, e), i && (t != null && t.disconnect) && await t.disconnect({ provider: n, providerType: s }), te.removeConnectedNamespace(e), Ze.resetChain(e), this.setUser(void 0, e), this.setStatus("disconnected", e), this.setConnectedWalletInfo(void 0, e), re.removeConnectorId(e), _.resetAccount(e), _.resetNetwork(e), this.setLoading(!1, e);
    } catch (t) {
      throw this.setLoading(!1, e), new Error(`Failed to disconnect chain ${e}: ${t.message}`);
    }
  }
  // -- Client Initialization ---------------------------------------------------
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var i;
        const e = _.state.activeChain, t = this.getAdapter(e), n = (i = this.getCaipNetwork(e)) == null ? void 0 : i.id;
        if (!t)
          throw new Error("Adapter not found");
        const s = await t.connectWalletConnect(n);
        this.close(), this.setClientId((s == null ? void 0 : s.clientId) || null), te.setConnectedNamespaces([..._.state.chains.keys()]), this.chainNamespaces.forEach((o) => {
          re.setConnectorId(ft.CONNECTOR_TYPE_WALLET_CONNECT, o);
        }), await this.syncWalletConnectAccount();
      },
      connectExternal: async ({ id: e, info: t, type: n, provider: s, chain: i, caipNetwork: o, socialUri: a }) => {
        var p, w, E, I, A, C;
        const c = _.state.activeChain, l = i || c, u = this.getAdapter(l);
        if (i && i !== c && !o) {
          const N = this.getCaipNetworks().find((x) => x.chainNamespace === i);
          N && this.setCaipNetwork(N);
        }
        if (!u)
          throw new Error("Adapter not found");
        const h = this.getCaipNetwork(l), d = await u.connect({
          id: e,
          info: t,
          type: n,
          provider: s,
          socialUri: a,
          chainId: (o == null ? void 0 : o.id) || (h == null ? void 0 : h.id),
          rpcUrl: ((E = (w = (p = o == null ? void 0 : o.rpcUrls) == null ? void 0 : p.default) == null ? void 0 : w.http) == null ? void 0 : E[0]) || ((C = (A = (I = h == null ? void 0 : h.rpcUrls) == null ? void 0 : I.default) == null ? void 0 : A.http) == null ? void 0 : C[0])
        });
        if (!d)
          return;
        te.addConnectedNamespace(l), this.syncProvider({ ...d, chainNamespace: l });
        const f = X.state.allAccounts, { accounts: g } = (f == null ? void 0 : f.length) > 0 ? (
          // eslint-disable-next-line line-comment-position
          // Using new array else the accounts will have the same reference and react will not re-render
          { accounts: [...f] }
        ) : await u.getAccounts({ namespace: l, id: e });
        this.setAllAccounts(g, l), this.setStatus("connected", l), this.syncConnectedWalletInfo(l);
      },
      reconnectExternal: async ({ id: e, info: t, type: n, provider: s }) => {
        var a;
        const i = _.state.activeChain, o = this.getAdapter(i);
        o != null && o.reconnect && (await (o == null ? void 0 : o.reconnect({ id: e, info: t, type: n, provider: s, chainId: (a = this.getCaipNetwork()) == null ? void 0 : a.id })), te.addConnectedNamespace(i), this.syncConnectedWalletInfo(i));
      },
      /**
       * Disconnect a connector or all connectors
       * @param {string} [options.id] - Connector ID to disconnect. If no id is passed, disconnects all connectors. If id is provided then disconnect the specific connector.
       * @param {ChainNamespace} [options.chainNamespace] - Chain namespace to disconnect from
       */
      disconnect: async ({ chainNamespace: e } = {}) => {
        const t = Px(e);
        try {
          const n = await Promise.allSettled(t.map(async ([i]) => this.disconnectNamespace(i)));
          tt.resetSend(), ue.resetWcConnection(), await Hh.clearSessions(), re.setFilterByNamespace(void 0);
          const s = n.filter((i) => i.status === "rejected");
          if (s.length > 0)
            throw new Error(s.map((i) => i.reason.message).join(", "));
          te.deleteConnectedSocialProvider(), ct.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: {
              namespace: e || "all"
            }
          });
        } catch (n) {
          throw new Error(`Failed to disconnect chains: ${n.message}`);
        }
      },
      checkInstalled: (e) => e ? e.some((t) => {
        var n;
        return !!((n = window.ethereum) != null && n[String(t)]);
      }) : !!window.ethereum,
      signMessage: async (e) => {
        const t = this.getAdapter(_.state.activeChain), n = await (t == null ? void 0 : t.signMessage({
          message: e,
          address: X.state.address,
          provider: Ze.getProvider(_.state.activeChain)
        }));
        return (n == null ? void 0 : n.signature) || "";
      },
      sendTransaction: async (e) => {
        const t = e.chainNamespace;
        if (at.SEND_SUPPORTED_NAMESPACES.includes(t)) {
          const n = this.getAdapter(_.state.activeChain), s = Ze.getProvider(t), i = await (n == null ? void 0 : n.sendTransaction({
            ...e,
            caipNetwork: this.getCaipNetwork(),
            provider: s
          }));
          return (i == null ? void 0 : i.hash) || "";
        }
        return "";
      },
      estimateGas: async (e) => {
        if (e.chainNamespace === W.CHAIN.EVM) {
          const t = this.getAdapter(_.state.activeChain), n = Ze.getProvider(_.state.activeChain), s = this.getCaipNetwork();
          if (!s)
            throw new Error("CaipNetwork is undefined");
          const i = await (t == null ? void 0 : t.estimateGas({
            ...e,
            provider: n,
            caipNetwork: s
          }));
          return (i == null ? void 0 : i.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var e;
        return await this.syncIdentity({
          address: X.state.address,
          chainId: Number((e = this.getCaipNetwork()) == null ? void 0 : e.id),
          chainNamespace: _.state.activeChain
        }), X.state.profileImage || !1;
      },
      getEnsAddress: async (e) => await Up.resolveReownName(e),
      writeContract: async (e) => {
        const t = this.getAdapter(_.state.activeChain), n = this.getCaipNetwork(), s = this.getCaipAddress(), i = Ze.getProvider(_.state.activeChain);
        if (!n || !s)
          throw new Error("CaipNetwork or CaipAddress is undefined");
        const o = await (t == null ? void 0 : t.writeContract({ ...e, caipNetwork: n, provider: i, caipAddress: s }));
        return o == null ? void 0 : o.hash;
      },
      parseUnits: (e, t) => {
        const n = this.getAdapter(_.state.activeChain);
        return (n == null ? void 0 : n.parseUnits({ value: e, decimals: t })) ?? 0n;
      },
      formatUnits: (e, t) => {
        const n = this.getAdapter(_.state.activeChain);
        return (n == null ? void 0 : n.formatUnits({ value: e, decimals: t })) ?? "0";
      },
      getCapabilities: async (e) => {
        const t = this.getAdapter(_.state.activeChain);
        return await (t == null ? void 0 : t.getCapabilities(e));
      },
      grantPermissions: async (e) => {
        const t = this.getAdapter(_.state.activeChain);
        return await (t == null ? void 0 : t.grantPermissions(e));
      },
      revokePermissions: async (e) => {
        const t = this.getAdapter(_.state.activeChain);
        return t != null && t.revokePermissions ? await t.revokePermissions(e) : "0x";
      },
      walletGetAssets: async (e) => {
        const t = this.getAdapter(_.state.activeChain);
        return await (t == null ? void 0 : t.walletGetAssets(e)) ?? {};
      },
      updateBalance: (e) => {
        const t = this.getCaipNetwork(e);
        !t || !X.state.address || this.updateNativeBalance(X.state.address, t == null ? void 0 : t.id, e);
      }
    }, this.networkControllerClient = {
      switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
    }, ue.setClient(this.connectionControllerClient);
  }
  getApprovedCaipNetworksData() {
    var t, n, s, i, o;
    if (Ze.getProviderId(_.state.activeChain) === ft.CONNECTOR_TYPE_WALLET_CONNECT) {
      const a = (n = (t = this.universalProvider) == null ? void 0 : t.session) == null ? void 0 : n.namespaces;
      return {
        /*
         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
         * will make it possible to switch to other networks.
         */
        supportsAllNetworks: ((o = (i = (s = this.universalProvider) == null ? void 0 : s.session) == null ? void 0 : i.peer) == null ? void 0 : o.metadata.name) === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(a)
      };
    }
    return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(e) {
    if (!e)
      return;
    const t = e.chainNamespace;
    if (this.getAddressByChainNamespace(e.chainNamespace)) {
      const s = Ze.getProvider(t), i = Ze.getProviderId(t);
      if (e.chainNamespace === _.state.activeChain) {
        const o = this.getAdapter(t);
        await (o == null ? void 0 : o.switchNetwork({ caipNetwork: e, provider: s, providerType: i }));
      } else if (this.setCaipNetwork(e), i === ft.CONNECTOR_TYPE_WALLET_CONNECT)
        this.syncWalletConnectAccount();
      else {
        const o = this.getAddressByChainNamespace(t);
        o && this.syncAccount({
          address: o,
          chainId: e.id,
          chainNamespace: t
        });
      }
    } else
      this.setCaipNetwork(e);
  }
  getChainsFromNamespaces(e = {}) {
    return Object.values(e).flatMap((t) => {
      const n = t.chains || [], s = t.accounts.map((i) => {
        const { chainId: o, chainNamespace: a } = tn.parseCaipAddress(i);
        return `${a}:${o}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...n, ...s]));
    });
  }
  // -- Adapter Initialization ---------------------------------------------------
  createAdapters(e) {
    return this.createClients(), this.chainNamespaces.reduce((t, n) => {
      var i;
      const s = e == null ? void 0 : e.find((o) => o.namespace === n);
      return s ? (s.construct({
        namespace: n,
        projectId: (i = this.options) == null ? void 0 : i.projectId,
        networks: this.getCaipNetworks()
      }), t[n] = s) : t[n] = new tW({
        namespace: n,
        networks: this.getCaipNetworks()
      }), t;
    }, {});
  }
  async initChainAdapter(e) {
    var t;
    this.onConnectors(e), this.listenAdapter(e), await ((t = this.chainAdapters) == null ? void 0 : t[e].syncConnectors(this.options, this)), await this.createUniversalProviderForAdapter(e);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (e) => {
      await this.initChainAdapter(e);
    }));
  }
  onConnectors(e) {
    const t = this.getAdapter(e);
    t == null || t.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(e) {
    const t = this.getAdapter(e);
    if (!t)
      return;
    const n = te.getConnectionStatus();
    n === "connected" ? this.setStatus("connecting", e) : n === "disconnected" ? (te.clearAddressCache(), this.setStatus(n, e)) : this.setStatus(n, e), t.on("switchNetwork", ({ address: s, chainId: i }) => {
      const o = this.getCaipNetworks().find((l) => l.id === i || l.caipNetworkId === i), a = _.state.activeChain === e, c = _.getAccountProp("address", e);
      if (o) {
        const l = a && s ? s : c;
        l && this.syncAccount({ address: l, chainId: o.id, chainNamespace: e });
      } else
        this.setUnsupportedNetwork(i);
    }), t.on("disconnect", this.disconnect.bind(this, e)), t.on("connections", (s) => {
      this.setConnections(s, e);
    }), t.on("pendingTransactions", () => {
      const s = X.state.address, i = _.state.activeCaipNetwork;
      !s || !(i != null && i.id) || this.updateNativeBalance(s, i.id, i.chainNamespace);
    }), t.on("accountChanged", ({ address: s, chainId: i }) => {
      var a, c;
      const o = _.state.activeChain === e;
      o && i ? this.syncAccount({
        address: s,
        chainId: i,
        chainNamespace: e
      }) : o && ((a = _.state.activeCaipNetwork) != null && a.id) ? this.syncAccount({
        address: s,
        chainId: (c = _.state.activeCaipNetwork) == null ? void 0 : c.id,
        chainNamespace: e
      }) : this.syncAccountInfo(s, i, e), this.syncAllAccounts(e);
    });
  }
  async createUniversalProviderForAdapter(e) {
    var t, n, s;
    await this.getUniversalProvider(), this.universalProvider && ((s = (n = (t = this.chainAdapters) == null ? void 0 : t[e]) == null ? void 0 : n.setUniversalProvider) == null || s.call(n, this.universalProvider));
  }
  // -- Connection Sync ---------------------------------------------------
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((e) => this.syncNamespaceConnection(e)));
  }
  async syncNamespaceConnection(e) {
    try {
      e === W.CHAIN.EVM && me.isSafeApp() && re.setConnectorId(W.CONNECTOR_ID.SAFE, e);
      const t = re.getConnectorId(e);
      switch (this.setStatus("connecting", e), t) {
        case W.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount();
          break;
        case W.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(e);
      }
    } catch (t) {
      console.warn("AppKit couldn't sync existing connection", t), this.setStatus("disconnected", e);
    }
  }
  async syncAdapterConnection(e) {
    var a, c, l;
    const t = this.getAdapter(e), n = re.getConnectorId(e), s = this.getCaipNetwork(e), o = re.getConnectors(e).find((u) => u.id === n);
    try {
      if (!t || !o)
        throw new Error(`Adapter or connector not found for namespace ${e}`);
      if (!(s != null && s.id))
        throw new Error("CaipNetwork not found");
      const u = await (t == null ? void 0 : t.syncConnection({
        namespace: e,
        id: o.id,
        chainId: s.id,
        rpcUrl: (l = (c = (a = s == null ? void 0 : s.rpcUrls) == null ? void 0 : a.default) == null ? void 0 : c.http) == null ? void 0 : l[0]
      }));
      if (u) {
        const h = await (t == null ? void 0 : t.getAccounts({
          namespace: e,
          id: o.id
        }));
        h && h.accounts.length > 0 ? this.setAllAccounts(h.accounts, e) : this.setAllAccounts([me.createAccount(e, u.address, "eoa")], e), this.syncProvider({ ...u, chainNamespace: e }), await this.syncAccount({ ...u, chainNamespace: e }), this.setStatus("connected", e);
      } else
        this.setStatus("disconnected", e);
    } catch {
      this.setStatus("disconnected", e);
    }
  }
  async syncWalletConnectAccount() {
    var n, s;
    const e = Object.keys(((s = (n = this.universalProvider) == null ? void 0 : n.session) == null ? void 0 : s.namespaces) || {}), t = this.chainNamespaces.map(async (i) => {
      var u, h, d, f, g;
      const o = this.getAdapter(i), a = ((f = (d = (h = (u = this.universalProvider) == null ? void 0 : u.session) == null ? void 0 : h.namespaces) == null ? void 0 : d[i]) == null ? void 0 : f.accounts) || [], c = (g = _.state.activeCaipNetwork) == null ? void 0 : g.id, l = a.find((p) => {
        const { chainId: w } = tn.parseCaipAddress(p);
        return w === (c == null ? void 0 : c.toString());
      }) || a[0];
      if (l) {
        const p = tn.validateCaipAddress(l), { chainId: w, address: E } = tn.parseCaipAddress(p);
        if (Ze.setProviderId(i, ft.CONNECTOR_TYPE_WALLET_CONNECT), this.caipNetworks && _.state.activeCaipNetwork && (o == null ? void 0 : o.namespace) !== W.CHAIN.EVM) {
          const I = o == null ? void 0 : o.getWalletConnectProvider({
            caipNetworks: this.getCaipNetworks(),
            provider: this.universalProvider,
            activeCaipNetwork: _.state.activeCaipNetwork
          });
          Ze.setProvider(i, I);
        } else
          Ze.setProvider(i, this.universalProvider);
        re.setConnectorId(W.CONNECTOR_ID.WALLET_CONNECT, i), te.addConnectedNamespace(i), this.syncWalletConnectAccounts(i), await this.syncAccount({
          address: E,
          chainId: w,
          chainNamespace: i
        });
      } else e.includes(i) && this.setStatus("disconnected", i);
      this.syncConnectedWalletInfo(i), await _.setApprovedCaipNetworksData(i);
    });
    await Promise.all(t);
  }
  syncWalletConnectAccounts(e) {
    var n, s, i, o, a;
    const t = (a = (o = (i = (s = (n = this.universalProvider) == null ? void 0 : n.session) == null ? void 0 : s.namespaces) == null ? void 0 : i[e]) == null ? void 0 : o.accounts) == null ? void 0 : a.map((c) => {
      const { address: l } = tn.parseCaipAddress(c);
      return l;
    }).filter((c, l, u) => u.indexOf(c) === l);
    t && this.setAllAccounts(t.map((c) => me.createAccount(e, c, e === "bip122" ? "payment" : "eoa")), e);
  }
  syncProvider({ type: e, provider: t, id: n, chainNamespace: s }) {
    Ze.setProviderId(s, e), Ze.setProvider(s, t), re.setConnectorId(n, s);
  }
  async syncAllAccounts(e) {
    const t = re.getConnectorId(e);
    if (!t)
      return;
    const n = this.getAdapter(e), s = await (n == null ? void 0 : n.getAccounts({ namespace: e, id: t }));
    s && s.accounts.length > 0 && this.setAllAccounts(s.accounts, e);
  }
  async syncAccount(e) {
    var h, d;
    const t = e.chainNamespace === _.state.activeChain, n = _.getCaipNetworkByNamespace(e.chainNamespace, e.chainId), { address: s, chainId: i, chainNamespace: o } = e, { chainId: a } = te.getActiveNetworkProps(), c = i || a, l = ((h = _.state.activeCaipNetwork) == null ? void 0 : h.name) === W.UNSUPPORTED_NETWORK_NAME, u = _.getNetworkProp("supportsAllNetworks", o);
    if (this.setStatus("connected", o), !(l && !u) && c) {
      let f = this.getCaipNetworks().find((w) => w.id.toString() === c.toString()), g = this.getCaipNetworks().find((w) => w.chainNamespace === o);
      if (!u && !f && !g) {
        const w = this.getApprovedCaipNetworkIds() || [], E = w.find((A) => {
          var C;
          return ((C = tn.parseCaipNetworkId(A)) == null ? void 0 : C.chainId) === c.toString();
        }), I = w.find((A) => {
          var C;
          return ((C = tn.parseCaipNetworkId(A)) == null ? void 0 : C.chainNamespace) === o;
        });
        f = this.getCaipNetworks().find((A) => A.caipNetworkId === E), g = this.getCaipNetworks().find((A) => A.caipNetworkId === I || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in A && A.deprecatedCaipNetworkId === I);
      }
      const p = f || g;
      (p == null ? void 0 : p.chainNamespace) === _.state.activeChain ? K.state.enableNetworkSwitch && !K.state.allowUnsupportedChain && ((d = _.state.activeCaipNetwork) == null ? void 0 : d.name) === W.UNSUPPORTED_NETWORK_NAME ? _.showUnsupportedChainUI() : this.setCaipNetwork(p) : t || n && this.setCaipNetworkOfNamespace(n, o), this.syncConnectedWalletInfo(o), Nd.isLowerCaseMatch(s, X.state.address) || this.syncAccountInfo(s, p == null ? void 0 : p.id, o), t ? await this.syncBalance({ address: s, chainId: p == null ? void 0 : p.id, chainNamespace: o }) : await this.syncBalance({ address: s, chainId: n == null ? void 0 : n.id, chainNamespace: o });
    }
  }
  async syncAccountInfo(e, t, n) {
    const s = this.getCaipAddress(n), i = t || (s == null ? void 0 : s.split(":")[1]);
    if (!i)
      return;
    const o = `${n}:${i}:${e}`;
    this.setCaipAddress(o, n), await this.syncIdentity({
      address: e,
      chainId: i,
      chainNamespace: n
    });
  }
  async syncReownName(e, t) {
    try {
      const n = await this.getReownName(e);
      if (n[0]) {
        const s = n[0];
        this.setProfileName(s.name, t);
      } else
        this.setProfileName(null, t);
    } catch {
      this.setProfileName(null, t);
    }
  }
  syncConnectedWalletInfo(e) {
    var s;
    const t = re.getConnectorId(e), n = Ze.getProviderId(e);
    if (n === ft.CONNECTOR_TYPE_ANNOUNCED || n === ft.CONNECTOR_TYPE_INJECTED) {
      if (t) {
        const i = this.getConnectors().find((o) => o.id === t);
        if (i) {
          const { info: o, name: a, imageUrl: c } = i, l = c || this.getConnectorImage(i);
          this.setConnectedWalletInfo({ name: a, icon: l, ...o }, e);
        }
      }
    } else if (n === ft.CONNECTOR_TYPE_WALLET_CONNECT) {
      const i = Ze.getProvider(e);
      i != null && i.session && this.setConnectedWalletInfo({
        ...i.session.peer.metadata,
        name: i.session.peer.metadata.name,
        icon: (s = i.session.peer.metadata.icons) == null ? void 0 : s[0]
      }, e);
    } else if (t && t === W.CONNECTOR_ID.COINBASE) {
      const i = this.getConnectors().find((o) => o.id === W.CONNECTOR_ID.COINBASE);
      this.setConnectedWalletInfo({ name: "Coinbase Wallet", icon: this.getConnectorImage(i) }, e);
    }
  }
  async syncBalance(e) {
    !jC.getNetworksByNamespace(this.getCaipNetworks(), e.chainNamespace).find((n) => {
      var s;
      return n.id.toString() === ((s = e.chainId) == null ? void 0 : s.toString());
    }) || !e.chainId || await this.updateNativeBalance(e.address, e.chainId, e.chainNamespace);
  }
  async ready() {
    await this.readyPromise;
  }
  async updateNativeBalance(e, t, n) {
    const s = this.getAdapter(n), i = _.getCaipNetworkByNamespace(n, t);
    if (s) {
      const o = await s.getBalance({
        address: e,
        chainId: t,
        caipNetwork: i,
        tokens: this.options.tokens
      });
      return this.setBalance(o.balance, o.symbol, n), o;
    }
  }
  // -- Universal Provider ---------------------------------------------------
  async initializeUniversalAdapter() {
    var n, s, i, o, a, c, l, u, h, d;
    const e = dH.createLogger((f, ...g) => {
      f && this.handleAlertError(f), console.error(...g);
    }), t = {
      projectId: (n = this.options) == null ? void 0 : n.projectId,
      metadata: {
        name: (s = this.options) != null && s.metadata ? (i = this.options) == null ? void 0 : i.metadata.name : "",
        description: (o = this.options) != null && o.metadata ? (a = this.options) == null ? void 0 : a.metadata.description : "",
        url: (c = this.options) != null && c.metadata ? (l = this.options) == null ? void 0 : l.metadata.url : "",
        icons: (u = this.options) != null && u.metadata ? (h = this.options) == null ? void 0 : h.metadata.icons : [""]
      },
      logger: e
    };
    K.setManualWCControl(!!((d = this.options) != null && d.manualWCControl)), this.universalProvider = this.options.universalProvider ?? await lH.init(t), this.listenWalletConnect();
  }
  listenWalletConnect() {
    this.universalProvider && (this.universalProvider.on("display_uri", (e) => {
      ue.setUri(e);
    }), this.universalProvider.on("connect", ue.finalizeWcConnection), this.universalProvider.on("disconnect", () => {
      this.chainNamespaces.forEach((e) => {
        this.resetAccount(e);
      }), ue.resetWcConnection();
    }), this.universalProvider.on("chainChanged", (e) => {
      const t = this.getCaipNetworks().find((s) => s.id == e), n = this.getCaipNetwork();
      if (!t) {
        this.setUnsupportedNetwork(e);
        return;
      }
      (n == null ? void 0 : n.id) !== (t == null ? void 0 : t.id) && this.setCaipNetwork(t);
    }), this.universalProvider.on("session_event", (e) => {
      if (Up.isSessionEventData(e)) {
        const { name: t, data: n } = e.params.event;
        t === "accountsChanged" && Array.isArray(n) && me.isCaipAddress(n[0]) && this.syncAccount(tn.parseCaipAddress(n[0]));
      }
    }));
  }
  createUniversalProvider() {
    var e;
    return !this.universalProviderInitPromise && me.isClient() && ((e = this.options) != null && e.projectId) && (this.universalProviderInitPromise = this.initializeUniversalAdapter()), this.universalProviderInitPromise;
  }
  async getUniversalProvider() {
    if (!this.universalProvider)
      try {
        await this.createUniversalProvider();
      } catch (e) {
        ct.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: e instanceof Error ? e.message : "Unknown",
            uncaught: !1
          }
        }), console.error("AppKit:getUniversalProvider - Cannot create provider", e);
      }
    return this.universalProvider;
  }
  // - Utils -------------------------------------------------------------------
  handleAlertError(e) {
    const t = Object.entries(Rr.UniversalProviderErrors).find(([, { message: a }]) => e.message.includes(a)), [n, s] = t ?? [], { message: i, alertErrorKey: o } = s ?? {};
    if (n && i && !this.reportedAlertErrors[n]) {
      const a = Rr.ALERT_ERRORS[o];
      a && (Zr.open(a, "error"), this.reportedAlertErrors[n] = !0);
    }
  }
  getAdapter(e) {
    var t;
    if (e)
      return (t = this.chainAdapters) == null ? void 0 : t[e];
  }
  createAdapter(e) {
    var s;
    if (!e)
      return;
    const t = e.namespace;
    if (!t)
      return;
    this.createClients();
    const n = e;
    n.namespace = t, n.construct({
      namespace: t,
      projectId: (s = this.options) == null ? void 0 : s.projectId,
      networks: this.getCaipNetworks()
    }), this.chainNamespaces.includes(t) || this.chainNamespaces.push(t), this.chainAdapters && (this.chainAdapters[t] = n);
  }
  // -- Public -------------------------------------------------------------------
  async open(e) {
    if (await this.injectModalUi(), e != null && e.uri && ue.setUri(e.uri), e != null && e.arguments)
      switch (e == null ? void 0 : e.view) {
        case "Swap":
          return nt.open({ ...e, data: { swap: e.arguments } });
      }
    return nt.open(e);
  }
  async close() {
    await this.injectModalUi(), nt.close();
  }
  setLoading(e, t) {
    nt.setLoading(e, t);
  }
  async disconnect(e) {
    await ue.disconnect({ namespace: e });
  }
  getSIWX() {
    return K.state.siwx;
  }
  // -- review these -------------------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    var e;
    return (e = _.state.activeCaipNetwork) == null ? void 0 : e.id;
  }
  async switchNetwork(e) {
    const t = this.getCaipNetworks().find((n) => n.id === e.id);
    if (!t) {
      Zr.open(Rr.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await _.switchActiveNetwork(t);
  }
  getWalletProvider() {
    return _.state.activeChain ? Ze.state.providers[_.state.activeChain] : null;
  }
  getWalletProviderType() {
    return Ze.getProviderId(_.state.activeChain);
  }
  subscribeProviders(e) {
    return Ze.subscribeProviders(e);
  }
  getThemeMode() {
    return Xr.state.themeMode;
  }
  getThemeVariables() {
    return Xr.state.themeVariables;
  }
  setThemeMode(e) {
    Xr.setThemeMode(e), DS(Xr.state.themeMode);
  }
  setTermsConditionsUrl(e) {
    K.setTermsConditionsUrl(e);
  }
  setPrivacyPolicyUrl(e) {
    K.setPrivacyPolicyUrl(e);
  }
  setThemeVariables(e) {
    Xr.setThemeVariables(e), Zq(Xr.state.themeVariables);
  }
  subscribeTheme(e) {
    return Xr.subscribe(e);
  }
  subscribeConnections(e) {
    return ue.subscribe(e);
  }
  getWalletInfo() {
    return X.state.connectedWalletInfo;
  }
  getAccount(e) {
    var o;
    const t = re.getAuthConnector(e), n = _.getAccountData(e), s = _.state.activeChain, i = te.getConnectedConnectorId(e || s);
    if (n)
      return {
        allAccounts: n.allAccounts,
        caipAddress: n.caipAddress,
        address: me.getPlainAddress(n.caipAddress),
        isConnected: !!n.caipAddress,
        status: n.status,
        embeddedWalletInfo: t && i === W.CONNECTOR_ID.AUTH ? {
          user: n.user ? {
            ...n.user,
            /*
             * Getting the username from the chain controller works well for social logins,
             * but Farcaster uses a different connection flow and doesn't emit the username via events.
             * Since the username is stored in local storage before the chain controller updates,
             * it's safe to use the local storage value here.
             */
            username: te.getConnectedSocialUsername()
          } : void 0,
          authProvider: n.socialProvider || "email",
          accountType: (o = n.preferredAccountTypes) == null ? void 0 : o[e || s],
          isSmartAccountDeployed: !!n.smartAccountDeployed
        } : void 0
      };
  }
  subscribeAccount(e, t) {
    const n = () => {
      const s = this.getAccount(t);
      s && e(s);
    };
    t ? _.subscribeChainProp("accountState", n, t) : _.subscribe(n), re.subscribe(n);
  }
  subscribeNetwork(e) {
    return _.subscribe(({ activeCaipNetwork: t }) => {
      e({
        caipNetwork: t,
        chainId: t == null ? void 0 : t.id,
        caipNetworkId: t == null ? void 0 : t.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(e) {
    return X.subscribeKey("connectedWalletInfo", e);
  }
  subscribeShouldUpdateToAddress(e) {
    X.subscribeKey("shouldUpdateToAddress", e);
  }
  subscribeCaipNetworkChange(e) {
    _.subscribeKey("activeCaipNetwork", e);
  }
  getState() {
    return Js.state;
  }
  subscribeState(e) {
    return Js.subscribe(e);
  }
  showErrorMessage(e) {
    ds.showError(e);
  }
  showSuccessMessage(e) {
    ds.showSuccess(e);
  }
  getEvent() {
    return { ...ct.state };
  }
  subscribeEvents(e) {
    return ct.subscribe(e);
  }
  replace(e) {
    Ce.replace(e);
  }
  redirect(e) {
    Ce.push(e);
  }
  popTransactionStack(e) {
    Ce.popTransactionStack(e);
  }
  isOpen() {
    return nt.state.open;
  }
  isTransactionStackEmpty() {
    return Ce.state.transactionStack.length === 0;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(e) {
    K.setFeatures(e);
  }
  updateRemoteFeatures(e) {
    K.setRemoteFeatures(e);
  }
  updateOptions(e) {
    const n = { ...K.state || {}, ...e };
    K.setOptions(n);
  }
  setConnectMethodsOrder(e) {
    K.setConnectMethodsOrder(e);
  }
  setWalletFeaturesOrder(e) {
    K.setWalletFeaturesOrder(e);
  }
  setCollapseWallets(e) {
    K.setCollapseWallets(e);
  }
  setSocialsOrder(e) {
    K.setSocialsOrder(e);
  }
  getConnectMethodsOrder() {
    return Gy.getConnectOrderMethod(K.state.features, re.getConnectors());
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(e, t) {
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`);
    const n = this.extendCaipNetwork(t, this.options);
    this.getCaipNetworks().find((s) => s.id === n.id) || _.addNetwork(n);
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(e, t) {
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`);
    this.getCaipNetworks().find((s) => s.id === t) && _.removeNetwork(e, t);
  }
}
let SA = !1;
class iW extends sW {
  // -- Private ------------------------------------------------------------------
  setupAuthConnectorListeners(e) {
    e.onRpcRequest((t) => {
      Cn.checkIfRequestExists(t) ? Cn.checkIfRequestIsSafe(t) || this.handleUnsafeRPCRequest() : (this.open(), console.error(rr.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
        method: t.method
      }), setTimeout(() => {
        this.showErrorMessage(rr.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
      }, 300), e.rejectRpcRequests());
    }), e.onRpcError(() => {
      this.isOpen() && (this.isTransactionStackEmpty() ? this.close() : this.popTransactionStack("error"));
    }), e.onRpcSuccess((t, n) => {
      const s = Cn.checkIfRequestIsSafe(n), i = X.state.address, o = _.state.activeCaipNetwork;
      s || (i && (o != null && o.id) && this.updateNativeBalance(i, o.id, o.chainNamespace), this.isTransactionStackEmpty() ? this.close() : this.popTransactionStack("success"));
    }), e.onNotConnected(() => {
      const t = _.state.activeChain;
      re.getConnectorId(t) === W.CONNECTOR_ID.AUTH && (this.setCaipAddress(void 0, t), this.setLoading(!1, t));
    }), e.onConnect((t) => {
      var l, u;
      const n = _.state.activeChain, s = n === W.CHAIN.EVM ? `eip155:${t.chainId}:${t.address}` : `${t.chainId}:${t.address}`, i = K.state.defaultAccountTypes[n], o = (l = X.state.preferredAccountTypes) == null ? void 0 : l[n], a = t.preferredAccountType || o || i;
      Nd.isLowerCaseMatch(t.address, X.state.address) || this.syncIdentity({
        address: t.address,
        chainId: t.chainId,
        chainNamespace: n
      }), this.setCaipAddress(s, n), this.setUser({ ...X.state.user || {}, ...t }, n), this.setSmartAccountDeployed(!!t.smartAccountDeployed, n), this.setPreferredAccountType(a, n);
      const c = (u = t.accounts) == null ? void 0 : u.map((h) => me.createAccount(n, h.address, h.type || o || i));
      this.setAllAccounts(c || [
        me.createAccount(n, t.address, t.preferredAccountType || a)
      ], n), this.setLoading(!1, n);
    }), e.onSocialConnected(({ userName: t }) => {
      this.setUser({ ...X.state.user || {}, username: t }, _.state.activeChain);
    }), e.onGetSmartAccountEnabledNetworks((t) => {
      this.setSmartAccountEnabledNetworks(t, _.state.activeChain);
    }), e.onSetPreferredAccount(({ address: t, type: n }) => {
      t && this.setPreferredAccountType(n, _.state.activeChain);
    });
  }
  async syncAuthConnector(e, t) {
    var h, d, f, g;
    const n = W.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(t), s = t === _.state.activeChain;
    if (!n)
      return;
    this.setLoading(!0, t);
    const i = e.getLoginEmailUsed();
    this.setLoading(i, t), i && this.setStatus("connecting", t);
    const o = e.getEmail(), a = e.getUsername();
    this.setUser({ ...((h = X.state) == null ? void 0 : h.user) || {}, username: a, email: o }, t), this.setupAuthConnectorListeners(e);
    const { isConnected: c } = await e.isConnected(), l = Xr.getSnapshot(), u = K.getSnapshot();
    await Promise.all([
      e.syncDappData({
        metadata: u.metadata,
        sdkVersion: u.sdkVersion,
        projectId: u.projectId,
        sdkType: u.sdkType
      }),
      e.syncTheme({
        themeMode: l.themeMode,
        themeVariables: l.themeVariables,
        w3mThemeVariables: Ri(l.themeVariables, l.themeMode)
      })
    ]), await e.getSmartAccountEnabledNetworks(), t && n && s && (c && ((d = this.connectionControllerClient) != null && d.connectExternal) ? (await ((g = this.connectionControllerClient) == null ? void 0 : g.connectExternal({
      id: W.CONNECTOR_ID.AUTH,
      info: { name: W.CONNECTOR_ID.AUTH },
      type: ft.CONNECTOR_TYPE_AUTH,
      provider: e,
      chainId: (f = _.state.activeCaipNetwork) == null ? void 0 : f.id,
      chain: t
    })), this.setStatus("connected", t)) : re.getConnectorId(t) === W.CONNECTOR_ID.AUTH && (this.setStatus("disconnected", t), te.removeConnectedNamespace(t))), this.setLoading(!1, t);
  }
  async checkExistingTelegramSocialConnection(e) {
    var t;
    try {
      if (!me.isTelegram())
        return;
      const n = te.getTelegramSocialProvider();
      if (!n || !me.isClient())
        return;
      const i = new URL(window.location.href).searchParams.get("result_uri");
      if (!i)
        return;
      X.setSocialProvider(n, e), await ((t = this.authProvider) == null ? void 0 : t.init());
      const o = re.getAuthConnector();
      n && o && (this.setLoading(!0, e), await ue.connectExternal({
        id: o.id,
        type: o.type,
        socialUri: i
      }, o.chain), te.setConnectedSocialProvider(n), te.removeTelegramSocialProvider(), ct.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_SUCCESS",
        properties: { provider: n }
      }));
    } catch (n) {
      this.setLoading(!1, e), console.error("checkExistingSTelegramocialConnection error", n);
    }
    try {
      const n = new URL(window.location.href);
      n.searchParams.delete("result_uri"), window.history.replaceState({}, document.title, n.toString());
    } catch (n) {
      console.error("tma social login failed", n);
    }
  }
  createAuthProvider(e) {
    var l, u, h, d;
    if (!W.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e))
      return;
    const n = (l = this.remoteFeatures) == null ? void 0 : l.email, s = Array.isArray((u = this.remoteFeatures) == null ? void 0 : u.socials) && this.remoteFeatures.socials.length > 0, i = n || s, a = Nd.getActiveNamespaceConnectedToAuth() || e;
    !this.authProvider && ((h = this.options) != null && h.projectId) && i && (this.authProvider = zh.getInstance({
      projectId: this.options.projectId,
      enableLogger: this.options.enableAuthLogger,
      chainId: (d = this.getCaipNetwork(a)) == null ? void 0 : d.caipNetworkId,
      abortController: Rr.EmbeddedWalletAbortController,
      onTimeout: (f) => {
        f === "iframe_load_failed" ? Zr.open(Rr.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error") : f === "iframe_request_timeout" ? Zr.open(Rr.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error") : f === "unverified_domain" && Zr.open(Rr.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
      }
    }), Js.subscribeOpen((f) => {
      var g;
      !f && this.isTransactionStackEmpty() && ((g = this.authProvider) == null || g.rejectRpcRequests());
    }));
    const c = e === _.state.activeChain;
    this.authProvider && c && (this.syncAuthConnector(this.authProvider, e), this.checkExistingTelegramSocialConnection(e));
  }
  createAuthProviderForAdapter(e) {
    var t, n, s;
    this.createAuthProvider(e), this.authProvider && ((s = (n = (t = this.chainAdapters) == null ? void 0 : t[e]) == null ? void 0 : n.setAuthProvider) == null || s.call(n, this.authProvider));
  }
  // -- Overrides ----------------------------------------------------------------
  initControllers(e) {
    super.initControllers(e), this.options.excludeWalletIds && ye.initializeExcludedWallets({ ids: this.options.excludeWalletIds });
  }
  async switchCaipNetwork(e) {
    var o, a;
    if (!e)
      return;
    const t = _.state.activeChain, n = e.chainNamespace, s = this.getAddressByChainNamespace(n);
    if (n === t && s) {
      const c = this.getAdapter(n), l = Ze.getProvider(n), u = Ze.getProviderId(n);
      await (c == null ? void 0 : c.switchNetwork({ caipNetwork: e, provider: l, providerType: u })), this.setCaipNetwork(e);
    } else {
      const l = Ze.getProviderId(t) === ft.CONNECTOR_TYPE_AUTH, u = Ze.getProviderId(n), h = u === ft.CONNECTOR_TYPE_AUTH, d = W.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(n);
      if ((l && u === void 0 || h) && d)
        try {
          if (_.state.activeChain = e.chainNamespace, s) {
            const f = this.getAdapter(n);
            await (f == null ? void 0 : f.switchNetwork({
              caipNetwork: e,
              provider: this.authProvider,
              providerType: u
            }));
          } else
            await ((a = (o = this.connectionControllerClient) == null ? void 0 : o.connectExternal) == null ? void 0 : a.call(o, {
              id: W.CONNECTOR_ID.AUTH,
              provider: this.authProvider,
              chain: n,
              chainId: e.id,
              type: ft.CONNECTOR_TYPE_AUTH,
              caipNetwork: e
            }));
          this.setCaipNetwork(e);
        } catch {
          const g = this.getAdapter(n);
          await (g == null ? void 0 : g.switchNetwork({
            caipNetwork: e,
            provider: this.authProvider,
            providerType: u
          }));
        }
      else u === ft.CONNECTOR_TYPE_WALLET_CONNECT ? (this.setCaipNetwork(e), this.syncWalletConnectAccount()) : (this.setCaipNetwork(e), s && this.syncAccount({
        address: s,
        chainId: e.id,
        chainNamespace: n
      }));
    }
  }
  async initialize(e) {
    var t;
    await super.initialize(e), (t = this.chainNamespaces) == null || t.forEach((n) => {
      this.createAuthProviderForAdapter(n);
    }), await this.injectModalUi(), Js.set({ initialized: !0 });
  }
  async syncIdentity({ address: e, chainId: t, chainNamespace: n }) {
    var o;
    const s = `${n}:${t}`, i = (o = this.caipNetworks) == null ? void 0 : o.find((a) => a.caipNetworkId === s);
    if (n !== W.CHAIN.EVM || i != null && i.testnet) {
      this.setProfileName(null, n), this.setProfileImage(null, n);
      return;
    }
    try {
      const { name: a, avatar: c } = await this.fetchIdentity({
        address: e,
        caipNetworkId: s
      });
      this.setProfileName(a, n), this.setProfileImage(c, n);
    } catch {
      await this.syncReownName(e, n), t !== 1 && this.setProfileImage(null, n);
    }
  }
  syncConnectedWalletInfo(e) {
    const t = Ze.getProviderId(e);
    if (t === ft.CONNECTOR_TYPE_AUTH) {
      const n = this.authProvider;
      if (n) {
        const s = te.getConnectedSocialProvider() ?? "email", i = n.getEmail() ?? n.getUsername();
        this.setConnectedWalletInfo({ name: t, identifier: i, social: s }, e);
      }
    } else
      super.syncConnectedWalletInfo(e);
  }
  async injectModalUi() {
    if (me.isClient() && !SA)
      try {
        const e = { ...at.DEFAULT_FEATURES, ...this.options.features }, t = this.remoteFeatures;
        if (await this.loadModalComponents(e, t), me.isClient() && !document.querySelector("w3m-modal")) {
          const s = document.createElement("w3m-modal");
          !K.state.disableAppend && !K.state.enableEmbedded && document.body.insertAdjacentElement("beforeend", s);
        }
        SA = !0;
      } catch (e) {
        console.error("Error injecting modal UI:", e);
      }
  }
  // This separate method helps with tree-shaking for SSR builds
  async loadModalComponents(e, t) {
    if (!me.isClient())
      return;
    const n = [];
    (t.email || t.socials && t.socials.length > 0) && n.push(import("./embedded-wallet-BhYz7-ax.mjs")), t.email && n.push(import("./email-kK272-zW.mjs")), t.socials && n.push(import("./socials-DokVix-q.mjs")), t.swaps && t.swaps.length > 0 && n.push(import("./swaps-CfbMFtFp.mjs")), e.send && n.push(import("./send-Funw705x.mjs")), e.receive && n.push(import("./receive-P_CpRhWV.mjs")), t.onramp && t.onramp.length > 0 && n.push(import("./onramp-DgdTOGvl.mjs")), t.activity && n.push(import("./transactions-CcDaWqdt.mjs")), e.pay && n.push(import("./index-B_VPkXxA.mjs")), await Promise.all([
      ...n,
      import("./index-YIKg1cpS.mjs"),
      import("./w3m-modal-DUJKQvie.mjs")
    ]);
  }
}
const oW = "1.7.9";
function tQ(r) {
  return new iW({
    ...r,
    sdkVersion: me.generateSdkVersion(r.adapters ?? [], "html", oW)
  });
}
const aW = "6.14.4";
function cW(r, e, t) {
  const n = e.split("|").map((i) => i.trim());
  for (let i = 0; i < n.length; i++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof r === e)
          return;
    }
  const s = new Error(`invalid value for type ${e}`);
  throw s.code = "INVALID_ARGUMENT", s.argument = `value.${t}`, s.value = r, s;
}
async function Dr(r) {
  const e = Object.keys(r);
  return (await Promise.all(e.map((n) => Promise.resolve(r[n])))).reduce((n, s, i) => (n[e[i]] = s, n), {});
}
function Ae(r, e, t) {
  for (let n in e) {
    let s = e[n];
    const i = t ? t[n] : null;
    i && cW(s, i, n), Object.defineProperty(r, n, { enumerable: !0, value: s, writable: !1 });
  }
}
function pl(r, e) {
  if (r == null)
    return "null";
  if (e == null && (e = /* @__PURE__ */ new Set()), typeof r == "object") {
    if (e.has(r))
      return "[Circular]";
    e.add(r);
  }
  if (Array.isArray(r))
    return "[ " + r.map((t) => pl(t, e)).join(", ") + " ]";
  if (r instanceof Uint8Array) {
    const t = "0123456789abcdef";
    let n = "0x";
    for (let s = 0; s < r.length; s++)
      n += t[r[s] >> 4], n += t[r[s] & 15];
    return n;
  }
  if (typeof r == "object" && typeof r.toJSON == "function")
    return pl(r.toJSON(), e);
  switch (typeof r) {
    case "boolean":
    case "number":
    case "symbol":
      return r.toString();
    case "bigint":
      return BigInt(r).toString();
    case "string":
      return JSON.stringify(r);
    case "object": {
      const t = Object.keys(r);
      return t.sort(), "{ " + t.map((n) => `${pl(n, e)}: ${pl(r[n], e)}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function hr(r, e) {
  return r && r.code === e;
}
function Ib(r) {
  return hr(r, "CALL_EXCEPTION");
}
function St(r, e, t) {
  let n = r;
  {
    const i = [];
    if (t) {
      if ("message" in t || "code" in t || "name" in t)
        throw new Error(`value will overwrite populated values: ${pl(t)}`);
      for (const o in t) {
        if (o === "shortMessage")
          continue;
        const a = t[o];
        i.push(o + "=" + pl(a));
      }
    }
    i.push(`code=${e}`), i.push(`version=${aW}`), i.length && (r += " (" + i.join(", ") + ")");
  }
  let s;
  switch (e) {
    case "INVALID_ARGUMENT":
      s = new TypeError(r);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s = new RangeError(r);
      break;
    default:
      s = new Error(r);
  }
  return Ae(s, { code: e }), t && Object.assign(s, t), s.shortMessage == null && Ae(s, { shortMessage: n }), s;
}
function z(r, e, t, n) {
  if (!r)
    throw St(e, t, n);
}
function D(r, e, t, n) {
  z(r, e, "INVALID_ARGUMENT", { argument: t, value: n });
}
function US(r, e, t) {
  t == null && (t = ""), t && (t = ": " + t), z(r >= e, "missing argument" + t, "MISSING_ARGUMENT", {
    count: r,
    expectedCount: e
  }), z(r <= e, "too many arguments" + t, "UNEXPECTED_ARGUMENT", {
    count: r,
    expectedCount: e
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((r, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    r.push(e);
  } catch {
  }
  return r;
}, []);
function Df(r, e, t) {
  if (t == null && (t = ""), r !== e) {
    let n = t, s = "new";
    t && (n += ".", s += " " + t), z(!1, `private constructor; use ${n}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: s
    });
  }
}
function BS(r, e, t) {
  if (r instanceof Uint8Array)
    return t ? new Uint8Array(r) : r;
  if (typeof r == "string" && r.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const n = new Uint8Array((r.length - 2) / 2);
    let s = 2;
    for (let i = 0; i < n.length; i++)
      n[i] = parseInt(r.substring(s, s + 2), 16), s += 2;
    return n;
  }
  D(!1, "invalid BytesLike value", e || "value", r);
}
function Le(r, e) {
  return BS(r, e, !1);
}
function kr(r, e) {
  return BS(r, e, !0);
}
function wt(r, e) {
  return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && r.length !== 2 + 2 * e || e === !0 && r.length % 2 !== 0);
}
function Sb(r) {
  return wt(r, !0) || r instanceof Uint8Array;
}
const NA = "0123456789abcdef";
function se(r) {
  const e = Le(r);
  let t = "0x";
  for (let n = 0; n < e.length; n++) {
    const s = e[n];
    t += NA[(s & 240) >> 4] + NA[s & 15];
  }
  return t;
}
function Pt(r) {
  return "0x" + r.map((e) => se(e).substring(2)).join("");
}
function Il(r) {
  return wt(r, !0) ? (r.length - 2) / 2 : Le(r).length;
}
function Ot(r, e, t) {
  const n = Le(r);
  return t != null && t > n.length && z(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: n,
    length: n.length,
    offset: t
  }), se(n.slice(e ?? 0, t ?? n.length));
}
function LS(r, e, t) {
  const n = Le(r);
  z(e >= n.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(n),
    length: e,
    offset: e + 1
  });
  const s = new Uint8Array(e);
  return s.fill(0), t ? s.set(n, e - n.length) : s.set(n, 0), se(s);
}
function Hi(r, e) {
  return LS(r, e, !0);
}
function lW(r, e) {
  return LS(r, e, !1);
}
const am = BigInt(0), fs = BigInt(1), gl = 9007199254740991;
function Eg(r, e) {
  const t = cm(r, "value"), n = BigInt(De(e, "width"));
  if (z(t >> n === am, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: r
  }), t >> n - fs) {
    const s = (fs << n) - fs;
    return -((~t & s) + fs);
  }
  return t;
}
function FS(r, e) {
  let t = ge(r, "value");
  const n = BigInt(De(e, "width")), s = fs << n - fs;
  if (t < am) {
    t = -t, z(t <= s, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
    const i = (fs << n) - fs;
    return (~t & i) + fs;
  } else
    z(t < s, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
  return t;
}
function Oa(r, e) {
  const t = cm(r, "value"), n = BigInt(De(e, "bits"));
  return t & (fs << n) - fs;
}
function ge(r, e) {
  switch (typeof r) {
    case "bigint":
      return r;
    case "number":
      return D(Number.isInteger(r), "underflow", e || "value", r), D(r >= -gl && r <= gl, "overflow", e || "value", r), BigInt(r);
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return r[0] === "-" && r[1] !== "-" ? -BigInt(r.substring(1)) : BigInt(r);
      } catch (t) {
        D(!1, `invalid BigNumberish string: ${t.message}`, e || "value", r);
      }
  }
  D(!1, "invalid BigNumberish value", e || "value", r);
}
function cm(r, e) {
  const t = ge(r, e);
  return z(t >= am, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: r
  }), t;
}
const TA = "0123456789abcdef";
function lm(r) {
  if (r instanceof Uint8Array) {
    let e = "0x0";
    for (const t of r)
      e += TA[t >> 4], e += TA[t & 15];
    return BigInt(e);
  }
  return ge(r);
}
function De(r, e) {
  switch (typeof r) {
    case "bigint":
      return D(r >= -gl && r <= gl, "overflow", e || "value", r), Number(r);
    case "number":
      return D(Number.isInteger(r), "underflow", e || "value", r), D(r >= -gl && r <= gl, "overflow", e || "value", r), r;
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return De(BigInt(r), e);
      } catch (t) {
        D(!1, `invalid numeric string: ${t.message}`, e || "value", r);
      }
  }
  D(!1, "invalid numeric value", e || "value", r);
}
function uW(r) {
  return De(lm(r));
}
function Qo(r, e) {
  let n = cm(r, "value").toString(16);
  if (e == null)
    n.length % 2 && (n = "0" + n);
  else {
    const s = De(e, "width");
    for (z(s * 2 >= n.length, `value exceeds width (${s} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: r
    }); n.length < s * 2; )
      n = "0" + n;
  }
  return "0x" + n;
}
function qt(r) {
  const e = cm(r, "value");
  if (e === am)
    return new Uint8Array([]);
  let t = e.toString(16);
  t.length % 2 && (t = "0" + t);
  const n = new Uint8Array(t.length / 2);
  for (let s = 0; s < n.length; s++) {
    const i = s * 2;
    n[s] = parseInt(t.substring(i, i + 2), 16);
  }
  return n;
}
function hs(r) {
  let e = se(Sb(r) ? r : qt(r)).substring(2);
  for (; e.startsWith("0"); )
    e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
const xA = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const OA = BigInt(58);
function hW(r) {
  const e = Le(r);
  let t = lm(e), n = "";
  for (; t; )
    n = xA[Number(t % OA)] + n, t /= OA;
  for (let s = 0; s < e.length && !e[s]; s++)
    n = xA[0] + n;
  return n;
}
function dW(r) {
  r = atob(r);
  const e = new Uint8Array(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return Le(e);
}
function fW(r) {
  const e = Le(r);
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += String.fromCharCode(e[n]);
  return btoa(t);
}
var Rl;
class $S {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(e, t, n) {
    /**
     *  The event filter.
     */
    F(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    F(this, "emitter");
    M(this, Rl);
    S(this, Rl, t), Ae(this, { emitter: e, filter: n });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    m(this, Rl) != null && await this.emitter.off(this.filter, m(this, Rl));
  }
}
Rl = new WeakMap();
function pW(r, e, t, n, s) {
  D(!1, `invalid codepoint at offset ${e}; ${r}`, "bytes", t);
}
function MS(r, e, t, n, s) {
  if (r === "BAD_PREFIX" || r === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = e + 1; o < t.length && t[o] >> 6 === 2; o++)
      i++;
    return i;
  }
  return r === "OVERRUN" ? t.length - e - 1 : 0;
}
function gW(r, e, t, n, s) {
  return r === "OVERLONG" ? (D(typeof s == "number", "invalid bad code point for replacement", "badCodepoint", s), n.push(s), 0) : (n.push(65533), MS(r, e, t));
}
const mW = Object.freeze({
  error: pW,
  ignore: MS,
  replace: gW
});
function wW(r, e) {
  e == null && (e = mW.error);
  const t = Le(r, "bytes"), n = [];
  let s = 0;
  for (; s < t.length; ) {
    const i = t[s++];
    if (!(i >> 7)) {
      n.push(i);
      continue;
    }
    let o = null, a = null;
    if ((i & 224) === 192)
      o = 1, a = 127;
    else if ((i & 240) === 224)
      o = 2, a = 2047;
    else if ((i & 248) === 240)
      o = 3, a = 65535;
    else {
      (i & 192) === 128 ? s += e("UNEXPECTED_CONTINUE", s - 1, t, n) : s += e("BAD_PREFIX", s - 1, t, n);
      continue;
    }
    if (s - 1 + o >= t.length) {
      s += e("OVERRUN", s - 1, t, n);
      continue;
    }
    let c = i & (1 << 8 - o - 1) - 1;
    for (let l = 0; l < o; l++) {
      let u = t[s];
      if ((u & 192) != 128) {
        s += e("MISSING_CONTINUE", s, t, n), c = null;
        break;
      }
      c = c << 6 | u & 63, s++;
    }
    if (c !== null) {
      if (c > 1114111) {
        s += e("OUT_OF_RANGE", s - 1 - o, t, n, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        s += e("UTF16_SURROGATE", s - 1 - o, t, n, c);
        continue;
      }
      if (c <= a) {
        s += e("OVERLONG", s - 1 - o, t, n, c);
        continue;
      }
      n.push(c);
    }
  }
  return n;
}
function Zs(r, e) {
  D(typeof r == "string", "invalid string value", "str", r);
  let t = [];
  for (let n = 0; n < r.length; n++) {
    const s = r.charCodeAt(n);
    if (s < 128)
      t.push(s);
    else if (s < 2048)
      t.push(s >> 6 | 192), t.push(s & 63 | 128);
    else if ((s & 64512) == 55296) {
      n++;
      const i = r.charCodeAt(n);
      D(n < r.length && (i & 64512) === 56320, "invalid surrogate pair", "str", r);
      const o = 65536 + ((s & 1023) << 10) + (i & 1023);
      t.push(o >> 18 | 240), t.push(o >> 12 & 63 | 128), t.push(o >> 6 & 63 | 128), t.push(o & 63 | 128);
    } else
      t.push(s >> 12 | 224), t.push(s >> 6 & 63 | 128), t.push(s & 63 | 128);
  }
  return new Uint8Array(t);
}
function yW(r) {
  return r.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function vg(r, e) {
  return yW(wW(r, e));
}
function jS(r) {
  async function e(t, n) {
    z(n == null || !n.cancelled, "request cancelled before sending", "CANCELLED");
    const s = t.url.split(":")[0].toLowerCase();
    z(s === "http" || s === "https", `unsupported protocol ${s}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: s },
      operation: "request"
    }), z(s === "https" || !t.credentials || t.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let i = null;
    const o = new AbortController(), a = setTimeout(() => {
      i = St("request timeout", "TIMEOUT"), o.abort();
    }, t.timeout);
    n && n.addListener(() => {
      i = St("request cancelled", "CANCELLED"), o.abort();
    });
    const c = Object.assign({}, r, {
      method: t.method,
      headers: new Headers(Array.from(t)),
      body: t.body || void 0,
      signal: o.signal
    });
    let l;
    try {
      l = await fetch(t.url, c);
    } catch (f) {
      throw clearTimeout(a), i || f;
    }
    clearTimeout(a);
    const u = {};
    l.headers.forEach((f, g) => {
      u[g.toLowerCase()] = f;
    });
    const h = await l.arrayBuffer(), d = h == null ? null : new Uint8Array(h);
    return {
      statusCode: l.status,
      statusMessage: l.statusText,
      headers: u,
      body: d
    };
  }
  return e;
}
const bW = 12, EW = 250;
let PA = jS();
const vW = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), AW = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let Nw = !1;
async function HS(r, e) {
  try {
    const t = r.match(vW);
    if (!t)
      throw new Error("invalid data");
    return new Wo(200, "OK", {
      "content-type": t[1] || "text/plain"
    }, t[2] ? dW(t[3]) : _W(t[3]));
  } catch {
    return new Wo(599, "BAD REQUEST (invalid data: URI)", {}, null, new zi(r));
  }
}
function zS(r) {
  async function e(t, n) {
    try {
      const s = t.match(AW);
      if (!s)
        throw new Error("invalid link");
      return new zi(`${r}${s[2]}`);
    } catch {
      return new Wo(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new zi(t));
    }
  }
  return e;
}
const fp = {
  data: HS,
  ipfs: zS("https://gateway.ipfs.io/ipfs/")
}, qS = /* @__PURE__ */ new WeakMap();
var ka, Eo;
class CW {
  constructor(e) {
    M(this, ka);
    M(this, Eo);
    S(this, ka, []), S(this, Eo, !1), qS.set(e, () => {
      if (!m(this, Eo)) {
        S(this, Eo, !0);
        for (const t of m(this, ka))
          setTimeout(() => {
            t();
          }, 0);
        S(this, ka, []);
      }
    });
  }
  addListener(e) {
    z(!m(this, Eo), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), m(this, ka).push(e);
  }
  get cancelled() {
    return m(this, Eo);
  }
  checkSignal() {
    z(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
ka = new WeakMap(), Eo = new WeakMap();
function pp(r) {
  if (r == null)
    throw new Error("missing signal; should not happen");
  return r.checkSignal(), r;
}
var Dl, kl, ss, yi, Ul, Bl, Jt, yn, bi, Ua, Ba, La, Ds, is, vo, Fa, Th;
const kg = class kg {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(e) {
    M(this, Fa);
    M(this, Dl);
    M(this, kl);
    M(this, ss);
    M(this, yi);
    M(this, Ul);
    M(this, Bl);
    M(this, Jt);
    M(this, yn);
    M(this, bi);
    // Hooks
    M(this, Ua);
    M(this, Ba);
    M(this, La);
    M(this, Ds);
    M(this, is);
    M(this, vo);
    S(this, Bl, String(e)), S(this, Dl, !1), S(this, kl, !0), S(this, ss, {}), S(this, yi, ""), S(this, Ul, 3e5), S(this, is, {
      slotInterval: EW,
      maxAttempts: bW
    }), S(this, vo, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return m(this, Bl);
  }
  set url(e) {
    S(this, Bl, String(e));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return m(this, Jt) == null ? null : new Uint8Array(m(this, Jt));
  }
  set body(e) {
    if (e == null)
      S(this, Jt, void 0), S(this, yn, void 0);
    else if (typeof e == "string")
      S(this, Jt, Zs(e)), S(this, yn, "text/plain");
    else if (e instanceof Uint8Array)
      S(this, Jt, e), S(this, yn, "application/octet-stream");
    else if (typeof e == "object")
      S(this, Jt, Zs(JSON.stringify(e))), S(this, yn, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return m(this, Jt) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return m(this, yi) ? m(this, yi) : this.hasBody() ? "POST" : "GET";
  }
  set method(e) {
    e == null && (e = ""), S(this, yi, String(e).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const e = Object.assign({}, m(this, ss));
    return m(this, bi) && (e.authorization = `Basic ${fW(Zs(m(this, bi)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && m(this, yn) && (e["content-type"] = m(this, yn)), this.body && (e["content-length"] = String(this.body.length)), e;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(e, t) {
    m(this, ss)[String(e).toLowerCase()] = String(t);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    S(this, ss, {});
  }
  [Symbol.iterator]() {
    const e = this.headers, t = Object.keys(e);
    let n = 0;
    return {
      next: () => {
        if (n < t.length) {
          const s = t[n++];
          return {
            value: [s, e[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return m(this, bi) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(e, t) {
    D(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), S(this, bi, `${e}:${t}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return m(this, kl);
  }
  set allowGzip(e) {
    S(this, kl, !!e);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!m(this, Dl);
  }
  set allowInsecureAuthentication(e) {
    S(this, Dl, !!e);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return m(this, Ul);
  }
  set timeout(e) {
    D(e >= 0, "timeout must be non-zero", "timeout", e), S(this, Ul, e);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return m(this, Ua) || null;
  }
  set preflightFunc(e) {
    S(this, Ua, e);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return m(this, Ba) || null;
  }
  set processFunc(e) {
    S(this, Ba, e);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return m(this, La) || null;
  }
  set retryFunc(e) {
    S(this, La, e);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return m(this, vo) || PA;
  }
  set getUrlFunc(e) {
    S(this, vo, e);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${m(this, Jt) ? se(m(this, Jt)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(e) {
    e.slotInterval != null && (m(this, is).slotInterval = e.slotInterval), e.maxAttempts != null && (m(this, is).maxAttempts = e.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return z(m(this, Ds) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), S(this, Ds, new CW(this)), V(this, Fa, Th).call(this, 0, RA() + this.timeout, 0, this, new Wo(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    z(m(this, Ds) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const e = qS.get(this);
    if (!e)
      throw new Error("missing signal; should not happen");
    e();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(e) {
    const t = this.url.split(":")[0].toLowerCase(), n = e.split(":")[0].toLowerCase();
    z(this.method === "GET" && (t !== "https" || n !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
    });
    const s = new kg(e);
    return s.method = "GET", s.allowGzip = this.allowGzip, s.timeout = this.timeout, S(s, ss, Object.assign({}, m(this, ss))), m(this, Jt) && S(s, Jt, new Uint8Array(m(this, Jt))), S(s, yn, m(this, yn)), s;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const e = new kg(this.url);
    return S(e, yi, m(this, yi)), m(this, Jt) && S(e, Jt, m(this, Jt)), S(e, yn, m(this, yn)), S(e, ss, Object.assign({}, m(this, ss))), S(e, bi, m(this, bi)), this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), S(e, Ua, m(this, Ua)), S(e, Ba, m(this, Ba)), S(e, La, m(this, La)), S(e, is, Object.assign({}, m(this, is))), S(e, vo, m(this, vo)), e;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    Nw = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(e) {
    return fp[e.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(e, t) {
    if (e = e.toLowerCase(), e === "http" || e === "https")
      throw new Error(`cannot intercept ${e}; use registerGetUrl`);
    if (Nw)
      throw new Error("gateways locked");
    fp[e] = t;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(e) {
    if (Nw)
      throw new Error("gateways locked");
    PA = e;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(e) {
    return jS(e);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return HS;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(e) {
    return zS(e);
  }
};
Dl = new WeakMap(), kl = new WeakMap(), ss = new WeakMap(), yi = new WeakMap(), Ul = new WeakMap(), Bl = new WeakMap(), Jt = new WeakMap(), yn = new WeakMap(), bi = new WeakMap(), Ua = new WeakMap(), Ba = new WeakMap(), La = new WeakMap(), Ds = new WeakMap(), is = new WeakMap(), vo = new WeakMap(), Fa = new WeakSet(), Th = async function(e, t, n, s, i) {
  var u, h, d;
  if (e >= m(this, is).maxAttempts)
    return i.makeServerError("exceeded maximum retry limit");
  z(RA() <= t, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: s
  }), n > 0 && await IW(n);
  let o = this.clone();
  const a = (o.url.split(":")[0] || "").toLowerCase();
  if (a in fp) {
    const f = await fp[a](o.url, pp(m(s, Ds)));
    if (f instanceof Wo) {
      let g = f;
      if (this.processFunc) {
        pp(m(s, Ds));
        try {
          g = await this.processFunc(o, g);
        } catch (p) {
          (p.throttle == null || typeof p.stall != "number") && g.makeServerError("error in post-processing function", p).assertOk();
        }
      }
      return g;
    }
    o = f;
  }
  this.preflightFunc && (o = await this.preflightFunc(o));
  const c = await this.getUrlFunc(o, pp(m(s, Ds)));
  let l = new Wo(c.statusCode, c.statusMessage, c.headers, c.body, s);
  if (l.statusCode === 301 || l.statusCode === 302) {
    try {
      const f = l.headers.location || "";
      return V(u = o.redirect(f), Fa, Th).call(u, e + 1, t, 0, s, l);
    } catch {
    }
    return l;
  } else if (l.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(o, l, e))) {
    const f = l.headers["retry-after"];
    let g = m(this, is).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
    return typeof f == "string" && f.match(/^[1-9][0-9]*$/) && (g = parseInt(f)), V(h = o.clone(), Fa, Th).call(h, e + 1, t, g, s, l);
  }
  if (this.processFunc) {
    pp(m(s, Ds));
    try {
      l = await this.processFunc(o, l);
    } catch (f) {
      (f.throttle == null || typeof f.stall != "number") && l.makeServerError("error in post-processing function", f).assertOk();
      let g = m(this, is).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
      return f.stall >= 0 && (g = f.stall), V(d = o.clone(), Fa, Th).call(d, e + 1, t, g, s, l);
    }
  }
  return l;
};
let zi = kg;
var ef, tf, rf, bn, Ll, $a;
const qb = class qb {
  constructor(e, t, n, s, i) {
    M(this, ef);
    M(this, tf);
    M(this, rf);
    M(this, bn);
    M(this, Ll);
    M(this, $a);
    S(this, ef, e), S(this, tf, t), S(this, rf, Object.keys(n).reduce((o, a) => (o[a.toLowerCase()] = String(n[a]), o), {})), S(this, bn, s == null ? null : new Uint8Array(s)), S(this, Ll, i || null), S(this, $a, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${m(this, bn) ? se(m(this, bn)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return m(this, ef);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return m(this, tf);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, m(this, rf));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return m(this, bn) == null ? null : new Uint8Array(m(this, bn));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return m(this, bn) == null ? "" : vg(m(this, bn));
    } catch {
      z(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      z(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const e = this.headers, t = Object.keys(e);
    let n = 0;
    return {
      next: () => {
        if (n < t.length) {
          const s = t[n++];
          return {
            value: [s, e[s]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(e, t) {
    let n;
    e ? n = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, n = `CLIENT ESCALATED SERVER ERROR (${e})`);
    const s = new qb(599, n, this.headers, this.body, m(this, Ll) || void 0);
    return S(s, $a, { message: e, error: t }), s;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(e, t) {
    t == null ? t = -1 : D(Number.isInteger(t) && t >= 0, "invalid stall timeout", "stall", t);
    const n = new Error(e || "throttling requests");
    throw Ae(n, { stall: t, throttle: !0 }), n;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return m(this, bn) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return m(this, Ll);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return m(this, $a).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: e, error: t } = m(this, $a);
    e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
    let n = null;
    this.request && (n = this.request.url);
    let s = null;
    try {
      m(this, bn) && (s = vg(m(this, bn)));
    } catch {
    }
    z(!1, e, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: t,
      info: {
        requestUrl: n,
        responseBody: s,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
ef = new WeakMap(), tf = new WeakMap(), rf = new WeakMap(), bn = new WeakMap(), Ll = new WeakMap(), $a = new WeakMap();
let Wo = qb;
function RA() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function _W(r) {
  return Zs(r.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
}
function IW(r) {
  return new Promise((e) => setTimeout(e, r));
}
const SW = BigInt(-1), ts = BigInt(0), ml = BigInt(1), NW = BigInt(5), tl = {};
let Sl = "0000";
for (; Sl.length < 80; )
  Sl += Sl;
function ua(r) {
  let e = Sl;
  for (; e.length < r; )
    e += e;
  return BigInt("1" + e.substring(0, r));
}
function wh(r, e, t) {
  const n = BigInt(e.width);
  if (e.signed) {
    const s = ml << n - ml;
    z(t == null || r >= -s && r < s, "overflow", "NUMERIC_FAULT", {
      operation: t,
      fault: "overflow",
      value: r
    }), r > ts ? r = Eg(Oa(r, n), n) : r = -Eg(Oa(-r, n), n);
  } else {
    const s = ml << n;
    z(t == null || r >= 0 && r < s, "overflow", "NUMERIC_FAULT", {
      operation: t,
      fault: "overflow",
      value: r
    }), r = (r % s + s) % s & s - ml;
  }
  return r;
}
function Tw(r) {
  typeof r == "number" && (r = `fixed128x${r}`);
  let e = !0, t = 128, n = 18;
  if (typeof r == "string") {
    if (r !== "fixed") if (r === "ufixed")
      e = !1;
    else {
      const i = r.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      D(i, "invalid fixed format", "format", r), e = i[1] !== "u", t = parseInt(i[2]), n = parseInt(i[3]);
    }
  } else if (r) {
    const i = r, o = (a, c, l) => i[a] == null ? l : (D(typeof i[a] === c, "invalid fixed format (" + a + " not " + c + ")", "format." + a, i[a]), i[a]);
    e = o("signed", "boolean", e), t = o("width", "number", t), n = o("decimals", "number", n);
  }
  D(t % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", t), D(n <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", n);
  const s = (e ? "" : "u") + "fixed" + String(t) + "x" + String(n);
  return { signed: e, width: t, decimals: n, name: s };
}
function TW(r, e) {
  let t = "";
  r < ts && (t = "-", r *= SW);
  let n = r.toString();
  if (e === 0)
    return t + n;
  for (; n.length <= e; )
    n = Sl + n;
  const s = n.length - e;
  for (n = n.substring(0, s) + "." + n.substring(s); n[0] === "0" && n[1] !== "."; )
    n = n.substring(1);
  for (; n[n.length - 1] === "0" && n[n.length - 2] !== "."; )
    n = n.substring(0, n.length - 1);
  return t + n;
}
var os, ht, Or, st, ga, fi, Jy, Yy, Qy, Zy;
const mo = class mo {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(e, t, n) {
    M(this, st);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    F(this, "format");
    M(this, os);
    // The actual value (accounting for decimals)
    M(this, ht);
    // A base-10 value to multiple values by to maintain the magnitude
    M(this, Or);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    F(this, "_value");
    Df(e, tl, "FixedNumber"), S(this, ht, t), S(this, os, n);
    const s = TW(t, n.decimals);
    Ae(this, { format: n.name, _value: s }), S(this, Or, ua(n.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return m(this, os).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return m(this, os).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return m(this, os).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return m(this, ht);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(e) {
    return V(this, st, Jy).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(e) {
    return V(this, st, Jy).call(this, e, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(e) {
    return V(this, st, Yy).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(e) {
    return V(this, st, Yy).call(this, e, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(e) {
    return V(this, st, Qy).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(e) {
    return V(this, st, Qy).call(this, e, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(e) {
    V(this, st, ga).call(this, e);
    const t = m(this, ht) * m(e, ht);
    return z(t % m(this, Or) === ts, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    }), V(this, st, fi).call(this, t / m(this, Or), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(e) {
    return V(this, st, Zy).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(e) {
    return V(this, st, Zy).call(this, e, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(e) {
    z(m(e, ht) !== ts, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    }), V(this, st, ga).call(this, e);
    const t = m(this, ht) * m(this, Or);
    return z(t % m(e, ht) === ts, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    }), V(this, st, fi).call(this, t / m(e, ht), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(e) {
    let t = this.value, n = e.value;
    const s = this.decimals - e.decimals;
    return s > 0 ? n *= ua(s) : s < 0 && (t *= ua(-s)), t < n ? -1 : t > n ? 1 : 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(e) {
    return this.cmp(e) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(e) {
    return this.cmp(e) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(e) {
    return this.cmp(e) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(e) {
    return this.cmp(e) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(e) {
    return this.cmp(e) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let e = m(this, ht);
    return m(this, ht) < ts && (e -= m(this, Or) - ml), e = m(this, ht) / m(this, Or) * m(this, Or), V(this, st, fi).call(this, e, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let e = m(this, ht);
    return m(this, ht) > ts && (e += m(this, Or) - ml), e = m(this, ht) / m(this, Or) * m(this, Or), V(this, st, fi).call(this, e, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(e) {
    if (e == null && (e = 0), e >= this.decimals)
      return this;
    const t = this.decimals - e, n = NW * ua(t - 1);
    let s = this.value + n;
    const i = ua(t);
    return s = s / i * i, wh(s, m(this, os), "round"), new mo(tl, s, m(this, os));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return m(this, ht) === ts;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return m(this, ht) < ts;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(e) {
    return mo.fromString(this.toString(), e);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(e, t, n) {
    const s = t == null ? 0 : De(t), i = Tw(n);
    let o = ge(e, "value");
    const a = s - i.decimals;
    if (a > 0) {
      const c = ua(a);
      z(o % c === ts, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: e
      }), o /= c;
    } else a < 0 && (o *= ua(-a));
    return wh(o, i, "fromValue"), new mo(tl, o, i);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(e, t) {
    const n = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    D(n && n[2].length + n[3].length > 0, "invalid FixedNumber string value", "value", e);
    const s = Tw(t);
    let i = n[2] || "0", o = n[3] || "";
    for (; o.length < s.decimals; )
      o += Sl;
    z(o.substring(s.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: e
    }), o = o.substring(0, s.decimals);
    const a = BigInt(n[1] + i + o);
    return wh(a, s, "fromString"), new mo(tl, a, s);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(e, t) {
    let n = lm(Le(e, "value"));
    const s = Tw(t);
    return s.signed && (n = Eg(n, s.width)), wh(n, s, "fromBytes"), new mo(tl, n, s);
  }
};
os = new WeakMap(), ht = new WeakMap(), Or = new WeakMap(), st = new WeakSet(), ga = function(e) {
  D(this.format === e.format, "incompatible format; use fixedNumber.toFormat", "other", e);
}, fi = function(e, t) {
  return e = wh(e, m(this, os), t), new mo(tl, e, m(this, os));
}, Jy = function(e, t) {
  return V(this, st, ga).call(this, e), V(this, st, fi).call(this, m(this, ht) + m(e, ht), t);
}, Yy = function(e, t) {
  return V(this, st, ga).call(this, e), V(this, st, fi).call(this, m(this, ht) - m(e, ht), t);
}, Qy = function(e, t) {
  return V(this, st, ga).call(this, e), V(this, st, fi).call(this, m(this, ht) * m(e, ht) / m(this, Or), t);
}, Zy = function(e, t) {
  return z(m(e, ht) !== ts, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  }), V(this, st, ga).call(this, e), V(this, st, fi).call(this, m(this, ht) * m(this, Or) / m(e, ht), t);
};
let Ag = mo;
function xW(r) {
  let e = r.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return "0x" + e;
}
function DA(r, e, t) {
  let n = 0;
  for (let s = 0; s < t; s++)
    n = n * 256 + r[e + s];
  return n;
}
function kA(r, e, t, n) {
  const s = [];
  for (; t < e + 1 + n; ) {
    const i = WS(r, t);
    s.push(i.result), t += i.consumed, z(t <= e + 1 + n, "child data too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: n,
      offset: e
    });
  }
  return { consumed: 1 + n, result: s };
}
function WS(r, e) {
  z(r.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: r,
    length: 0,
    offset: 1
  });
  const t = (n) => {
    z(n <= r.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: r.length,
      offset: n
    });
  };
  if (r[e] >= 248) {
    const n = r[e] - 247;
    t(e + 1 + n);
    const s = DA(r, e + 1, n);
    return t(e + 1 + n + s), kA(r, e, e + 1 + n, n + s);
  } else if (r[e] >= 192) {
    const n = r[e] - 192;
    return t(e + 1 + n), kA(r, e, e + 1, n);
  } else if (r[e] >= 184) {
    const n = r[e] - 183;
    t(e + 1 + n);
    const s = DA(r, e + 1, n);
    t(e + 1 + n + s);
    const i = se(r.slice(e + 1 + n, e + 1 + n + s));
    return { consumed: 1 + n + s, result: i };
  } else if (r[e] >= 128) {
    const n = r[e] - 128;
    t(e + 1 + n);
    const s = se(r.slice(e + 1, e + 1 + n));
    return { consumed: 1 + n, result: s };
  }
  return { consumed: 1, result: xW(r[e]) };
}
function kf(r) {
  const e = Le(r, "data"), t = WS(e, 0);
  return D(t.consumed === e.length, "unexpected junk after rlp payload", "data", r), t.result;
}
function UA(r) {
  const e = [];
  for (; r; )
    e.unshift(r & 255), r >>= 8;
  return e;
}
function VS(r) {
  if (Array.isArray(r)) {
    let n = [];
    if (r.forEach(function(i) {
      n = n.concat(VS(i));
    }), n.length <= 55)
      return n.unshift(192 + n.length), n;
    const s = UA(n.length);
    return s.unshift(247 + s.length), s.concat(n);
  }
  const e = Array.prototype.slice.call(Le(r, "object"));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const t = UA(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
const BA = "0123456789abcdef";
function Zo(r) {
  let e = "0x";
  for (const t of VS(r))
    e += BA[t >> 4], e += BA[t & 15];
  return e;
}
const GS = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function KS(r, e) {
  let t = 18;
  if (typeof e == "string") {
    const n = GS.indexOf(e);
    D(n >= 0, "invalid unit", "unit", e), t = 3 * n;
  } else e != null && (t = De(e, "unit"));
  return Ag.fromValue(r, t, { decimals: t, width: 512 }).toString();
}
function OW(r, e) {
  D(typeof r == "string", "value must be a string", "value", r);
  let t = 18;
  if (typeof e == "string") {
    const n = GS.indexOf(e);
    D(n >= 0, "invalid unit", "unit", e), t = 3 * n;
  } else e != null && (t = De(e, "unit"));
  return Ag.fromString(r, { decimals: t, width: 512 }).value;
}
function PW(r) {
  return KS(r, 18);
}
const Ur = 32, Xy = new Uint8Array(Ur), RW = ["then"], gp = {}, JS = /* @__PURE__ */ new WeakMap();
function Ea(r) {
  return JS.get(r);
}
function LA(r, e) {
  JS.set(r, e);
}
function yh(r, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${r}`);
  throw t.error = e, t;
}
function e0(r, e, t) {
  return r.indexOf(null) >= 0 ? e.map((n, s) => n instanceof Ou ? e0(Ea(n), n, t) : n) : r.reduce((n, s, i) => {
    let o = e.getValue(s);
    return s in n || (t && o instanceof Ou && (o = e0(Ea(o), o, t)), n[s] = o), n;
  }, {});
}
var Fl;
const wl = class wl extends Array {
  /**
   *  @private
   */
  constructor(...t) {
    const n = t[0];
    let s = t[1], i = (t[2] || []).slice(), o = !0;
    n !== gp && (s = t, i = [], o = !1);
    super(s.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    M(this, Fl);
    s.forEach((l, u) => {
      this[u] = l;
    });
    const a = i.reduce((l, u) => (typeof u == "string" && l.set(u, (l.get(u) || 0) + 1), l), /* @__PURE__ */ new Map());
    if (LA(this, Object.freeze(s.map((l, u) => {
      const h = i[u];
      return h != null && a.get(h) === 1 ? h : null;
    }))), S(this, Fl, []), m(this, Fl) == null && m(this, Fl), !o)
      return;
    Object.freeze(this);
    const c = new Proxy(this, {
      get: (l, u, h) => {
        if (typeof u == "string") {
          if (u.match(/^[0-9]+$/)) {
            const f = De(u, "%index");
            if (f < 0 || f >= this.length)
              throw new RangeError("out of result range");
            const g = l[f];
            return g instanceof Error && yh(`index ${f}`, g), g;
          }
          if (RW.indexOf(u) >= 0)
            return Reflect.get(l, u, h);
          const d = l[u];
          if (d instanceof Function)
            return function(...f) {
              return d.apply(this === h ? l : this, f);
            };
          if (!(u in l))
            return l.getValue.apply(this === h ? l : this, [u]);
        }
        return Reflect.get(l, u, h);
      }
    });
    return LA(c, Ea(this)), c;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(t) {
    const n = [];
    return this.forEach((s, i) => {
      s instanceof Error && yh(`index ${i}`, s), t && s instanceof wl && (s = s.toArray(t)), n.push(s);
    }), n;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(t) {
    const n = Ea(this);
    return n.reduce((s, i, o) => (z(i != null, `value at index ${o} unnamed`, "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), e0(n, this, t)), {});
  }
  /**
   *  @_ignore
   */
  slice(t, n) {
    t == null && (t = 0), t < 0 && (t += this.length, t < 0 && (t = 0)), n == null && (n = this.length), n < 0 && (n += this.length, n < 0 && (n = 0)), n > this.length && (n = this.length);
    const s = Ea(this), i = [], o = [];
    for (let a = t; a < n; a++)
      i.push(this[a]), o.push(s[a]);
    return new wl(gp, i, o);
  }
  /**
   *  @_ignore
   */
  filter(t, n) {
    const s = Ea(this), i = [], o = [];
    for (let a = 0; a < this.length; a++) {
      const c = this[a];
      c instanceof Error && yh(`index ${a}`, c), t.call(n, c, a, this) && (i.push(c), o.push(s[a]));
    }
    return new wl(gp, i, o);
  }
  /**
   *  @_ignore
   */
  map(t, n) {
    const s = [];
    for (let i = 0; i < this.length; i++) {
      const o = this[i];
      o instanceof Error && yh(`index ${i}`, o), s.push(t.call(n, o, i, this));
    }
    return s;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(t) {
    const n = Ea(this).indexOf(t);
    if (n === -1)
      return;
    const s = this[n];
    return s instanceof Error && yh(`property ${JSON.stringify(t)}`, s.error), s;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(t, n) {
    return new wl(gp, t, n);
  }
};
Fl = new WeakMap();
let Ou = wl;
function FA(r) {
  let e = qt(r);
  return z(e.length <= Ur, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: e, length: Ur, offset: e.length }), e.length !== Ur && (e = kr(Pt([Xy.slice(e.length % Ur), e]))), e;
}
class Wi {
  constructor(e, t, n, s) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    F(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    F(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    F(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    F(this, "dynamic");
    Ae(this, { name: e, type: t, localName: n, dynamic: s }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(e, t) {
    D(!1, e, this.localName, t);
  }
}
var Ei, Ma, $l, Bp;
class t0 {
  constructor() {
    M(this, $l);
    // An array of WordSize lengthed objects to concatenation
    M(this, Ei);
    M(this, Ma);
    S(this, Ei, []), S(this, Ma, 0);
  }
  get data() {
    return Pt(m(this, Ei));
  }
  get length() {
    return m(this, Ma);
  }
  appendWriter(e) {
    return V(this, $l, Bp).call(this, kr(e.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(e) {
    let t = kr(e);
    const n = t.length % Ur;
    return n && (t = kr(Pt([t, Xy.slice(n)]))), V(this, $l, Bp).call(this, t);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(e) {
    return V(this, $l, Bp).call(this, FA(e));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const e = m(this, Ei).length;
    return m(this, Ei).push(Xy), S(this, Ma, m(this, Ma) + Ur), (t) => {
      m(this, Ei)[e] = FA(t);
    };
  }
}
Ei = new WeakMap(), Ma = new WeakMap(), $l = new WeakSet(), Bp = function(e) {
  return m(this, Ei).push(e), S(this, Ma, m(this, Ma) + e.length), e.length;
};
var Yr, En, ja, Ha, Ao, Ac, n0, YS;
const Wb = class Wb {
  constructor(e, t, n) {
    M(this, Ac);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    F(this, "allowLoose");
    M(this, Yr);
    M(this, En);
    M(this, ja);
    M(this, Ha);
    M(this, Ao);
    Ae(this, { allowLoose: !!t }), S(this, Yr, kr(e)), S(this, ja, 0), S(this, Ha, null), S(this, Ao, n ?? 1024), S(this, En, 0);
  }
  get data() {
    return se(m(this, Yr));
  }
  get dataLength() {
    return m(this, Yr).length;
  }
  get consumed() {
    return m(this, En);
  }
  get bytes() {
    return new Uint8Array(m(this, Yr));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(e) {
    const t = new Wb(m(this, Yr).slice(m(this, En) + e), this.allowLoose, m(this, Ao));
    return S(t, Ha, this), t;
  }
  // Read bytes
  readBytes(e, t) {
    let n = V(this, Ac, YS).call(this, 0, e, !!t);
    return V(this, Ac, n0).call(this, e), S(this, En, m(this, En) + n.length), n.slice(0, e);
  }
  // Read a numeric values
  readValue() {
    return lm(this.readBytes(Ur));
  }
  readIndex() {
    return uW(this.readBytes(Ur));
  }
};
Yr = new WeakMap(), En = new WeakMap(), ja = new WeakMap(), Ha = new WeakMap(), Ao = new WeakMap(), Ac = new WeakSet(), n0 = function(e) {
  var t;
  if (m(this, Ha))
    return V(t = m(this, Ha), Ac, n0).call(t, e);
  S(this, ja, m(this, ja) + e), z(m(this, Ao) < 1 || m(this, ja) <= m(this, Ao) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${m(this, Ao)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: kr(m(this, Yr)),
    offset: m(this, En),
    length: e,
    info: {
      bytesRead: m(this, ja),
      dataLength: this.dataLength
    }
  });
}, YS = function(e, t, n) {
  let s = Math.ceil(t / Ur) * Ur;
  return m(this, En) + s > m(this, Yr).length && (this.allowLoose && n && m(this, En) + t <= m(this, Yr).length ? s = t : z(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: kr(m(this, Yr)),
    length: m(this, Yr).length,
    offset: m(this, En) + s
  })), m(this, Yr).slice(m(this, En), m(this, En) + s);
};
let r0 = Wb;
function Cg(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error(`Wrong positive integer: ${r}`);
}
function Nb(r, ...e) {
  if (!(r instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${r.length}`);
}
function DW(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Cg(r.outputLen), Cg(r.blockLen);
}
function Pu(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function QS(r, e) {
  Nb(r);
  const t = e.outputLen;
  if (r.length < t)
    throw new Error(`digestInto() expects output buffer of length at least ${t}`);
}
const xw = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ZS = (r) => r instanceof Uint8Array, kW = (r) => new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4)), Ow = (r) => new DataView(r.buffer, r.byteOffset, r.byteLength), Ts = (r, e) => r << 32 - e | r >>> e, UW = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!UW)
  throw new Error("Non little-endian hardware is not supported");
function BW(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function um(r) {
  if (typeof r == "string" && (r = BW(r)), !ZS(r))
    throw new Error(`expected Uint8Array, got ${typeof r}`);
  return r;
}
function LW(...r) {
  const e = new Uint8Array(r.reduce((n, s) => n + s.length, 0));
  let t = 0;
  return r.forEach((n) => {
    if (!ZS(n))
      throw new Error("Uint8Array expected");
    e.set(n, t), t += n.length;
  }), e;
}
class Tb {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function xb(r) {
  const e = (n) => r().update(um(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function FW(r = 32) {
  if (xw && typeof xw.getRandomValues == "function")
    return xw.getRandomValues(new Uint8Array(r));
  throw new Error("crypto.getRandomValues must be defined");
}
class XS extends Tb {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, DW(e);
    const n = um(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(n.length > s ? e.create().update(n).digest() : n);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = e.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(e) {
    return Pu(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Pu(this), Nb(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: n, finished: s, destroyed: i, blockLen: o, outputLen: a } = this;
    return e = e, e.finished = s, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const eN = (r, e, t) => new XS(r, e).update(t).digest();
eN.create = (r, e) => new XS(r, e);
function $W(r, e, t, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(e, t, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), c = n ? 4 : 0, l = n ? 0 : 4;
  r.setUint32(e + c, o, n), r.setUint32(e + l, a, n);
}
class tN extends Tb {
  constructor(e, t, n, s) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Ow(this.buffer);
  }
  update(e) {
    Pu(this);
    const { view: t, buffer: n, blockLen: s } = this;
    e = um(e);
    const i = e.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o);
      if (a === s) {
        const c = Ow(e);
        for (; s <= i - o; o += s)
          this.process(c, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Pu(this), QS(e, this), this.finished = !0;
    const { buffer: t, view: n, blockLen: s, isLE: i } = this;
    let { pos: o } = this;
    t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
    for (let h = o; h < s; h++)
      t[h] = 0;
    $W(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Ow(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = c / 4, u = this.get();
    if (l > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < l; h++)
      a.setUint32(4 * h, u[h], i);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
    return e.length = s, e.pos = a, e.finished = i, e.destroyed = o, s % t && e.buffer.set(n), e;
  }
}
const MW = (r, e, t) => r & e ^ ~r & t, jW = (r, e, t) => r & e ^ r & t ^ e & t, HW = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), io = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), oo = /* @__PURE__ */ new Uint32Array(64);
class zW extends tN {
  constructor() {
    super(64, 32, 8, !1), this.A = io[0] | 0, this.B = io[1] | 0, this.C = io[2] | 0, this.D = io[3] | 0, this.E = io[4] | 0, this.F = io[5] | 0, this.G = io[6] | 0, this.H = io[7] | 0;
  }
  get() {
    const { A: e, B: t, C: n, D: s, E: i, F: o, G: a, H: c } = this;
    return [e, t, n, s, i, o, a, c];
  }
  // prettier-ignore
  set(e, t, n, s, i, o, a, c) {
    this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(e, t) {
    for (let h = 0; h < 16; h++, t += 4)
      oo[h] = e.getUint32(t, !1);
    for (let h = 16; h < 64; h++) {
      const d = oo[h - 15], f = oo[h - 2], g = Ts(d, 7) ^ Ts(d, 18) ^ d >>> 3, p = Ts(f, 17) ^ Ts(f, 19) ^ f >>> 10;
      oo[h] = p + oo[h - 7] + g + oo[h - 16] | 0;
    }
    let { A: n, B: s, C: i, D: o, E: a, F: c, G: l, H: u } = this;
    for (let h = 0; h < 64; h++) {
      const d = Ts(a, 6) ^ Ts(a, 11) ^ Ts(a, 25), f = u + d + MW(a, c, l) + HW[h] + oo[h] | 0, p = (Ts(n, 2) ^ Ts(n, 13) ^ Ts(n, 22)) + jW(n, s, i) | 0;
      u = l, l = c, c = a, a = o + f | 0, o = i, i = s, s = n, n = f + p | 0;
    }
    n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(n, s, i, o, a, c, l, u);
  }
  roundClean() {
    oo.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const rN = /* @__PURE__ */ xb(() => new zW()), mp = /* @__PURE__ */ BigInt(2 ** 32 - 1), s0 = /* @__PURE__ */ BigInt(32);
function nN(r, e = !1) {
  return e ? { h: Number(r & mp), l: Number(r >> s0 & mp) } : { h: Number(r >> s0 & mp) | 0, l: Number(r & mp) | 0 };
}
function sN(r, e = !1) {
  let t = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let s = 0; s < r.length; s++) {
    const { h: i, l: o } = nN(r[s], e);
    [t[s], n[s]] = [i, o];
  }
  return [t, n];
}
const qW = (r, e) => BigInt(r >>> 0) << s0 | BigInt(e >>> 0), WW = (r, e, t) => r >>> t, VW = (r, e, t) => r << 32 - t | e >>> t, GW = (r, e, t) => r >>> t | e << 32 - t, KW = (r, e, t) => r << 32 - t | e >>> t, JW = (r, e, t) => r << 64 - t | e >>> t - 32, YW = (r, e, t) => r >>> t - 32 | e << 64 - t, QW = (r, e) => e, ZW = (r, e) => r, iN = (r, e, t) => r << t | e >>> 32 - t, oN = (r, e, t) => e << t | r >>> 32 - t, aN = (r, e, t) => e << t - 32 | r >>> 64 - t, cN = (r, e, t) => r << t - 32 | e >>> 64 - t;
function XW(r, e, t, n) {
  const s = (e >>> 0) + (n >>> 0);
  return { h: r + t + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const eV = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0), tV = (r, e, t, n) => e + t + n + (r / 2 ** 32 | 0) | 0, rV = (r, e, t, n) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0), nV = (r, e, t, n, s) => e + t + n + s + (r / 2 ** 32 | 0) | 0, sV = (r, e, t, n, s) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0), iV = (r, e, t, n, s, i) => e + t + n + s + i + (r / 2 ** 32 | 0) | 0, Be = {
  fromBig: nN,
  split: sN,
  toBig: qW,
  shrSH: WW,
  shrSL: VW,
  rotrSH: GW,
  rotrSL: KW,
  rotrBH: JW,
  rotrBL: YW,
  rotr32H: QW,
  rotr32L: ZW,
  rotlSH: iN,
  rotlSL: oN,
  rotlBH: aN,
  rotlBL: cN,
  add: XW,
  add3L: eV,
  add3H: tV,
  add4L: rV,
  add4H: nV,
  add5H: iV,
  add5L: sV
}, [oV, aV] = Be.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((r) => BigInt(r))), ao = /* @__PURE__ */ new Uint32Array(80), co = /* @__PURE__ */ new Uint32Array(80);
class cV extends tN {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: t, Bh: n, Bl: s, Ch: i, Cl: o, Dh: a, Dl: c, Eh: l, El: u, Fh: h, Fl: d, Gh: f, Gl: g, Hh: p, Hl: w } = this;
    return [e, t, n, s, i, o, a, c, l, u, h, d, f, g, p, w];
  }
  // prettier-ignore
  set(e, t, n, s, i, o, a, c, l, u, h, d, f, g, p, w) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = u | 0, this.Fh = h | 0, this.Fl = d | 0, this.Gh = f | 0, this.Gl = g | 0, this.Hh = p | 0, this.Hl = w | 0;
  }
  process(e, t) {
    for (let A = 0; A < 16; A++, t += 4)
      ao[A] = e.getUint32(t), co[A] = e.getUint32(t += 4);
    for (let A = 16; A < 80; A++) {
      const C = ao[A - 15] | 0, N = co[A - 15] | 0, x = Be.rotrSH(C, N, 1) ^ Be.rotrSH(C, N, 8) ^ Be.shrSH(C, N, 7), O = Be.rotrSL(C, N, 1) ^ Be.rotrSL(C, N, 8) ^ Be.shrSL(C, N, 7), k = ao[A - 2] | 0, P = co[A - 2] | 0, $ = Be.rotrSH(k, P, 19) ^ Be.rotrBH(k, P, 61) ^ Be.shrSH(k, P, 6), U = Be.rotrSL(k, P, 19) ^ Be.rotrBL(k, P, 61) ^ Be.shrSL(k, P, 6), j = Be.add4L(O, U, co[A - 7], co[A - 16]), H = Be.add4H(j, x, $, ao[A - 7], ao[A - 16]);
      ao[A] = H | 0, co[A] = j | 0;
    }
    let { Ah: n, Al: s, Bh: i, Bl: o, Ch: a, Cl: c, Dh: l, Dl: u, Eh: h, El: d, Fh: f, Fl: g, Gh: p, Gl: w, Hh: E, Hl: I } = this;
    for (let A = 0; A < 80; A++) {
      const C = Be.rotrSH(h, d, 14) ^ Be.rotrSH(h, d, 18) ^ Be.rotrBH(h, d, 41), N = Be.rotrSL(h, d, 14) ^ Be.rotrSL(h, d, 18) ^ Be.rotrBL(h, d, 41), x = h & f ^ ~h & p, O = d & g ^ ~d & w, k = Be.add5L(I, N, O, aV[A], co[A]), P = Be.add5H(k, E, C, x, oV[A], ao[A]), $ = k | 0, U = Be.rotrSH(n, s, 28) ^ Be.rotrBH(n, s, 34) ^ Be.rotrBH(n, s, 39), j = Be.rotrSL(n, s, 28) ^ Be.rotrBL(n, s, 34) ^ Be.rotrBL(n, s, 39), H = n & i ^ n & a ^ i & a, ee = s & o ^ s & c ^ o & c;
      E = p | 0, I = w | 0, p = f | 0, w = g | 0, f = h | 0, g = d | 0, { h, l: d } = Be.add(l | 0, u | 0, P | 0, $ | 0), l = a | 0, u = c | 0, a = i | 0, c = o | 0, i = n | 0, o = s | 0;
      const y = Be.add3L($, j, ee);
      n = Be.add3H(y, P, U, H), s = y | 0;
    }
    ({ h: n, l: s } = Be.add(this.Ah | 0, this.Al | 0, n | 0, s | 0)), { h: i, l: o } = Be.add(this.Bh | 0, this.Bl | 0, i | 0, o | 0), { h: a, l: c } = Be.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: l, l: u } = Be.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0), { h, l: d } = Be.add(this.Eh | 0, this.El | 0, h | 0, d | 0), { h: f, l: g } = Be.add(this.Fh | 0, this.Fl | 0, f | 0, g | 0), { h: p, l: w } = Be.add(this.Gh | 0, this.Gl | 0, p | 0, w | 0), { h: E, l: I } = Be.add(this.Hh | 0, this.Hl | 0, E | 0, I | 0), this.set(n, s, i, o, a, c, l, u, h, d, f, g, p, w, E, I);
  }
  roundClean() {
    ao.fill(0), co.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const lV = /* @__PURE__ */ xb(() => new cV());
function uV() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const $A = uV();
$A.crypto || $A.msCrypto;
function hV(r) {
  switch (r) {
    case "sha256":
      return rN.create();
    case "sha512":
      return lV.create();
  }
  D(!1, "invalid hashing algorithm name", "algorithm", r);
}
const [lN, uN, hN] = [[], [], []], dV = /* @__PURE__ */ BigInt(0), bh = /* @__PURE__ */ BigInt(1), fV = /* @__PURE__ */ BigInt(2), pV = /* @__PURE__ */ BigInt(7), gV = /* @__PURE__ */ BigInt(256), mV = /* @__PURE__ */ BigInt(113);
for (let r = 0, e = bh, t = 1, n = 0; r < 24; r++) {
  [t, n] = [n, (2 * t + 3 * n) % 5], lN.push(2 * (5 * n + t)), uN.push((r + 1) * (r + 2) / 2 % 64);
  let s = dV;
  for (let i = 0; i < 7; i++)
    e = (e << bh ^ (e >> pV) * mV) % gV, e & fV && (s ^= bh << (bh << /* @__PURE__ */ BigInt(i)) - bh);
  hN.push(s);
}
const [wV, yV] = /* @__PURE__ */ sN(hN, !0), MA = (r, e, t) => t > 32 ? aN(r, e, t) : iN(r, e, t), jA = (r, e, t) => t > 32 ? cN(r, e, t) : oN(r, e, t);
function bV(r, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, l = t[c], u = t[c + 1], h = MA(l, u, 1) ^ t[a], d = jA(l, u, 1) ^ t[a + 1];
      for (let f = 0; f < 50; f += 10)
        r[o + f] ^= h, r[o + f + 1] ^= d;
    }
    let s = r[2], i = r[3];
    for (let o = 0; o < 24; o++) {
      const a = uN[o], c = MA(s, i, a), l = jA(s, i, a), u = lN[o];
      s = r[u], i = r[u + 1], r[u] = c, r[u + 1] = l;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        t[a] = r[o + a];
      for (let a = 0; a < 10; a++)
        r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    r[0] ^= wV[n], r[1] ^= yV[n];
  }
  t.fill(0);
}
class Ob extends Tb {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, t, n, s = !1, i = 24) {
    if (super(), this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = s, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Cg(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = kW(this.state);
  }
  keccak() {
    bV(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Pu(this);
    const { blockLen: t, state: n } = this;
    e = um(e);
    const s = e.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(t - this.pos, s - i);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[i++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: t, pos: n, blockLen: s } = this;
    e[n] ^= t, t & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Pu(this, !1), Nb(e), this.finish();
    const t = this.state, { blockLen: n } = this;
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - s);
      e.set(t.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Cg(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (QS(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
    return e || (e = new Ob(t, n, s, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const EV = (r, e, t) => xb(() => new Ob(e, r, t)), vV = /* @__PURE__ */ EV(1, 136, 256 / 8);
let dN = !1;
const fN = function(r) {
  return vV(r);
};
let pN = fN;
function $t(r) {
  const e = Le(r, "data");
  return se(pN(e));
}
$t._ = fN;
$t.lock = function() {
  dN = !0;
};
$t.register = function(r) {
  if (dN)
    throw new TypeError("keccak256 is locked");
  pN = r;
};
Object.freeze($t);
const gN = function(r) {
  return hV("sha256").update(r).digest();
};
let mN = gN, wN = !1;
function Gu(r) {
  const e = Le(r, "data");
  return se(mN(e));
}
Gu._ = gN;
Gu.lock = function() {
  wN = !0;
};
Gu.register = function(r) {
  if (wN)
    throw new Error("sha256 is locked");
  mN = r;
};
Object.freeze(Gu);
Object.freeze(Gu);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const yN = BigInt(0), hm = BigInt(1), AV = BigInt(2), dm = (r) => r instanceof Uint8Array, CV = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function Ru(r) {
  if (!dm(r))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let t = 0; t < r.length; t++)
    e += CV[r[t]];
  return e;
}
function bN(r) {
  const e = r.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function Pb(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  return BigInt(r === "" ? "0" : `0x${r}`);
}
function Du(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  const e = r.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const t = new Uint8Array(e / 2);
  for (let n = 0; n < t.length; n++) {
    const s = n * 2, i = r.slice(s, s + 2), o = Number.parseInt(i, 16);
    if (Number.isNaN(o) || o < 0)
      throw new Error("Invalid byte sequence");
    t[n] = o;
  }
  return t;
}
function ic(r) {
  return Pb(Ru(r));
}
function Rb(r) {
  if (!dm(r))
    throw new Error("Uint8Array expected");
  return Pb(Ru(Uint8Array.from(r).reverse()));
}
function ku(r, e) {
  return Du(r.toString(16).padStart(e * 2, "0"));
}
function Db(r, e) {
  return ku(r, e).reverse();
}
function _V(r) {
  return Du(bN(r));
}
function ns(r, e, t) {
  let n;
  if (typeof e == "string")
    try {
      n = Du(e);
    } catch (i) {
      throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${i}`);
    }
  else if (dm(e))
    n = Uint8Array.from(e);
  else
    throw new Error(`${r} must be hex string or Uint8Array`);
  const s = n.length;
  if (typeof t == "number" && s !== t)
    throw new Error(`${r} expected ${t} bytes, got ${s}`);
  return n;
}
function zd(...r) {
  const e = new Uint8Array(r.reduce((n, s) => n + s.length, 0));
  let t = 0;
  return r.forEach((n) => {
    if (!dm(n))
      throw new Error("Uint8Array expected");
    e.set(n, t), t += n.length;
  }), e;
}
function IV(r, e) {
  if (r.length !== e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
function SV(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function NV(r) {
  let e;
  for (e = 0; r > yN; r >>= hm, e += 1)
    ;
  return e;
}
function TV(r, e) {
  return r >> BigInt(e) & hm;
}
const xV = (r, e, t) => r | (t ? hm : yN) << BigInt(e), kb = (r) => (AV << BigInt(r - 1)) - hm, Pw = (r) => new Uint8Array(r), HA = (r) => Uint8Array.from(r);
function EN(r, e, t) {
  if (typeof r != "number" || r < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof t != "function")
    throw new Error("hmacFn must be a function");
  let n = Pw(r), s = Pw(r), i = 0;
  const o = () => {
    n.fill(1), s.fill(0), i = 0;
  }, a = (...h) => t(s, n, ...h), c = (h = Pw()) => {
    s = a(HA([0]), h), n = a(), h.length !== 0 && (s = a(HA([1]), h), n = a());
  }, l = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let h = 0;
    const d = [];
    for (; h < e; ) {
      n = a();
      const f = n.slice();
      d.push(f), h += n.length;
    }
    return zd(...d);
  };
  return (h, d) => {
    o(), c(h);
    let f;
    for (; !(f = d(l())); )
      c();
    return o(), f;
  };
}
const OV = {
  bigint: (r) => typeof r == "bigint",
  function: (r) => typeof r == "function",
  boolean: (r) => typeof r == "boolean",
  string: (r) => typeof r == "string",
  stringOrUint8Array: (r) => typeof r == "string" || r instanceof Uint8Array,
  isSafeInteger: (r) => Number.isSafeInteger(r),
  array: (r) => Array.isArray(r),
  field: (r, e) => e.Fp.isValid(r),
  hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function Uf(r, e, t = {}) {
  const n = (s, i, o) => {
    const a = OV[i];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const c = r[s];
    if (!(o && c === void 0) && !a(c, r))
      throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${i}`);
  };
  for (const [s, i] of Object.entries(e))
    n(s, i, !1);
  for (const [s, i] of Object.entries(t))
    n(s, i, !0);
  return r;
}
const PV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: TV,
  bitLen: NV,
  bitMask: kb,
  bitSet: xV,
  bytesToHex: Ru,
  bytesToNumberBE: ic,
  bytesToNumberLE: Rb,
  concatBytes: zd,
  createHmacDrbg: EN,
  ensureBytes: ns,
  equalBytes: IV,
  hexToBytes: Du,
  hexToNumber: Pb,
  numberToBytesBE: ku,
  numberToBytesLE: Db,
  numberToHexUnpadded: bN,
  numberToVarBytesBE: _V,
  utf8ToBytes: SV,
  validateObject: Uf
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const tr = BigInt(0), Ut = BigInt(1), va = BigInt(2), RV = BigInt(3), i0 = BigInt(4), zA = BigInt(5), qA = BigInt(8);
BigInt(9);
BigInt(16);
function sn(r, e) {
  const t = r % e;
  return t >= tr ? t : e + t;
}
function DV(r, e, t) {
  if (t <= tr || e < tr)
    throw new Error("Expected power/modulo > 0");
  if (t === Ut)
    return tr;
  let n = Ut;
  for (; e > tr; )
    e & Ut && (n = n * r % t), r = r * r % t, e >>= Ut;
  return n;
}
function Dn(r, e, t) {
  let n = r;
  for (; e-- > tr; )
    n *= n, n %= t;
  return n;
}
function o0(r, e) {
  if (r === tr || e <= tr)
    throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);
  let t = sn(r, e), n = e, s = tr, i = Ut;
  for (; t !== tr; ) {
    const a = n / t, c = n % t, l = s - i * a;
    n = t, t = c, s = i, i = l;
  }
  if (n !== Ut)
    throw new Error("invert: does not exist");
  return sn(s, e);
}
function kV(r) {
  const e = (r - Ut) / va;
  let t, n, s;
  for (t = r - Ut, n = 0; t % va === tr; t /= va, n++)
    ;
  for (s = va; s < r && DV(s, e, r) !== r - Ut; s++)
    ;
  if (n === 1) {
    const o = (r + Ut) / i0;
    return function(c, l) {
      const u = c.pow(l, o);
      if (!c.eql(c.sqr(u), l))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  const i = (t + Ut) / va;
  return function(a, c) {
    if (a.pow(c, e) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let l = n, u = a.pow(a.mul(a.ONE, s), t), h = a.pow(c, i), d = a.pow(c, t);
    for (; !a.eql(d, a.ONE); ) {
      if (a.eql(d, a.ZERO))
        return a.ZERO;
      let f = 1;
      for (let p = a.sqr(d); f < l && !a.eql(p, a.ONE); f++)
        p = a.sqr(p);
      const g = a.pow(u, Ut << BigInt(l - f - 1));
      u = a.sqr(g), h = a.mul(h, g), d = a.mul(d, u), l = f;
    }
    return h;
  };
}
function UV(r) {
  if (r % i0 === RV) {
    const e = (r + Ut) / i0;
    return function(n, s) {
      const i = n.pow(s, e);
      if (!n.eql(n.sqr(i), s))
        throw new Error("Cannot find square root");
      return i;
    };
  }
  if (r % qA === zA) {
    const e = (r - zA) / qA;
    return function(n, s) {
      const i = n.mul(s, va), o = n.pow(i, e), a = n.mul(s, o), c = n.mul(n.mul(a, va), o), l = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(l), s))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  return kV(r);
}
const BV = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function LV(r) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, t = BV.reduce((n, s) => (n[s] = "function", n), e);
  return Uf(r, t);
}
function FV(r, e, t) {
  if (t < tr)
    throw new Error("Expected power > 0");
  if (t === tr)
    return r.ONE;
  if (t === Ut)
    return e;
  let n = r.ONE, s = e;
  for (; t > tr; )
    t & Ut && (n = r.mul(n, s)), s = r.sqr(s), t >>= Ut;
  return n;
}
function $V(r, e) {
  const t = new Array(e.length), n = e.reduce((i, o, a) => r.is0(o) ? i : (t[a] = i, r.mul(i, o)), r.ONE), s = r.inv(n);
  return e.reduceRight((i, o, a) => r.is0(o) ? i : (t[a] = r.mul(i, t[a]), r.mul(i, o)), s), t;
}
function vN(r, e) {
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function MV(r, e, t = !1, n = {}) {
  if (r <= tr)
    throw new Error(`Expected Field ORDER > 0, got ${r}`);
  const { nBitLength: s, nByteLength: i } = vN(r, e);
  if (i > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = UV(r), a = Object.freeze({
    ORDER: r,
    BITS: s,
    BYTES: i,
    MASK: kb(s),
    ZERO: tr,
    ONE: Ut,
    create: (c) => sn(c, r),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return tr <= c && c < r;
    },
    is0: (c) => c === tr,
    isOdd: (c) => (c & Ut) === Ut,
    neg: (c) => sn(-c, r),
    eql: (c, l) => c === l,
    sqr: (c) => sn(c * c, r),
    add: (c, l) => sn(c + l, r),
    sub: (c, l) => sn(c - l, r),
    mul: (c, l) => sn(c * l, r),
    pow: (c, l) => FV(a, c, l),
    div: (c, l) => sn(c * o0(l, r), r),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, l) => c + l,
    subN: (c, l) => c - l,
    mulN: (c, l) => c * l,
    inv: (c) => o0(c, r),
    sqrt: n.sqrt || ((c) => o(a, c)),
    invertBatch: (c) => $V(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, l, u) => u ? l : c,
    toBytes: (c) => t ? Db(c, i) : ku(c, i),
    fromBytes: (c) => {
      if (c.length !== i)
        throw new Error(`Fp.fromBytes: expected ${i}, got ${c.length}`);
      return t ? Rb(c) : ic(c);
    }
  });
  return Object.freeze(a);
}
function AN(r) {
  if (typeof r != "bigint")
    throw new Error("field order must be bigint");
  const e = r.toString(2).length;
  return Math.ceil(e / 8);
}
function CN(r) {
  const e = AN(r);
  return e + Math.ceil(e / 2);
}
function jV(r, e, t = !1) {
  const n = r.length, s = AN(e), i = CN(e);
  if (n < 16 || n < i || n > 1024)
    throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);
  const o = t ? ic(r) : Rb(r), a = sn(o, e - Ut) + Ut;
  return t ? Db(a, s) : ku(a, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const HV = BigInt(0), Rw = BigInt(1);
function zV(r, e) {
  const t = (s, i) => {
    const o = i.negate();
    return s ? o : i;
  }, n = (s) => {
    const i = Math.ceil(e / s) + 1, o = 2 ** (s - 1);
    return { windows: i, windowSize: o };
  };
  return {
    constTimeNegate: t,
    // non-const time multiplication ladder
    unsafeLadder(s, i) {
      let o = r.ZERO, a = s;
      for (; i > HV; )
        i & Rw && (o = o.add(a)), a = a.double(), i >>= Rw;
      return o;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, i) {
      const { windows: o, windowSize: a } = n(i), c = [];
      let l = s, u = l;
      for (let h = 0; h < o; h++) {
        u = l, c.push(u);
        for (let d = 1; d < a; d++)
          u = u.add(l), c.push(u);
        l = u.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, i, o) {
      const { windows: a, windowSize: c } = n(s);
      let l = r.ZERO, u = r.BASE;
      const h = BigInt(2 ** s - 1), d = 2 ** s, f = BigInt(s);
      for (let g = 0; g < a; g++) {
        const p = g * c;
        let w = Number(o & h);
        o >>= f, w > c && (w -= d, o += Rw);
        const E = p, I = p + Math.abs(w) - 1, A = g % 2 !== 0, C = w < 0;
        w === 0 ? u = u.add(t(A, i[E])) : l = l.add(t(C, i[I]));
      }
      return { p: l, f: u };
    },
    wNAFCached(s, i, o, a) {
      const c = s._WINDOW_SIZE || 1;
      let l = i.get(s);
      return l || (l = this.precomputeWindow(s, c), c !== 1 && i.set(s, a(l))), this.wNAF(c, l, o);
    }
  };
}
function _N(r) {
  return LV(r.Fp), Uf(r, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...vN(r.n, r.nBitLength),
    ...r,
    p: r.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function qV(r) {
  const e = _N(r);
  Uf(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: t, Fp: n, a: s } = e;
  if (t) {
    if (!n.eql(s, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: WV, hexToBytes: VV } = PV, Pa = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(r) {
    const { Err: e } = Pa;
    if (r.length < 2 || r[0] !== 2)
      throw new e("Invalid signature integer tag");
    const t = r[1], n = r.subarray(2, t + 2);
    if (!t || n.length !== t)
      throw new e("Invalid signature integer: wrong length");
    if (n[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (n[0] === 0 && !(n[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: WV(n), l: r.subarray(t + 2) };
  },
  toSig(r) {
    const { Err: e } = Pa, t = typeof r == "string" ? VV(r) : r;
    if (!(t instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = t.length;
    if (n < 2 || t[0] != 48)
      throw new e("Invalid signature tag");
    if (t[1] !== n - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: s, l: i } = Pa._parseInt(t.subarray(2)), { d: o, l: a } = Pa._parseInt(i);
    if (a.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: s, s: o };
  },
  hexFromSig(r) {
    const e = (l) => Number.parseInt(l[0], 16) & 8 ? "00" + l : l, t = (l) => {
      const u = l.toString(16);
      return u.length & 1 ? `0${u}` : u;
    }, n = e(t(r.s)), s = e(t(r.r)), i = n.length / 2, o = s.length / 2, a = t(i), c = t(o);
    return `30${t(o + i + 4)}02${c}${s}02${a}${n}`;
  }
}, Pi = BigInt(0), zn = BigInt(1);
BigInt(2);
const WA = BigInt(3);
BigInt(4);
function GV(r) {
  const e = qV(r), { Fp: t } = e, n = e.toBytes || ((g, p, w) => {
    const E = p.toAffine();
    return zd(Uint8Array.from([4]), t.toBytes(E.x), t.toBytes(E.y));
  }), s = e.fromBytes || ((g) => {
    const p = g.subarray(1), w = t.fromBytes(p.subarray(0, t.BYTES)), E = t.fromBytes(p.subarray(t.BYTES, 2 * t.BYTES));
    return { x: w, y: E };
  });
  function i(g) {
    const { a: p, b: w } = e, E = t.sqr(g), I = t.mul(E, g);
    return t.add(t.add(I, t.mul(g, p)), w);
  }
  if (!t.eql(t.sqr(e.Gy), i(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function o(g) {
    return typeof g == "bigint" && Pi < g && g < e.n;
  }
  function a(g) {
    if (!o(g))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(g) {
    const { allowedPrivateKeyLengths: p, nByteLength: w, wrapPrivateKey: E, n: I } = e;
    if (p && typeof g != "bigint") {
      if (g instanceof Uint8Array && (g = Ru(g)), typeof g != "string" || !p.includes(g.length))
        throw new Error("Invalid key");
      g = g.padStart(w * 2, "0");
    }
    let A;
    try {
      A = typeof g == "bigint" ? g : ic(ns("private key", g, w));
    } catch {
      throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof g}`);
    }
    return E && (A = sn(A, I)), a(A), A;
  }
  const l = /* @__PURE__ */ new Map();
  function u(g) {
    if (!(g instanceof h))
      throw new Error("ProjectivePoint expected");
  }
  class h {
    constructor(p, w, E) {
      if (this.px = p, this.py = w, this.pz = E, p == null || !t.isValid(p))
        throw new Error("x required");
      if (w == null || !t.isValid(w))
        throw new Error("y required");
      if (E == null || !t.isValid(E))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x: w, y: E } = p || {};
      if (!p || !t.isValid(w) || !t.isValid(E))
        throw new Error("invalid affine point");
      if (p instanceof h)
        throw new Error("projective point not allowed");
      const I = (A) => t.eql(A, t.ZERO);
      return I(w) && I(E) ? h.ZERO : new h(w, E, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(p) {
      const w = t.invertBatch(p.map((E) => E.pz));
      return p.map((E, I) => E.toAffine(w[I])).map(h.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(p) {
      const w = h.fromAffine(s(ns("pointHex", p)));
      return w.assertValidity(), w;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(p) {
      return h.BASE.multiply(c(p));
    }
    // "Private method", don't use it directly
    _setWindowSize(p) {
      this._WINDOW_SIZE = p, l.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !t.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: p, y: w } = this.toAffine();
      if (!t.isValid(p) || !t.isValid(w))
        throw new Error("bad point: x or y not FE");
      const E = t.sqr(w), I = i(p);
      if (!t.eql(E, I))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: p } = this.toAffine();
      if (t.isOdd)
        return !t.isOdd(p);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(p) {
      u(p);
      const { px: w, py: E, pz: I } = this, { px: A, py: C, pz: N } = p, x = t.eql(t.mul(w, N), t.mul(A, I)), O = t.eql(t.mul(E, N), t.mul(C, I));
      return x && O;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new h(this.px, t.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: p, b: w } = e, E = t.mul(w, WA), { px: I, py: A, pz: C } = this;
      let N = t.ZERO, x = t.ZERO, O = t.ZERO, k = t.mul(I, I), P = t.mul(A, A), $ = t.mul(C, C), U = t.mul(I, A);
      return U = t.add(U, U), O = t.mul(I, C), O = t.add(O, O), N = t.mul(p, O), x = t.mul(E, $), x = t.add(N, x), N = t.sub(P, x), x = t.add(P, x), x = t.mul(N, x), N = t.mul(U, N), O = t.mul(E, O), $ = t.mul(p, $), U = t.sub(k, $), U = t.mul(p, U), U = t.add(U, O), O = t.add(k, k), k = t.add(O, k), k = t.add(k, $), k = t.mul(k, U), x = t.add(x, k), $ = t.mul(A, C), $ = t.add($, $), k = t.mul($, U), N = t.sub(N, k), O = t.mul($, P), O = t.add(O, O), O = t.add(O, O), new h(N, x, O);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(p) {
      u(p);
      const { px: w, py: E, pz: I } = this, { px: A, py: C, pz: N } = p;
      let x = t.ZERO, O = t.ZERO, k = t.ZERO;
      const P = e.a, $ = t.mul(e.b, WA);
      let U = t.mul(w, A), j = t.mul(E, C), H = t.mul(I, N), ee = t.add(w, E), y = t.add(A, C);
      ee = t.mul(ee, y), y = t.add(U, j), ee = t.sub(ee, y), y = t.add(w, I);
      let b = t.add(A, N);
      return y = t.mul(y, b), b = t.add(U, H), y = t.sub(y, b), b = t.add(E, I), x = t.add(C, N), b = t.mul(b, x), x = t.add(j, H), b = t.sub(b, x), k = t.mul(P, y), x = t.mul($, H), k = t.add(x, k), x = t.sub(j, k), k = t.add(j, k), O = t.mul(x, k), j = t.add(U, U), j = t.add(j, U), H = t.mul(P, H), y = t.mul($, y), j = t.add(j, H), H = t.sub(U, H), H = t.mul(P, H), y = t.add(y, H), U = t.mul(j, y), O = t.add(O, U), U = t.mul(b, y), x = t.mul(ee, x), x = t.sub(x, U), U = t.mul(ee, j), k = t.mul(b, k), k = t.add(k, U), new h(x, O, k);
    }
    subtract(p) {
      return this.add(p.negate());
    }
    is0() {
      return this.equals(h.ZERO);
    }
    wNAF(p) {
      return f.wNAFCached(this, l, p, (w) => {
        const E = t.invertBatch(w.map((I) => I.pz));
        return w.map((I, A) => I.toAffine(E[A])).map(h.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(p) {
      const w = h.ZERO;
      if (p === Pi)
        return w;
      if (a(p), p === zn)
        return this;
      const { endo: E } = e;
      if (!E)
        return f.unsafeLadder(this, p);
      let { k1neg: I, k1: A, k2neg: C, k2: N } = E.splitScalar(p), x = w, O = w, k = this;
      for (; A > Pi || N > Pi; )
        A & zn && (x = x.add(k)), N & zn && (O = O.add(k)), k = k.double(), A >>= zn, N >>= zn;
      return I && (x = x.negate()), C && (O = O.negate()), O = new h(t.mul(O.px, E.beta), O.py, O.pz), x.add(O);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(p) {
      a(p);
      let w = p, E, I;
      const { endo: A } = e;
      if (A) {
        const { k1neg: C, k1: N, k2neg: x, k2: O } = A.splitScalar(w);
        let { p: k, f: P } = this.wNAF(N), { p: $, f: U } = this.wNAF(O);
        k = f.constTimeNegate(C, k), $ = f.constTimeNegate(x, $), $ = new h(t.mul($.px, A.beta), $.py, $.pz), E = k.add($), I = P.add(U);
      } else {
        const { p: C, f: N } = this.wNAF(w);
        E = C, I = N;
      }
      return h.normalizeZ([E, I])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(p, w, E) {
      const I = h.BASE, A = (N, x) => x === Pi || x === zn || !N.equals(I) ? N.multiplyUnsafe(x) : N.multiply(x), C = A(this, w).add(A(p, E));
      return C.is0() ? void 0 : C;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(p) {
      const { px: w, py: E, pz: I } = this, A = this.is0();
      p == null && (p = A ? t.ONE : t.inv(I));
      const C = t.mul(w, p), N = t.mul(E, p), x = t.mul(I, p);
      if (A)
        return { x: t.ZERO, y: t.ZERO };
      if (!t.eql(x, t.ONE))
        throw new Error("invZ was invalid");
      return { x: C, y: N };
    }
    isTorsionFree() {
      const { h: p, isTorsionFree: w } = e;
      if (p === zn)
        return !0;
      if (w)
        return w(h, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: p, clearCofactor: w } = e;
      return p === zn ? this : w ? w(h, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(p = !0) {
      return this.assertValidity(), n(h, this, p);
    }
    toHex(p = !0) {
      return Ru(this.toRawBytes(p));
    }
  }
  h.BASE = new h(e.Gx, e.Gy, t.ONE), h.ZERO = new h(t.ZERO, t.ONE, t.ZERO);
  const d = e.nBitLength, f = zV(h, e.endo ? Math.ceil(d / 2) : d);
  return {
    CURVE: e,
    ProjectivePoint: h,
    normPrivateKeyToScalar: c,
    weierstrassEquation: i,
    isWithinCurveOrder: o
  };
}
function KV(r) {
  const e = _N(r);
  return Uf(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function JV(r) {
  const e = KV(r), { Fp: t, n } = e, s = t.BYTES + 1, i = 2 * t.BYTES + 1;
  function o(y) {
    return Pi < y && y < t.ORDER;
  }
  function a(y) {
    return sn(y, n);
  }
  function c(y) {
    return o0(y, n);
  }
  const { ProjectivePoint: l, normPrivateKeyToScalar: u, weierstrassEquation: h, isWithinCurveOrder: d } = GV({
    ...e,
    toBytes(y, b, T) {
      const B = b.toAffine(), R = t.toBytes(B.x), L = zd;
      return T ? L(Uint8Array.from([b.hasEvenY() ? 2 : 3]), R) : L(Uint8Array.from([4]), R, t.toBytes(B.y));
    },
    fromBytes(y) {
      const b = y.length, T = y[0], B = y.subarray(1);
      if (b === s && (T === 2 || T === 3)) {
        const R = ic(B);
        if (!o(R))
          throw new Error("Point is not on curve");
        const L = h(R);
        let q = t.sqrt(L);
        const Y = (q & zn) === zn;
        return (T & 1) === 1 !== Y && (q = t.neg(q)), { x: R, y: q };
      } else if (b === i && T === 4) {
        const R = t.fromBytes(B.subarray(0, t.BYTES)), L = t.fromBytes(B.subarray(t.BYTES, 2 * t.BYTES));
        return { x: R, y: L };
      } else
        throw new Error(`Point of length ${b} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`);
    }
  }), f = (y) => Ru(ku(y, e.nByteLength));
  function g(y) {
    const b = n >> zn;
    return y > b;
  }
  function p(y) {
    return g(y) ? a(-y) : y;
  }
  const w = (y, b, T) => ic(y.slice(b, T));
  class E {
    constructor(b, T, B) {
      this.r = b, this.s = T, this.recovery = B, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(b) {
      const T = e.nByteLength;
      return b = ns("compactSignature", b, T * 2), new E(w(b, 0, T), w(b, T, 2 * T));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(b) {
      const { r: T, s: B } = Pa.toSig(ns("DER", b));
      return new E(T, B);
    }
    assertValidity() {
      if (!d(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!d(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(b) {
      return new E(this.r, this.s, b);
    }
    recoverPublicKey(b) {
      const { r: T, s: B, recovery: R } = this, L = O(ns("msgHash", b));
      if (R == null || ![0, 1, 2, 3].includes(R))
        throw new Error("recovery id invalid");
      const q = R === 2 || R === 3 ? T + e.n : T;
      if (q >= t.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Y = R & 1 ? "03" : "02", de = l.fromHex(Y + f(q)), ne = c(q), we = a(-L * ne), ke = a(B * ne), xe = l.BASE.multiplyAndAddUnsafe(de, we, ke);
      if (!xe)
        throw new Error("point at infinify");
      return xe.assertValidity(), xe;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return g(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new E(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Du(this.toDERHex());
    }
    toDERHex() {
      return Pa.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Du(this.toCompactHex());
    }
    toCompactHex() {
      return f(this.r) + f(this.s);
    }
  }
  const I = {
    isValidPrivateKey(y) {
      try {
        return u(y), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: u,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const y = CN(e.n);
      return jV(e.randomBytes(y), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(y = 8, b = l.BASE) {
      return b._setWindowSize(y), b.multiply(BigInt(3)), b;
    }
  };
  function A(y, b = !0) {
    return l.fromPrivateKey(y).toRawBytes(b);
  }
  function C(y) {
    const b = y instanceof Uint8Array, T = typeof y == "string", B = (b || T) && y.length;
    return b ? B === s || B === i : T ? B === 2 * s || B === 2 * i : y instanceof l;
  }
  function N(y, b, T = !0) {
    if (C(y))
      throw new Error("first arg must be private key");
    if (!C(b))
      throw new Error("second arg must be public key");
    return l.fromHex(b).multiply(u(y)).toRawBytes(T);
  }
  const x = e.bits2int || function(y) {
    const b = ic(y), T = y.length * 8 - e.nBitLength;
    return T > 0 ? b >> BigInt(T) : b;
  }, O = e.bits2int_modN || function(y) {
    return a(x(y));
  }, k = kb(e.nBitLength);
  function P(y) {
    if (typeof y != "bigint")
      throw new Error("bigint expected");
    if (!(Pi <= y && y < k))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return ku(y, e.nByteLength);
  }
  function $(y, b, T = U) {
    if (["recovered", "canonical"].some((Ne) => Ne in T))
      throw new Error("sign() legacy options not supported");
    const { hash: B, randomBytes: R } = e;
    let { lowS: L, prehash: q, extraEntropy: Y } = T;
    L == null && (L = !0), y = ns("msgHash", y), q && (y = ns("prehashed msgHash", B(y)));
    const de = O(y), ne = u(b), we = [P(ne), P(de)];
    if (Y != null) {
      const Ne = Y === !0 ? R(t.BYTES) : Y;
      we.push(ns("extraEntropy", Ne));
    }
    const ke = zd(...we), xe = de;
    function Ve(Ne) {
      const yt = x(Ne);
      if (!d(yt))
        return;
      const Wt = c(yt), Bt = l.BASE.multiply(yt).toAffine(), It = a(Bt.x);
      if (It === Pi)
        return;
      const Rt = a(Wt * a(xe + It * ne));
      if (Rt === Pi)
        return;
      let Tn = (Bt.x === It ? 0 : 2) | Number(Bt.y & zn), na = Rt;
      return L && g(Rt) && (na = p(Rt), Tn ^= 1), new E(It, na, Tn);
    }
    return { seed: ke, k2sig: Ve };
  }
  const U = { lowS: e.lowS, prehash: !1 }, j = { lowS: e.lowS, prehash: !1 };
  function H(y, b, T = U) {
    const { seed: B, k2sig: R } = $(y, b, T), L = e;
    return EN(L.hash.outputLen, L.nByteLength, L.hmac)(B, R);
  }
  l.BASE._setWindowSize(8);
  function ee(y, b, T, B = j) {
    var Bt;
    const R = y;
    if (b = ns("msgHash", b), T = ns("publicKey", T), "strict" in B)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: L, prehash: q } = B;
    let Y, de;
    try {
      if (typeof R == "string" || R instanceof Uint8Array)
        try {
          Y = E.fromDER(R);
        } catch (It) {
          if (!(It instanceof Pa.Err))
            throw It;
          Y = E.fromCompact(R);
        }
      else if (typeof R == "object" && typeof R.r == "bigint" && typeof R.s == "bigint") {
        const { r: It, s: Rt } = R;
        Y = new E(It, Rt);
      } else
        throw new Error("PARSE");
      de = l.fromHex(T);
    } catch (It) {
      if (It.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (L && Y.hasHighS())
      return !1;
    q && (b = e.hash(b));
    const { r: ne, s: we } = Y, ke = O(b), xe = c(we), Ve = a(ke * xe), Ne = a(ne * xe), yt = (Bt = l.BASE.multiplyAndAddUnsafe(de, Ve, Ne)) == null ? void 0 : Bt.toAffine();
    return yt ? a(yt.x) === ne : !1;
  }
  return {
    CURVE: e,
    getPublicKey: A,
    getSharedSecret: N,
    sign: H,
    verify: ee,
    ProjectivePoint: l,
    Signature: E,
    utils: I
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function YV(r) {
  return {
    hash: r,
    hmac: (e, ...t) => eN(r, e, LW(...t)),
    randomBytes: FW
  };
}
function QV(r, e) {
  const t = (n) => JV({ ...r, ...YV(n) });
  return Object.freeze({ ...t(e), create: t });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const IN = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), VA = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), ZV = BigInt(1), a0 = BigInt(2), GA = (r, e) => (r + e / a0) / e;
function XV(r) {
  const e = IN, t = BigInt(3), n = BigInt(6), s = BigInt(11), i = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), l = r * r * r % e, u = l * l * r % e, h = Dn(u, t, e) * u % e, d = Dn(h, t, e) * u % e, f = Dn(d, a0, e) * l % e, g = Dn(f, s, e) * f % e, p = Dn(g, i, e) * g % e, w = Dn(p, a, e) * p % e, E = Dn(w, c, e) * w % e, I = Dn(E, a, e) * p % e, A = Dn(I, t, e) * u % e, C = Dn(A, o, e) * g % e, N = Dn(C, n, e) * l % e, x = Dn(N, a0, e);
  if (!c0.eql(c0.sqr(x), r))
    throw new Error("Cannot find square root");
  return x;
}
const c0 = MV(IN, void 0, void 0, { sqrt: XV }), lo = QV({
  a: BigInt(0),
  b: BigInt(7),
  Fp: c0,
  n: VA,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (r) => {
      const e = VA, t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -ZV * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = t, o = BigInt("0x100000000000000000000000000000000"), a = GA(i * r, e), c = GA(-n * r, e);
      let l = sn(r - a * t - c * s, e), u = sn(-a * n - c * i, e);
      const h = l > o, d = u > o;
      if (h && (l = e - l), d && (u = e - u), l > o || u > o)
        throw new Error("splitScalar: Endomorphism failed, k=" + r);
      return { k1neg: h, k1: l, k2neg: d, k2: u };
    }
  }
}, rN);
BigInt(0);
lo.ProjectivePoint;
const qd = "0x0000000000000000000000000000000000000000", KA = "0x0000000000000000000000000000000000000000000000000000000000000000", JA = BigInt(0), YA = BigInt(1), QA = BigInt(2), ZA = BigInt(27), XA = BigInt(28), wp = BigInt(35), rl = {};
function eC(r) {
  return Hi(qt(r), 32);
}
var Ml, jl, Hl, za;
const rs = class rs {
  /**
   *  @private
   */
  constructor(e, t, n, s) {
    M(this, Ml);
    M(this, jl);
    M(this, Hl);
    M(this, za);
    Df(e, rl, "Signature"), S(this, Ml, t), S(this, jl, n), S(this, Hl, s), S(this, za, null);
  }
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return m(this, Ml);
  }
  set r(e) {
    D(Il(e) === 32, "invalid r", "value", e), S(this, Ml, se(e));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return m(this, jl);
  }
  set s(e) {
    D(Il(e) === 32, "invalid s", "value", e);
    const t = se(e);
    D(parseInt(t.substring(0, 3)) < 8, "non-canonical s", "value", t), S(this, jl, t);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return m(this, Hl);
  }
  set v(e) {
    const t = De(e, "value");
    D(t === 27 || t === 28, "invalid v", "v", e), S(this, Hl, t);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return m(this, za);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : rs.getChainId(e);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const e = Le(this.s);
    return this.yParity && (e[0] |= 128), se(e);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return Pt([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return Pt([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const e = new rs(rl, this.r, this.s, this.v);
    return this.networkV && S(e, za, this.networkV), e;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(e) {
    const t = ge(e, "v");
    return t == ZA || t == XA ? JA : (D(t >= wp, "invalid EIP-155 v", "v", e), (t - wp) / QA);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(e, t) {
    return ge(e) * QA + BigInt(35 + t - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(e) {
    const t = ge(e);
    return t === JA || t === ZA ? 27 : t === YA || t === XA ? 28 : (D(t >= wp, "invalid v", "v", e), t & YA ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(e) {
    function t(l, u) {
      D(l, u, "signature", e);
    }
    if (e == null)
      return new rs(rl, KA, KA, 27);
    if (typeof e == "string") {
      const l = Le(e, "signature");
      if (l.length === 64) {
        const u = se(l.slice(0, 32)), h = l.slice(32, 64), d = h[0] & 128 ? 28 : 27;
        return h[0] &= 127, new rs(rl, u, se(h), d);
      }
      if (l.length === 65) {
        const u = se(l.slice(0, 32)), h = l.slice(32, 64);
        t((h[0] & 128) === 0, "non-canonical s");
        const d = rs.getNormalizedV(l[64]);
        return new rs(rl, u, se(h), d);
      }
      t(!1, "invalid raw signature length");
    }
    if (e instanceof rs)
      return e.clone();
    const n = e.r;
    t(n != null, "missing r");
    const s = eC(n), i = function(l, u) {
      if (l != null)
        return eC(l);
      if (u != null) {
        t(wt(u, 32), "invalid yParityAndS");
        const h = Le(u);
        return h[0] &= 127, se(h);
      }
      t(!1, "missing s");
    }(e.s, e.yParityAndS);
    t((Le(i)[0] & 128) == 0, "non-canonical s");
    const { networkV: o, v: a } = function(l, u, h) {
      if (l != null) {
        const d = ge(l);
        return {
          networkV: d >= wp ? d : void 0,
          v: rs.getNormalizedV(d)
        };
      }
      if (u != null)
        return t(wt(u, 32), "invalid yParityAndS"), { v: Le(u)[0] & 128 ? 28 : 27 };
      if (h != null) {
        switch (De(h, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        t(!1, "invalid yParity");
      }
      t(!1, "missing v");
    }(e.v, e.yParityAndS, e.yParity), c = new rs(rl, s, i, a);
    return o && S(c, za, o), t(e.yParity == null || De(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), t(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
};
Ml = new WeakMap(), jl = new WeakMap(), Hl = new WeakMap(), za = new WeakMap();
let ln = rs;
var vi;
const Aa = class Aa {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(e) {
    M(this, vi);
    D(Il(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), S(this, vi, se(e));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return m(this, vi);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return Aa.computePublicKey(m(this, vi));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return Aa.computePublicKey(m(this, vi), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(e) {
    D(Il(e) === 32, "invalid digest length", "digest", e);
    const t = lo.sign(kr(e), kr(m(this, vi)), {
      lowS: !0
    });
    return ln.from({
      r: Qo(t.r, 32),
      s: Qo(t.s, 32),
      v: t.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(e) {
    const t = Aa.computePublicKey(e);
    return se(lo.getSharedSecret(kr(m(this, vi)), Le(t), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(e, t) {
    let n = Le(e, "key");
    if (n.length === 32) {
      const i = lo.getPublicKey(n, !!t);
      return se(i);
    }
    if (n.length === 64) {
      const i = new Uint8Array(65);
      i[0] = 4, i.set(n, 1), n = i;
    }
    const s = lo.ProjectivePoint.fromHex(n);
    return se(s.toRawBytes(t));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(e, t) {
    D(Il(e) === 32, "invalid digest length", "digest", e);
    const n = ln.from(t);
    let s = lo.Signature.fromCompact(kr(Pt([n.r, n.s])));
    s = s.addRecoveryBit(n.yParity);
    const i = s.recoverPublicKey(kr(e));
    return D(i != null, "invalid signature for digest", "signature", t), "0x" + i.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(e, t, n) {
    const s = lo.ProjectivePoint.fromHex(Aa.computePublicKey(e).substring(2)), i = lo.ProjectivePoint.fromHex(Aa.computePublicKey(t).substring(2));
    return "0x" + s.add(i).toHex(!!n);
  }
};
vi = new WeakMap();
let Wd = Aa;
const eG = BigInt(0), tG = BigInt(36);
function tC(r) {
  r = r.toLowerCase();
  const e = r.substring(2).split(""), t = new Uint8Array(40);
  for (let s = 0; s < 40; s++)
    t[s] = e[s].charCodeAt(0);
  const n = Le($t(t));
  for (let s = 0; s < 40; s += 2)
    n[s >> 1] >> 4 >= 8 && (e[s] = e[s].toUpperCase()), (n[s >> 1] & 15) >= 8 && (e[s + 1] = e[s + 1].toUpperCase());
  return "0x" + e.join("");
}
const Ub = {};
for (let r = 0; r < 10; r++)
  Ub[String(r)] = String(r);
for (let r = 0; r < 26; r++)
  Ub[String.fromCharCode(65 + r)] = String(10 + r);
const rC = 15;
function rG(r) {
  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
  let e = r.split("").map((n) => Ub[n]).join("");
  for (; e.length >= rC; ) {
    let n = e.substring(0, rC);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
const nG = function() {
  const r = {};
  for (let e = 0; e < 36; e++) {
    const t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    r[t] = BigInt(e);
  }
  return r;
}();
function sG(r) {
  r = r.toLowerCase();
  let e = eG;
  for (let t = 0; t < r.length; t++)
    e = e * tG + nG[r[t]];
  return e;
}
function it(r) {
  if (D(typeof r == "string", "invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    r.startsWith("0x") || (r = "0x" + r);
    const e = tC(r);
    return D(!r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === r, "bad address checksum", "address", r), e;
  }
  if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    D(r.substring(2, 4) === rG(r), "bad icap checksum", "address", r);
    let e = sG(r.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return tC("0x" + e);
  }
  D(!1, "invalid address", "address", r);
}
function iG(r) {
  const e = it(r.from);
  let n = ge(r.nonce, "tx.nonce").toString(16);
  return n === "0" ? n = "0x" : n.length % 2 ? n = "0x0" + n : n = "0x" + n, it(Ot($t(Zo([e, n])), 12));
}
function SN(r) {
  return r && typeof r.getAddress == "function";
}
async function Dw(r, e) {
  const t = await e;
  return (t == null || t === "0x0000000000000000000000000000000000000000") && (z(typeof r != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: r }), D(!1, "invalid AddressLike value; did not resolve to a value address", "target", r)), it(t);
}
function Br(r, e) {
  if (typeof r == "string")
    return r.match(/^0x[0-9a-f]{40}$/i) ? it(r) : (z(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), Dw(r, e.resolveName(r)));
  if (SN(r))
    return Dw(r, r.getAddress());
  if (r && typeof r.then == "function")
    return Dw(r, r);
  D(!1, "unsupported addressable value", "target", r);
}
const pi = {};
function fe(r, e) {
  let t = !1;
  return e < 0 && (t = !0, e *= -1), new Sr(pi, `${t ? "" : "u"}int${e}`, r, { signed: t, width: e });
}
function Ye(r, e) {
  return new Sr(pi, `bytes${e || ""}`, r, { size: e });
}
const nC = Symbol.for("_ethers_typed");
var qa;
const gi = class gi {
  /**
   *  @_ignore:
   */
  constructor(e, t, n, s) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    F(this, "type");
    /**
     *  The actual value.
     */
    F(this, "value");
    M(this, qa);
    /**
     *  @_ignore:
     */
    F(this, "_typedSymbol");
    s == null && (s = null), Df(pi, e, "Typed"), Ae(this, { _typedSymbol: nC, type: t, value: n }), S(this, qa, s), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((e) => e.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return m(this, qa);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return m(this, qa) === !0 ? -1 : m(this, qa) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(e, t) {
    return new gi(pi, e, t);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(e) {
    return fe(e, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(e) {
    return fe(e, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(e) {
    return fe(e, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(e) {
    return fe(e, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(e) {
    return fe(e, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(e) {
    return fe(e, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(e) {
    return fe(e, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(e) {
    return fe(e, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(e) {
    return fe(e, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(e) {
    return fe(e, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(e) {
    return fe(e, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(e) {
    return fe(e, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(e) {
    return fe(e, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(e) {
    return fe(e, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(e) {
    return fe(e, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(e) {
    return fe(e, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(e) {
    return fe(e, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(e) {
    return fe(e, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(e) {
    return fe(e, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(e) {
    return fe(e, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(e) {
    return fe(e, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(e) {
    return fe(e, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(e) {
    return fe(e, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(e) {
    return fe(e, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(e) {
    return fe(e, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(e) {
    return fe(e, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(e) {
    return fe(e, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(e) {
    return fe(e, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(e) {
    return fe(e, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(e) {
    return fe(e, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(e) {
    return fe(e, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(e) {
    return fe(e, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(e) {
    return fe(e, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(e) {
    return fe(e, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(e) {
    return fe(e, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(e) {
    return fe(e, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(e) {
    return fe(e, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(e) {
    return fe(e, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(e) {
    return fe(e, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(e) {
    return fe(e, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(e) {
    return fe(e, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(e) {
    return fe(e, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(e) {
    return fe(e, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(e) {
    return fe(e, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(e) {
    return fe(e, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(e) {
    return fe(e, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(e) {
    return fe(e, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(e) {
    return fe(e, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(e) {
    return fe(e, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(e) {
    return fe(e, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(e) {
    return fe(e, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(e) {
    return fe(e, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(e) {
    return fe(e, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(e) {
    return fe(e, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(e) {
    return fe(e, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(e) {
    return fe(e, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(e) {
    return fe(e, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(e) {
    return fe(e, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(e) {
    return fe(e, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(e) {
    return fe(e, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(e) {
    return fe(e, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(e) {
    return fe(e, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(e) {
    return fe(e, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(e) {
    return fe(e, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(e) {
    return fe(e, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(e) {
    return fe(e, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(e) {
    return Ye(e, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(e) {
    return Ye(e, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(e) {
    return Ye(e, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(e) {
    return Ye(e, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(e) {
    return Ye(e, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(e) {
    return Ye(e, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(e) {
    return Ye(e, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(e) {
    return Ye(e, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(e) {
    return Ye(e, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(e) {
    return Ye(e, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(e) {
    return Ye(e, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(e) {
    return Ye(e, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(e) {
    return Ye(e, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(e) {
    return Ye(e, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(e) {
    return Ye(e, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(e) {
    return Ye(e, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(e) {
    return Ye(e, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(e) {
    return Ye(e, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(e) {
    return Ye(e, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(e) {
    return Ye(e, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(e) {
    return Ye(e, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(e) {
    return Ye(e, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(e) {
    return Ye(e, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(e) {
    return Ye(e, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(e) {
    return Ye(e, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(e) {
    return Ye(e, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(e) {
    return Ye(e, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(e) {
    return Ye(e, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(e) {
    return Ye(e, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(e) {
    return Ye(e, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(e) {
    return Ye(e, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(e) {
    return Ye(e, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(e) {
    return new gi(pi, "address", e);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(e) {
    return new gi(pi, "bool", !!e);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(e) {
    return new gi(pi, "bytes", e);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(e) {
    return new gi(pi, "string", e);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(e, t) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(e, t) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(e) {
    return new gi(pi, "overrides", Object.assign({}, e));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(e) {
    return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === nC;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(e, t) {
    if (gi.isTyped(e)) {
      if (e.type !== t)
        throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);
      return e.value;
    }
    return e;
  }
};
qa = new WeakMap();
let Sr = gi;
class oG extends Wi {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    let n = Sr.dereference(t, "string");
    try {
      n = it(n);
    } catch (s) {
      return this._throwError(s.message, t);
    }
    return e.writeValue(n);
  }
  decode(e) {
    return it(Qo(e.readValue(), 20));
  }
}
class aG extends Wi {
  constructor(t) {
    super(t.name, t.type, "_", t.dynamic);
    F(this, "coder");
    this.coder = t;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(t, n) {
    return this.coder.encode(t, n);
  }
  decode(t) {
    return this.coder.decode(t);
  }
}
function NN(r, e, t) {
  let n = [];
  if (Array.isArray(t))
    n = t;
  else if (t && typeof t == "object") {
    let c = {};
    n = e.map((l) => {
      const u = l.localName;
      return z(u, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: l }, value: t }), z(!c[u], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: l }, value: t }), c[u] = !0, t[u];
    });
  } else
    D(!1, "invalid tuple value", "tuple", t);
  D(e.length === n.length, "types/value length mismatch", "tuple", t);
  let s = new t0(), i = new t0(), o = [];
  e.forEach((c, l) => {
    let u = n[l];
    if (c.dynamic) {
      let h = i.length;
      c.encode(i, u);
      let d = s.writeUpdatableValue();
      o.push((f) => {
        d(f + h);
      });
    } else
      c.encode(s, u);
  }), o.forEach((c) => {
    c(s.length);
  });
  let a = r.appendWriter(s);
  return a += r.appendWriter(i), a;
}
function TN(r, e) {
  let t = [], n = [], s = r.subReader(0);
  return e.forEach((i) => {
    let o = null;
    if (i.dynamic) {
      let a = r.readIndex(), c = s.subReader(a);
      try {
        o = i.decode(c);
      } catch (l) {
        if (hr(l, "BUFFER_OVERRUN"))
          throw l;
        o = l, o.baseType = i.name, o.name = i.localName, o.type = i.type;
      }
    } else
      try {
        o = i.decode(r);
      } catch (a) {
        if (hr(a, "BUFFER_OVERRUN"))
          throw a;
        o = a, o.baseType = i.name, o.name = i.localName, o.type = i.type;
      }
    if (o == null)
      throw new Error("investigate");
    t.push(o), n.push(i.localName || null);
  }), Ou.fromItems(t, n);
}
class cG extends Wi {
  constructor(t, n, s) {
    const i = t.type + "[" + (n >= 0 ? n : "") + "]", o = n === -1 || t.dynamic;
    super("array", i, s, o);
    F(this, "coder");
    F(this, "length");
    Ae(this, { coder: t, length: n });
  }
  defaultValue() {
    const t = this.coder.defaultValue(), n = [];
    for (let s = 0; s < this.length; s++)
      n.push(t);
    return n;
  }
  encode(t, n) {
    const s = Sr.dereference(n, "array");
    Array.isArray(s) || this._throwError("expected array value", s);
    let i = this.length;
    i === -1 && (i = s.length, t.writeValue(s.length)), US(s.length, i, "coder array" + (this.localName ? " " + this.localName : ""));
    let o = [];
    for (let a = 0; a < s.length; a++)
      o.push(this.coder);
    return NN(t, o, s);
  }
  decode(t) {
    let n = this.length;
    n === -1 && (n = t.readIndex(), z(n * Ur <= t.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: t.bytes, offset: n * Ur, length: t.dataLength }));
    let s = [];
    for (let i = 0; i < n; i++)
      s.push(new aG(this.coder));
    return TN(t, s);
  }
}
class lG extends Wi {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    const n = Sr.dereference(t, "bool");
    return e.writeValue(n ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
}
class xN extends Wi {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, t) {
    t = kr(t);
    let n = e.writeValue(t.length);
    return n += e.writeBytes(t), n;
  }
  decode(e) {
    return e.readBytes(e.readIndex(), !0);
  }
}
class uG extends xN {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return se(super.decode(e));
  }
}
class hG extends Wi {
  constructor(t, n) {
    let s = "bytes" + String(t);
    super(s, s, n, !1);
    F(this, "size");
    Ae(this, { size: t }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(t, n) {
    let s = kr(Sr.dereference(n, this.type));
    return s.length !== this.size && this._throwError("incorrect data length", n), t.writeBytes(s);
  }
  decode(t) {
    return se(t.readBytes(this.size));
  }
}
const dG = new Uint8Array([]);
class fG extends Wi {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError("not null", t), e.writeBytes(dG);
  }
  decode(e) {
    return e.readBytes(0), null;
  }
}
const pG = BigInt(0), gG = BigInt(1), mG = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class wG extends Wi {
  constructor(t, n, s) {
    const i = (n ? "int" : "uint") + t * 8;
    super(i, i, s, !1);
    F(this, "size");
    F(this, "signed");
    Ae(this, { size: t, signed: n }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(t, n) {
    let s = ge(Sr.dereference(n, this.type)), i = Oa(mG, Ur * 8);
    if (this.signed) {
      let o = Oa(i, this.size * 8 - 1);
      (s > o || s < -(o + gG)) && this._throwError("value out-of-bounds", n), s = FS(s, 8 * Ur);
    } else (s < pG || s > Oa(i, this.size * 8)) && this._throwError("value out-of-bounds", n);
    return t.writeValue(s);
  }
  decode(t) {
    let n = Oa(t.readValue(), this.size * 8);
    return this.signed && (n = Eg(n, this.size * 8)), n;
  }
}
class yG extends xN {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, Zs(Sr.dereference(t, "string")));
  }
  decode(e) {
    return vg(super.decode(e));
  }
}
class yp extends Wi {
  constructor(t, n) {
    let s = !1;
    const i = [];
    t.forEach((a) => {
      a.dynamic && (s = !0), i.push(a.type);
    });
    const o = "tuple(" + i.join(",") + ")";
    super("tuple", o, n, s);
    F(this, "coders");
    Ae(this, { coders: Object.freeze(t.slice()) });
  }
  defaultValue() {
    const t = [];
    this.coders.forEach((s) => {
      t.push(s.defaultValue());
    });
    const n = this.coders.reduce((s, i) => {
      const o = i.localName;
      return o && (s[o] || (s[o] = 0), s[o]++), s;
    }, {});
    return this.coders.forEach((s, i) => {
      let o = s.localName;
      !o || n[o] !== 1 || (o === "length" && (o = "_length"), t[o] == null && (t[o] = t[i]));
    }), Object.freeze(t);
  }
  encode(t, n) {
    const s = Sr.dereference(n, "tuple");
    return NN(t, this.coders, s);
  }
  decode(t) {
    return TN(t, this.coders);
  }
}
function kw(r, e) {
  return {
    address: it(r),
    storageKeys: e.map((t, n) => (D(wt(t, 32), "invalid slot", `storageKeys[${n}]`, t), t.toLowerCase()))
  };
}
function Rc(r) {
  if (Array.isArray(r))
    return r.map((t, n) => Array.isArray(t) ? (D(t.length === 2, "invalid slot set", `value[${n}]`, t), kw(t[0], t[1])) : (D(t != null && typeof t == "object", "invalid address-slot set", "value", r), kw(t.address, t.storageKeys)));
  D(r != null && typeof r == "object", "invalid access list", "value", r);
  const e = Object.keys(r).map((t) => {
    const n = r[t].reduce((s, i) => (s[i] = !0, s), {});
    return kw(t, Object.keys(n).sort());
  });
  return e.sort((t, n) => t.address.localeCompare(n.address)), e;
}
function ON(r) {
  return {
    address: it(r.address),
    nonce: ge(r.nonce != null ? r.nonce : 0),
    chainId: ge(r.chainId != null ? r.chainId : 0),
    signature: ln.from(r.signature)
  };
}
function bG(r) {
  let e;
  return typeof r == "string" ? e = Wd.computePublicKey(r, !1) : e = r.publicKey, it($t("0x" + e.substring(4)).substring(26));
}
function EG(r, e) {
  return bG(Wd.recoverPublicKey(r, e));
}
const Qt = BigInt(0), vG = BigInt(2), AG = BigInt(27), CG = BigInt(28), _G = BigInt(35), IG = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), Uw = 4096 * 32;
function SG(r) {
  return { blobToKzgCommitment: (n) => {
    if ("computeBlobProof" in r) {
      if ("blobToKzgCommitment" in r && typeof r.blobToKzgCommitment == "function")
        return Le(r.blobToKzgCommitment(se(n)));
    } else if ("blobToKzgCommitment" in r && typeof r.blobToKzgCommitment == "function")
      return Le(r.blobToKzgCommitment(n));
    if ("blobToKZGCommitment" in r && typeof r.blobToKZGCommitment == "function")
      return Le(r.blobToKZGCommitment(se(n)));
    D(!1, "unsupported KZG library", "kzg", r);
  }, computeBlobKzgProof: (n, s) => {
    if ("computeBlobProof" in r && typeof r.computeBlobProof == "function")
      return Le(r.computeBlobProof(se(n), se(s)));
    if ("computeBlobKzgProof" in r && typeof r.computeBlobKzgProof == "function")
      return r.computeBlobKzgProof(n, s);
    if ("computeBlobKZGProof" in r && typeof r.computeBlobKZGProof == "function")
      return Le(r.computeBlobKZGProof(se(n), se(s)));
    D(!1, "unsupported KZG library", "kzg", r);
  } };
}
function sC(r, e) {
  let t = r.toString(16);
  for (; t.length < 2; )
    t = "0" + t;
  return t += Gu(e).substring(4), "0x" + t;
}
function Ku(r) {
  return r === "0x" ? null : it(r);
}
function fm(r, e) {
  try {
    return Rc(r);
  } catch (t) {
    D(!1, t.message, e, r);
  }
}
function NG(r, e) {
  try {
    if (!Array.isArray(r))
      throw new Error("authorizationList: invalid array");
    const t = [];
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      if (!Array.isArray(s))
        throw new Error(`authorization[${n}]: invalid array`);
      if (s.length !== 6)
        throw new Error(`authorization[${n}]: wrong length`);
      if (!s[1])
        throw new Error(`authorization[${n}]: null address`);
      t.push({
        address: Ku(s[1]),
        nonce: pt(s[2], "nonce"),
        chainId: pt(s[0], "chainId"),
        signature: ln.from({
          yParity: Dc(s[3], "yParity"),
          r: Hi(s[4], 32),
          s: Hi(s[5], 32)
        })
      });
    }
    return t;
  } catch (t) {
    D(!1, t.message, e, r);
  }
}
function Dc(r, e) {
  return r === "0x" ? 0 : De(r, e);
}
function pt(r, e) {
  if (r === "0x")
    return Qt;
  const t = ge(r, e);
  return D(t <= IG, "value exceeds uint size", e, t), t;
}
function ze(r, e) {
  const t = ge(r, "value"), n = qt(t);
  return D(n.length <= 32, "value too large", `tx.${e}`, t), n;
}
function pm(r) {
  return Rc(r).map((e) => [e.address, e.storageKeys]);
}
function TG(r) {
  return r.map((e) => [
    ze(e.chainId, "chainId"),
    e.address,
    ze(e.nonce, "nonce"),
    ze(e.signature.yParity, "yParity"),
    qt(e.signature.r),
    qt(e.signature.s)
  ]);
}
function xG(r, e) {
  D(Array.isArray(r), `invalid ${e}`, "value", r);
  for (let t = 0; t < r.length; t++)
    D(wt(r[t], 32), "invalid ${ param } hash", `value[${t}]`, r[t]);
  return r;
}
function OG(r) {
  const e = kf(r);
  D(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", r);
  const t = {
    type: 0,
    nonce: Dc(e[0], "nonce"),
    gasPrice: pt(e[1], "gasPrice"),
    gasLimit: pt(e[2], "gasLimit"),
    to: Ku(e[3]),
    value: pt(e[4], "value"),
    data: se(e[5]),
    chainId: Qt
  };
  if (e.length === 6)
    return t;
  const n = pt(e[6], "v"), s = pt(e[7], "r"), i = pt(e[8], "s");
  if (s === Qt && i === Qt)
    t.chainId = n;
  else {
    let o = (n - _G) / vG;
    o < Qt && (o = Qt), t.chainId = o, D(o !== Qt || n === AG || n === CG, "non-canonical legacy v", "v", e[6]), t.signature = ln.from({
      r: Hi(e[7], 32),
      s: Hi(e[8], 32),
      v: n
    });
  }
  return t;
}
function PG(r, e) {
  const t = [
    ze(r.nonce, "nonce"),
    ze(r.gasPrice || 0, "gasPrice"),
    ze(r.gasLimit, "gasLimit"),
    r.to || "0x",
    ze(r.value, "value"),
    r.data
  ];
  let n = Qt;
  if (r.chainId != Qt)
    n = ge(r.chainId, "tx.chainId"), D(!e || e.networkV == null || e.legacyChainId === n, "tx.chainId/sig.v mismatch", "sig", e);
  else if (r.signature) {
    const i = r.signature.legacyChainId;
    i != null && (n = i);
  }
  if (!e)
    return n !== Qt && (t.push(qt(n)), t.push("0x"), t.push("0x")), Zo(t);
  let s = BigInt(27 + e.yParity);
  return n !== Qt ? s = ln.getChainIdV(n, e.v) : BigInt(e.v) !== s && D(!1, "tx.chainId/sig.v mismatch", "sig", e), t.push(qt(s)), t.push(qt(e.r)), t.push(qt(e.s)), Zo(t);
}
function gm(r, e) {
  let t;
  try {
    if (t = Dc(e[0], "yParity"), t !== 0 && t !== 1)
      throw new Error("bad yParity");
  } catch {
    D(!1, "invalid yParity", "yParity", e[0]);
  }
  const n = Hi(e[1], 32), s = Hi(e[2], 32), i = ln.from({ r: n, s, yParity: t });
  r.signature = i;
}
function RG(r) {
  const e = kf(Le(r).slice(1));
  D(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", se(r));
  const t = {
    type: 2,
    chainId: pt(e[0], "chainId"),
    nonce: Dc(e[1], "nonce"),
    maxPriorityFeePerGas: pt(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: pt(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: pt(e[4], "gasLimit"),
    to: Ku(e[5]),
    value: pt(e[6], "value"),
    data: se(e[7]),
    accessList: fm(e[8], "accessList")
  };
  return e.length === 9 || gm(t, e.slice(9)), t;
}
function DG(r, e) {
  const t = [
    ze(r.chainId, "chainId"),
    ze(r.nonce, "nonce"),
    ze(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ze(r.maxFeePerGas || 0, "maxFeePerGas"),
    ze(r.gasLimit, "gasLimit"),
    r.to || "0x",
    ze(r.value, "value"),
    r.data,
    pm(r.accessList || [])
  ];
  return e && (t.push(ze(e.yParity, "yParity")), t.push(qt(e.r)), t.push(qt(e.s))), Pt(["0x02", Zo(t)]);
}
function kG(r) {
  const e = kf(Le(r).slice(1));
  D(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", se(r));
  const t = {
    type: 1,
    chainId: pt(e[0], "chainId"),
    nonce: Dc(e[1], "nonce"),
    gasPrice: pt(e[2], "gasPrice"),
    gasLimit: pt(e[3], "gasLimit"),
    to: Ku(e[4]),
    value: pt(e[5], "value"),
    data: se(e[6]),
    accessList: fm(e[7], "accessList")
  };
  return e.length === 8 || gm(t, e.slice(8)), t;
}
function UG(r, e) {
  const t = [
    ze(r.chainId, "chainId"),
    ze(r.nonce, "nonce"),
    ze(r.gasPrice || 0, "gasPrice"),
    ze(r.gasLimit, "gasLimit"),
    r.to || "0x",
    ze(r.value, "value"),
    r.data,
    pm(r.accessList || [])
  ];
  return e && (t.push(ze(e.yParity, "recoveryParam")), t.push(qt(e.r)), t.push(qt(e.s))), Pt(["0x01", Zo(t)]);
}
function BG(r) {
  let e = kf(Le(r).slice(1)), t = "3", n = null;
  if (e.length === 4 && Array.isArray(e[0])) {
    t = "3 (network format)";
    const i = e[1], o = e[2], a = e[3];
    D(Array.isArray(i), "invalid network format: blobs not an array", "fields[1]", i), D(Array.isArray(o), "invalid network format: commitments not an array", "fields[2]", o), D(Array.isArray(a), "invalid network format: proofs not an array", "fields[3]", a), D(i.length === o.length, "invalid network format: blobs/commitments length mismatch", "fields", e), D(i.length === a.length, "invalid network format: blobs/proofs length mismatch", "fields", e), n = [];
    for (let c = 0; c < e[1].length; c++)
      n.push({
        data: i[c],
        commitment: o[c],
        proof: a[c]
      });
    e = e[0];
  }
  D(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${t}`, "data", se(r));
  const s = {
    type: 3,
    chainId: pt(e[0], "chainId"),
    nonce: Dc(e[1], "nonce"),
    maxPriorityFeePerGas: pt(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: pt(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: pt(e[4], "gasLimit"),
    to: Ku(e[5]),
    value: pt(e[6], "value"),
    data: se(e[7]),
    accessList: fm(e[8], "accessList"),
    maxFeePerBlobGas: pt(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10]
  };
  n && (s.blobs = n), D(s.to != null, `invalid address for transaction type: ${t}`, "data", r), D(Array.isArray(s.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", r);
  for (let i = 0; i < s.blobVersionedHashes.length; i++)
    D(wt(s.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", r);
  return e.length === 11 || gm(s, e.slice(11)), s;
}
function LG(r, e, t) {
  const n = [
    ze(r.chainId, "chainId"),
    ze(r.nonce, "nonce"),
    ze(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ze(r.maxFeePerGas || 0, "maxFeePerGas"),
    ze(r.gasLimit, "gasLimit"),
    r.to || qd,
    ze(r.value, "value"),
    r.data,
    pm(r.accessList || []),
    ze(r.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    xG(r.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return e && (n.push(ze(e.yParity, "yParity")), n.push(qt(e.r)), n.push(qt(e.s)), t) ? Pt([
    "0x03",
    Zo([
      n,
      t.map((s) => s.data),
      t.map((s) => s.commitment),
      t.map((s) => s.proof)
    ])
  ]) : Pt(["0x03", Zo(n)]);
}
function FG(r) {
  const e = kf(Le(r).slice(1));
  D(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", se(r));
  const t = {
    type: 4,
    chainId: pt(e[0], "chainId"),
    nonce: Dc(e[1], "nonce"),
    maxPriorityFeePerGas: pt(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: pt(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: pt(e[4], "gasLimit"),
    to: Ku(e[5]),
    value: pt(e[6], "value"),
    data: se(e[7]),
    accessList: fm(e[8], "accessList"),
    authorizationList: NG(e[9], "authorizationList")
  };
  return e.length === 10 || gm(t, e.slice(10)), t;
}
function $G(r, e) {
  const t = [
    ze(r.chainId, "chainId"),
    ze(r.nonce, "nonce"),
    ze(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ze(r.maxFeePerGas || 0, "maxFeePerGas"),
    ze(r.gasLimit, "gasLimit"),
    r.to || "0x",
    ze(r.value, "value"),
    r.data,
    pm(r.accessList || []),
    TG(r.authorizationList || [])
  ];
  return e && (t.push(ze(e.yParity, "yParity")), t.push(qt(e.r)), t.push(qt(e.s))), Pt(["0x04", Zo(t)]);
}
var as, zl, ql, Wl, Vl, Gl, Kl, Jl, Yl, Ql, Zl, Xl, Wa, Co, ks, _o, eu, tu, Lp;
const Rs = class Rs {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    M(this, tu);
    M(this, as);
    M(this, zl);
    M(this, ql);
    M(this, Wl);
    M(this, Vl);
    M(this, Gl);
    M(this, Kl);
    M(this, Jl);
    M(this, Yl);
    M(this, Ql);
    M(this, Zl);
    M(this, Xl);
    M(this, Wa);
    M(this, Co);
    M(this, ks);
    M(this, _o);
    M(this, eu);
    S(this, as, null), S(this, zl, null), S(this, Wl, 0), S(this, Vl, Qt), S(this, Gl, null), S(this, Kl, null), S(this, Jl, null), S(this, ql, "0x"), S(this, Yl, Qt), S(this, Ql, Qt), S(this, Zl, null), S(this, Xl, null), S(this, Wa, null), S(this, Co, null), S(this, ks, null), S(this, _o, null), S(this, eu, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return m(this, as);
  }
  set type(e) {
    switch (e) {
      case null:
        S(this, as, null);
        break;
      case 0:
      case "legacy":
        S(this, as, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        S(this, as, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        S(this, as, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        S(this, as, 3);
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        S(this, as, 4);
        break;
      default:
        D(!1, "unsupported transaction type", "type", e);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const e = m(this, zl);
    return e == null && this.type === 3 ? qd : e;
  }
  set to(e) {
    S(this, zl, e == null ? null : it(e));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return m(this, Wl);
  }
  set nonce(e) {
    S(this, Wl, De(e, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return m(this, Vl);
  }
  set gasLimit(e) {
    S(this, Vl, ge(e));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const e = m(this, Gl);
    return e == null && (this.type === 0 || this.type === 1) ? Qt : e;
  }
  set gasPrice(e) {
    S(this, Gl, e == null ? null : ge(e, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const e = m(this, Kl);
    return e ?? (this.type === 2 || this.type === 3 ? Qt : null);
  }
  set maxPriorityFeePerGas(e) {
    S(this, Kl, e == null ? null : ge(e, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const e = m(this, Jl);
    return e ?? (this.type === 2 || this.type === 3 ? Qt : null);
  }
  set maxFeePerGas(e) {
    S(this, Jl, e == null ? null : ge(e, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return m(this, ql);
  }
  set data(e) {
    S(this, ql, se(e));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return m(this, Yl);
  }
  set value(e) {
    S(this, Yl, ge(e, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return m(this, Ql);
  }
  set chainId(e) {
    S(this, Ql, ge(e));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return m(this, Zl) || null;
  }
  set signature(e) {
    S(this, Zl, e == null ? null : ln.from(e));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const e = m(this, Xl) || null;
    return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(e) {
    S(this, Xl, e == null ? null : Rc(e));
  }
  get authorizationList() {
    const e = m(this, eu) || null;
    return e == null && this.type === 4 ? [] : e;
  }
  set authorizationList(e) {
    S(this, eu, e == null ? null : e.map((t) => ON(t)));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const e = m(this, Wa);
    return e == null && this.type === 3 ? Qt : e;
  }
  set maxFeePerBlobGas(e) {
    S(this, Wa, e == null ? null : ge(e, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let e = m(this, Co);
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      D(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
      for (let t = 0; t < e.length; t++)
        D(wt(e[t], 32), "invalid blobVersionedHash", `value[${t}]`, e[t]);
    }
    S(this, Co, e);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return m(this, _o) == null ? null : m(this, _o).map((e) => Object.assign({}, e));
  }
  set blobs(e) {
    if (e == null) {
      S(this, _o, null);
      return;
    }
    const t = [], n = [];
    for (let s = 0; s < e.length; s++) {
      const i = e[s];
      if (Sb(i)) {
        z(m(this, ks), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let o = Le(i);
        if (D(o.length <= Uw, "blob is too large", `blobs[${s}]`, i), o.length !== Uw) {
          const l = new Uint8Array(Uw);
          l.set(o), o = l;
        }
        const a = m(this, ks).blobToKzgCommitment(o), c = se(m(this, ks).computeBlobKzgProof(o, a));
        t.push({
          data: se(o),
          commitment: se(a),
          proof: c
        }), n.push(sC(1, a));
      } else {
        const o = se(i.commitment);
        t.push({
          data: se(i.data),
          commitment: o,
          proof: se(i.proof)
        }), n.push(sC(1, o));
      }
    }
    S(this, _o, t), S(this, Co, n);
  }
  get kzg() {
    return m(this, ks);
  }
  set kzg(e) {
    e == null ? S(this, ks, null) : S(this, ks, SG(e));
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : $t(V(this, tu, Lp).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return $t(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : EG(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : Wd.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return V(this, tu, Lp).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return V(this, tu, Lp).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const e = this.gasPrice != null, t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, n = this.accessList != null, s = m(this, Wa) != null || m(this, Co);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && z(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), z(!t || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), z(this.type !== 0 || !n, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const i = [];
    return this.type != null ? i.push(this.type) : this.authorizationList && this.authorizationList.length ? i.push(4) : t ? i.push(2) : e ? (i.push(1), n || i.push(0)) : n ? (i.push(1), i.push(2)) : (s && this.to || (i.push(0), i.push(1), i.push(2)), i.push(3)), i.sort(), i;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return Rs.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const e = (t) => t == null ? null : t.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(e) {
    if (e == null)
      return new Rs();
    if (typeof e == "string") {
      const n = Le(e);
      if (n[0] >= 127)
        return Rs.from(OG(n));
      switch (n[0]) {
        case 1:
          return Rs.from(kG(n));
        case 2:
          return Rs.from(RG(n));
        case 3:
          return Rs.from(BG(n));
        case 4:
          return Rs.from(FG(n));
      }
      z(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const t = new Rs();
    return e.type != null && (t.type = e.type), e.to != null && (t.to = e.to), e.nonce != null && (t.nonce = e.nonce), e.gasLimit != null && (t.gasLimit = e.gasLimit), e.gasPrice != null && (t.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (t.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (t.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (t.data = e.data), e.value != null && (t.value = e.value), e.chainId != null && (t.chainId = e.chainId), e.signature != null && (t.signature = ln.from(e.signature)), e.accessList != null && (t.accessList = e.accessList), e.authorizationList != null && (t.authorizationList = e.authorizationList), e.blobVersionedHashes != null && (t.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (t.kzg = e.kzg), e.blobs != null && (t.blobs = e.blobs), e.hash != null && (D(t.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), D(t.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (D(t.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), D(t.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), t;
  }
};
as = new WeakMap(), zl = new WeakMap(), ql = new WeakMap(), Wl = new WeakMap(), Vl = new WeakMap(), Gl = new WeakMap(), Kl = new WeakMap(), Jl = new WeakMap(), Yl = new WeakMap(), Ql = new WeakMap(), Zl = new WeakMap(), Xl = new WeakMap(), Wa = new WeakMap(), Co = new WeakMap(), ks = new WeakMap(), _o = new WeakMap(), eu = new WeakMap(), tu = new WeakSet(), Lp = function(e, t) {
  z(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const n = e ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return PG(this, n);
    case 1:
      return UG(this, n);
    case 2:
      return DG(this, n);
    case 3:
      return LG(this, n, t ? this.blobs : null);
    case 4:
      return $G(this, n);
  }
  z(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let _g = Rs;
function yc(r) {
  return $t(Zs(r));
}
var MG = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const iC = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), oC = 4;
function jG(r) {
  let e = 0;
  function t() {
    return r[e++] << 8 | r[e++];
  }
  let n = t(), s = 1, i = [0, 1];
  for (let N = 1; N < n; N++)
    i.push(s += t());
  let o = t(), a = e;
  e += o;
  let c = 0, l = 0;
  function u() {
    return c == 0 && (l = l << 8 | r[e++], c = 8), l >> --c & 1;
  }
  const h = 31, d = 2 ** h, f = d >>> 1, g = f >> 1, p = d - 1;
  let w = 0;
  for (let N = 0; N < h; N++) w = w << 1 | u();
  let E = [], I = 0, A = d;
  for (; ; ) {
    let N = Math.floor(((w - I + 1) * s - 1) / A), x = 0, O = n;
    for (; O - x > 1; ) {
      let $ = x + O >>> 1;
      N < i[$] ? O = $ : x = $;
    }
    if (x == 0) break;
    E.push(x);
    let k = I + Math.floor(A * i[x] / s), P = I + Math.floor(A * i[x + 1] / s) - 1;
    for (; !((k ^ P) & f); )
      w = w << 1 & p | u(), k = k << 1 & p, P = P << 1 & p | 1;
    for (; k & ~P & g; )
      w = w & f | w << 1 & p >>> 1 | u(), k = k << 1 ^ f, P = (P ^ f) << 1 | f | 1;
    I = k, A = 1 + P - k;
  }
  let C = n - 4;
  return E.map((N) => {
    switch (N - C) {
      case 3:
        return C + 65792 + (r[a++] << 16 | r[a++] << 8 | r[a++]);
      case 2:
        return C + 256 + (r[a++] << 8 | r[a++]);
      case 1:
        return C + r[a++];
      default:
        return N - 1;
    }
  });
}
function HG(r) {
  let e = 0;
  return () => r[e++];
}
function PN(r) {
  return HG(jG(zG(r)));
}
function zG(r) {
  let e = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((s, i) => e[s.charCodeAt(0)] = i);
  let t = r.length, n = new Uint8Array(6 * t >> 3);
  for (let s = 0, i = 0, o = 0, a = 0; s < t; s++)
    a = a << 6 | e[r.charCodeAt(s)], o += 6, o >= 8 && (n[i++] = a >> (o -= 8));
  return n;
}
function qG(r) {
  return r & 1 ? ~r >> 1 : r >> 1;
}
function WG(r, e) {
  let t = Array(r);
  for (let n = 0, s = 0; n < r; n++) t[n] = s += qG(e());
  return t;
}
function Vd(r, e = 0) {
  let t = [];
  for (; ; ) {
    let n = r(), s = r();
    if (!s) break;
    e += n;
    for (let i = 0; i < s; i++)
      t.push(e + i);
    e += s + 1;
  }
  return t;
}
function RN(r) {
  return Gd(() => {
    let e = Vd(r);
    if (e.length) return e;
  });
}
function DN(r) {
  let e = [];
  for (; ; ) {
    let t = r();
    if (t == 0) break;
    e.push(VG(t, r));
  }
  for (; ; ) {
    let t = r() - 1;
    if (t < 0) break;
    e.push(GG(t, r));
  }
  return e.flat();
}
function Gd(r) {
  let e = [];
  for (; ; ) {
    let t = r(e.length);
    if (!t) break;
    e.push(t);
  }
  return e;
}
function kN(r, e, t) {
  let n = Array(r).fill().map(() => []);
  for (let s = 0; s < e; s++)
    WG(r, t).forEach((i, o) => n[o].push(i));
  return n;
}
function VG(r, e) {
  let t = 1 + e(), n = e(), s = Gd(e);
  return kN(s.length, 1 + r, e).flatMap((o, a) => {
    let [c, ...l] = o;
    return Array(s[a]).fill().map((u, h) => {
      let d = h * n;
      return [c + h * t, l.map((f) => f + d)];
    });
  });
}
function GG(r, e) {
  let t = 1 + e();
  return kN(t, 1 + r, e).map((s) => [s[0], s.slice(1)]);
}
function KG(r) {
  let e = [], t = Vd(r);
  return s(n([]), []), e;
  function n(i) {
    let o = r(), a = Gd(() => {
      let c = Vd(r).map((l) => t[l]);
      if (c.length) return n(c);
    });
    return { S: o, B: a, Q: i };
  }
  function s({ S: i, B: o }, a, c) {
    if (!(i & 4 && c === a[a.length - 1])) {
      i & 2 && (c = a[a.length - 1]), i & 1 && e.push(a);
      for (let l of o)
        for (let u of l.Q)
          s(l, [...a, u], c);
    }
  }
}
function JG(r) {
  return r.toString(16).toUpperCase().padStart(2, "0");
}
function UN(r) {
  return `{${JG(r)}}`;
}
function YG(r) {
  let e = [];
  for (let t = 0, n = r.length; t < n; ) {
    let s = r.codePointAt(t);
    t += s < 65536 ? 1 : 2, e.push(s);
  }
  return e;
}
function Uu(r) {
  let t = r.length;
  if (t < 4096) return String.fromCodePoint(...r);
  let n = [];
  for (let s = 0; s < t; )
    n.push(String.fromCodePoint(...r.slice(s, s += 4096)));
  return n.join("");
}
function QG(r, e) {
  let t = r.length, n = t - e.length;
  for (let s = 0; n == 0 && s < t; s++) n = r[s] - e[s];
  return n;
}
var ZG = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const Kd = 44032, Ig = 4352, Sg = 4449, Ng = 4519, BN = 19, LN = 21, Bu = 28, Tg = LN * Bu, XG = BN * Tg, eK = Kd + XG, tK = Ig + BN, rK = Sg + LN, nK = Ng + Bu;
function xh(r) {
  return r >> 24 & 255;
}
function FN(r) {
  return r & 16777215;
}
let l0, aC, u0, Fp;
function sK() {
  let r = PN(ZG);
  l0 = new Map(RN(r).flatMap((e, t) => e.map((n) => [n, t + 1 << 24]))), aC = new Set(Vd(r)), u0 = /* @__PURE__ */ new Map(), Fp = /* @__PURE__ */ new Map();
  for (let [e, t] of DN(r)) {
    if (!aC.has(e) && t.length == 2) {
      let [n, s] = t, i = Fp.get(n);
      i || (i = /* @__PURE__ */ new Map(), Fp.set(n, i)), i.set(s, e);
    }
    u0.set(e, t.reverse());
  }
}
function $N(r) {
  return r >= Kd && r < eK;
}
function iK(r, e) {
  if (r >= Ig && r < tK && e >= Sg && e < rK)
    return Kd + (r - Ig) * Tg + (e - Sg) * Bu;
  if ($N(r) && e > Ng && e < nK && (r - Kd) % Bu == 0)
    return r + (e - Ng);
  {
    let t = Fp.get(r);
    return t && (t = t.get(e), t) ? t : -1;
  }
}
function MN(r) {
  l0 || sK();
  let e = [], t = [], n = !1;
  function s(i) {
    let o = l0.get(i);
    o && (n = !0, i |= o), e.push(i);
  }
  for (let i of r)
    for (; ; ) {
      if (i < 128)
        e.push(i);
      else if ($N(i)) {
        let o = i - Kd, a = o / Tg | 0, c = o % Tg / Bu | 0, l = o % Bu;
        s(Ig + a), s(Sg + c), l > 0 && s(Ng + l);
      } else {
        let o = u0.get(i);
        o ? t.push(...o) : s(i);
      }
      if (!t.length) break;
      i = t.pop();
    }
  if (n && e.length > 1) {
    let i = xh(e[0]);
    for (let o = 1; o < e.length; o++) {
      let a = xh(e[o]);
      if (a == 0 || i <= a) {
        i = a;
        continue;
      }
      let c = o - 1;
      for (; ; ) {
        let l = e[c + 1];
        if (e[c + 1] = e[c], e[c] = l, !c || (i = xh(e[--c]), i <= a)) break;
      }
      i = xh(e[o]);
    }
  }
  return e;
}
function oK(r) {
  let e = [], t = [], n = -1, s = 0;
  for (let i of r) {
    let o = xh(i), a = FN(i);
    if (n == -1)
      o == 0 ? n = a : e.push(a);
    else if (s > 0 && s >= o)
      o == 0 ? (e.push(n, ...t), t.length = 0, n = a) : t.push(a), s = o;
    else {
      let c = iK(n, a);
      c >= 0 ? n = c : s == 0 && o == 0 ? (e.push(n), n = a) : (t.push(a), s = o);
    }
  }
  return n >= 0 && e.push(n, ...t), e;
}
function jN(r) {
  return MN(r).map(FN);
}
function aK(r) {
  return oK(MN(r));
}
const cC = 45, HN = ".", zN = 65039, qN = 1, xg = (r) => Array.from(r);
function Jd(r, e) {
  return r.P.has(e) || r.Q.has(e);
}
class cK extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let h0, WN, Ra, d0, VN, Nl, Bw, ll, ma, lC, f0;
function Bb() {
  if (h0) return;
  let r = PN(MG);
  const e = () => Vd(r), t = () => new Set(e()), n = (u, h) => h.forEach((d) => u.add(d));
  h0 = new Map(DN(r)), WN = t(), Ra = e(), d0 = new Set(e().map((u) => Ra[u])), Ra = new Set(Ra), VN = t(), t();
  let s = RN(r), i = r();
  const o = () => {
    let u = /* @__PURE__ */ new Set();
    return e().forEach((h) => n(u, s[h])), n(u, e()), u;
  };
  Nl = Gd((u) => {
    let h = Gd(r).map((d) => d + 96);
    if (h.length) {
      let d = u >= i;
      h[0] -= 32, h = Uu(h), d && (h = `Restricted[${h}]`);
      let f = o(), g = o(), p = !r();
      return { N: h, P: f, Q: g, M: p, R: d };
    }
  }), Bw = t(), ll = /* @__PURE__ */ new Map();
  let a = e().concat(xg(Bw)).sort((u, h) => u - h);
  a.forEach((u, h) => {
    let d = r(), f = a[h] = d ? a[h - d] : { V: [], M: /* @__PURE__ */ new Map() };
    f.V.push(u), Bw.has(u) || ll.set(u, f);
  });
  for (let { V: u, M: h } of new Set(ll.values())) {
    let d = [];
    for (let g of u) {
      let p = Nl.filter((E) => Jd(E, g)), w = d.find(({ G: E }) => p.some((I) => E.has(I)));
      w || (w = { G: /* @__PURE__ */ new Set(), V: [] }, d.push(w)), w.V.push(g), n(w.G, p);
    }
    let f = d.flatMap((g) => xg(g.G));
    for (let { G: g, V: p } of d) {
      let w = new Set(f.filter((E) => !g.has(E)));
      for (let E of p)
        h.set(E, w);
    }
  }
  ma = /* @__PURE__ */ new Set();
  let c = /* @__PURE__ */ new Set();
  const l = (u) => ma.has(u) ? c.add(u) : ma.add(u);
  for (let u of Nl) {
    for (let h of u.P) l(h);
    for (let h of u.Q) l(h);
  }
  for (let u of ma)
    !ll.has(u) && !c.has(u) && ll.set(u, qN);
  n(ma, jN(ma)), lC = KG(r).map((u) => cK.from(u)).sort(QG), f0 = /* @__PURE__ */ new Map();
  for (let u of lC) {
    let h = [f0];
    for (let d of u) {
      let f = h.map((g) => {
        let p = g.get(d);
        return p || (p = /* @__PURE__ */ new Map(), g.set(d, p)), p;
      });
      d === zN ? h.push(...f) : h = f;
    }
    for (let d of h)
      d.V = u;
  }
}
function Lb(r) {
  return (GN(r) ? "" : `${Fb(mm([r]))} `) + UN(r);
}
function Fb(r) {
  return `"${r}"`;
}
function lK(r) {
  if (r.length >= 4 && r[2] == cC && r[3] == cC)
    throw new Error(`invalid label extension: "${Uu(r.slice(0, 4))}"`);
}
function uK(r) {
  for (let t = r.lastIndexOf(95); t > 0; )
    if (r[--t] !== 95)
      throw new Error("underscore allowed only at start");
}
function hK(r) {
  let e = r[0], t = iC.get(e);
  if (t) throw Gh(`leading ${t}`);
  let n = r.length, s = -1;
  for (let i = 1; i < n; i++) {
    e = r[i];
    let o = iC.get(e);
    if (o) {
      if (s == i) throw Gh(`${t} + ${o}`);
      s = i + 1, t = o;
    }
  }
  if (s == n) throw Gh(`trailing ${t}`);
}
function mm(r, e = 1 / 0, t = UN) {
  let n = [];
  dK(r[0]) && n.push(""), r.length > e && (e >>= 1, r = [...r.slice(0, e), 8230, ...r.slice(-e)]);
  let s = 0, i = r.length;
  for (let o = 0; o < i; o++) {
    let a = r[o];
    GN(a) && (n.push(Uu(r.slice(s, o))), n.push(t(a)), s = o + 1);
  }
  return n.push(Uu(r.slice(s, i))), n.join("");
}
function dK(r) {
  return Bb(), Ra.has(r);
}
function GN(r) {
  return Bb(), VN.has(r);
}
function fK(r) {
  return wK(pK(r, aK, EK));
}
function pK(r, e, t) {
  if (!r) return [];
  Bb();
  let n = 0;
  return r.split(HN).map((s) => {
    let i = YG(s), o = {
      input: i,
      offset: n
      // codepoint, not substring!
    };
    n += i.length + 1;
    try {
      let a = o.tokens = bK(i, e, t), c = a.length, l;
      if (!c)
        throw new Error("empty label");
      let u = o.output = a.flat();
      if (uK(u), !(o.emoji = c > 1 || a[0].is_emoji) && u.every((d) => d < 128))
        lK(u), l = "ASCII";
      else {
        let d = a.flatMap((f) => f.is_emoji ? [] : f);
        if (!d.length)
          l = "Emoji";
        else {
          if (Ra.has(u[0])) throw Gh("leading combining mark");
          for (let p = 1; p < c; p++) {
            let w = a[p];
            if (!w.is_emoji && Ra.has(w[0]))
              throw Gh(`emoji + combining mark: "${Uu(a[p - 1])} + ${mm([w[0]])}"`);
          }
          hK(u);
          let f = xg(new Set(d)), [g] = mK(f);
          yK(g, d), gK(g, f), l = g.N;
        }
      }
      o.type = l;
    } catch (a) {
      o.error = a;
    }
    return o;
  });
}
function gK(r, e) {
  let t, n = [];
  for (let s of e) {
    let i = ll.get(s);
    if (i === qN) return;
    if (i) {
      let o = i.M.get(s);
      if (t = t ? t.filter((a) => o.has(a)) : xg(o), !t.length) return;
    } else
      n.push(s);
  }
  if (t) {
    for (let s of t)
      if (n.every((i) => Jd(s, i)))
        throw new Error(`whole-script confusable: ${r.N}/${s.N}`);
  }
}
function mK(r) {
  let e = Nl;
  for (let t of r) {
    let n = e.filter((s) => Jd(s, t));
    if (!n.length)
      throw Nl.some((s) => Jd(s, t)) ? JN(e[0], t) : KN(t);
    if (e = n, n.length == 1) break;
  }
  return e;
}
function wK(r) {
  return r.map(({ input: e, error: t, output: n }) => {
    if (t) {
      let s = t.message;
      throw new Error(r.length == 1 ? s : `Invalid label ${Fb(mm(e, 63))}: ${s}`);
    }
    return Uu(n);
  }).join(HN);
}
function KN(r) {
  return new Error(`disallowed character: ${Lb(r)}`);
}
function JN(r, e) {
  let t = Lb(e), n = Nl.find((s) => s.P.has(e));
  return n && (t = `${n.N} ${t}`), new Error(`illegal mixture: ${r.N} + ${t}`);
}
function Gh(r) {
  return new Error(`illegal placement: ${r}`);
}
function yK(r, e) {
  for (let t of e)
    if (!Jd(r, t))
      throw JN(r, t);
  if (r.M) {
    let t = jN(e);
    for (let n = 1, s = t.length; n < s; n++)
      if (d0.has(t[n])) {
        let i = n + 1;
        for (let o; i < s && d0.has(o = t[i]); i++)
          for (let a = n; a < i; a++)
            if (t[a] == o)
              throw new Error(`duplicate non-spacing marks: ${Lb(o)}`);
        if (i - n > oC)
          throw new Error(`excessive non-spacing marks: ${Fb(mm(t.slice(n - 1, i)))} (${i - n}/${oC})`);
        n = i;
      }
  }
}
function bK(r, e, t) {
  let n = [], s = [];
  for (r = r.slice().reverse(); r.length; ) {
    let i = vK(r);
    if (i)
      s.length && (n.push(e(s)), s = []), n.push(t(i));
    else {
      let o = r.pop();
      if (ma.has(o))
        s.push(o);
      else {
        let a = h0.get(o);
        if (a)
          s.push(...a);
        else if (!WN.has(o))
          throw KN(o);
      }
    }
  }
  return s.length && n.push(e(s)), n;
}
function EK(r) {
  return r.filter((e) => e != zN);
}
function vK(r, e) {
  let t = f0, n, s = r.length;
  for (; s && (t = t.get(r[--s]), !!t); ) {
    let { V: i } = t;
    i && (n = i, r.length = s);
  }
  return n;
}
const YN = new Uint8Array(32);
YN.fill(0);
function uC(r) {
  return D(r.length !== 0, "invalid ENS name; empty component", "comp", r), r;
}
function QN(r) {
  const e = Zs(AK(r)), t = [];
  if (r.length === 0)
    return t;
  let n = 0;
  for (let s = 0; s < e.length; s++)
    e[s] === 46 && (t.push(uC(e.slice(n, s))), n = s + 1);
  return D(n < e.length, "invalid ENS name; empty component", "name", r), t.push(uC(e.slice(n))), t;
}
function AK(r) {
  try {
    if (r.length === 0)
      throw new Error("empty label");
    return fK(r);
  } catch (e) {
    D(!1, `invalid ENS name (${e.message})`, "name", r);
  }
}
function p0(r) {
  D(typeof r == "string", "invalid ENS name; not a string", "name", r), D(r.length, "invalid ENS name (empty label)", "name", r);
  let e = YN;
  const t = QN(r);
  for (; t.length; )
    e = $t(Pt([e, $t(t.pop())]));
  return se(e);
}
function CK(r, e) {
  const t = e;
  return D(t <= 255, "DNS encoded label cannot exceed 255", "length", t), se(Pt(QN(r).map((n) => {
    D(n.length <= t, `label ${JSON.stringify(r)} exceeds ${t} bytes`, "name", r);
    const s = new Uint8Array(n.length + 1);
    return s.set(n, 1), s[0] = s.length - 1, s;
  }))) + "00";
}
const ZN = new Uint8Array(32);
ZN.fill(0);
const _K = BigInt(-1), XN = BigInt(0), eT = BigInt(1), IK = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function SK(r) {
  const e = Le(r), t = e.length % 32;
  return t ? Pt([e, ZN.slice(t)]) : se(e);
}
const NK = Qo(eT, 32), TK = Qo(XN, 32), hC = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, Lw = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function dC(r) {
  return function(e) {
    return D(typeof e == "string", `invalid domain value for ${JSON.stringify(r)}`, `domain.${r}`, e), e;
  };
}
const xK = {
  name: dC("name"),
  version: dC("version"),
  chainId: function(r) {
    const e = ge(r, "domain.chainId");
    return D(e >= 0, "invalid chain ID", "domain.chainId", r), Number.isSafeInteger(e) ? Number(e) : hs(e);
  },
  verifyingContract: function(r) {
    try {
      return it(r).toLowerCase();
    } catch {
    }
    D(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", r);
  },
  salt: function(r) {
    const e = Le(r, "domain.salt");
    return D(e.length === 32, 'invalid domain value "salt"', "domain.salt", r), se(e);
  }
};
function Fw(r) {
  {
    const e = r.match(/^(u?)int(\d+)$/);
    if (e) {
      const t = e[1] === "", n = parseInt(e[2]);
      D(n % 8 === 0 && n !== 0 && n <= 256 && e[2] === String(n), "invalid numeric width", "type", r);
      const s = Oa(IK, t ? n - 1 : n), i = t ? (s + eT) * _K : XN;
      return function(o) {
        const a = ge(o, "value");
        return D(a >= i && a <= s, `value out-of-bounds for ${r}`, "value", a), Qo(t ? FS(a, 256) : a, 32);
      };
    }
  }
  {
    const e = r.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return D(t !== 0 && t <= 32 && e[1] === String(t), "invalid bytes width", "type", r), function(n) {
        const s = Le(n);
        return D(s.length === t, `invalid length for ${r}`, "value", n), SK(n);
      };
    }
  }
  switch (r) {
    case "address":
      return function(e) {
        return Hi(it(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? NK : TK;
      };
    case "bytes":
      return function(e) {
        return $t(e);
      };
    case "string":
      return function(e) {
        return yc(e);
      };
  }
  return null;
}
function fC(r, e) {
  return `${r}(${e.map(({ name: t, type: n }) => n + " " + t).join(",")})`;
}
function bp(r) {
  const e = r.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return e ? {
    base: e[1],
    index: e[2] + e[4],
    array: {
      base: e[1],
      prefix: e[1] + e[2],
      count: e[5] ? parseInt(e[5]) : -1
    }
  } : { base: r };
}
var nf, Ai, ru, Ug, tT;
const Bn = class Bn {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(e) {
    M(this, Ug);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    F(this, "primaryType");
    M(this, nf);
    M(this, Ai);
    M(this, ru);
    S(this, Ai, /* @__PURE__ */ new Map()), S(this, ru, /* @__PURE__ */ new Map());
    const t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = {};
    Object.keys(e).forEach((c) => {
      i[c] = e[c].map(({ name: l, type: u }) => {
        let { base: h, index: d } = bp(u);
        return h === "int" && !e.int && (h = "int256"), h === "uint" && !e.uint && (h = "uint256"), { name: l, type: h + (d || "") };
      }), t.set(c, /* @__PURE__ */ new Set()), n.set(c, []), s.set(c, /* @__PURE__ */ new Set());
    }), S(this, nf, JSON.stringify(i));
    for (const c in i) {
      const l = /* @__PURE__ */ new Set();
      for (const u of i[c]) {
        D(!l.has(u.name), `duplicate variable name ${JSON.stringify(u.name)} in ${JSON.stringify(c)}`, "types", e), l.add(u.name);
        const h = bp(u.type).base;
        D(h !== c, `circular type reference to ${JSON.stringify(h)}`, "types", e), !Fw(h) && (D(n.has(h), `unknown type ${JSON.stringify(h)}`, "types", e), n.get(h).push(c), t.get(c).add(h));
      }
    }
    const o = Array.from(n.keys()).filter((c) => n.get(c).length === 0);
    D(o.length !== 0, "missing primary type", "types", e), D(o.length === 1, `ambiguous primary types or unused types: ${o.map((c) => JSON.stringify(c)).join(", ")}`, "types", e), Ae(this, { primaryType: o[0] });
    function a(c, l) {
      D(!l.has(c), `circular type reference to ${JSON.stringify(c)}`, "types", e), l.add(c);
      for (const u of t.get(c))
        if (n.has(u)) {
          a(u, l);
          for (const h of l)
            s.get(h).add(u);
        }
      l.delete(c);
    }
    a(this.primaryType, /* @__PURE__ */ new Set());
    for (const [c, l] of s) {
      const u = Array.from(l);
      u.sort(), m(this, Ai).set(c, fC(c, i[c]) + u.map((h) => fC(h, i[h])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(m(this, nf));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(e) {
    let t = m(this, ru).get(e);
    return t || (t = V(this, Ug, tT).call(this, e), m(this, ru).set(e, t)), t;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(e) {
    const t = m(this, Ai).get(e);
    return D(t, `unknown type: ${JSON.stringify(e)}`, "name", e), t;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(e, t) {
    return $t(this.encodeData(e, t));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  /**
   *  @_ignore:
   */
  _visit(e, t, n) {
    if (Fw(e))
      return n(e, t);
    const s = bp(e).array;
    if (s)
      return D(s.count === -1 || s.count === t.length, `array length mismatch; expected length ${s.count}`, "value", t), t.map((o) => this._visit(s.prefix, o, n));
    const i = this.types[e];
    if (i)
      return i.reduce((o, { name: a, type: c }) => (o[a] = this._visit(c, t[a], n), o), {});
    D(!1, `unknown type: ${e}`, "type", e);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(e) {
    return new Bn(e);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(e) {
    return Bn.from(e).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(e, t, n) {
    return Bn.from(t).hashStruct(e, n);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(e) {
    const t = [];
    for (const n in e) {
      if (e[n] == null)
        continue;
      const s = hC[n];
      D(s, `invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", e), t.push({ name: n, type: s });
    }
    return t.sort((n, s) => Lw.indexOf(n.name) - Lw.indexOf(s.name)), Bn.hashStruct("EIP712Domain", { EIP712Domain: t }, e);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(e, t, n) {
    return Pt([
      "0x1901",
      Bn.hashDomain(e),
      Bn.from(t).hash(n)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(e, t, n) {
    return $t(Bn.encode(e, t, n));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(e, t, n, s) {
    e = Object.assign({}, e);
    for (const a in e)
      e[a] == null && delete e[a];
    const i = {};
    e.verifyingContract && !wt(e.verifyingContract, 20) && (i[e.verifyingContract] = "0x");
    const o = Bn.from(t);
    o.visit(n, (a, c) => (a === "address" && !wt(c, 20) && (i[c] = "0x"), c));
    for (const a in i)
      i[a] = await s(a);
    return e.verifyingContract && i[e.verifyingContract] && (e.verifyingContract = i[e.verifyingContract]), n = o.visit(n, (a, c) => a === "address" && i[c] ? i[c] : c), { domain: e, value: n };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(e, t, n) {
    Bn.hashDomain(e);
    const s = {}, i = [];
    Lw.forEach((c) => {
      const l = e[c];
      l != null && (s[c] = xK[c](l), i.push({ name: c, type: hC[c] }));
    });
    const o = Bn.from(t);
    t = o.types;
    const a = Object.assign({}, t);
    return D(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", t), a.EIP712Domain = i, o.encode(n), {
      types: a,
      domain: s,
      primaryType: o.primaryType,
      message: o.visit(n, (c, l) => {
        if (c.match(/^bytes(\d*)/))
          return se(Le(l));
        if (c.match(/^u?int/))
          return ge(l).toString();
        switch (c) {
          case "address":
            return l.toLowerCase();
          case "bool":
            return !!l;
          case "string":
            return D(typeof l == "string", "invalid string", "value", l), l;
        }
        D(!1, "unsupported type", "type", c);
      })
    };
  }
};
nf = new WeakMap(), Ai = new WeakMap(), ru = new WeakMap(), Ug = new WeakSet(), tT = function(e) {
  {
    const s = Fw(e);
    if (s)
      return s;
  }
  const t = bp(e).array;
  if (t) {
    const s = t.prefix, i = this.getEncoder(s);
    return (o) => {
      D(t.count === -1 || t.count === o.length, `array length mismatch; expected length ${t.count}`, "value", o);
      let a = o.map(i);
      return m(this, Ai).has(s) && (a = a.map($t)), $t(Pt(a));
    };
  }
  const n = this.types[e];
  if (n) {
    const s = yc(m(this, Ai).get(e));
    return (i) => {
      const o = n.map(({ name: a, type: c }) => {
        const l = this.getEncoder(c)(i[a]);
        return m(this, Ai).has(c) ? $t(l) : l;
      });
      return o.unshift(s), Pt(o);
    };
  }
  D(!1, `unknown type: ${e}`, "type", e);
};
let Og = Bn;
function Lr(r) {
  const e = /* @__PURE__ */ new Set();
  return r.forEach((t) => e.add(t)), Object.freeze(e);
}
const OK = "external public payable override", PK = Lr(OK.split(" ")), rT = "constant external internal payable private public pure view override", RK = Lr(rT.split(" ")), nT = "constructor error event fallback function receive struct", sT = Lr(nT.split(" ")), iT = "calldata memory storage payable indexed", DK = Lr(iT.split(" ")), kK = "tuple returns", UK = [nT, iT, kK, rT].join(" "), BK = Lr(UK.split(" ")), LK = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, FK = new RegExp("^(\\s*)"), $K = new RegExp("^([0-9]+)"), MK = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), oT = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), aT = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var cr, cs, sf, g0;
const Bg = class Bg {
  constructor(e) {
    M(this, sf);
    M(this, cr);
    M(this, cs);
    S(this, cr, 0), S(this, cs, e.slice());
  }
  get offset() {
    return m(this, cr);
  }
  get length() {
    return m(this, cs).length - m(this, cr);
  }
  clone() {
    return new Bg(m(this, cs));
  }
  reset() {
    S(this, cr, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(e) {
    const t = this.peek();
    if (t.type !== "KEYWORD" || !e.has(t.text))
      throw new Error(`expected keyword ${t.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(e) {
    if (this.peek().type !== e) {
      const t = this.peek();
      throw new Error(`expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const t = V(this, sf, g0).call(this, m(this, cr) + 1, e.match + 1);
    return S(this, cr, e.match + 1), t;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const t = [];
    for (; m(this, cr) < e.match - 1; ) {
      const n = this.peek().linkNext;
      t.push(V(this, sf, g0).call(this, m(this, cr) + 1, n)), S(this, cr, n);
    }
    return S(this, cr, e.match + 1), t;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (m(this, cr) >= m(this, cs).length)
      throw new Error("out-of-bounds");
    return m(this, cs)[m(this, cr)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(e) {
    const t = this.peekType("KEYWORD");
    return t != null && e.has(t) ? t : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(e) {
    if (this.length === 0)
      return null;
    const t = this.peek();
    return t.type === e ? t.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const e = this.peek();
    return Ju(this, cr)._++, e;
  }
  toString() {
    const e = [];
    for (let t = m(this, cr); t < m(this, cs).length; t++) {
      const n = m(this, cs)[t];
      e.push(`${n.type}:${n.text}`);
    }
    return `<TokenString ${e.join(" ")}>`;
  }
};
cr = new WeakMap(), cs = new WeakMap(), sf = new WeakSet(), g0 = function(e = 0, t = 0) {
  return new Bg(m(this, cs).slice(e, t).map((n) => Object.freeze(Object.assign({}, n, {
    match: n.match - e,
    linkBack: n.linkBack - e,
    linkNext: n.linkNext - e
  }))));
};
let Es = Bg;
function ra(r) {
  const e = [], t = (o) => {
    const a = i < r.length ? JSON.stringify(r[i]) : "$EOI";
    throw new Error(`invalid token ${a} at ${i}: ${o}`);
  };
  let n = [], s = [], i = 0;
  for (; i < r.length; ) {
    let o = r.substring(i), a = o.match(FK);
    a && (i += a[1].length, o = r.substring(i));
    const c = { depth: n.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: i, value: -1 };
    e.push(c);
    let l = LK[o[0]] || "";
    if (l) {
      if (c.type = l, c.text = o[0], i++, l === "OPEN_PAREN")
        n.push(e.length - 1), s.push(e.length - 1);
      else if (l == "CLOSE_PAREN")
        n.length === 0 && t("no matching open bracket"), c.match = n.pop(), e[c.match].match = e.length - 1, c.depth--, c.linkBack = s.pop(), e[c.linkBack].linkNext = e.length - 1;
      else if (l === "COMMA")
        c.linkBack = s.pop(), e[c.linkBack].linkNext = e.length - 1, s.push(e.length - 1);
      else if (l === "OPEN_BRACKET")
        c.type = "BRACKET";
      else if (l === "CLOSE_BRACKET") {
        let u = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          const h = e.pop().text;
          u = h + u, e[e.length - 1].value = De(h);
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += u;
      }
      continue;
    }
    if (a = o.match(MK), a) {
      if (c.text = a[1], i += c.text.length, BK.has(c.text)) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(aT)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (a = o.match($K), a) {
      c.text = a[1], c.type = "NUMBER", i += c.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${i}`);
  }
  return new Es(e.map((o) => Object.freeze(o)));
}
function pC(r, e) {
  let t = [];
  for (const n in e.keys())
    r.has(n) && t.push(n);
  if (t.length > 1)
    throw new Error(`conflicting types: ${t.join(", ")}`);
}
function wm(r, e) {
  if (e.peekKeyword(sT)) {
    const t = e.pop().text;
    if (t !== r)
      throw new Error(`expected ${r}, got ${t}`);
  }
  return e.popType("ID");
}
function qi(r, e) {
  const t = /* @__PURE__ */ new Set();
  for (; ; ) {
    const n = r.peekType("KEYWORD");
    if (n == null || e && !e.has(n))
      break;
    if (r.pop(), t.has(n))
      throw new Error(`duplicate keywords: ${JSON.stringify(n)}`);
    t.add(n);
  }
  return Object.freeze(t);
}
function cT(r) {
  let e = qi(r, RK);
  return pC(e, Lr("constant payable nonpayable".split(" "))), pC(e, Lr("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
}
function Fi(r, e) {
  return r.popParams().map((t) => dr.from(t, e));
}
function lT(r) {
  if (r.peekType("AT")) {
    if (r.pop(), r.peekType("NUMBER"))
      return ge(r.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function bc(r) {
  if (r.length)
    throw new Error(`unexpected tokens at offset ${r.offset}: ${r.toString()}`);
}
const jK = new RegExp(/^(.*)\[([0-9]*)\]$/);
function gC(r) {
  const e = r.match(aT);
  if (D(e, "invalid type", "type", r), r === "uint")
    return "uint256";
  if (r === "int")
    return "int256";
  if (e[2]) {
    const t = parseInt(e[2]);
    D(t !== 0 && t <= 32, "invalid bytes length", "type", r);
  } else if (e[3]) {
    const t = parseInt(e[3]);
    D(t !== 0 && t <= 256 && t % 8 === 0, "invalid numeric width", "type", r);
  }
  return r;
}
const Tt = {}, un = Symbol.for("_ethers_internal"), mC = "_ParamTypeInternal", wC = "_ErrorInternal", yC = "_EventInternal", bC = "_ConstructorInternal", EC = "_FallbackInternal", vC = "_FunctionInternal", AC = "_StructInternal";
var nu, $p;
const Ln = class Ln {
  /**
   *  @private
   */
  constructor(e, t, n, s, i, o, a, c) {
    M(this, nu);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    F(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    F(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    F(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    F(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    F(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    F(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    F(this, "arrayChildren");
    if (Df(e, Tt, "ParamType"), Object.defineProperty(this, un, { value: mC }), o && (o = Object.freeze(o.slice())), s === "array") {
      if (a == null || c == null)
        throw new Error("");
    } else if (a != null || c != null)
      throw new Error("");
    if (s === "tuple") {
      if (o == null)
        throw new Error("");
    } else if (o != null)
      throw new Error("");
    Ae(this, {
      name: t,
      type: n,
      baseType: s,
      indexed: i,
      components: o,
      arrayLength: a,
      arrayChildren: c
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json") {
      const n = this.name || "";
      if (this.isArray()) {
        const i = JSON.parse(this.arrayChildren.format("json"));
        return i.name = n, i.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(i);
      }
      const s = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: n
      };
      return typeof this.indexed == "boolean" && (s.indexed = this.indexed), this.isTuple() && (s.components = this.components.map((i) => JSON.parse(i.format(e)))), JSON.stringify(s);
    }
    let t = "";
    return this.isArray() ? (t += this.arrayChildren.format(e), t += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? t += "(" + this.components.map((n) => n.format(e)).join(e === "full" ? ", " : ",") + ")" : t += this.type, e !== "sighash" && (this.indexed === !0 && (t += " indexed"), e === "full" && this.name && (t += " " + this.name)), t;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(e, t) {
    if (this.isArray()) {
      if (!Array.isArray(e))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && e.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const n = this;
      return e.map((s) => n.arrayChildren.walk(s, t));
    }
    if (this.isTuple()) {
      if (!Array.isArray(e))
        throw new Error("invalid tuple value");
      if (e.length !== this.components.length)
        throw new Error("array is wrong length");
      const n = this;
      return e.map((s, i) => n.components[i].walk(s, t));
    }
    return t(this.type, e);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(e, t) {
    const n = [], s = [e];
    return V(this, nu, $p).call(this, n, e, t, (i) => {
      s[0] = i;
    }), n.length && await Promise.all(n), s[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(e, t) {
    if (Ln.isParamType(e))
      return e;
    if (typeof e == "string")
      try {
        return Ln.from(ra(e), t);
      } catch {
        D(!1, "invalid param type", "obj", e);
      }
    else if (e instanceof Es) {
      let a = "", c = "", l = null;
      qi(e, Lr(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (c = "tuple", l = e.popParams().map((p) => Ln.from(p)), a = `tuple(${l.map((p) => p.format()).join(",")})`) : (a = gC(e.popType("TYPE")), c = a);
      let u = null, h = null;
      for (; e.length && e.peekType("BRACKET"); ) {
        const p = e.pop();
        u = new Ln(Tt, "", a, c, null, l, h, u), h = p.value, a += p.text, c = "array", l = null;
      }
      let d = null;
      if (qi(e, DK).has("indexed")) {
        if (!t)
          throw new Error("");
        d = !0;
      }
      const g = e.peekType("ID") ? e.pop().text : "";
      if (e.length)
        throw new Error("leftover tokens");
      return new Ln(Tt, g, a, c, d, l, h, u);
    }
    const n = e.name;
    D(!n || typeof n == "string" && n.match(oT), "invalid name", "obj.name", n);
    let s = e.indexed;
    s != null && (D(t, "parameter cannot be indexed", "obj.indexed", e.indexed), s = !!s);
    let i = e.type, o = i.match(jK);
    if (o) {
      const a = parseInt(o[2] || "-1"), c = Ln.from({
        type: o[1],
        components: e.components
      });
      return new Ln(Tt, n || "", i, "array", s, null, a, c);
    }
    if (i === "tuple" || i.startsWith(
      "tuple("
      /* fix: ) */
    ) || i.startsWith(
      "("
      /* fix: ) */
    )) {
      const a = e.components != null ? e.components.map((l) => Ln.from(l)) : null;
      return new Ln(Tt, n || "", i, "tuple", s, a, null, null);
    }
    return i = gC(e.type), new Ln(Tt, n || "", i, i, s, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(e) {
    return e && e[un] === mC;
  }
};
nu = new WeakSet(), $p = function(e, t, n, s) {
  if (this.isArray()) {
    if (!Array.isArray(t))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && t.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const o = this.arrayChildren, a = t.slice();
    a.forEach((c, l) => {
      var u;
      V(u = o, nu, $p).call(u, e, c, n, (h) => {
        a[l] = h;
      });
    }), s(a);
    return;
  }
  if (this.isTuple()) {
    const o = this.components;
    let a;
    if (Array.isArray(t))
      a = t.slice();
    else {
      if (t == null || typeof t != "object")
        throw new Error("invalid tuple value");
      a = o.map((c) => {
        if (!c.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(c.name in t))
          throw new Error(`missing value for component ${c.name}`);
        return t[c.name];
      });
    }
    if (a.length !== this.components.length)
      throw new Error("array is wrong length");
    a.forEach((c, l) => {
      var u;
      V(u = o[l], nu, $p).call(u, e, c, n, (h) => {
        a[l] = h;
      });
    }), s(a);
    return;
  }
  const i = n(this.type, t);
  i.then ? e.push(async function() {
    s(await i);
  }()) : s(i);
};
let dr = Ln;
class Ec {
  /**
   *  @private
   */
  constructor(e, t, n) {
    /**
     *  The type of the fragment.
     */
    F(this, "type");
    /**
     *  The inputs for the fragment.
     */
    F(this, "inputs");
    Df(e, Tt, "Fragment"), n = Object.freeze(n.slice()), Ae(this, { type: t, inputs: n });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(e) {
    if (typeof e == "string") {
      try {
        Ec.from(JSON.parse(e));
      } catch {
      }
      return Ec.from(ra(e));
    }
    if (e instanceof Es)
      switch (e.peekKeyword(sT)) {
        case "constructor":
          return ki.from(e);
        case "error":
          return on.from(e);
        case "event":
          return Ws.from(e);
        case "fallback":
        case "receive":
          return wi.from(e);
        case "function":
          return Vs.from(e);
        case "struct":
          return oc.from(e);
      }
    else if (typeof e == "object") {
      switch (e.type) {
        case "constructor":
          return ki.from(e);
        case "error":
          return on.from(e);
        case "event":
          return Ws.from(e);
        case "fallback":
        case "receive":
          return wi.from(e);
        case "function":
          return Vs.from(e);
        case "struct":
          return oc.from(e);
      }
      z(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    D(!1, "unsupported frgament object", "obj", e);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(e) {
    return ki.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(e) {
    return on.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(e) {
    return Ws.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(e) {
    return Vs.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(e) {
    return oc.isFragment(e);
  }
}
class ym extends Ec {
  /**
   *  @private
   */
  constructor(t, n, s, i) {
    super(t, n, i);
    /**
     *  The name of the fragment.
     */
    F(this, "name");
    D(typeof s == "string" && s.match(oT), "invalid identifier", "name", s), i = Object.freeze(i.slice()), Ae(this, { name: s });
  }
}
function Yd(r, e) {
  return "(" + e.map((t) => t.format(r)).join(r === "full" ? ", " : ",") + ")";
}
class on extends ym {
  /**
   *  @private
   */
  constructor(e, t, n) {
    super(e, "error", t, n), Object.defineProperty(this, un, { value: wC });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return yc(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(e)))
      });
    const t = [];
    return e !== "sighash" && t.push("error"), t.push(this.name + Yd(e, this.inputs)), t.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(e) {
    if (on.isFragment(e))
      return e;
    if (typeof e == "string")
      return on.from(ra(e));
    if (e instanceof Es) {
      const t = wm("error", e), n = Fi(e);
      return bc(e), new on(Tt, t, n);
    }
    return new on(Tt, e.name, e.inputs ? e.inputs.map(dr.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(e) {
    return e && e[un] === wC;
  }
}
class Ws extends ym {
  /**
   *  @private
   */
  constructor(t, n, s, i) {
    super(t, "event", n, s);
    /**
     *  Whether this event is anonymous.
     */
    F(this, "anonymous");
    Object.defineProperty(this, un, { value: yC }), Ae(this, { anonymous: i });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return yc(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((s) => JSON.parse(s.format(t)))
      });
    const n = [];
    return t !== "sighash" && n.push("event"), n.push(this.name + Yd(t, this.inputs)), t !== "sighash" && this.anonymous && n.push("anonymous"), n.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(t, n) {
    return n = (n || []).map((i) => dr.from(i)), new Ws(Tt, t, n, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(t) {
    if (Ws.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return Ws.from(ra(t));
      } catch {
        D(!1, "invalid event fragment", "obj", t);
      }
    else if (t instanceof Es) {
      const n = wm("event", t), s = Fi(t, !0), i = !!qi(t, Lr(["anonymous"])).has("anonymous");
      return bc(t), new Ws(Tt, n, s, i);
    }
    return new Ws(Tt, t.name, t.inputs ? t.inputs.map((n) => dr.from(n, !0)) : [], !!t.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(t) {
    return t && t[un] === yC;
  }
}
class ki extends Ec {
  /**
   *  @private
   */
  constructor(t, n, s, i, o) {
    super(t, n, s);
    /**
     *  Whether the constructor can receive an endowment.
     */
    F(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    F(this, "gas");
    Object.defineProperty(this, un, { value: bC }), Ae(this, { payable: i, gas: o });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(t) {
    if (z(t != null && t !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), t === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(t)))
      });
    const n = [`constructor${Yd(t, this.inputs)}`];
    return this.payable && n.push("payable"), this.gas != null && n.push(`@${this.gas.toString()}`), n.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(t) {
    if (ki.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return ki.from(ra(t));
      } catch {
        D(!1, "invalid constuctor fragment", "obj", t);
      }
    else if (t instanceof Es) {
      qi(t, Lr(["constructor"]));
      const n = Fi(t), s = !!qi(t, PK).has("payable"), i = lT(t);
      return bc(t), new ki(Tt, "constructor", n, s, i);
    }
    return new ki(Tt, "constructor", t.inputs ? t.inputs.map(dr.from) : [], !!t.payable, t.gas != null ? t.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(t) {
    return t && t[un] === bC;
  }
}
class wi extends Ec {
  constructor(t, n, s) {
    super(t, "fallback", n);
    /**
     *  If the function can be sent value during invocation.
     */
    F(this, "payable");
    Object.defineProperty(this, un, { value: EC }), Ae(this, { payable: s });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(t) {
    const n = this.inputs.length === 0 ? "receive" : "fallback";
    if (t === "json") {
      const s = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: n, stateMutability: s });
    }
    return `${n}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(t) {
    if (wi.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return wi.from(ra(t));
      } catch {
        D(!1, "invalid fallback fragment", "obj", t);
      }
    else if (t instanceof Es) {
      const n = t.toString(), s = t.peekKeyword(Lr(["fallback", "receive"]));
      if (D(s, "type must be fallback or receive", "obj", n), t.popKeyword(Lr(["fallback", "receive"])) === "receive") {
        const c = Fi(t);
        return D(c.length === 0, "receive cannot have arguments", "obj.inputs", c), qi(t, Lr(["payable"])), bc(t), new wi(Tt, [], !0);
      }
      let o = Fi(t);
      o.length ? D(o.length === 1 && o[0].type === "bytes", "invalid fallback inputs", "obj.inputs", o.map((c) => c.format("minimal")).join(", ")) : o = [dr.from("bytes")];
      const a = cT(t);
      if (D(a === "nonpayable" || a === "payable", "fallback cannot be constants", "obj.stateMutability", a), qi(t, Lr(["returns"])).has("returns")) {
        const c = Fi(t);
        D(c.length === 1 && c[0].type === "bytes", "invalid fallback outputs", "obj.outputs", c.map((l) => l.format("minimal")).join(", "));
      }
      return bc(t), new wi(Tt, o, a === "payable");
    }
    if (t.type === "receive")
      return new wi(Tt, [], !0);
    if (t.type === "fallback") {
      const n = [dr.from("bytes")], s = t.stateMutability === "payable";
      return new wi(Tt, n, s);
    }
    D(!1, "invalid fallback description", "obj", t);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(t) {
    return t && t[un] === EC;
  }
}
class Vs extends ym {
  /**
   *  @private
   */
  constructor(t, n, s, i, o, a) {
    super(t, "function", n, i);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    F(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    F(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    F(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    F(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    F(this, "gas");
    Object.defineProperty(this, un, { value: vC }), o = Object.freeze(o.slice()), Ae(this, { constant: s === "view" || s === "pure", gas: a, outputs: o, payable: s === "payable", stateMutability: s });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return yc(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((s) => JSON.parse(s.format(t))),
        outputs: this.outputs.map((s) => JSON.parse(s.format(t)))
      });
    const n = [];
    return t !== "sighash" && n.push("function"), n.push(this.name + Yd(t, this.inputs)), t !== "sighash" && (this.stateMutability !== "nonpayable" && n.push(this.stateMutability), this.outputs && this.outputs.length && (n.push("returns"), n.push(Yd(t, this.outputs))), this.gas != null && n.push(`@${this.gas.toString()}`)), n.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(t, n) {
    return n = (n || []).map((i) => dr.from(i)), new Vs(Tt, t, "view", n, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(t) {
    if (Vs.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return Vs.from(ra(t));
      } catch {
        D(!1, "invalid function fragment", "obj", t);
      }
    else if (t instanceof Es) {
      const s = wm("function", t), i = Fi(t), o = cT(t);
      let a = [];
      qi(t, Lr(["returns"])).has("returns") && (a = Fi(t));
      const c = lT(t);
      return bc(t), new Vs(Tt, s, o, i, a, c);
    }
    let n = t.stateMutability;
    return n == null && (n = "payable", typeof t.constant == "boolean" ? (n = "view", t.constant || (n = "payable", typeof t.payable == "boolean" && !t.payable && (n = "nonpayable"))) : typeof t.payable == "boolean" && !t.payable && (n = "nonpayable")), new Vs(Tt, t.name, n, t.inputs ? t.inputs.map(dr.from) : [], t.outputs ? t.outputs.map(dr.from) : [], t.gas != null ? t.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(t) {
    return t && t[un] === vC;
  }
}
class oc extends ym {
  /**
   *  @private
   */
  constructor(e, t, n) {
    super(e, "struct", t, n), Object.defineProperty(this, un, { value: AC });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(e) {
    if (typeof e == "string")
      try {
        return oc.from(ra(e));
      } catch {
        D(!1, "invalid struct fragment", "obj", e);
      }
    else if (e instanceof Es) {
      const t = wm("struct", e), n = Fi(e);
      return bc(e), new oc(Tt, t, n);
    }
    return new oc(Tt, e.name, e.inputs ? e.inputs.map(dr.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(e) {
    return e && e[un] === AC;
  }
}
const Cs = /* @__PURE__ */ new Map();
Cs.set(0, "GENERIC_PANIC");
Cs.set(1, "ASSERT_FALSE");
Cs.set(17, "OVERFLOW");
Cs.set(18, "DIVIDE_BY_ZERO");
Cs.set(33, "ENUM_RANGE_ERROR");
Cs.set(34, "BAD_STORAGE_DATA");
Cs.set(49, "STACK_UNDERFLOW");
Cs.set(50, "ARRAY_RANGE_ERROR");
Cs.set(65, "OUT_OF_MEMORY");
Cs.set(81, "UNINITIALIZED_FUNCTION_CALL");
const HK = new RegExp(/^bytes([0-9]*)$/), zK = new RegExp(/^(u?int)([0-9]*)$/);
let $w = null, CC = 1024;
function qK(r, e, t, n) {
  let s = "missing revert data", i = null;
  const o = null;
  let a = null;
  if (t) {
    s = "execution reverted";
    const l = Le(t);
    if (t = se(t), l.length === 0)
      s += " (no data present; likely require(false) occurred", i = "require(false)";
    else if (l.length % 32 !== 4)
      s += " (could not decode reason; invalid data length)";
    else if (se(l.slice(0, 4)) === "0x08c379a0")
      try {
        i = n.decode(["string"], l.slice(4))[0], a = {
          signature: "Error(string)",
          name: "Error",
          args: [i]
        }, s += `: ${JSON.stringify(i)}`;
      } catch {
        s += " (could not decode reason; invalid string data)";
      }
    else if (se(l.slice(0, 4)) === "0x4e487b71")
      try {
        const u = Number(n.decode(["uint256"], l.slice(4))[0]);
        a = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [u]
        }, i = `Panic due to ${Cs.get(u) || "UNKNOWN"}(${u})`, s += `: ${i}`;
      } catch {
        s += " (could not decode panic code)";
      }
    else
      s += " (unknown custom error)";
  }
  const c = {
    to: e.to ? it(e.to) : null,
    data: e.data || "0x"
  };
  return e.from && (c.from = it(e.from)), St(s, "CALL_EXCEPTION", {
    action: r,
    data: t,
    reason: i,
    transaction: c,
    invocation: o,
    revert: a
  });
}
var Io, ul;
const Lg = class Lg {
  constructor() {
    M(this, Io);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(e) {
    const t = e.map((s) => V(this, Io, ul).call(this, dr.from(s)));
    return new yp(t, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(e, t) {
    US(t.length, e.length, "types/values length mismatch");
    const n = e.map((o) => V(this, Io, ul).call(this, dr.from(o))), s = new yp(n, "_"), i = new t0();
    return s.encode(i, t), i.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(e, t, n) {
    const s = e.map((o) => V(this, Io, ul).call(this, dr.from(o)));
    return new yp(s, "_").decode(new r0(t, n, CC));
  }
  static _setDefaultMaxInflation(e) {
    D(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), CC = e;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return $w == null && ($w = new Lg()), $w;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(e, t, n) {
    return qK(e, t, n, Lg.defaultAbiCoder());
  }
};
Io = new WeakSet(), ul = function(e) {
  if (e.isArray())
    return new cG(V(this, Io, ul).call(this, e.arrayChildren), e.arrayLength, e.name);
  if (e.isTuple())
    return new yp(e.components.map((n) => V(this, Io, ul).call(this, n)), e.name);
  switch (e.baseType) {
    case "address":
      return new oG(e.name);
    case "bool":
      return new lG(e.name);
    case "string":
      return new yG(e.name);
    case "bytes":
      return new uG(e.name);
    case "":
      return new fG(e.name);
  }
  let t = e.type.match(zK);
  if (t) {
    let n = parseInt(t[2] || "256");
    return D(n !== 0 && n <= 256 && n % 8 === 0, "invalid " + t[1] + " bit length", "param", e), new wG(n / 8, t[1] === "int", e.name);
  }
  if (t = e.type.match(HK), t) {
    let n = parseInt(t[1]);
    return D(n !== 0 && n <= 32, "invalid bytes length", "param", e), new hG(n, e.name);
  }
  D(!1, "invalid type", "type", e.type);
};
let Qd = Lg;
class WK {
  /**
   *  @_ignore:
   */
  constructor(e, t, n) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    F(this, "fragment");
    /**
     *  The name of the Event.
     */
    F(this, "name");
    /**
     *  The full Event signature.
     */
    F(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    F(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    F(this, "args");
    const s = e.name, i = e.format();
    Ae(this, {
      fragment: e,
      name: s,
      signature: i,
      topic: t,
      args: n
    });
  }
}
class VK {
  /**
   *  @_ignore:
   */
  constructor(e, t, n, s) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    F(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    F(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    F(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    F(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    F(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    F(this, "value");
    const i = e.name, o = e.format();
    Ae(this, {
      fragment: e,
      name: i,
      args: n,
      signature: o,
      selector: t,
      value: s
    });
  }
}
class GK {
  /**
   *  @_ignore:
   */
  constructor(e, t, n) {
    /**
     *  The matching fragment.
     */
    F(this, "fragment");
    /**
     *  The name of the Error.
     */
    F(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    F(this, "args");
    /**
     *  The full Error signature.
     */
    F(this, "signature");
    /**
     *  The selector for the Error.
     */
    F(this, "selector");
    const s = e.name, i = e.format();
    Ae(this, {
      fragment: e,
      name: s,
      args: n,
      signature: i,
      selector: t
    });
  }
}
class _C {
  /**
   *  @_ignore:
   */
  constructor(e) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    F(this, "hash");
    /**
     *  @_ignore:
     */
    F(this, "_isIndexed");
    Ae(this, { hash: e, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const IC = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, SC = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (r) => `reverted with reason string ${JSON.stringify(r)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (r) => {
      let e = "unknown panic code";
      return r >= 0 && r <= 255 && IC[r.toString()] && (e = IC[r.toString()]), `reverted with panic code 0x${r.toString(16)} (${e})`;
    }
  }
};
var Us, Bs, Ls, Cr, Xs, Mp, jp;
const Ca = class Ca {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(e) {
    M(this, Xs);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    F(this, "fragments");
    /**
     *  The Contract constructor.
     */
    F(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    F(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    F(this, "receive");
    M(this, Us);
    M(this, Bs);
    M(this, Ls);
    //    #structs: Map<string, StructFragment>;
    M(this, Cr);
    let t = [];
    typeof e == "string" ? t = JSON.parse(e) : t = e, S(this, Ls, /* @__PURE__ */ new Map()), S(this, Us, /* @__PURE__ */ new Map()), S(this, Bs, /* @__PURE__ */ new Map());
    const n = [];
    for (const o of t)
      try {
        n.push(Ec.from(o));
      } catch (a) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(o)}:`, a.message);
      }
    Ae(this, {
      fragments: Object.freeze(n)
    });
    let s = null, i = !1;
    S(this, Cr, this.getAbiCoder()), this.fragments.forEach((o, a) => {
      let c;
      switch (o.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          Ae(this, { deploy: o });
          return;
        case "fallback":
          o.inputs.length === 0 ? i = !0 : (D(!s || o.payable !== s.payable, "conflicting fallback fragments", `fragments[${a}]`, o), s = o, i = s.payable);
          return;
        case "function":
          c = m(this, Ls);
          break;
        case "event":
          c = m(this, Bs);
          break;
        case "error":
          c = m(this, Us);
          break;
        default:
          return;
      }
      const l = o.format();
      c.has(l) || c.set(l, o);
    }), this.deploy || Ae(this, {
      deploy: ki.from("constructor()")
    }), Ae(this, { fallback: s, receive: i });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(e) {
    const t = e ? "minimal" : "full";
    return this.fragments.map((s) => s.format(t));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const e = this.fragments.map((t) => t.format("json"));
    return JSON.stringify(e.map((t) => JSON.parse(t)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return Qd.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(e) {
    const t = V(this, Xs, Mp).call(this, e, null, !1);
    return D(t, "no matching function", "key", e), t.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(e) {
    return !!V(this, Xs, Mp).call(this, e, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(e, t) {
    return V(this, Xs, Mp).call(this, e, t || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(e) {
    const t = Array.from(m(this, Ls).keys());
    t.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      e(m(this, Ls).get(s), n);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(e) {
    const t = V(this, Xs, jp).call(this, e, null, !1);
    return D(t, "no matching event", "key", e), t.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(e) {
    return !!V(this, Xs, jp).call(this, e, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(e, t) {
    return V(this, Xs, jp).call(this, e, t || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(e) {
    const t = Array.from(m(this, Bs).keys());
    t.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      e(m(this, Bs).get(s), n);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(e, t) {
    if (wt(e)) {
      const s = e.toLowerCase();
      if (SC[s])
        return on.from(SC[s].signature);
      for (const i of m(this, Us).values())
        if (s === i.selector)
          return i;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const s = [];
      for (const [i, o] of m(this, Us))
        i.split(
          "("
          /* fix:) */
        )[0] === e && s.push(o);
      if (s.length === 0)
        return e === "Error" ? on.from("error Error(string)") : e === "Panic" ? on.from("error Panic(uint256)") : null;
      if (s.length > 1) {
        const i = s.map((o) => JSON.stringify(o.format())).join(", ");
        D(!1, `ambiguous error description (i.e. ${i})`, "name", e);
      }
      return s[0];
    }
    if (e = on.from(e).format(), e === "Error(string)")
      return on.from("error Error(string)");
    if (e === "Panic(uint256)")
      return on.from("error Panic(uint256)");
    const n = m(this, Us).get(e);
    return n || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(e) {
    const t = Array.from(m(this, Us).keys());
    t.sort((n, s) => n.localeCompare(s));
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      e(m(this, Us).get(s), n);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(e, t) {
    return m(this, Cr).decode(e, t);
  }
  _encodeParams(e, t) {
    return m(this, Cr).encode(e, t);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(e, t) {
    if (typeof e == "string") {
      const n = this.getError(e);
      D(n, "unknown error", "fragment", e), e = n;
    }
    return D(Ot(t, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", t), this._decodeParams(e.inputs, Ot(t, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(e, t) {
    if (typeof e == "string") {
      const n = this.getError(e);
      D(n, "unknown error", "fragment", e), e = n;
    }
    return Pt([
      e.selector,
      this._encodeParams(e.inputs, t || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      D(n, "unknown function", "fragment", e), e = n;
    }
    return D(Ot(t, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", t), this._decodeParams(e.inputs, Ot(t, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      D(n, "unknown function", "fragment", e), e = n;
    }
    return Pt([
      e.selector,
      this._encodeParams(e.inputs, t || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(e, t) {
    if (typeof e == "string") {
      const i = this.getFunction(e);
      D(i, "unknown function", "fragment", e), e = i;
    }
    let n = "invalid length for result data";
    const s = kr(t);
    if (s.length % 32 === 0)
      try {
        return m(this, Cr).decode(e.outputs, s);
      } catch {
        n = "could not decode result data";
      }
    z(!1, n, "BAD_DATA", {
      value: se(s),
      info: { method: e.name, signature: e.format() }
    });
  }
  makeError(e, t) {
    const n = Le(e, "data"), s = Qd.getBuiltinCallException("call", t, n);
    if (s.message.startsWith("execution reverted (unknown custom error)")) {
      const a = se(n.slice(0, 4)), c = this.getError(a);
      if (c)
        try {
          const l = m(this, Cr).decode(c.inputs, n.slice(4));
          s.revert = {
            name: c.name,
            signature: c.format(),
            args: l
          }, s.reason = s.revert.signature, s.message = `execution reverted: ${s.reason}`;
        } catch {
          s.message = "execution reverted (coult not decode custom error)";
        }
    }
    const o = this.parseTransaction(t);
    return o && (s.invocation = {
      method: o.name,
      signature: o.signature,
      args: o.args
    }), s;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      D(n, "unknown function", "fragment", e), e = n;
    }
    return se(m(this, Cr).encode(e.outputs, t || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, t) {
    if (typeof e == "string") {
      const i = this.getEvent(e);
      D(i, "unknown event", "eventFragment", e), e = i;
    }
    z(t.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", { count: t.length, expectedCount: e.inputs.length });
    const n = [];
    e.anonymous || n.push(e.topicHash);
    const s = (i, o) => i.type === "string" ? yc(o) : i.type === "bytes" ? $t(se(o)) : (i.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : i.type.match(/^u?int/) ? o = Qo(o) : i.type.match(/^bytes/) ? o = lW(o, 32) : i.type === "address" && m(this, Cr).encode(["address"], [o]), Hi(se(o), 32));
    for (t.forEach((i, o) => {
      const a = e.inputs[o];
      if (!a.indexed) {
        D(i == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, i);
        return;
      }
      i == null ? n.push(null) : a.baseType === "array" || a.baseType === "tuple" ? D(!1, "filtering with tuples or arrays not supported", "contract." + a.name, i) : Array.isArray(i) ? n.push(i.map((c) => s(a, c))) : n.push(s(a, i));
    }); n.length && n[n.length - 1] === null; )
      n.pop();
    return n;
  }
  encodeEventLog(e, t) {
    if (typeof e == "string") {
      const o = this.getEvent(e);
      D(o, "unknown event", "eventFragment", e), e = o;
    }
    const n = [], s = [], i = [];
    return e.anonymous || n.push(e.topicHash), D(t.length === e.inputs.length, "event arguments/values mismatch", "values", t), e.inputs.forEach((o, a) => {
      const c = t[a];
      if (o.indexed)
        if (o.type === "string")
          n.push(yc(c));
        else if (o.type === "bytes")
          n.push($t(c));
        else {
          if (o.baseType === "tuple" || o.baseType === "array")
            throw new Error("not implemented");
          n.push(m(this, Cr).encode([o.type], [c]));
        }
      else
        s.push(o), i.push(c);
    }), {
      data: m(this, Cr).encode(s, i),
      topics: n
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, t, n) {
    if (typeof e == "string") {
      const f = this.getEvent(e);
      D(f, "unknown event", "eventFragment", e), e = f;
    }
    if (n != null && !e.anonymous) {
      const f = e.topicHash;
      D(wt(n[0], 32) && n[0].toLowerCase() === f, "fragment/topic mismatch", "topics[0]", n[0]), n = n.slice(1);
    }
    const s = [], i = [], o = [];
    e.inputs.forEach((f, g) => {
      f.indexed ? f.type === "string" || f.type === "bytes" || f.baseType === "tuple" || f.baseType === "array" ? (s.push(dr.from({ type: "bytes32", name: f.name })), o.push(!0)) : (s.push(f), o.push(!1)) : (i.push(f), o.push(!1));
    });
    const a = n != null ? m(this, Cr).decode(s, Pt(n)) : null, c = m(this, Cr).decode(i, t, !0), l = [], u = [];
    let h = 0, d = 0;
    return e.inputs.forEach((f, g) => {
      let p = null;
      if (f.indexed)
        if (a == null)
          p = new _C(null);
        else if (o[g])
          p = new _C(a[d++]);
        else
          try {
            p = a[d++];
          } catch (w) {
            p = w;
          }
      else
        try {
          p = c[h++];
        } catch (w) {
          p = w;
        }
      l.push(p), u.push(f.name || null);
    }), Ou.fromItems(l, u);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(e) {
    const t = Le(e.data, "tx.data"), n = ge(e.value != null ? e.value : 0, "tx.value"), s = this.getFunction(se(t.slice(0, 4)));
    if (!s)
      return null;
    const i = m(this, Cr).decode(s.inputs, t.slice(4));
    return new VK(s, s.selector, i, n);
  }
  parseCallResult(e) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(e) {
    const t = this.getEvent(e.topics[0]);
    return !t || t.anonymous ? null : new WK(t, t.topicHash, this.decodeEventLog(t, e.data, e.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(e) {
    const t = se(e), n = this.getError(Ot(t, 0, 4));
    if (!n)
      return null;
    const s = m(this, Cr).decode(n.inputs, Ot(t, 4));
    return new GK(n, n.selector, s);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(e) {
    return e instanceof Ca ? e : typeof e == "string" ? new Ca(JSON.parse(e)) : typeof e.formatJson == "function" ? new Ca(e.formatJson()) : typeof e.format == "function" ? new Ca(e.format("json")) : new Ca(e);
  }
};
Us = new WeakMap(), Bs = new WeakMap(), Ls = new WeakMap(), Cr = new WeakMap(), Xs = new WeakSet(), // Find a function definition by any means necessary (unless it is ambiguous)
Mp = function(e, t, n) {
  if (wt(e)) {
    const i = e.toLowerCase();
    for (const o of m(this, Ls).values())
      if (i === o.selector)
        return o;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const i = [];
    for (const [o, a] of m(this, Ls))
      o.split(
        "("
        /* fix:) */
      )[0] === e && i.push(a);
    if (t) {
      const o = t.length > 0 ? t[t.length - 1] : null;
      let a = t.length, c = !0;
      Sr.isTyped(o) && o.type === "overrides" && (c = !1, a--);
      for (let l = i.length - 1; l >= 0; l--) {
        const u = i[l].inputs.length;
        u !== a && (!c || u !== a - 1) && i.splice(l, 1);
      }
      for (let l = i.length - 1; l >= 0; l--) {
        const u = i[l].inputs;
        for (let h = 0; h < t.length; h++)
          if (Sr.isTyped(t[h])) {
            if (h >= u.length) {
              if (t[h].type === "overrides")
                continue;
              i.splice(l, 1);
              break;
            }
            if (t[h].type !== u[h].baseType) {
              i.splice(l, 1);
              break;
            }
          }
      }
    }
    if (i.length === 1 && t && t.length !== i[0].inputs.length) {
      const o = t[t.length - 1];
      (o == null || Array.isArray(o) || typeof o != "object") && i.splice(0, 1);
    }
    if (i.length === 0)
      return null;
    if (i.length > 1 && n) {
      const o = i.map((a) => JSON.stringify(a.format())).join(", ");
      D(!1, `ambiguous function description (i.e. matches ${o})`, "key", e);
    }
    return i[0];
  }
  const s = m(this, Ls).get(Vs.from(e).format());
  return s || null;
}, // Find an event definition by any means necessary (unless it is ambiguous)
jp = function(e, t, n) {
  if (wt(e)) {
    const i = e.toLowerCase();
    for (const o of m(this, Bs).values())
      if (i === o.topicHash)
        return o;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const i = [];
    for (const [o, a] of m(this, Bs))
      o.split(
        "("
        /* fix:) */
      )[0] === e && i.push(a);
    if (t) {
      for (let o = i.length - 1; o >= 0; o--)
        i[o].inputs.length < t.length && i.splice(o, 1);
      for (let o = i.length - 1; o >= 0; o--) {
        const a = i[o].inputs;
        for (let c = 0; c < t.length; c++)
          if (Sr.isTyped(t[c]) && t[c].type !== a[c].baseType) {
            i.splice(o, 1);
            break;
          }
      }
    }
    if (i.length === 0)
      return null;
    if (i.length > 1 && n) {
      const o = i.map((a) => JSON.stringify(a.format())).join(", ");
      D(!1, `ambiguous event description (i.e. matches ${o})`, "key", e);
    }
    return i[0];
  }
  const s = m(this, Bs).get(Ws.from(e).format());
  return s || null;
};
let m0 = Ca;
const uT = BigInt(0);
function Tl(r) {
  return r ?? null;
}
function Dt(r) {
  return r == null ? null : r.toString();
}
class NC {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(e, t, n) {
    /**
     *  The gas price for legacy networks.
     */
    F(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    F(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    F(this, "maxPriorityFeePerGas");
    Ae(this, {
      gasPrice: Tl(e),
      maxFeePerGas: Tl(t),
      maxPriorityFeePerGas: Tl(n)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: e, maxFeePerGas: t, maxPriorityFeePerGas: n } = this;
    return {
      _type: "FeeData",
      gasPrice: Dt(e),
      maxFeePerGas: Dt(t),
      maxPriorityFeePerGas: Dt(n)
    };
  }
}
function Pg(r) {
  const e = {};
  r.to && (e.to = r.to), r.from && (e.from = r.from), r.data && (e.data = se(r.data));
  const t = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const s of t)
    !(s in r) || r[s] == null || (e[s] = ge(r[s], `request.${s}`));
  const n = "type,nonce".split(/,/);
  for (const s of n)
    !(s in r) || r[s] == null || (e[s] = De(r[s], `request.${s}`));
  return r.accessList && (e.accessList = Rc(r.accessList)), r.authorizationList && (e.authorizationList = r.authorizationList.slice()), "blockTag" in r && (e.blockTag = r.blockTag), "enableCcipRead" in r && (e.enableCcipRead = !!r.enableCcipRead), "customData" in r && (e.customData = r.customData), "blobVersionedHashes" in r && r.blobVersionedHashes && (e.blobVersionedHashes = r.blobVersionedHashes.slice()), "kzg" in r && (e.kzg = r.kzg), "blobs" in r && r.blobs && (e.blobs = r.blobs.map((s) => Sb(s) ? se(s) : Object.assign({}, s))), e;
}
var Ci;
class KK {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(e, t) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    F(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    F(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    F(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    F(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    F(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    F(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    F(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    F(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    F(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    F(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    F(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    F(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    F(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    F(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    F(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    F(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    F(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    F(this, "baseFeePerGas");
    M(this, Ci);
    S(this, Ci, e.transactions.map((n) => typeof n != "string" ? new Zd(n, t) : n)), Ae(this, {
      provider: t,
      hash: Tl(e.hash),
      number: e.number,
      timestamp: e.timestamp,
      parentHash: e.parentHash,
      parentBeaconBlockRoot: e.parentBeaconBlockRoot,
      nonce: e.nonce,
      difficulty: e.difficulty,
      gasLimit: e.gasLimit,
      gasUsed: e.gasUsed,
      blobGasUsed: e.blobGasUsed,
      excessBlobGas: e.excessBlobGas,
      miner: e.miner,
      prevRandao: Tl(e.prevRandao),
      extraData: e.extraData,
      baseFeePerGas: Tl(e.baseFeePerGas),
      stateRoot: e.stateRoot,
      receiptsRoot: e.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return m(this, Ci).map((e) => typeof e == "string" ? e : e.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const e = m(this, Ci).slice();
    return e.length === 0 ? [] : (z(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), e);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: e, difficulty: t, extraData: n, gasLimit: s, gasUsed: i, hash: o, miner: a, prevRandao: c, nonce: l, number: u, parentHash: h, parentBeaconBlockRoot: d, stateRoot: f, receiptsRoot: g, timestamp: p, transactions: w } = this;
    return {
      _type: "Block",
      baseFeePerGas: Dt(e),
      difficulty: Dt(t),
      extraData: n,
      gasLimit: Dt(s),
      gasUsed: Dt(i),
      blobGasUsed: Dt(this.blobGasUsed),
      excessBlobGas: Dt(this.excessBlobGas),
      hash: o,
      miner: a,
      prevRandao: c,
      nonce: l,
      number: u,
      parentHash: h,
      timestamp: p,
      parentBeaconBlockRoot: d,
      stateRoot: f,
      receiptsRoot: g,
      transactions: w
    };
  }
  [Symbol.iterator]() {
    let e = 0;
    const t = this.transactions;
    return {
      next: () => e < this.length ? {
        value: t[e++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return m(this, Ci).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(e) {
    let t;
    if (typeof e == "number")
      t = m(this, Ci)[e];
    else {
      const n = e.toLowerCase();
      for (const s of m(this, Ci))
        if (typeof s == "string") {
          if (s !== n)
            continue;
          t = s;
          break;
        } else {
          if (s.hash !== n)
            continue;
          t = s;
          break;
        }
    }
    if (t == null)
      throw new Error("no such tx");
    return typeof t == "string" ? await this.provider.getTransaction(t) : t;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(e) {
    const t = this.prefetchedTransactions;
    if (typeof e == "number")
      return t[e];
    e = e.toLowerCase();
    for (const n of t)
      if (n.hash === e)
        return n;
    D(!1, "no matching transaction", "indexOrHash", e);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return JK(this);
  }
}
Ci = new WeakMap();
class Bf {
  /**
   *  @_ignore:
   */
  constructor(e, t) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    F(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    F(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    F(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    F(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    F(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    F(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    F(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    F(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    F(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    F(this, "transactionIndex");
    this.provider = t;
    const n = Object.freeze(e.topics.slice());
    Ae(this, {
      transactionHash: e.transactionHash,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      removed: e.removed,
      address: e.address,
      data: e.data,
      topics: n,
      index: e.index,
      transactionIndex: e.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: e, blockHash: t, blockNumber: n, data: s, index: i, removed: o, topics: a, transactionHash: c, transactionIndex: l } = this;
    return {
      _type: "log",
      address: e,
      blockHash: t,
      blockNumber: n,
      data: s,
      index: i,
      removed: o,
      topics: a,
      transactionHash: c,
      transactionIndex: l
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    return z(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.transactionHash);
    return z(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const e = await this.provider.getTransactionReceipt(this.transactionHash);
    return z(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return YK(this);
  }
}
var of;
class hT {
  /**
   *  @_ignore:
   */
  constructor(e, t) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    F(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    F(this, "to");
    /**
     *  The sender of the transaction.
     */
    F(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    F(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    F(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    F(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    F(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    F(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    F(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    F(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    F(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    F(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    F(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    F(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    F(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    F(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    F(this, "root");
    M(this, of);
    S(this, of, Object.freeze(e.logs.map((s) => new Bf(s, t))));
    let n = uT;
    e.effectiveGasPrice != null ? n = e.effectiveGasPrice : e.gasPrice != null && (n = e.gasPrice), Ae(this, {
      provider: t,
      to: e.to,
      from: e.from,
      contractAddress: e.contractAddress,
      hash: e.hash,
      index: e.index,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      logsBloom: e.logsBloom,
      gasUsed: e.gasUsed,
      cumulativeGasUsed: e.cumulativeGasUsed,
      blobGasUsed: e.blobGasUsed,
      gasPrice: n,
      blobGasPrice: e.blobGasPrice,
      type: e.type,
      //byzantium: tx.byzantium,
      status: e.status,
      root: e.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return m(this, of);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: e,
      from: t,
      contractAddress: n,
      hash: s,
      index: i,
      blockHash: o,
      blockNumber: a,
      logsBloom: c,
      logs: l,
      //byzantium, 
      status: u,
      root: h
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: o,
      blockNumber: a,
      //byzantium, 
      contractAddress: n,
      cumulativeGasUsed: Dt(this.cumulativeGasUsed),
      from: t,
      gasPrice: Dt(this.gasPrice),
      blobGasUsed: Dt(this.blobGasUsed),
      blobGasPrice: Dt(this.blobGasPrice),
      gasUsed: Dt(this.gasUsed),
      hash: s,
      index: i,
      logs: l,
      logsBloom: c,
      root: h,
      status: u,
      to: e
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.length ? { value: this.logs[e++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.hash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return fT(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(e) {
    return z(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), dT(this, e);
  }
}
of = new WeakMap();
var So;
const Vb = class Vb {
  /**
   *  @_ignore:
   */
  constructor(e, t) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    F(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    F(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    F(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    F(this, "index");
    /**
     *  The transaction hash.
     */
    F(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    F(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    F(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    F(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    F(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    F(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    F(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    F(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    F(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    F(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    F(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    F(this, "value");
    /**
     *  The chain ID.
     */
    F(this, "chainId");
    /**
     *  The signature.
     */
    F(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    F(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    F(this, "blobVersionedHashes");
    /**
     *  The [[link-eip-7702]] authorizations (if any).
     */
    F(this, "authorizationList");
    M(this, So);
    this.provider = t, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null, this.authorizationList = e.authorizationList != null ? e.authorizationList : null, S(this, So, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: e, blockHash: t, index: n, hash: s, type: i, to: o, from: a, nonce: c, data: l, signature: u, accessList: h, blobVersionedHashes: d } = this;
    return {
      _type: "TransactionResponse",
      accessList: h,
      blockNumber: e,
      blockHash: t,
      blobVersionedHashes: d,
      chainId: Dt(this.chainId),
      data: l,
      from: a,
      gasLimit: Dt(this.gasLimit),
      gasPrice: Dt(this.gasPrice),
      hash: s,
      maxFeePerGas: Dt(this.maxFeePerGas),
      maxPriorityFeePerGas: Dt(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: Dt(this.maxFeePerBlobGas),
      nonce: c,
      signature: u,
      to: o,
      index: n,
      type: i,
      value: Dt(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let e = this.blockNumber;
    if (e == null) {
      const n = await this.getTransaction();
      n && (e = n.blockNumber);
    }
    if (e == null)
      return null;
    const t = this.provider.getBlock(e);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: t, blockNumber: n } = await Dr({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return t == null || t.blockNumber == null ? 0 : n - t.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, t) {
    const n = e ?? 1, s = t ?? 0;
    let i = m(this, So), o = -1, a = i === -1;
    const c = async () => {
      if (a)
        return null;
      const { blockNumber: d, nonce: f } = await Dr({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (f < this.nonce) {
        i = d;
        return;
      }
      if (a)
        return null;
      const g = await this.getTransaction();
      if (!(g && g.blockNumber != null))
        for (o === -1 && (o = i - 3, o < m(this, So) && (o = m(this, So))); o <= d; ) {
          if (a)
            return null;
          const p = await this.provider.getBlock(o, !0);
          if (p == null)
            return;
          for (const w of p)
            if (w === this.hash)
              return;
          for (let w = 0; w < p.length; w++) {
            const E = await p.getTransaction(w);
            if (E.from === this.from && E.nonce === this.nonce) {
              if (a)
                return null;
              const I = await this.provider.getTransactionReceipt(E.hash);
              if (I == null || d - I.blockNumber + 1 < n)
                return;
              let A = "replaced";
              E.data === this.data && E.to === this.to && E.value === this.value ? A = "repriced" : E.data === "0x" && E.from === E.to && E.value === uT && (A = "cancelled"), z(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: A === "replaced" || A === "cancelled",
                reason: A,
                replacement: E.replaceableTransaction(i),
                hash: E.hash,
                receipt: I
              });
            }
          }
          o++;
        }
    }, l = (d) => {
      if (d == null || d.status !== 0)
        return d;
      z(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: d.to,
          from: d.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: d
      });
    }, u = await this.provider.getTransactionReceipt(this.hash);
    if (n === 0)
      return l(u);
    if (u) {
      if (n === 1 || await u.confirmations() >= n)
        return l(u);
    } else if (await c(), n === 0)
      return null;
    return await new Promise((d, f) => {
      const g = [], p = () => {
        g.forEach((E) => E());
      };
      if (g.push(() => {
        a = !0;
      }), s > 0) {
        const E = setTimeout(() => {
          p(), f(St("wait for transaction timeout", "TIMEOUT"));
        }, s);
        g.push(() => {
          clearTimeout(E);
        });
      }
      const w = async (E) => {
        if (await E.confirmations() >= n) {
          p();
          try {
            d(l(E));
          } catch (I) {
            f(I);
          }
        }
      };
      if (g.push(() => {
        this.provider.off(this.hash, w);
      }), this.provider.on(this.hash, w), i >= 0) {
        const E = async () => {
          try {
            await c();
          } catch (I) {
            if (hr(I, "TRANSACTION_REPLACED")) {
              p(), f(I);
              return;
            }
          }
          a || this.provider.once("block", E);
        };
        g.push(() => {
          this.provider.off("block", E);
        }), this.provider.once("block", E);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return z(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), fT(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(e) {
    return z(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), z(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), dT(this, e);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(e) {
    D(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
    const t = new Vb(this, this.provider);
    return S(t, So, e), t;
  }
};
So = new WeakMap();
let Zd = Vb;
function JK(r) {
  return { orphan: "drop-block", hash: r.hash, number: r.number };
}
function dT(r, e) {
  return { orphan: "reorder-transaction", tx: r, other: e };
}
function fT(r) {
  return { orphan: "drop-transaction", tx: r };
}
function YK(r) {
  return { orphan: "drop-log", log: {
    transactionHash: r.transactionHash,
    blockHash: r.blockHash,
    blockNumber: r.blockNumber,
    address: r.address,
    data: r.data,
    topics: Object.freeze(r.topics.slice()),
    index: r.index
  } };
}
class $b extends Bf {
  /**
   * @_ignore:
   */
  constructor(t, n, s) {
    super(t, t.provider);
    /**
     *  The Contract Interface.
     */
    F(this, "interface");
    /**
     *  The matching event.
     */
    F(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    F(this, "args");
    const i = n.decodeEventLog(s, t.data, t.topics);
    Ae(this, { args: i, fragment: s, interface: n });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class pT extends Bf {
  /**
   * @_ignore:
   */
  constructor(t, n) {
    super(t, t.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    F(this, "error");
    Ae(this, { error: n });
  }
}
var su;
class QK extends hT {
  /**
   *  @_ignore:
   */
  constructor(t, n, s) {
    super(s, n);
    M(this, su);
    S(this, su, t);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((t) => {
      const n = t.topics.length ? m(this, su).getEvent(t.topics[0]) : null;
      if (n)
        try {
          return new $b(t, m(this, su), n);
        } catch (s) {
          return new pT(t, s);
        }
      return t;
    });
  }
}
su = new WeakMap();
var af;
class Mb extends Zd {
  /**
   *  @_ignore:
   */
  constructor(t, n, s) {
    super(s, n);
    M(this, af);
    S(this, af, t);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(t, n) {
    const s = await super.wait(t, n);
    return s == null ? null : new QK(m(this, af), this.provider, s);
  }
}
af = new WeakMap();
class gT extends $S {
  /**
   *  @_event:
   */
  constructor(t, n, s, i) {
    super(t, n, s);
    /**
     *  The log with no matching events.
     */
    F(this, "log");
    Ae(this, { log: i });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ZK extends gT {
  /**
   *  @_ignore:
   */
  constructor(e, t, n, s, i) {
    super(e, t, n, new $b(i, e.interface, s));
    const o = e.interface.decodeEventLog(s, this.log.data, this.log.topics);
    Ae(this, { args: o, fragment: s });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const TC = BigInt(0);
function mT(r) {
  return r && typeof r.call == "function";
}
function wT(r) {
  return r && typeof r.estimateGas == "function";
}
function bm(r) {
  return r && typeof r.resolveName == "function";
}
function yT(r) {
  return r && typeof r.sendTransaction == "function";
}
function bT(r) {
  if (r != null) {
    if (bm(r))
      return r;
    if (r.provider)
      return r.provider;
  }
}
var cf;
class XK {
  constructor(e, t, n) {
    M(this, cf);
    F(this, "fragment");
    if (Ae(this, { fragment: t }), t.inputs.length < n.length)
      throw new Error("too many arguments");
    const s = vc(e.runner, "resolveName"), i = bm(s) ? s : null;
    S(this, cf, async function() {
      const o = await Promise.all(t.inputs.map((a, c) => n[c] == null ? null : a.walkAsync(n[c], (u, h) => u === "address" ? Array.isArray(h) ? Promise.all(h.map((d) => Br(d, i))) : Br(h, i) : h)));
      return e.interface.encodeFilterTopics(t, o);
    }());
  }
  getTopicFilter() {
    return m(this, cf);
  }
}
cf = new WeakMap();
function vc(r, e) {
  return r == null ? null : typeof r[e] == "function" ? r : r.provider && typeof r.provider[e] == "function" ? r.provider : null;
}
function Da(r) {
  return r == null ? null : r.provider || null;
}
async function ET(r, e) {
  const t = Sr.dereference(r, "overrides");
  D(typeof t == "object", "invalid overrides parameter", "overrides", r);
  const n = Pg(t);
  return D(n.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", n.to), D(n.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", n.data), n.from && (n.from = n.from), n;
}
async function eJ(r, e, t) {
  const n = vc(r, "resolveName"), s = bm(n) ? n : null;
  return await Promise.all(e.map((i, o) => i.walkAsync(t[o], (a, c) => (c = Sr.dereference(c, a), a === "address" ? Br(c, s) : c))));
}
function tJ(r) {
  const e = async function(o) {
    const a = await ET(o, ["data"]);
    a.to = await r.getAddress(), a.from && (a.from = await Br(a.from, bT(r.runner)));
    const c = r.interface, l = ge(a.value || TC, "overrides.value") === TC, u = (a.data || "0x") === "0x";
    c.fallback && !c.fallback.payable && c.receive && !u && !l && D(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", o), D(c.fallback || u, "cannot send data to receive-only contract", "overrides.data", a.data);
    const h = c.receive || c.fallback && c.fallback.payable;
    return D(h || l, "cannot send value to non-payable fallback", "overrides.value", a.value), D(c.fallback || u, "cannot send data to receive-only contract", "overrides.data", a.data), a;
  }, t = async function(o) {
    const a = vc(r.runner, "call");
    z(mT(a), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const c = await e(o);
    try {
      return await a.call(c);
    } catch (l) {
      throw Ib(l) && l.data ? r.interface.makeError(l.data, c) : l;
    }
  }, n = async function(o) {
    const a = r.runner;
    z(yT(a), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const c = await a.sendTransaction(await e(o)), l = Da(r.runner);
    return new Mb(r.interface, l, c);
  }, s = async function(o) {
    const a = vc(r.runner, "estimateGas");
    return z(wT(a), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await a.estimateGas(await e(o));
  }, i = async (o) => await n(o);
  return Ae(i, {
    _contract: r,
    estimateGas: s,
    populateTransaction: e,
    send: n,
    staticCall: t
  }), i;
}
function rJ(r, e) {
  const t = function(...l) {
    const u = r.interface.getFunction(e, l);
    return z(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: l }
    }), u;
  }, n = async function(...l) {
    const u = t(...l);
    let h = {};
    if (u.inputs.length + 1 === l.length && (h = await ET(l.pop()), h.from && (h.from = await Br(h.from, bT(r.runner)))), u.inputs.length !== l.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const d = await eJ(r.runner, u.inputs, l);
    return Object.assign({}, h, await Dr({
      to: r.getAddress(),
      data: r.interface.encodeFunctionData(u, d)
    }));
  }, s = async function(...l) {
    const u = await a(...l);
    return u.length === 1 ? u[0] : u;
  }, i = async function(...l) {
    const u = r.runner;
    z(yT(u), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const h = await u.sendTransaction(await n(...l)), d = Da(r.runner);
    return new Mb(r.interface, d, h);
  }, o = async function(...l) {
    const u = vc(r.runner, "estimateGas");
    return z(wT(u), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await u.estimateGas(await n(...l));
  }, a = async function(...l) {
    const u = vc(r.runner, "call");
    z(mT(u), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const h = await n(...l);
    let d = "0x";
    try {
      d = await u.call(h);
    } catch (g) {
      throw Ib(g) && g.data ? r.interface.makeError(g.data, h) : g;
    }
    const f = t(...l);
    return r.interface.decodeFunctionResult(f, d);
  }, c = async (...l) => t(...l).constant ? await s(...l) : await i(...l);
  return Ae(c, {
    name: r.interface.getFunctionName(e),
    _contract: r,
    _key: e,
    getFragment: t,
    estimateGas: o,
    populateTransaction: n,
    send: i,
    staticCall: s,
    staticCallResult: a
  }), Object.defineProperty(c, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const l = r.interface.getFunction(e);
      return z(l, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), l;
    }
  }), c;
}
function nJ(r, e) {
  const t = function(...s) {
    const i = r.interface.getEvent(e, s);
    return z(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: s }
    }), i;
  }, n = function(...s) {
    return new XK(r, t(...s), s);
  };
  return Ae(n, {
    name: r.interface.getEventName(e),
    _contract: r,
    _key: e,
    getFragment: t
  }), Object.defineProperty(n, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const s = r.interface.getEvent(e);
      return z(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), s;
    }
  }), n;
}
const Rg = Symbol.for("_ethersInternal_contract"), vT = /* @__PURE__ */ new WeakMap();
function sJ(r, e) {
  vT.set(r[Rg], e);
}
function wn(r) {
  return vT.get(r[Rg]);
}
function iJ(r) {
  return r && typeof r == "object" && "getTopicFilter" in r && typeof r.getTopicFilter == "function" && r.fragment;
}
async function jb(r, e) {
  let t, n = null;
  if (Array.isArray(e)) {
    const i = function(o) {
      if (wt(o, 32))
        return o;
      const a = r.interface.getEvent(o);
      return D(a, "unknown fragment", "name", o), a.topicHash;
    };
    t = e.map((o) => o == null ? null : Array.isArray(o) ? o.map(i) : i(o));
  } else e === "*" ? t = [null] : typeof e == "string" ? wt(e, 32) ? t = [e] : (n = r.interface.getEvent(e), D(n, "unknown fragment", "event", e), t = [n.topicHash]) : iJ(e) ? t = await e.getTopicFilter() : "fragment" in e ? (n = e.fragment, t = [n.topicHash]) : D(!1, "unknown event name", "event", e);
  t = t.map((i) => {
    if (i == null)
      return null;
    if (Array.isArray(i)) {
      const o = Array.from(new Set(i.map((a) => a.toLowerCase())).values());
      return o.length === 1 ? o[0] : (o.sort(), o);
    }
    return i.toLowerCase();
  });
  const s = t.map((i) => i == null ? "null" : Array.isArray(i) ? i.join("|") : i).join("&");
  return { fragment: n, tag: s, topics: t };
}
async function Oh(r, e) {
  const { subs: t } = wn(r);
  return t.get((await jb(r, e)).tag) || null;
}
async function xC(r, e, t) {
  const n = Da(r.runner);
  z(n, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: e });
  const { fragment: s, tag: i, topics: o } = await jb(r, t), { addr: a, subs: c } = wn(r);
  let l = c.get(i);
  if (!l) {
    const h = { address: a || r, topics: o }, d = (w) => {
      let E = s;
      if (E == null)
        try {
          E = r.interface.getEvent(w.topics[0]);
        } catch {
        }
      if (E) {
        const I = E, A = s ? r.interface.decodeEventLog(s, w.data, w.topics) : [];
        y0(r, t, A, (C) => new ZK(r, C, t, I, w));
      } else
        y0(r, t, [], (I) => new gT(r, I, t, w));
    };
    let f = [];
    l = { tag: i, listeners: [], start: () => {
      f.length || f.push(n.on(h, d));
    }, stop: async () => {
      if (f.length == 0)
        return;
      let w = f;
      f = [], await Promise.all(w), n.off(h, d);
    } }, c.set(i, l);
  }
  return l;
}
let w0 = Promise.resolve();
async function oJ(r, e, t, n) {
  await w0;
  const s = await Oh(r, e);
  if (!s)
    return !1;
  const i = s.listeners.length;
  return s.listeners = s.listeners.filter(({ listener: o, once: a }) => {
    const c = Array.from(t);
    n && c.push(n(a ? null : o));
    try {
      o.call(r, ...c);
    } catch {
    }
    return !a;
  }), s.listeners.length === 0 && (s.stop(), wn(r).subs.delete(s.tag)), i > 0;
}
async function y0(r, e, t, n) {
  try {
    await w0;
  } catch {
  }
  const s = oJ(r, e, t, n);
  return w0 = s, await s;
}
const Ep = ["then"];
var MC;
MC = Rg;
const Jh = class Jh {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(e, t, n, s) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    F(this, "target");
    /**
     *  The contract Interface.
     */
    F(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    F(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    F(this, "filters");
    /**
     *  @_ignore:
     */
    F(this, MC);
    /**
     *  The fallback or receive function if any.
     */
    F(this, "fallback");
    D(typeof e == "string" || SN(e), "invalid value for Contract target", "target", e), n == null && (n = null);
    const i = m0.from(t);
    Ae(this, { target: e, runner: n, interface: i }), Object.defineProperty(this, Rg, { value: {} });
    let o, a = null, c = null;
    if (s) {
      const h = Da(n);
      c = new Mb(this.interface, h, s);
    }
    let l = /* @__PURE__ */ new Map();
    if (typeof e == "string")
      if (wt(e))
        a = e, o = Promise.resolve(e);
      else {
        const h = vc(n, "resolveName");
        if (!bm(h))
          throw St("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        o = h.resolveName(e).then((d) => {
          if (d == null)
            throw St("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: e
            });
          return wn(this).addr = d, d;
        });
      }
    else
      o = e.getAddress().then((h) => {
        if (h == null)
          throw new Error("TODO");
        return wn(this).addr = h, h;
      });
    sJ(this, { addrPromise: o, addr: a, deployTx: c, subs: l });
    const u = new Proxy({}, {
      get: (h, d, f) => {
        if (typeof d == "symbol" || Ep.indexOf(d) >= 0)
          return Reflect.get(h, d, f);
        try {
          return this.getEvent(d);
        } catch (g) {
          if (!hr(g, "INVALID_ARGUMENT") || g.argument !== "key")
            throw g;
        }
      },
      has: (h, d) => Ep.indexOf(d) >= 0 ? Reflect.has(h, d) : Reflect.has(h, d) || this.interface.hasEvent(String(d))
    });
    return Ae(this, { filters: u }), Ae(this, {
      fallback: i.receive || i.fallback ? tJ(this) : null
    }), new Proxy(this, {
      get: (h, d, f) => {
        if (typeof d == "symbol" || d in h || Ep.indexOf(d) >= 0)
          return Reflect.get(h, d, f);
        try {
          return h.getFunction(d);
        } catch (g) {
          if (!hr(g, "INVALID_ARGUMENT") || g.argument !== "key")
            throw g;
        }
      },
      has: (h, d) => typeof d == "symbol" || d in h || Ep.indexOf(d) >= 0 ? Reflect.has(h, d) : h.interface.hasFunction(d)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(e) {
    return new Jh(this.target, this.interface, e);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(e) {
    return new Jh(e, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await wn(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const e = Da(this.runner);
    z(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const t = await e.getCode(await this.getAddress());
    return t === "0x" ? null : t;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const e = this.deploymentTransaction();
    if (e)
      return await e.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const n = Da(this.runner);
    return z(n != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((s, i) => {
      const o = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return s(this);
          n.once("block", o);
        } catch (a) {
          i(a);
        }
      };
      o();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return wn(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(e) {
    return typeof e != "string" && (e = e.format()), rJ(this, e);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(e) {
    return typeof e != "string" && (e = e.format()), nJ(this, e);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(e) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(e, t, n) {
    t == null && (t = 0), n == null && (n = "latest");
    const { addr: s, addrPromise: i } = wn(this), o = s || await i, { fragment: a, topics: c } = await jb(this, e), l = { address: o, topics: c, fromBlock: t, toBlock: n }, u = Da(this.runner);
    return z(u, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await u.getLogs(l)).map((h) => {
      let d = a;
      if (d == null)
        try {
          d = this.interface.getEvent(h.topics[0]);
        } catch {
        }
      if (d)
        try {
          return new $b(h, this.interface, d);
        } catch (f) {
          return new pT(h, f);
        }
      return new Bf(h, u);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(e, t) {
    const n = await xC(this, "on", e);
    return n.listeners.push({ listener: t, once: !1 }), n.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(e, t) {
    const n = await xC(this, "once", e);
    return n.listeners.push({ listener: t, once: !0 }), n.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(e, ...t) {
    return await y0(this, e, t, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(e) {
    if (e) {
      const s = await Oh(this, e);
      return s ? s.listeners.length : 0;
    }
    const { subs: t } = wn(this);
    let n = 0;
    for (const { listeners: s } of t.values())
      n += s.length;
    return n;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(e) {
    if (e) {
      const s = await Oh(this, e);
      return s ? s.listeners.map(({ listener: i }) => i) : [];
    }
    const { subs: t } = wn(this);
    let n = [];
    for (const { listeners: s } of t.values())
      n = n.concat(s.map(({ listener: i }) => i));
    return n;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(e, t) {
    const n = await Oh(this, e);
    if (!n)
      return this;
    if (t) {
      const s = n.listeners.map(({ listener: i }) => i).indexOf(t);
      s >= 0 && n.listeners.splice(s, 1);
    }
    return (t == null || n.listeners.length === 0) && (n.stop(), wn(this).subs.delete(n.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(e) {
    if (e) {
      const t = await Oh(this, e);
      if (!t)
        return this;
      t.stop(), wn(this).subs.delete(t.tag);
    } else {
      const { subs: t } = wn(this);
      for (const { tag: n, stop: s } of t.values())
        s(), t.delete(n);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(e, t) {
    return await this.on(e, t);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(e, t) {
    return await this.off(e, t);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(e) {
    class t extends Jh {
      constructor(s, i = null) {
        super(s, e, i);
      }
    }
    return t;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(e, t, n) {
    return n == null && (n = null), new this(e, t, n);
  }
};
let b0 = Jh;
function aJ() {
  return b0;
}
class xl extends aJ() {
}
function Mw(r) {
  return r.match(/^ipfs:\/\/ipfs\//i) ? r = r.substring(12) : r.match(/^ipfs:\/\//i) ? r = r.substring(7) : D(!1, "unsupported IPFS format", "link", r), `https://gateway.ipfs.io/ipfs/${r}`;
}
class cJ {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(e) {
    /**
     *  The name.
     */
    F(this, "name");
    Ae(this, { name: e });
  }
  connect(e) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(e) {
    return !1;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(e, t) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(e, t) {
    throw new Error("unsupported coin");
  }
}
const AT = new RegExp("^(ipfs)://(.*)$", "i"), OC = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  AT,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var No, Va, To, hl, Fg, CT;
const yl = class yl {
  constructor(e, t, n) {
    M(this, To);
    /**
     *  The connected provider.
     */
    F(this, "provider");
    /**
     *  The address of the resolver.
     */
    F(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    F(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    M(this, No);
    M(this, Va);
    Ae(this, { provider: e, address: t, name: n }), S(this, No, null), S(this, Va, new xl(t, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], e));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return m(this, No) == null && S(this, No, (async () => {
      try {
        return await m(this, Va).supportsInterface("0x9061b923");
      } catch (e) {
        if (hr(e, "CALL_EXCEPTION"))
          return !1;
        throw S(this, No, null), e;
      }
    })()), await m(this, No);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(e) {
    if (e == null && (e = 60), e === 60)
      try {
        const i = await V(this, To, hl).call(this, "addr(bytes32)");
        return i == null || i === qd ? null : i;
      } catch (i) {
        if (hr(i, "CALL_EXCEPTION"))
          return null;
        throw i;
      }
    if (e >= 0 && e < 2147483648) {
      let i = e + 2147483648;
      const o = await V(this, To, hl).call(this, "addr(bytes32,uint)", [i]);
      if (wt(o, 20))
        return it(o);
    }
    let t = null;
    for (const i of this.provider.plugins)
      if (i instanceof cJ && i.supportsCoinType(e)) {
        t = i;
        break;
      }
    if (t == null)
      return null;
    const n = await V(this, To, hl).call(this, "addr(bytes32,uint)", [e]);
    if (n == null || n === "0x")
      return null;
    const s = await t.decodeAddress(e, n);
    if (s != null)
      return s;
    z(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${e})`,
      info: { coinType: e, data: n }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(e) {
    const t = await V(this, To, hl).call(this, "text(bytes32,string)", [e]);
    return t == null || t === "0x" ? null : t;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const e = await V(this, To, hl).call(this, "contenthash(bytes32)");
    if (e == null || e === "0x")
      return null;
    const t = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (t) {
      const s = t[1] === "e3010170" ? "ipfs" : "ipns", i = parseInt(t[4], 16);
      if (t[5].length === i * 2)
        return `${s}://${hW("0x" + t[2])}`;
    }
    const n = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (n && n[1].length === 64)
      return `bzz://${n[1]}`;
    z(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: e }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const e = [{ type: "name", value: this.name }];
    try {
      const t = await this.getText("avatar");
      if (t == null)
        return e.push({ type: "!avatar", value: "" }), { url: null, linkage: e };
      e.push({ type: "avatar", value: t });
      for (let n = 0; n < OC.length; n++) {
        const s = t.match(OC[n]);
        if (s == null)
          continue;
        const i = s[1].toLowerCase();
        switch (i) {
          case "https":
          case "data":
            return e.push({ type: "url", value: t }), { linkage: e, url: t };
          case "ipfs": {
            const o = Mw(t);
            return e.push({ type: "ipfs", value: t }), e.push({ type: "url", value: o }), { linkage: e, url: o };
          }
          case "erc721":
          case "erc1155": {
            const o = i === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            e.push({ type: i, value: t });
            const a = await this.getAddress();
            if (a == null)
              return e.push({ type: "!owner", value: "" }), { url: null, linkage: e };
            const c = (s[2] || "").split("/");
            if (c.length !== 2)
              return e.push({ type: `!${i}caip`, value: s[2] || "" }), { url: null, linkage: e };
            const l = c[1], u = new xl(c[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (i === "erc721") {
              const p = await u.ownerOf(l);
              if (a !== p)
                return e.push({ type: "!owner", value: p }), { url: null, linkage: e };
              e.push({ type: "owner", value: p });
            } else if (i === "erc1155") {
              const p = await u.balanceOf(a, l);
              if (!p)
                return e.push({ type: "!balance", value: "0" }), { url: null, linkage: e };
              e.push({ type: "balance", value: p.toString() });
            }
            let h = await u[o](l);
            if (h == null || h === "0x")
              return e.push({ type: "!metadata-url", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata-url-base", value: h }), i === "erc1155" && (h = h.replace("{id}", Qo(l, 32).substring(2)), e.push({ type: "metadata-url-expanded", value: h })), h.match(/^ipfs:/i) && (h = Mw(h)), e.push({ type: "metadata-url", value: h });
            let d = {};
            const f = await new zi(h).send();
            f.assertOk();
            try {
              d = f.bodyJson;
            } catch {
              try {
                e.push({ type: "!metadata", value: f.bodyText });
              } catch {
                const E = f.body;
                return E && e.push({ type: "!metadata", value: se(E) }), { url: null, linkage: e };
              }
              return { url: null, linkage: e };
            }
            if (!d)
              return e.push({ type: "!metadata", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata", value: JSON.stringify(d) });
            let g = d.image;
            if (typeof g != "string")
              return e.push({ type: "!imageUrl", value: "" }), { url: null, linkage: e };
            if (!g.match(/^(https:\/\/|data:)/i)) {
              if (g.match(AT) == null)
                return e.push({ type: "!imageUrl-ipfs", value: g }), { url: null, linkage: e };
              e.push({ type: "imageUrl-ipfs", value: g }), g = Mw(g);
            }
            return e.push({ type: "url", value: g }), { linkage: e, url: g };
          }
        }
      }
    } catch {
    }
    return { linkage: e, url: null };
  }
  static async getEnsAddress(e) {
    const t = await e.getNetwork(), n = t.getPlugin("org.ethers.plugins.network.Ens");
    return z(n, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: t }
    }), n.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(e, t) {
    var s;
    let n = t;
    for (; ; ) {
      if (n === "" || n === "." || t !== "eth" && n === "eth")
        return null;
      const i = await V(s = yl, Fg, CT).call(s, e, n);
      if (i != null) {
        const o = new yl(e, i, t);
        return n !== t && !await o.supportsWildcard() ? null : o;
      }
      n = n.split(".").slice(1).join(".");
    }
  }
};
No = new WeakMap(), Va = new WeakMap(), To = new WeakSet(), hl = async function(e, t) {
  t = (t || []).slice();
  const n = m(this, Va).interface;
  t.unshift(p0(this.name));
  let s = null;
  await this.supportsWildcard() && (s = n.getFunction(e), z(s, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: e }
  }), t = [
    CK(this.name, 255),
    n.encodeFunctionData(s, t)
  ], e = "resolve(bytes,bytes)"), t.push({
    enableCcipRead: !0
  });
  try {
    const i = await m(this, Va)[e](...t);
    return s ? n.decodeFunctionResult(s, i)[0] : i;
  } catch (i) {
    if (!hr(i, "CALL_EXCEPTION"))
      throw i;
  }
  return null;
}, Fg = new WeakSet(), CT = async function(e, t) {
  const n = await yl.getEnsAddress(e);
  try {
    const i = await new xl(n, [
      "function resolver(bytes32) view returns (address)"
    ], e).resolver(p0(t), {
      enableCcipRead: !0
    });
    return i === qd ? null : i;
  } catch (s) {
    throw s;
  }
  return null;
}, M(yl, Fg);
let Dg = yl;
const PC = BigInt(0);
function He(r, e) {
  return function(t) {
    return t == null ? e : r(t);
  };
}
function Xd(r, e) {
  return (t) => {
    if (e && t == null)
      return null;
    if (!Array.isArray(t))
      throw new Error("not an array");
    return t.map((n) => r(n));
  };
}
function Lf(r, e) {
  return (t) => {
    const n = {};
    for (const s in r) {
      let i = s;
      if (e && s in e && !(i in t)) {
        for (const o of e[s])
          if (o in t) {
            i = o;
            break;
          }
      }
      try {
        const o = r[s](t[i]);
        o !== void 0 && (n[s] = o);
      } catch (o) {
        const a = o instanceof Error ? o.message : "not-an-error";
        z(!1, `invalid value for value.${s} (${a})`, "BAD_DATA", { value: t });
      }
    }
    return n;
  };
}
function lJ(r) {
  switch (r) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  D(!1, `invalid boolean; ${JSON.stringify(r)}`, "value", r);
}
function Lu(r) {
  return D(wt(r, !0), "invalid data", "value", r), r;
}
function ur(r) {
  return D(wt(r, 32), "invalid hash", "value", r), r;
}
const uJ = Lf({
  address: it,
  blockHash: ur,
  blockNumber: De,
  data: Lu,
  index: De,
  removed: He(lJ, !1),
  topics: Xd(ur),
  transactionHash: ur,
  transactionIndex: De
}, {
  index: ["logIndex"]
});
function hJ(r) {
  return uJ(r);
}
const dJ = Lf({
  hash: He(ur),
  parentHash: ur,
  parentBeaconBlockRoot: He(ur, null),
  number: De,
  timestamp: De,
  nonce: He(Lu),
  difficulty: ge,
  gasLimit: ge,
  gasUsed: ge,
  stateRoot: He(ur, null),
  receiptsRoot: He(ur, null),
  blobGasUsed: He(ge, null),
  excessBlobGas: He(ge, null),
  miner: He(it),
  prevRandao: He(ur, null),
  extraData: Lu,
  baseFeePerGas: He(ge)
}, {
  prevRandao: ["mixHash"]
});
function fJ(r) {
  const e = dJ(r);
  return e.transactions = r.transactions.map((t) => typeof t == "string" ? t : _T(t)), e;
}
const pJ = Lf({
  transactionIndex: De,
  blockNumber: De,
  transactionHash: ur,
  address: it,
  topics: Xd(ur),
  data: Lu,
  index: De,
  blockHash: ur
}, {
  index: ["logIndex"]
});
function gJ(r) {
  return pJ(r);
}
const mJ = Lf({
  to: He(it, null),
  from: He(it, null),
  contractAddress: He(it, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: De,
  root: He(se),
  gasUsed: ge,
  blobGasUsed: He(ge, null),
  logsBloom: He(Lu),
  blockHash: ur,
  hash: ur,
  logs: Xd(gJ),
  blockNumber: De,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: ge,
  effectiveGasPrice: He(ge),
  blobGasPrice: He(ge, null),
  status: He(De),
  type: He(De, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function wJ(r) {
  return mJ(r);
}
function _T(r) {
  r.to && ge(r.to) === PC && (r.to = "0x0000000000000000000000000000000000000000");
  const e = Lf({
    hash: ur,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: He(De, void 0),
    type: (t) => t === "0x" || t == null ? 0 : De(t),
    accessList: He(Rc, null),
    blobVersionedHashes: He(Xd(ur, !0), null),
    authorizationList: He(Xd((t) => {
      let n;
      if (t.signature)
        n = t.signature;
      else {
        let s = t.yParity;
        s === "0x1b" ? s = 0 : s === "0x1c" && (s = 1), n = Object.assign({}, t, { yParity: s });
      }
      return {
        address: it(t.address),
        chainId: ge(t.chainId),
        nonce: ge(t.nonce),
        signature: ln.from(n)
      };
    }, !1), null),
    blockHash: He(ur, null),
    blockNumber: He(De, null),
    transactionIndex: He(De, null),
    from: it,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: He(ge),
    maxPriorityFeePerGas: He(ge),
    maxFeePerGas: He(ge),
    maxFeePerBlobGas: He(ge, null),
    gasLimit: ge,
    to: He(it, null),
    value: ge,
    nonce: De,
    data: Lu,
    creates: He(it, null),
    chainId: He(ge, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(r);
  if (e.to == null && e.creates == null && (e.creates = iG(e)), (r.type === 1 || r.type === 2) && r.accessList == null && (e.accessList = []), r.signature ? e.signature = ln.from(r.signature) : e.signature = ln.from(r), e.chainId == null) {
    const t = e.signature.legacyChainId;
    t != null && (e.chainId = t);
  }
  return e.blockHash && ge(e.blockHash) === PC && (e.blockHash = null), e;
}
const yJ = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class Ff {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(e) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    F(this, "name");
    Ae(this, { name: e });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new Ff(this.name);
  }
}
class Em extends Ff {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(t, n) {
    t == null && (t = 0);
    super(`org.ethers.network.plugins.GasCost#${t || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    F(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    F(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    F(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    F(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    F(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    F(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    F(this, "txAccessListAddress");
    const s = { effectiveBlock: t };
    function i(o, a) {
      let c = (n || {})[o];
      c == null && (c = a), D(typeof c == "number", `invalud value for ${o}`, "costs", n), s[o] = c;
    }
    i("txBase", 21e3), i("txCreate", 32e3), i("txDataZero", 4), i("txDataNonzero", 16), i("txAccessListStorageKey", 1900), i("txAccessListAddress", 2400), Ae(this, s);
  }
  clone() {
    return new Em(this.effectiveBlock, this);
  }
}
class vm extends Ff {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(t, n) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    F(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    F(this, "targetNetwork");
    Ae(this, {
      address: t || yJ,
      targetNetwork: n ?? 1
    });
  }
  clone() {
    return new vm(this.address, this.targetNetwork);
  }
}
var lf, uf;
class bJ extends Ff {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(t, n) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    M(this, lf);
    M(this, uf);
    S(this, lf, t), S(this, uf, n);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return m(this, lf);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return m(this, uf);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
lf = new WeakMap(), uf = new WeakMap();
const jw = /* @__PURE__ */ new Map();
var iu, ou, xo;
const bl = class bl {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(e, t) {
    M(this, iu);
    M(this, ou);
    M(this, xo);
    S(this, iu, e), S(this, ou, ge(t)), S(this, xo, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return m(this, iu);
  }
  set name(e) {
    S(this, iu, e);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return m(this, ou);
  }
  set chainId(e) {
    S(this, ou, ge(e, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(e) {
    if (e == null)
      return !1;
    if (typeof e == "string") {
      try {
        return this.chainId === ge(e);
      } catch {
      }
      return this.name === e;
    }
    if (typeof e == "number" || typeof e == "bigint") {
      try {
        return this.chainId === ge(e);
      } catch {
      }
      return !1;
    }
    if (typeof e == "object") {
      if (e.chainId != null) {
        try {
          return this.chainId === ge(e.chainId);
        } catch {
        }
        return !1;
      }
      return e.name != null ? this.name === e.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(m(this, xo).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(e) {
    if (m(this, xo).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return m(this, xo).set(e.name, e.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(e) {
    return m(this, xo).get(e) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(e) {
    return this.plugins.filter((t) => t.name.split("#")[0] === e);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const e = new bl(this.name, this.chainId);
    return this.plugins.forEach((t) => {
      e.attachPlugin(t.clone());
    }), e;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(e) {
    const t = this.getPlugin("org.ethers.plugins.network.GasCost") || new Em();
    let n = t.txBase;
    if (e.to == null && (n += t.txCreate), e.data)
      for (let s = 2; s < e.data.length; s += 2)
        e.data.substring(s, s + 2) === "00" ? n += t.txDataZero : n += t.txDataNonzero;
    if (e.accessList) {
      const s = Rc(e.accessList);
      for (const i in s)
        n += t.txAccessListAddress + t.txAccessListStorageKey * s[i].storageKeys.length;
    }
    return n;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(e) {
    if (EJ(), e == null)
      return bl.from("mainnet");
    if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
      const t = jw.get(e);
      if (t)
        return t();
      if (typeof e == "bigint")
        return new bl("unknown", e);
      D(!1, "unknown network", "network", e);
    }
    if (typeof e.clone == "function")
      return e.clone();
    if (typeof e == "object") {
      D(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
      const t = new bl(e.name, e.chainId);
      return (e.ensAddress || e.ensNetwork != null) && t.attachPlugin(new vm(e.ensAddress, e.ensNetwork)), t;
    }
    D(!1, "invalid network", "network", e);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(e, t) {
    typeof e == "number" && (e = BigInt(e));
    const n = jw.get(e);
    n && D(!1, `conflicting network for ${JSON.stringify(n.name)}`, "nameOrChainId", e), jw.set(e, t);
  }
};
iu = new WeakMap(), ou = new WeakMap(), xo = new WeakMap();
let Gs = bl;
function RC(r, e) {
  const t = String(r);
  if (!t.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${r}`);
  const n = t.split(".");
  if (n.length === 1 && n.push(""), n.length !== 2)
    throw new Error(`invalid gwei value: ${r}`);
  for (; n[1].length < e; )
    n[1] += "0";
  if (n[1].length > 9) {
    let s = BigInt(n[1].substring(0, 9));
    n[1].substring(9).match(/^0+$/) || s++, n[1] = s.toString();
  }
  return BigInt(n[0] + n[1]);
}
function DC(r) {
  return new bJ(r, async (e, t, n) => {
    n.setHeader("User-Agent", "ethers");
    let s;
    try {
      const [i, o] = await Promise.all([
        n.send(),
        e()
      ]);
      s = i;
      const a = s.bodyJson.standard;
      return {
        gasPrice: o.gasPrice,
        maxFeePerGas: RC(a.maxFee, 9),
        maxPriorityFeePerGas: RC(a.maxPriorityFee, 9)
      };
    } catch (i) {
      z(!1, `error encountered with polygon gas station (${JSON.stringify(n.url)})`, "SERVER_ERROR", { request: n, response: s, error: i });
    }
  });
}
let kC = !1;
function EJ() {
  if (kC)
    return;
  kC = !0;
  function r(e, t, n) {
    const s = function() {
      const i = new Gs(e, t);
      return n.ensNetwork != null && i.attachPlugin(new vm(null, n.ensNetwork)), i.attachPlugin(new Em()), (n.plugins || []).forEach((o) => {
        i.attachPlugin(o);
      }), i;
    };
    Gs.register(e, s), Gs.register(t, s), n.altNames && n.altNames.forEach((i) => {
      Gs.register(i, s);
    });
  }
  r("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), r("ropsten", 3, { ensNetwork: 3 }), r("rinkeby", 4, { ensNetwork: 4 }), r("goerli", 5, { ensNetwork: 5 }), r("kovan", 42, { ensNetwork: 42 }), r("sepolia", 11155111, { ensNetwork: 11155111 }), r("holesky", 17e3, { ensNetwork: 17e3 }), r("classic", 61, {}), r("classicKotti", 6, {}), r("arbitrum", 42161, {
    ensNetwork: 1
  }), r("arbitrum-goerli", 421613, {}), r("arbitrum-sepolia", 421614, {}), r("base", 8453, { ensNetwork: 1 }), r("base-goerli", 84531, {}), r("base-sepolia", 84532, {}), r("bnb", 56, { ensNetwork: 1 }), r("bnbt", 97, {}), r("linea", 59144, { ensNetwork: 1 }), r("linea-goerli", 59140, {}), r("linea-sepolia", 59141, {}), r("matic", 137, {
    ensNetwork: 1,
    plugins: [
      DC("https://gasstation.polygon.technology/v2")
    ]
  }), r("matic-amoy", 80002, {}), r("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      DC("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), r("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), r("optimism-goerli", 420, {}), r("optimism-sepolia", 11155420, {}), r("xdai", 100, { ensNetwork: 1 });
}
function E0(r) {
  return JSON.parse(JSON.stringify(r));
}
var _i, Fn, Oo, Fs, au, Hp;
class vJ {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    M(this, au);
    M(this, _i);
    M(this, Fn);
    M(this, Oo);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    M(this, Fs);
    S(this, _i, e), S(this, Fn, null), S(this, Oo, 4e3), S(this, Fs, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return m(this, Oo);
  }
  set pollingInterval(e) {
    S(this, Oo, e);
  }
  start() {
    m(this, Fn) || (S(this, Fn, m(this, _i)._setTimeout(V(this, au, Hp).bind(this), m(this, Oo))), V(this, au, Hp).call(this));
  }
  stop() {
    m(this, Fn) && (m(this, _i)._clearTimeout(m(this, Fn)), S(this, Fn, null));
  }
  pause(e) {
    this.stop(), e && S(this, Fs, -2);
  }
  resume() {
    this.start();
  }
}
_i = new WeakMap(), Fn = new WeakMap(), Oo = new WeakMap(), Fs = new WeakMap(), au = new WeakSet(), Hp = async function() {
  try {
    const e = await m(this, _i).getBlockNumber();
    if (m(this, Fs) === -2) {
      S(this, Fs, e);
      return;
    }
    if (e !== m(this, Fs)) {
      for (let t = m(this, Fs) + 1; t <= e; t++) {
        if (m(this, Fn) == null)
          return;
        await m(this, _i).emit("block", t);
      }
      S(this, Fs, e);
    }
  } catch {
  }
  m(this, Fn) != null && S(this, Fn, m(this, _i)._setTimeout(V(this, au, Hp).bind(this), m(this, Oo)));
};
var Ga, Ka, Po;
class Hb {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    M(this, Ga);
    M(this, Ka);
    M(this, Po);
    S(this, Ga, e), S(this, Po, !1), S(this, Ka, (t) => {
      this._poll(t, m(this, Ga));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(e, t) {
    throw new Error("sub-classes must override this");
  }
  start() {
    m(this, Po) || (S(this, Po, !0), m(this, Ka).call(this, -2), m(this, Ga).on("block", m(this, Ka)));
  }
  stop() {
    m(this, Po) && (S(this, Po, !1), m(this, Ga).off("block", m(this, Ka)));
  }
  pause(e) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
Ga = new WeakMap(), Ka = new WeakMap(), Po = new WeakMap();
var cu, Ii;
class AJ extends Hb {
  constructor(t, n) {
    super(t);
    M(this, cu);
    M(this, Ii);
    S(this, cu, n), S(this, Ii, -2);
  }
  pause(t) {
    t && S(this, Ii, -2), super.pause(t);
  }
  async _poll(t, n) {
    const s = await n.getBlock(m(this, cu));
    s != null && (m(this, Ii) === -2 ? S(this, Ii, s.number) : s.number > m(this, Ii) && (n.emit(m(this, cu), s.number), S(this, Ii, s.number)));
  }
}
cu = new WeakMap(), Ii = new WeakMap();
var $g;
class CJ extends Hb {
  constructor(t, n) {
    super(t);
    M(this, $g);
    S(this, $g, E0(n));
  }
  async _poll(t, n) {
    throw new Error("@TODO");
  }
}
$g = new WeakMap();
var lu;
class _J extends Hb {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(t, n) {
    super(t);
    M(this, lu);
    S(this, lu, n);
  }
  async _poll(t, n) {
    const s = await n.getTransactionReceipt(m(this, lu));
    s && n.emit(m(this, lu), s);
  }
}
lu = new WeakMap();
var Si, uu, hu, Ro, $n, Mg, IT;
class zb {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(e, t) {
    M(this, Mg);
    M(this, Si);
    M(this, uu);
    M(this, hu);
    M(this, Ro);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    M(this, $n);
    S(this, Si, e), S(this, uu, E0(t)), S(this, hu, V(this, Mg, IT).bind(this)), S(this, Ro, !1), S(this, $n, -2);
  }
  start() {
    m(this, Ro) || (S(this, Ro, !0), m(this, $n) === -2 && m(this, Si).getBlockNumber().then((e) => {
      S(this, $n, e);
    }), m(this, Si).on("block", m(this, hu)));
  }
  stop() {
    m(this, Ro) && (S(this, Ro, !1), m(this, Si).off("block", m(this, hu)));
  }
  pause(e) {
    this.stop(), e && S(this, $n, -2);
  }
  resume() {
    this.start();
  }
}
Si = new WeakMap(), uu = new WeakMap(), hu = new WeakMap(), Ro = new WeakMap(), $n = new WeakMap(), Mg = new WeakSet(), IT = async function(e) {
  if (m(this, $n) === -2)
    return;
  const t = E0(m(this, uu));
  t.fromBlock = m(this, $n) + 1, t.toBlock = e;
  const n = await m(this, Si).getLogs(t);
  if (n.length === 0) {
    m(this, $n) < e - 60 && S(this, $n, e - 60);
    return;
  }
  for (const s of n)
    m(this, Si).emit(m(this, uu), s), S(this, $n, s.blockNumber);
};
const IJ = BigInt(2), SJ = 10;
function vp(r) {
  return r && typeof r.then == "function";
}
function zp(r, e) {
  return r + ":" + JSON.stringify(e, (t, n) => {
    if (n == null)
      return "null";
    if (typeof n == "bigint")
      return `bigint:${n.toString()}`;
    if (typeof n == "string")
      return n.toLowerCase();
    if (typeof n == "object" && !Array.isArray(n)) {
      const s = Object.keys(n);
      return s.sort(), s.reduce((i, o) => (i[o] = n[o], i), {});
    }
    return n;
  });
}
class ST {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(e) {
    /**
     *  The name fof the event.
     */
    F(this, "name");
    Ae(this, { name: e });
  }
  start() {
  }
  stop() {
  }
  pause(e) {
  }
  resume() {
  }
}
function NJ(r) {
  return JSON.parse(JSON.stringify(r));
}
function v0(r) {
  return r = Array.from(new Set(r).values()), r.sort(), r;
}
async function Hw(r, e) {
  if (r == null)
    throw new Error("invalid event");
  if (Array.isArray(r) && (r = { topics: r }), typeof r == "string")
    switch (r) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: r, tag: r };
    }
  if (wt(r, 32)) {
    const t = r.toLowerCase();
    return { type: "transaction", tag: zp("tx", { hash: t }), hash: t };
  }
  if (r.orphan) {
    const t = r;
    return { type: "orphan", tag: zp("orphan", t), filter: NJ(t) };
  }
  if (r.address || r.topics) {
    const t = r, n = {
      topics: (t.topics || []).map((s) => s == null ? null : Array.isArray(s) ? v0(s.map((i) => i.toLowerCase())) : s.toLowerCase())
    };
    if (t.address) {
      const s = [], i = [], o = (a) => {
        wt(a) ? s.push(a) : i.push((async () => {
          s.push(await Br(a, e));
        })());
      };
      Array.isArray(t.address) ? t.address.forEach(o) : o(t.address), i.length && await Promise.all(i), n.address = v0(s.map((a) => a.toLowerCase()));
    }
    return { filter: n, tag: zp("event", n), type: "event" };
  }
  D(!1, "unknown ProviderEvent", "event", r);
}
function zw() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const TJ = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var _r, Do, Ir, du, vn, Ja, ko, Ni, hf, Mn, fu, pu, $e, gn, A0, C0, Ph, _0, Rh, qp;
class xJ {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(e, t) {
    M(this, $e);
    M(this, _r);
    M(this, Do);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    M(this, Ir);
    M(this, du);
    M(this, vn);
    M(this, Ja);
    M(this, ko);
    // The most recent block number if running an event or -1 if no "block" event
    M(this, Ni);
    M(this, hf);
    M(this, Mn);
    M(this, fu);
    M(this, pu);
    if (S(this, pu, Object.assign({}, TJ, t || {})), e === "any")
      S(this, Ja, !0), S(this, vn, null);
    else if (e) {
      const n = Gs.from(e);
      S(this, Ja, !1), S(this, vn, Promise.resolve(n)), setTimeout(() => {
        this.emit("network", n, null);
      }, 0);
    } else
      S(this, Ja, !1), S(this, vn, null);
    S(this, Ni, -1), S(this, ko, /* @__PURE__ */ new Map()), S(this, _r, /* @__PURE__ */ new Map()), S(this, Do, /* @__PURE__ */ new Map()), S(this, Ir, null), S(this, du, !1), S(this, hf, 1), S(this, Mn, /* @__PURE__ */ new Map()), S(this, fu, !1);
  }
  get pollingInterval() {
    return m(this, pu).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(m(this, Do).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(e) {
    if (m(this, Do).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return m(this, Do).set(e.name, e.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(e) {
    return m(this, Do).get(e) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return m(this, fu);
  }
  set disableCcipRead(e) {
    S(this, fu, !!e);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(e, t, n) {
    if (this.disableCcipRead || n.length === 0 || e.to == null)
      return null;
    const s = e.to.toLowerCase(), i = t.toLowerCase(), o = [];
    for (let a = 0; a < n.length; a++) {
      const c = n[a], l = c.replace("{sender}", s).replace("{data}", i), u = new zi(l);
      c.indexOf("{data}") === -1 && (u.body = { data: i, sender: s }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: u, index: a, urls: n });
      let h = "unknown error", d;
      try {
        d = await u.send();
      } catch (f) {
        o.push(f.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: u, result: { error: f } });
        continue;
      }
      try {
        const f = d.bodyJson;
        if (f.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: u, result: f }), f.data;
        f.message && (h = f.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: u, result: f });
      } catch {
      }
      z(d.statusCode < 400 || d.statusCode >= 500, `response not found during CCIP fetch: ${h}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: e, info: { url: c, errorMessage: h } }), o.push(h);
    }
    z(!1, `error encountered during CCIP fetch: ${o.map((a) => JSON.stringify(a)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: e,
      info: { urls: n, errorMessages: o }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(e, t) {
    return new KK(fJ(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(e, t) {
    return new Bf(hJ(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(e, t) {
    return new hT(wJ(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(e, t) {
    return new Zd(_T(e), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    z(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(e) {
    z(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: e
    });
  }
  // State
  async getBlockNumber() {
    const e = De(await V(this, $e, gn).call(this, { method: "getBlockNumber" }), "%response");
    return m(this, Ni) >= 0 && S(this, Ni, e), e;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(e) {
    return Br(e, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(e) {
    if (e == null)
      return "latest";
    switch (e) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return e;
    }
    if (wt(e))
      return wt(e, 32) ? e : hs(e);
    if (typeof e == "bigint" && (e = De(e, "blockTag")), typeof e == "number")
      return e >= 0 ? hs(e) : m(this, Ni) >= 0 ? hs(m(this, Ni) + e) : this.getBlockNumber().then((t) => hs(t + e));
    D(!1, "invalid blockTag", "blockTag", e);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(e) {
    const t = (e.topics || []).map((c) => c == null ? null : Array.isArray(c) ? v0(c.map((l) => l.toLowerCase())) : c.toLowerCase()), n = "blockHash" in e ? e.blockHash : void 0, s = (c, l, u) => {
      let h;
      switch (c.length) {
        case 0:
          break;
        case 1:
          h = c[0];
          break;
        default:
          c.sort(), h = c;
      }
      if (n && (l != null || u != null))
        throw new Error("invalid filter");
      const d = {};
      return h && (d.address = h), t.length && (d.topics = t), l && (d.fromBlock = l), u && (d.toBlock = u), n && (d.blockHash = n), d;
    };
    let i = [];
    if (e.address)
      if (Array.isArray(e.address))
        for (const c of e.address)
          i.push(this._getAddress(c));
      else
        i.push(this._getAddress(e.address));
    let o;
    "fromBlock" in e && (o = this._getBlockTag(e.fromBlock));
    let a;
    return "toBlock" in e && (a = this._getBlockTag(e.toBlock)), i.filter((c) => typeof c != "string").length || o != null && typeof o != "string" || a != null && typeof a != "string" ? Promise.all([Promise.all(i), o, a]).then((c) => s(c[0], c[1], c[2])) : s(i, o, a);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(e) {
    const t = Pg(e), n = [];
    if (["to", "from"].forEach((s) => {
      if (t[s] == null)
        return;
      const i = Br(t[s], this);
      vp(i) ? n.push(async function() {
        t[s] = await i;
      }()) : t[s] = i;
    }), t.blockTag != null) {
      const s = this._getBlockTag(t.blockTag);
      vp(s) ? n.push(async function() {
        t.blockTag = await s;
      }()) : t.blockTag = s;
    }
    return n.length ? async function() {
      return await Promise.all(n), t;
    }() : t;
  }
  async getNetwork() {
    if (m(this, vn) == null) {
      const s = (async () => {
        try {
          const i = await this._detectNetwork();
          return this.emit("network", i, null), i;
        } catch (i) {
          throw m(this, vn) === s && S(this, vn, null), i;
        }
      })();
      return S(this, vn, s), (await s).clone();
    }
    const e = m(this, vn), [t, n] = await Promise.all([
      e,
      this._detectNetwork()
      // The actual connected network
    ]);
    return t.chainId !== n.chainId && (m(this, Ja) ? (this.emit("network", n, t), m(this, vn) === e && S(this, vn, Promise.resolve(n))) : z(!1, `network changed: ${t.chainId} => ${n.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), t.clone();
  }
  async getFeeData() {
    const e = await this.getNetwork(), t = async () => {
      const { _block: s, gasPrice: i, priorityFee: o } = await Dr({
        _block: V(this, $e, _0).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const u = await V(this, $e, gn).call(this, { method: "getGasPrice" });
            return ge(u, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const u = await V(this, $e, gn).call(this, { method: "getPriorityFee" });
            return ge(u, "%response");
          } catch {
          }
          return null;
        })()
      });
      let a = null, c = null;
      const l = this._wrapBlock(s, e);
      return l && l.baseFeePerGas && (c = o ?? BigInt("1000000000"), a = l.baseFeePerGas * IJ + c), new NC(i, a, c);
    }, n = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (n) {
      const s = new zi(n.url), i = await n.processFunc(t, this, s);
      return new NC(i.gasPrice, i.maxFeePerGas, i.maxPriorityFeePerGas);
    }
    return await t();
  }
  async estimateGas(e) {
    let t = this._getTransactionRequest(e);
    return vp(t) && (t = await t), ge(await V(this, $e, gn).call(this, {
      method: "estimateGas",
      transaction: t
    }), "%response");
  }
  async call(e) {
    const { tx: t, blockTag: n } = await Dr({
      tx: this._getTransactionRequest(e),
      blockTag: this._getBlockTag(e.blockTag)
    });
    return await V(this, $e, C0).call(this, V(this, $e, A0).call(this, t, n, e.enableCcipRead ? 0 : -1));
  }
  async getBalance(e, t) {
    return ge(await V(this, $e, Ph).call(this, { method: "getBalance" }, e, t), "%response");
  }
  async getTransactionCount(e, t) {
    return De(await V(this, $e, Ph).call(this, { method: "getTransactionCount" }, e, t), "%response");
  }
  async getCode(e, t) {
    return se(await V(this, $e, Ph).call(this, { method: "getCode" }, e, t));
  }
  async getStorage(e, t, n) {
    const s = ge(t, "position");
    return se(await V(this, $e, Ph).call(this, { method: "getStorage", position: s }, e, n));
  }
  // Write
  async broadcastTransaction(e) {
    const { blockNumber: t, hash: n, network: s } = await Dr({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: e
      }),
      network: this.getNetwork()
    }), i = _g.from(e);
    if (i.hash !== n)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(i, s).replaceableTransaction(t);
  }
  // Queries
  async getBlock(e, t) {
    const { network: n, params: s } = await Dr({
      network: this.getNetwork(),
      params: V(this, $e, _0).call(this, e, !!t)
    });
    return s == null ? null : this._wrapBlock(s, n);
  }
  async getTransaction(e) {
    const { network: t, params: n } = await Dr({
      network: this.getNetwork(),
      params: V(this, $e, gn).call(this, { method: "getTransaction", hash: e })
    });
    return n == null ? null : this._wrapTransactionResponse(n, t);
  }
  async getTransactionReceipt(e) {
    const { network: t, params: n } = await Dr({
      network: this.getNetwork(),
      params: V(this, $e, gn).call(this, { method: "getTransactionReceipt", hash: e })
    });
    if (n == null)
      return null;
    if (n.gasPrice == null && n.effectiveGasPrice == null) {
      const s = await V(this, $e, gn).call(this, { method: "getTransaction", hash: e });
      if (s == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      n.effectiveGasPrice = s.gasPrice;
    }
    return this._wrapTransactionReceipt(n, t);
  }
  async getTransactionResult(e) {
    const { result: t } = await Dr({
      network: this.getNetwork(),
      result: V(this, $e, gn).call(this, { method: "getTransactionResult", hash: e })
    });
    return t == null ? null : se(t);
  }
  // Bloom-filter Queries
  async getLogs(e) {
    let t = this._getFilter(e);
    vp(t) && (t = await t);
    const { network: n, params: s } = await Dr({
      network: this.getNetwork(),
      params: V(this, $e, gn).call(this, { method: "getLogs", filter: t })
    });
    return s.map((i) => this._wrapLog(i, n));
  }
  // ENS
  _getProvider(e) {
    z(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(e) {
    return await Dg.fromName(this, e);
  }
  async getAvatar(e) {
    const t = await this.getResolver(e);
    return t ? await t.getAvatar() : null;
  }
  async resolveName(e) {
    const t = await this.getResolver(e);
    return t ? await t.getAddress() : null;
  }
  async lookupAddress(e) {
    e = it(e);
    const t = p0(e.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const n = await Dg.getEnsAddress(this), i = await new xl(n, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(t);
      if (i == null || i === qd)
        return null;
      const a = await new xl(i, [
        "function name(bytes32) view returns (string)"
      ], this).name(t);
      return await this.resolveName(a) !== e ? null : a;
    } catch (n) {
      if (hr(n, "BAD_DATA") && n.value === "0x" || hr(n, "CALL_EXCEPTION"))
        return null;
      throw n;
    }
    return null;
  }
  async waitForTransaction(e, t, n) {
    const s = t ?? 1;
    return s === 0 ? this.getTransactionReceipt(e) : new Promise(async (i, o) => {
      let a = null;
      const c = async (l) => {
        try {
          const u = await this.getTransactionReceipt(e);
          if (u != null && l - u.blockNumber + 1 >= s) {
            i(u), a && (clearTimeout(a), a = null);
            return;
          }
        } catch (u) {
          console.log("EEE", u);
        }
        this.once("block", c);
      };
      n != null && (a = setTimeout(() => {
        a != null && (a = null, this.off("block", c), o(St("timeout", "TIMEOUT", { reason: "timeout" })));
      }, n)), c(await this.getBlockNumber());
    });
  }
  async waitForBlock(e) {
    z(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(e) {
    const t = m(this, Mn).get(e);
    t && (t.timer && clearTimeout(t.timer), m(this, Mn).delete(e));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(e, t) {
    t == null && (t = 0);
    const n = Ju(this, hf)._++, s = () => {
      m(this, Mn).delete(n), e();
    };
    if (this.paused)
      m(this, Mn).set(n, { timer: null, func: s, time: t });
    else {
      const i = setTimeout(s, t);
      m(this, Mn).set(n, { timer: i, func: s, time: zw() });
    }
    return n;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(e) {
    for (const t of m(this, _r).values())
      e(t.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(e) {
    switch (e.type) {
      case "debug":
      case "error":
      case "network":
        return new ST(e.type);
      case "block": {
        const t = new vJ(this);
        return t.pollingInterval = this.pollingInterval, t;
      }
      case "safe":
      case "finalized":
        return new AJ(this, e.type);
      case "event":
        return new zb(this, e.filter);
      case "transaction":
        return new _J(this, e.hash);
      case "orphan":
        return new CJ(this, e.filter);
    }
    throw new Error(`unsupported event: ${e.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(e, t) {
    for (const n of m(this, _r).values())
      if (n.subscriber === e) {
        n.started && n.subscriber.stop(), n.subscriber = t, n.started && t.start(), m(this, Ir) != null && t.pause(m(this, Ir));
        break;
      }
  }
  async on(e, t) {
    const n = await V(this, $e, qp).call(this, e);
    return n.listeners.push({ listener: t, once: !1 }), n.started || (n.subscriber.start(), n.started = !0, m(this, Ir) != null && n.subscriber.pause(m(this, Ir))), this;
  }
  async once(e, t) {
    const n = await V(this, $e, qp).call(this, e);
    return n.listeners.push({ listener: t, once: !0 }), n.started || (n.subscriber.start(), n.started = !0, m(this, Ir) != null && n.subscriber.pause(m(this, Ir))), this;
  }
  async emit(e, ...t) {
    const n = await V(this, $e, Rh).call(this, e, t);
    if (!n || n.listeners.length === 0)
      return !1;
    const s = n.listeners.length;
    return n.listeners = n.listeners.filter(({ listener: i, once: o }) => {
      const a = new $S(this, o ? null : i, e);
      try {
        i.call(this, ...t, a);
      } catch {
      }
      return !o;
    }), n.listeners.length === 0 && (n.started && n.subscriber.stop(), m(this, _r).delete(n.tag)), s > 0;
  }
  async listenerCount(e) {
    if (e) {
      const n = await V(this, $e, Rh).call(this, e);
      return n ? n.listeners.length : 0;
    }
    let t = 0;
    for (const { listeners: n } of m(this, _r).values())
      t += n.length;
    return t;
  }
  async listeners(e) {
    if (e) {
      const n = await V(this, $e, Rh).call(this, e);
      return n ? n.listeners.map(({ listener: s }) => s) : [];
    }
    let t = [];
    for (const { listeners: n } of m(this, _r).values())
      t = t.concat(n.map(({ listener: s }) => s));
    return t;
  }
  async off(e, t) {
    const n = await V(this, $e, Rh).call(this, e);
    if (!n)
      return this;
    if (t) {
      const s = n.listeners.map(({ listener: i }) => i).indexOf(t);
      s >= 0 && n.listeners.splice(s, 1);
    }
    return (!t || n.listeners.length === 0) && (n.started && n.subscriber.stop(), m(this, _r).delete(n.tag)), this;
  }
  async removeAllListeners(e) {
    if (e) {
      const { tag: t, started: n, subscriber: s } = await V(this, $e, qp).call(this, e);
      n && s.stop(), m(this, _r).delete(t);
    } else
      for (const [t, { started: n, subscriber: s }] of m(this, _r))
        n && s.stop(), m(this, _r).delete(t);
    return this;
  }
  // Alias for "on"
  async addListener(e, t) {
    return await this.on(e, t);
  }
  // Alias for "off"
  async removeListener(e, t) {
    return this.off(e, t);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return m(this, du);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const e of m(this, Mn).keys())
      this._clearTimeout(e);
    S(this, du, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return m(this, Ir) != null;
  }
  set paused(e) {
    !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(e) {
    if (S(this, Ni, -1), m(this, Ir) != null) {
      if (m(this, Ir) == !!e)
        return;
      z(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((t) => t.pause(e)), S(this, Ir, !!e);
    for (const t of m(this, Mn).values())
      t.timer && clearTimeout(t.timer), t.time = zw() - t.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (m(this, Ir) != null) {
      this._forEachSubscriber((e) => e.resume()), S(this, Ir, null);
      for (const e of m(this, Mn).values()) {
        let t = e.time;
        t < 0 && (t = 0), e.time = zw(), setTimeout(e.func, t);
      }
    }
  }
}
_r = new WeakMap(), Do = new WeakMap(), Ir = new WeakMap(), du = new WeakMap(), vn = new WeakMap(), Ja = new WeakMap(), ko = new WeakMap(), Ni = new WeakMap(), hf = new WeakMap(), Mn = new WeakMap(), fu = new WeakMap(), pu = new WeakMap(), $e = new WeakSet(), gn = async function(e) {
  const t = m(this, pu).cacheTimeout;
  if (t < 0)
    return await this._perform(e);
  const n = zp(e.method, e);
  let s = m(this, ko).get(n);
  return s || (s = this._perform(e), m(this, ko).set(n, s), setTimeout(() => {
    m(this, ko).get(n) === s && m(this, ko).delete(n);
  }, t)), await s;
}, A0 = async function(e, t, n) {
  z(n < SJ, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, e, { blockTag: t, enableCcipRead: !0 })
  });
  const s = Pg(e);
  try {
    return se(await this._perform({ method: "call", transaction: s, blockTag: t }));
  } catch (i) {
    if (!this.disableCcipRead && Ib(i) && i.data && n >= 0 && t === "latest" && s.to != null && Ot(i.data, 0, 4) === "0x556f1830") {
      const o = i.data, a = await Br(s.to, this);
      let c;
      try {
        c = kJ(Ot(i.data, 4));
      } catch (h) {
        z(!1, h.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: s,
          info: { data: o }
        });
      }
      z(c.sender.toLowerCase() === a.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: o,
        reason: "OffchainLookup",
        transaction: s,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: c.errorArgs
        }
      });
      const l = await this.ccipReadFetch(s, c.calldata, c.urls);
      z(l != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: s,
        info: { data: i.data, errorArgs: c.errorArgs }
      });
      const u = {
        to: a,
        data: Pt([c.selector, DJ([l, c.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: u });
      try {
        const h = await V(this, $e, A0).call(this, u, t, n + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, u), result: h }), h;
      } catch (h) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, u), error: h }), h;
      }
    }
    throw i;
  }
}, C0 = async function(e) {
  const { value: t } = await Dr({
    network: this.getNetwork(),
    value: e
  });
  return t;
}, Ph = async function(e, t, n) {
  let s = this._getAddress(t), i = this._getBlockTag(n);
  return (typeof s != "string" || typeof i != "string") && ([s, i] = await Promise.all([s, i])), await V(this, $e, C0).call(this, V(this, $e, gn).call(this, Object.assign(e, { address: s, blockTag: i })));
}, _0 = async function(e, t) {
  if (wt(e, 32))
    return await V(this, $e, gn).call(this, {
      method: "getBlock",
      blockHash: e,
      includeTransactions: t
    });
  let n = this._getBlockTag(e);
  return typeof n != "string" && (n = await n), await V(this, $e, gn).call(this, {
    method: "getBlock",
    blockTag: n,
    includeTransactions: t
  });
}, Rh = async function(e, t) {
  let n = await Hw(e, this);
  return n.type === "event" && t && t.length > 0 && t[0].removed === !0 && (n = await Hw({ orphan: "drop-log", log: t[0] }, this)), m(this, _r).get(n.tag) || null;
}, qp = async function(e) {
  const t = await Hw(e, this), n = t.tag;
  let s = m(this, _r).get(n);
  return s || (s = { subscriber: this._getSubscriber(t), tag: n, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, m(this, _r).set(n, s)), s;
};
function OJ(r, e) {
  try {
    const t = I0(r, e);
    if (t)
      return vg(t);
  } catch {
  }
  return null;
}
function I0(r, e) {
  if (r === "0x")
    return null;
  try {
    const t = De(Ot(r, e, e + 32)), n = De(Ot(r, t, t + 32));
    return Ot(r, t + 32, t + 32 + n);
  } catch {
  }
  return null;
}
function UC(r) {
  const e = qt(r);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function PJ(r) {
  if (r.length % 32 === 0)
    return r;
  const e = new Uint8Array(Math.ceil(r.length / 32) * 32);
  return e.set(r), e;
}
const RJ = new Uint8Array([]);
function DJ(r) {
  const e = [];
  let t = 0;
  for (let n = 0; n < r.length; n++)
    e.push(RJ), t += 32;
  for (let n = 0; n < r.length; n++) {
    const s = Le(r[n]);
    e[n] = UC(t), e.push(UC(s.length)), e.push(PJ(s)), t += 32 + Math.ceil(s.length / 32) * 32;
  }
  return Pt(e);
}
const BC = "0x0000000000000000000000000000000000000000000000000000000000000000";
function kJ(r) {
  const e = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  z(Il(r) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const t = Ot(r, 0, 32);
  z(Ot(t, 0, 12) === Ot(BC, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), e.sender = Ot(t, 12);
  try {
    const n = [], s = De(Ot(r, 32, 64)), i = De(Ot(r, s, s + 32)), o = Ot(r, s + 32);
    for (let a = 0; a < i; a++) {
      const c = OJ(o, a * 32);
      if (c == null)
        throw new Error("abort");
      n.push(c);
    }
    e.urls = n;
  } catch {
    z(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const n = I0(r, 64);
    if (n == null)
      throw new Error("abort");
    e.calldata = n;
  } catch {
    z(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  z(Ot(r, 100, 128) === Ot(BC, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), e.selector = Ot(r, 96, 100);
  try {
    const n = I0(r, 128);
    if (n == null)
      throw new Error("abort");
    e.extraData = n;
  } catch {
    z(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((n) => e[n]), e;
}
function ha(r, e) {
  if (r.provider)
    return r.provider;
  z(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
}
async function LC(r, e) {
  let t = Pg(e);
  if (t.to != null && (t.to = Br(t.to, r)), t.from != null) {
    const n = t.from;
    t.from = Promise.all([
      r.getAddress(),
      Br(n, r)
    ]).then(([s, i]) => (D(s.toLowerCase() === i.toLowerCase(), "transaction from mismatch", "tx.from", i), s));
  } else
    t.from = r.getAddress();
  return await Dr(t);
}
class UJ {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(e) {
    /**
     *  The provider this signer is connected to.
     */
    F(this, "provider");
    Ae(this, { provider: e || null });
  }
  async getNonce(e) {
    return ha(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e);
  }
  async populateCall(e) {
    return await LC(this, e);
  }
  async populateTransaction(e) {
    const t = ha(this, "populateTransaction"), n = await LC(this, e);
    n.nonce == null && (n.nonce = await this.getNonce("pending")), n.gasLimit == null && (n.gasLimit = await this.estimateGas(n));
    const s = await this.provider.getNetwork();
    if (n.chainId != null) {
      const o = ge(n.chainId);
      D(o === s.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId);
    } else
      n.chainId = s.chainId;
    const i = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null;
    if (n.gasPrice != null && (n.type === 2 || i) ? D(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (n.type === 0 || n.type === 1) && i && D(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (n.type === 2 || n.type == null) && n.maxFeePerGas != null && n.maxPriorityFeePerGas != null)
      n.type = 2;
    else if (n.type === 0 || n.type === 1) {
      const o = await t.getFeeData();
      z(o.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), n.gasPrice == null && (n.gasPrice = o.gasPrice);
    } else {
      const o = await t.getFeeData();
      if (n.type == null)
        if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
          if (n.authorizationList && n.authorizationList.length ? n.type = 4 : n.type = 2, n.gasPrice != null) {
            const a = n.gasPrice;
            delete n.gasPrice, n.maxFeePerGas = a, n.maxPriorityFeePerGas = a;
          } else
            n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
        else o.gasPrice != null ? (z(!i, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
          operation: "populateTransaction"
        }), n.gasPrice == null && (n.gasPrice = o.gasPrice), n.type = 0) : z(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
          operation: "signer.getFeeData"
        });
      else (n.type === 2 || n.type === 3 || n.type === 4) && (n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas));
    }
    return await Dr(n);
  }
  async populateAuthorization(e) {
    const t = Object.assign({}, e);
    return t.chainId == null && (t.chainId = (await ha(this, "getNetwork").getNetwork()).chainId), t.nonce == null && (t.nonce = await this.getNonce()), t;
  }
  async estimateGas(e) {
    return ha(this, "estimateGas").estimateGas(await this.populateCall(e));
  }
  async call(e) {
    return ha(this, "call").call(await this.populateCall(e));
  }
  async resolveName(e) {
    return await ha(this, "resolveName").resolveName(e);
  }
  async sendTransaction(e) {
    const t = ha(this, "sendTransaction"), n = await this.populateTransaction(e);
    delete n.from;
    const s = _g.from(n);
    return await t.broadcastTransaction(await this.signTransaction(s));
  }
  // @TODO: in v7 move this to be abstract
  authorize(e) {
    z(!1, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}
function BJ(r) {
  return JSON.parse(JSON.stringify(r));
}
var Pr, $s, Ya, Uo, Qa, gu, Xo, S0, N0;
class NT {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(e) {
    M(this, Xo);
    M(this, Pr);
    M(this, $s);
    M(this, Ya);
    M(this, Uo);
    M(this, Qa);
    M(this, gu);
    S(this, Pr, e), S(this, $s, null), S(this, Ya, V(this, Xo, S0).bind(this)), S(this, Uo, !1), S(this, Qa, null), S(this, gu, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(e, t) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(e) {
    throw new Error("subclasses must override this");
  }
  start() {
    m(this, Uo) || (S(this, Uo, !0), V(this, Xo, S0).call(this, -2));
  }
  stop() {
    m(this, Uo) && (S(this, Uo, !1), S(this, gu, !0), V(this, Xo, N0).call(this), m(this, Pr).off("block", m(this, Ya)));
  }
  pause(e) {
    e && V(this, Xo, N0).call(this), m(this, Pr).off("block", m(this, Ya));
  }
  resume() {
    this.start();
  }
}
Pr = new WeakMap(), $s = new WeakMap(), Ya = new WeakMap(), Uo = new WeakMap(), Qa = new WeakMap(), gu = new WeakMap(), Xo = new WeakSet(), S0 = async function(e) {
  try {
    m(this, $s) == null && S(this, $s, this._subscribe(m(this, Pr)));
    let t = null;
    try {
      t = await m(this, $s);
    } catch (i) {
      if (!hr(i, "UNSUPPORTED_OPERATION") || i.operation !== "eth_newFilter")
        throw i;
    }
    if (t == null) {
      S(this, $s, null), m(this, Pr)._recoverSubscriber(this, this._recover(m(this, Pr)));
      return;
    }
    const n = await m(this, Pr).getNetwork();
    if (m(this, Qa) || S(this, Qa, n), m(this, Qa).chainId !== n.chainId)
      throw new Error("chaid changed");
    if (m(this, gu))
      return;
    const s = await m(this, Pr).send("eth_getFilterChanges", [t]);
    await this._emitResults(m(this, Pr), s);
  } catch (t) {
    console.log("@TODO", t);
  }
  m(this, Pr).once("block", m(this, Ya));
}, N0 = function() {
  const e = m(this, $s);
  e && (S(this, $s, null), e.then((t) => {
    m(this, Pr).destroyed || m(this, Pr).send("eth_uninstallFilter", [t]);
  }));
};
var Za;
class LJ extends NT {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(t, n) {
    super(t);
    M(this, Za);
    S(this, Za, BJ(n));
  }
  _recover(t) {
    return new zb(t, m(this, Za));
  }
  async _subscribe(t) {
    return await t.send("eth_newFilter", [m(this, Za)]);
  }
  async _emitResults(t, n) {
    for (const s of n)
      t.emit(m(this, Za), t._wrapLog(s, t._network));
  }
}
Za = new WeakMap();
class FJ extends NT {
  async _subscribe(e) {
    return await e.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(e, t) {
    for (const n of t)
      e.emit("pending", n);
  }
}
const $J = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Wp(r) {
  if (r == null || $J.indexOf(typeof r) >= 0 || typeof r.getAddress == "function")
    return r;
  if (Array.isArray(r))
    return r.map(Wp);
  if (typeof r == "object")
    return Object.keys(r).reduce((e, t) => (e[t] = r[t], e), {});
  throw new Error(`should not happen: ${r} (${typeof r})`);
}
function MJ(r) {
  return new Promise((e) => {
    setTimeout(e, r);
  });
}
function nl(r) {
  return r && r.toLowerCase();
}
function FC(r) {
  return r && typeof r.pollingInterval == "number";
}
const TT = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class Ol extends UJ {
  constructor(t, n) {
    super(t);
    F(this, "address");
    n = it(n), Ae(this, { address: n });
  }
  connect(t) {
    z(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(t) {
    return await this.populateCall(t);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(t) {
    const n = Wp(t), s = [];
    if (n.from) {
      const o = n.from;
      s.push((async () => {
        const a = await Br(o, this.provider);
        D(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", t), n.from = a;
      })());
    } else
      n.from = this.address;
    if (n.gasLimit == null && s.push((async () => {
      n.gasLimit = await this.provider.estimateGas({ ...n, from: this.address });
    })()), n.to != null) {
      const o = n.to;
      s.push((async () => {
        n.to = await Br(o, this.provider);
      })());
    }
    s.length && await Promise.all(s);
    const i = this.provider.getRpcTransaction(n);
    return this.provider.send("eth_sendTransaction", [i]);
  }
  async sendTransaction(t) {
    const n = await this.provider.getBlockNumber(), s = await this.sendUncheckedTransaction(t);
    return await new Promise((i, o) => {
      const a = [1e3, 100];
      let c = 0;
      const l = async () => {
        try {
          const u = await this.provider.getTransaction(s);
          if (u != null) {
            i(u.replaceableTransaction(n));
            return;
          }
        } catch (u) {
          if (hr(u, "CANCELLED") || hr(u, "BAD_DATA") || hr(u, "NETWORK_ERROR") || hr(u, "UNSUPPORTED_OPERATION")) {
            u.info == null && (u.info = {}), u.info.sendTransactionHash = s, o(u);
            return;
          }
          if (hr(u, "INVALID_ARGUMENT") && (c++, u.info == null && (u.info = {}), u.info.sendTransactionHash = s, c > 10)) {
            o(u);
            return;
          }
          this.provider.emit("error", St("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: u }));
        }
        this.provider._setTimeout(() => {
          l();
        }, a.pop() || 4e3);
      };
      l();
    });
  }
  async signTransaction(t) {
    const n = Wp(t);
    if (n.from) {
      const i = await Br(n.from, this.provider);
      D(i != null && i.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", t), n.from = i;
    } else
      n.from = this.address;
    const s = this.provider.getRpcTransaction(n);
    return await this.provider.send("eth_signTransaction", [s]);
  }
  async signMessage(t) {
    const n = typeof t == "string" ? Zs(t) : t;
    return await this.provider.send("personal_sign", [
      se(n),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(t, n, s) {
    const i = Wp(s), o = await Og.resolveNames(t, n, i, async (a) => {
      const c = await Br(a);
      return D(c != null, "TypedData does not support null address", "value", a), c;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(Og.getPayload(o.domain, n, o.value))
    ]);
  }
  async unlock(t) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      t,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(t) {
    const n = typeof t == "string" ? Zs(t) : t;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      se(n)
    ]);
  }
}
var Xa, mu, Ti, Ms, ls, jn, Qr, df, T0;
class jJ extends xJ {
  constructor(t, n) {
    super(t, n);
    M(this, df);
    M(this, Xa);
    // The next ID to use for the JSON-RPC ID field
    M(this, mu);
    // Payloads are queued and triggered in batches using the drainTimer
    M(this, Ti);
    M(this, Ms);
    M(this, ls);
    M(this, jn);
    M(this, Qr);
    S(this, mu, 1), S(this, Xa, Object.assign({}, TT, n || {})), S(this, Ti, []), S(this, Ms, null), S(this, jn, null), S(this, Qr, null);
    {
      let i = null;
      const o = new Promise((a) => {
        i = a;
      });
      S(this, ls, { promise: o, resolve: i });
    }
    const s = this._getOption("staticNetwork");
    typeof s == "boolean" ? (D(!s || t !== "any", "staticNetwork cannot be used on special network 'any'", "options", n), s && t != null && S(this, jn, Gs.from(t))) : s && (D(t == null || s.matches(t), "staticNetwork MUST match network object", "options", n), S(this, jn, s));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(t) {
    return m(this, Xa)[t];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return z(m(this, jn), "network is not available yet", "NETWORK_ERROR"), m(this, jn);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(t) {
    if (t.method === "call" || t.method === "estimateGas") {
      let s = t.transaction;
      if (s && s.type != null && ge(s.type) && s.maxFeePerGas == null && s.maxPriorityFeePerGas == null) {
        const i = await this.getFeeData();
        i.maxFeePerGas == null && i.maxPriorityFeePerGas == null && (t = Object.assign({}, t, {
          transaction: Object.assign({}, s, { type: void 0 })
        }));
      }
    }
    const n = this.getRpcRequest(t);
    return n != null ? await this.send(n.method, n.args) : super._perform(t);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const t = this._getOption("staticNetwork");
    if (t)
      if (t === !0) {
        if (m(this, jn))
          return m(this, jn);
      } else
        return t;
    return m(this, Qr) ? await m(this, Qr) : this.ready ? (S(this, Qr, (async () => {
      try {
        const n = Gs.from(ge(await this.send("eth_chainId", [])));
        return S(this, Qr, null), n;
      } catch (n) {
        throw S(this, Qr, null), n;
      }
    })()), await m(this, Qr)) : (S(this, Qr, (async () => {
      const n = {
        id: Ju(this, mu)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: n });
      let s;
      try {
        s = (await this._send(n))[0], S(this, Qr, null);
      } catch (i) {
        throw S(this, Qr, null), this.emit("debug", { action: "receiveRpcError", error: i }), i;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: s }), "result" in s)
        return Gs.from(ge(s.result));
      throw this.getRpcError(n, s);
    })()), await m(this, Qr));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    m(this, ls) == null || m(this, ls).resolve == null || (m(this, ls).resolve(), S(this, ls, null), (async () => {
      for (; m(this, jn) == null && !this.destroyed; )
        try {
          S(this, jn, await this._detectNetwork());
        } catch (t) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", St("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: t } })), await MJ(1e3);
        }
      V(this, df, T0).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (m(this, ls) != null)
      return await m(this, ls).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(t) {
    return t.type === "pending" ? new FJ(this) : t.type === "event" ? this._getOption("polling") ? new zb(this, t.filter) : new LJ(this, t.filter) : t.type === "orphan" && t.filter.orphan === "drop-log" ? new ST("orphan") : super._getSubscriber(t);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return m(this, ls) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(t) {
    const n = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((s) => {
      if (t[s] == null)
        return;
      let i = s;
      s === "gasLimit" && (i = "gas"), n[i] = hs(ge(t[s], `tx.${s}`));
    }), ["from", "to", "data"].forEach((s) => {
      t[s] != null && (n[s] = se(t[s]));
    }), t.accessList && (n.accessList = Rc(t.accessList)), t.blobVersionedHashes && (n.blobVersionedHashes = t.blobVersionedHashes.map((s) => s.toLowerCase())), t.authorizationList && (n.authorizationList = t.authorizationList.map((s) => {
      const i = ON(s);
      return {
        address: i.address,
        nonce: hs(i.nonce),
        chainId: hs(i.chainId),
        yParity: hs(i.signature.yParity),
        r: hs(i.signature.r),
        s: hs(i.signature.s)
      };
    })), n;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(t) {
    switch (t.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [nl(t.address), t.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [nl(t.address), t.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [nl(t.address), t.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            nl(t.address),
            "0x" + t.position.toString(16),
            t.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [t.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in t)
          return {
            method: "eth_getBlockByNumber",
            args: [t.blockTag, !!t.includeTransactions]
          };
        if ("blockHash" in t)
          return {
            method: "eth_getBlockByHash",
            args: [t.blockHash, !!t.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [t.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [t.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(t.transaction), t.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(t.transaction)]
        };
      case "getLogs":
        return t.filter && t.filter.address != null && (Array.isArray(t.filter.address) ? t.filter.address = t.filter.address.map(nl) : t.filter.address = nl(t.filter.address)), { method: "eth_getLogs", args: [t.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(t, n) {
    const { method: s } = t, { error: i } = n;
    if (s === "eth_estimateGas" && i.message) {
      const c = i.message;
      if (!c.match(/revert/i) && c.match(/insufficient funds/i))
        return St("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: t.params[0],
          info: { payload: t, error: i }
        });
      if (c.match(/nonce/i) && c.match(/too low/i))
        return St("nonce has already been used", "NONCE_EXPIRED", {
          transaction: t.params[0],
          info: { payload: t, error: i }
        });
    }
    if (s === "eth_call" || s === "eth_estimateGas") {
      const c = x0(i), l = Qd.getBuiltinCallException(s === "eth_call" ? "call" : "estimateGas", t.params[0], c ? c.data : null);
      return l.info = { error: i, payload: t }, l;
    }
    const o = JSON.stringify(zJ(i));
    if (typeof i.message == "string" && i.message.match(/user denied|ethers-user-denied/i))
      return St("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[s] || "unknown",
        reason: "rejected",
        info: { payload: t, error: i }
      });
    if (s === "eth_sendRawTransaction" || s === "eth_sendTransaction") {
      const c = t.params[0];
      if (o.match(/insufficient funds|base fee exceeds gas limit/i))
        return St("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: c,
          info: { error: i }
        });
      if (o.match(/nonce/i) && o.match(/too low/i))
        return St("nonce has already been used", "NONCE_EXPIRED", { transaction: c, info: { error: i } });
      if (o.match(/replacement transaction/i) && o.match(/underpriced/i))
        return St("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: c, info: { error: i } });
      if (o.match(/only replay-protected/i))
        return St("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: s,
          info: { transaction: c, info: { error: i } }
        });
    }
    let a = !!o.match(/the method .* does not exist/i);
    return a || i && i.details && i.details.startsWith("Unauthorized method:") && (a = !0), a ? St("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: t.method,
      info: { error: i, payload: t }
    }) : St("could not coalesce error", "UNKNOWN_ERROR", { error: i, payload: t });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(t, n) {
    if (this.destroyed)
      return Promise.reject(St("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: t }));
    const s = Ju(this, mu)._++, i = new Promise((o, a) => {
      m(this, Ti).push({
        resolve: o,
        reject: a,
        payload: { method: t, params: n, id: s, jsonrpc: "2.0" }
      });
    });
    return V(this, df, T0).call(this), i;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(t) {
    t == null && (t = 0);
    const n = this.send("eth_accounts", []);
    if (typeof t == "number") {
      const i = await n;
      if (t >= i.length)
        throw new Error("no such account");
      return new Ol(this, i[t]);
    }
    const { accounts: s } = await Dr({
      network: this.getNetwork(),
      accounts: n
    });
    t = it(t);
    for (const i of s)
      if (it(i) === t)
        return new Ol(this, t);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((n) => new Ol(this, n));
  }
  destroy() {
    m(this, Ms) && (clearTimeout(m(this, Ms)), S(this, Ms, null));
    for (const { payload: t, reject: n } of m(this, Ti))
      n(St("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: t.method }));
    S(this, Ti, []), super.destroy();
  }
}
Xa = new WeakMap(), mu = new WeakMap(), Ti = new WeakMap(), Ms = new WeakMap(), ls = new WeakMap(), jn = new WeakMap(), Qr = new WeakMap(), df = new WeakSet(), T0 = function() {
  if (m(this, Ms))
    return;
  const t = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  S(this, Ms, setTimeout(() => {
    S(this, Ms, null);
    const n = m(this, Ti);
    for (S(this, Ti, []); n.length; ) {
      const s = [n.shift()];
      for (; n.length && s.length !== m(this, Xa).batchMaxCount; )
        if (s.push(n.shift()), JSON.stringify(s.map((o) => o.payload)).length > m(this, Xa).batchMaxSize) {
          n.unshift(s.pop());
          break;
        }
      (async () => {
        const i = s.length === 1 ? s[0].payload : s.map((o) => o.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: i });
        try {
          const o = await this._send(i);
          this.emit("debug", { action: "receiveRpcResult", result: o });
          for (const { resolve: a, reject: c, payload: l } of s) {
            if (this.destroyed) {
              c(St("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: l.method }));
              continue;
            }
            const u = o.filter((h) => h.id === l.id)[0];
            if (u == null) {
              const h = St("missing response for request", "BAD_DATA", {
                value: o,
                info: { payload: l }
              });
              this.emit("error", h), c(h);
              continue;
            }
            if ("error" in u) {
              c(this.getRpcError(l, u));
              continue;
            }
            a(u.result);
          }
        } catch (o) {
          this.emit("debug", { action: "receiveRpcError", error: o });
          for (const { reject: a } of s)
            a(o);
        }
      })();
    }
  }, t));
};
var Bo;
class xT extends jJ {
  constructor(t, n) {
    super(t, n);
    M(this, Bo);
    let s = this._getOption("pollingInterval");
    s == null && (s = TT.pollingInterval), S(this, Bo, s);
  }
  _getSubscriber(t) {
    const n = super._getSubscriber(t);
    return FC(n) && (n.pollingInterval = m(this, Bo)), n;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return m(this, Bo);
  }
  set pollingInterval(t) {
    if (!Number.isInteger(t) || t < 0)
      throw new Error("invalid interval");
    S(this, Bo, t), this._forEachSubscriber((n) => {
      FC(n) && (n.pollingInterval = m(this, Bo));
    });
  }
}
Bo = new WeakMap();
var wu;
class HJ extends xT {
  constructor(t, n, s) {
    t == null && (t = "http://localhost:8545");
    super(n, s);
    M(this, wu);
    typeof t == "string" ? S(this, wu, new zi(t)) : S(this, wu, t.clone());
  }
  _getConnection() {
    return m(this, wu).clone();
  }
  async send(t, n) {
    return await this._start(), await super.send(t, n);
  }
  async _send(t) {
    const n = this._getConnection();
    n.body = JSON.stringify(t), n.setHeader("content-type", "application/json");
    const s = await n.send();
    s.assertOk();
    let i = s.bodyJson;
    return Array.isArray(i) || (i = [i]), i;
  }
}
wu = new WeakMap();
function x0(r) {
  if (r == null)
    return null;
  if (typeof r.message == "string" && r.message.match(/revert/i) && wt(r.data))
    return { message: r.message, data: r.data };
  if (typeof r == "object") {
    for (const e in r) {
      const t = x0(r[e]);
      if (t)
        return t;
    }
    return null;
  }
  if (typeof r == "string")
    try {
      return x0(JSON.parse(r));
    } catch {
    }
  return null;
}
function O0(r, e) {
  if (r != null) {
    if (typeof r.message == "string" && e.push(r.message), typeof r == "object")
      for (const t in r)
        O0(r[t], e);
    if (typeof r == "string")
      try {
        return O0(JSON.parse(r), e);
      } catch {
      }
  }
}
function zJ(r) {
  const e = [];
  return O0(r, e), e;
}
var yu, bu;
const _a = class _a extends xT {
  /**
   *  Connect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(t, n, s) {
    const i = Object.assign({}, s ?? {}, { batchMaxCount: 1 });
    D(t && t.request, "invalid EIP-1193 provider", "ethereum", t);
    super(n, i);
    M(this, yu);
    M(this, bu);
    S(this, bu, null), s && s.providerInfo && S(this, bu, s.providerInfo), S(this, yu, async (o, a) => {
      const c = { method: o, params: a };
      this.emit("debug", { action: "sendEip1193Request", payload: c });
      try {
        const l = await t.request(c);
        return this.emit("debug", { action: "receiveEip1193Result", result: l }), l;
      } catch (l) {
        const u = new Error(l.message);
        throw u.code = l.code, u.data = l.data, u.payload = c, this.emit("debug", { action: "receiveEip1193Error", error: u }), u;
      }
    });
  }
  get providerInfo() {
    return m(this, bu);
  }
  async send(t, n) {
    return await this._start(), await super.send(t, n);
  }
  async _send(t) {
    D(!Array.isArray(t), "EIP-1193 does not support batch request", "payload", t);
    try {
      const n = await m(this, yu).call(this, t.method, t.params || []);
      return [{ id: t.id, result: n }];
    } catch (n) {
      return [{
        id: t.id,
        error: { code: n.code, data: n.data, message: n.message }
      }];
    }
  }
  getRpcError(t, n) {
    switch (n = JSON.parse(JSON.stringify(n)), n.error.code || -1) {
      case 4001:
        n.error.message = `ethers-user-denied: ${n.error.message}`;
        break;
      case 4200:
        n.error.message = `ethers-unsupported: ${n.error.message}`;
        break;
    }
    return super.getRpcError(t, n);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(t) {
    t == null && (t = 0);
    const n = await this.send("eth_accounts", []);
    return typeof t == "number" ? n.length > t : (t = t.toLowerCase(), n.filter((s) => s.toLowerCase() === t).length !== 0);
  }
  async getSigner(t) {
    if (t == null && (t = 0), !await this.hasSigner(t))
      try {
        await m(this, yu).call(this, "eth_requestAccounts", []);
      } catch (n) {
        const s = n.payload;
        throw this.getRpcError(s, { id: s.id, error: n });
      }
    return await super.getSigner(t);
  }
  /**
   *  Discover and connect to a Provider in the Browser using the
   *  [[link-eip-6963]] discovery mechanism. If no providers are
   *  present, ``null`` is resolved.
   */
  static async discover(t) {
    if (t == null && (t = {}), t.provider)
      return new _a(t.provider);
    const n = t.window ? t.window : typeof window < "u" ? window : null;
    if (n == null)
      return null;
    const s = t.anyProvider;
    if (s && n.ethereum)
      return new _a(n.ethereum);
    if (!("addEventListener" in n && "dispatchEvent" in n && "removeEventListener" in n))
      return null;
    const i = t.timeout ? t.timeout : 300;
    return i === 0 ? null : await new Promise((o, a) => {
      let c = [];
      const l = (d) => {
        c.push(d.detail), s && u();
      }, u = () => {
        if (clearTimeout(h), c.length)
          if (t && t.filter) {
            const d = t.filter(c.map((f) => Object.assign({}, f.info)));
            if (d == null)
              o(null);
            else if (d instanceof _a)
              o(d);
            else {
              let f = null;
              if (d.uuid && (f = c.filter((p) => d.uuid === p.info.uuid)[0]), f) {
                const { provider: g, info: p } = f;
                o(new _a(g, void 0, {
                  providerInfo: p
                }));
              } else
                a(St("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                  value: d
                }));
            }
          } else {
            const { provider: d, info: f } = c[0];
            o(new _a(d, void 0, {
              providerInfo: f
            }));
          }
        else
          o(null);
        n.removeEventListener("eip6963:announceProvider", l);
      }, h = setTimeout(() => {
        u();
      }, i);
      n.addEventListener("eip6963:announceProvider", l), n.dispatchEvent(new Event("eip6963:requestProvider"));
    });
  }
};
yu = new WeakMap(), bu = new WeakMap();
let Kh = _a;
const Pl = {
  hexStringToNumber(r) {
    const e = r.startsWith("0x") ? r.slice(2) : r;
    return parseInt(e, 16);
  },
  numberToHexString(r) {
    return `0x${r.toString(16)}`;
  },
  async getUserInfo(r) {
    const [e, t] = await Promise.all([
      Pl.getAddresses(r),
      Pl.getChainId(r)
    ]);
    return { chainId: t, addresses: e };
  },
  async getChainId(r) {
    const e = await r.request({ method: "eth_chainId" });
    return Number(e);
  },
  async getAddress(r) {
    const [e] = await r.request({ method: "eth_accounts" });
    return e;
  },
  async getAddresses(r) {
    return await r.request({ method: "eth_accounts" });
  },
  async addEthereumChain(r, e) {
    var n, s;
    const t = ((n = e.rpcUrls.chainDefault) == null ? void 0 : n.http) || [];
    await r.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: Pl.numberToHexString(e.id),
          rpcUrls: [...t],
          chainName: e.name,
          nativeCurrency: {
            name: e.nativeCurrency.name,
            decimals: e.nativeCurrency.decimals,
            symbol: e.nativeCurrency.symbol
          },
          blockExplorerUrls: [(s = e.blockExplorers) == null ? void 0 : s.default.url],
          iconUrls: [qs.NetworkImageIds[e.id]]
        }
      ]
    });
  }
}, da = {
  signMessage: async (r, e, t) => {
    if (!e)
      throw new Error("signMessage - provider is undefined");
    const n = wt(r) ? r : se(Zs(r));
    return await e.request({
      method: "personal_sign",
      params: [n, t]
    });
  },
  estimateGas: async (r, e, t, n) => {
    if (!e)
      throw new Error("estimateGas - provider is undefined");
    if (!t)
      throw new Error("estimateGas - address is undefined");
    if (r.chainNamespace && r.chainNamespace !== "eip155")
      throw new Error("estimateGas - chainNamespace is not eip155");
    const s = {
      from: r.address,
      to: r.to,
      data: r.data,
      type: 0
    }, i = new Kh(e, n);
    return await new Ol(i, t).estimateGas(s);
  },
  sendTransaction: async (r, e, t, n) => {
    if (!e)
      throw new Error("sendTransaction - provider is undefined");
    if (!t)
      throw new Error("sendTransaction - address is undefined");
    if (r.chainNamespace && r.chainNamespace !== "eip155")
      throw new Error("sendTransaction - chainNamespace is not eip155");
    const s = {
      to: r.to,
      value: r.value,
      gasLimit: r.gas,
      gasPrice: r.gasPrice,
      data: r.data,
      type: 0
    }, i = new Kh(e, n), c = await (await new Ol(i, t).sendTransaction(s)).wait();
    return (c == null ? void 0 : c.hash) || null;
  },
  writeContract: async (r, e, t, n) => {
    if (!e)
      throw new Error("writeContract - provider is undefined");
    if (!t)
      throw new Error("writeContract - address is undefined");
    const s = new Kh(e, n), i = new Ol(s, t), o = new xl(r.tokenAddress, r.abi, i);
    if (!o || !r.method)
      throw new Error("Contract method is undefined");
    const a = o[r.method];
    if (a)
      return await a(...r.args);
    throw new Error("Contract method is undefined");
  },
  parseWalletCapabilities: (r) => {
    try {
      return JSON.parse(r);
    } catch {
      throw new Error("Error parsing wallet capabilities");
    }
  },
  parseUnits: OW,
  formatUnits: KS
};
class nQ extends kS {
  constructor() {
    super({
      adapterType: W.ADAPTER_TYPES.ETHERS,
      namespace: W.CHAIN.EVM
    }), this.balancePromises = {}, this.providerHandlers = null;
  }
  async createEthersConfig(e) {
    if (!e.metadata)
      return;
    let t;
    function n() {
      if (t)
        return t;
      if (!(typeof window > "u") && window.ethereum)
        return t = window.ethereum, t;
    }
    async function s() {
      const { SafeProvider: a } = await import("./SafeProvider-D7jlQNWj.mjs"), { default: c } = await import("./index-LCw1T0iy.mjs").then((d) => d.e), l = new c(), u = await l.safe.getInfo(), h = new a(u, l);
      return await h.connect().catch((d) => {
        console.info("Failed to auto-connect to Safe:", d);
      }), h;
    }
    async function i() {
      var a, c, l;
      try {
        const { createCoinbaseWalletSDK: u } = await import("./index-D00BC2T4.mjs");
        return typeof window > "u" ? void 0 : u({
          appName: (a = e == null ? void 0 : e.metadata) == null ? void 0 : a.name,
          appLogoUrl: (c = e == null ? void 0 : e.metadata) == null ? void 0 : c.icons[0],
          appChainIds: ((l = e.networks) == null ? void 0 : l.map((d) => d.id)) || [1, 84532],
          preference: {
            options: e.coinbasePreference ?? "all"
          }
        }).getProvider();
      } catch (u) {
        console.error("Failed to import Coinbase Wallet SDK:", u);
        return;
      }
    }
    const o = { metadata: e.metadata };
    if (e.enableInjected !== !1 && (o.injected = n()), e.enableCoinbase !== !1) {
      const a = await i();
      a && (o.coinbase = a);
    }
    if (me.isSafeApp()) {
      const a = await s();
      a && (o.safe = a);
    }
    return o.EIP6963 = e.enableEIP6963 !== !1, o;
  }
  async signMessage(e) {
    const { message: t, address: n, provider: s } = e;
    if (!s)
      throw new Error("Provider is undefined");
    try {
      return { signature: await da.signMessage(t, s, n) };
    } catch {
      throw new Error("EthersAdapter:signMessage - Sign message failed");
    }
  }
  async sendTransaction(e) {
    var n;
    if (!e.provider)
      throw new Error("Provider is undefined");
    return { hash: await da.sendTransaction({
      value: Number.isNaN(Number(e.value)) ? BigInt(0) : BigInt(e.value),
      to: e.to,
      data: e.data ? e.data : "0x",
      gas: e.gas ? BigInt(e.gas) : void 0,
      gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
      address: X.state.address
    }, e.provider, X.state.address, Number((n = e.caipNetwork) == null ? void 0 : n.id)) };
  }
  async writeContract(e) {
    var s;
    if (!e.provider)
      throw new Error("Provider is undefined");
    const { address: t } = tn.parseCaipAddress(e.caipAddress);
    return { hash: await da.writeContract(e, e.provider, t, Number((s = e.caipNetwork) == null ? void 0 : s.id)) };
  }
  async estimateGas(e) {
    const { provider: t, caipNetwork: n, address: s } = e;
    if (!t)
      throw new Error("Provider is undefined");
    try {
      return { gas: await da.estimateGas({
        data: e.data,
        to: e.to,
        address: s
      }, t, s, Number(n == null ? void 0 : n.id)) };
    } catch {
      throw new Error("EthersAdapter:estimateGas - Estimate gas failed");
    }
  }
  parseUnits(e) {
    return da.parseUnits(e.value, e.decimals);
  }
  formatUnits(e) {
    return da.formatUnits(e.value, e.decimals);
  }
  async syncConnection(e) {
    const { id: t, chainId: n } = e, s = this.connectors.find((c) => c.id === t), i = s == null ? void 0 : s.provider;
    if (!i)
      throw new Error("Provider not found");
    const o = await i.request({
      method: "eth_requestAccounts"
    }), a = await i.request({
      method: "eth_chainId"
    });
    if (this.listenProviderEvents(i), !o[0])
      throw new Error("No accounts found");
    if (!(s != null && s.type))
      throw new Error("Connector type not found");
    return {
      address: o[0],
      chainId: Number(a) || Number(n),
      provider: i,
      type: s.type,
      id: t
    };
  }
  async syncConnectors(e) {
    var n;
    this.ethersConfig = await this.createEthersConfig(e), (n = this.ethersConfig) != null && n.EIP6963 && this.listenInjectedConnector(!0), Object.keys(this.ethersConfig || {}).filter((s) => s !== "metadata" && s !== "EIP6963").forEach((s) => {
      var a, c;
      const i = s === "coinbase" ? "coinbaseWalletSDK" : s, o = s === W.CONNECTOR_ID.INJECTED;
      this.namespace && this.addConnector({
        id: i,
        explorerId: qs.ConnectorExplorerIds[i],
        imageUrl: (a = e == null ? void 0 : e.connectorImages) == null ? void 0 : a[i],
        name: qs.ConnectorNamesMap[i] || "Unknown",
        imageId: qs.ConnectorImageIds[i],
        type: qs.ConnectorTypesMap[i] ?? "EXTERNAL",
        info: o ? void 0 : { rdns: i },
        chain: this.namespace,
        chains: [],
        provider: (c = this.ethersConfig) == null ? void 0 : c[s]
      });
    });
  }
  setUniversalProvider(e) {
    this.addConnector(new _b({
      provider: e,
      caipNetworks: this.getCaipNetworks(),
      namespace: "eip155"
    }));
  }
  eip6963EventHandler(e) {
    var t;
    if (e.detail) {
      const { info: n, provider: s } = e.detail;
      if (!((t = this.connectors) == null ? void 0 : t.find((o) => o.name === (n == null ? void 0 : n.name)))) {
        const o = qs.ConnectorTypesMap[W.CONNECTOR_ID.EIP6963], a = (n == null ? void 0 : n.rdns) || (n == null ? void 0 : n.name) || (n == null ? void 0 : n.uuid);
        this.namespace && a && this.addConnector({
          id: a,
          type: o,
          imageUrl: n == null ? void 0 : n.icon,
          name: (n == null ? void 0 : n.name) || "Unknown",
          provider: s,
          info: n,
          chain: this.namespace,
          chains: []
        });
      }
    }
  }
  listenInjectedConnector(e) {
    if (typeof window < "u" && e) {
      const t = this.eip6963EventHandler.bind(this);
      window.addEventListener(ft.EIP6963_ANNOUNCE_EVENT, t), window.dispatchEvent(new Event(ft.EIP6963_REQUEST_EVENT));
    }
  }
  async connect({ id: e, type: t, chainId: n, socialUri: s }) {
    var l;
    const i = this.connectors.find((u) => u.id === e), o = i == null ? void 0 : i.provider;
    if (!o)
      throw new Error("Provider not found");
    let a = [], c;
    if (t === ft.CONNECTOR_TYPE_AUTH) {
      const { address: u } = await o.connect({
        chainId: n,
        socialUri: s,
        preferredAccountType: (l = X.state.preferredAccountTypes) == null ? void 0 : l.eip155
      });
      a = [u], this.emit("accountChanged", {
        address: a[0],
        chainId: Number(n)
      });
    } else {
      if (a = await o.request({
        method: "eth_requestAccounts"
      }), c = await o.request({
        method: "eth_chainId"
      }), c !== n) {
        const u = this.getCaipNetworks().find((h) => h.id === n);
        if (!u)
          throw new Error("EthersAdapter:connect - could not find the caipNetwork to switch");
        try {
          await this.switchNetwork({
            caipNetwork: u,
            provider: o,
            providerType: t
          });
        } catch {
          throw new Error("EthersAdapter:connect - Switch network failed");
        }
      }
      this.emit("accountChanged", {
        address: a[0],
        chainId: Number(n)
      }), this.listenProviderEvents(o);
    }
    return {
      address: a[0],
      chainId: Number(n),
      provider: o,
      type: t,
      id: e
    };
  }
  async reconnect(e) {
    var i;
    const { id: t, chainId: n } = e, s = this.connectors.find((o) => o.id === t);
    s && s.type === "AUTH" && n && await s.provider.connect({
      chainId: n,
      preferredAccountType: (i = X.state.preferredAccountTypes) == null ? void 0 : i.eip155
    });
  }
  async getAccounts(e) {
    const t = this.connectors.find((i) => i.id === e.id), n = t == null ? void 0 : t.provider;
    if (!n || !t)
      throw new Error("Provider not found");
    if (e.id === W.CONNECTOR_ID.AUTH) {
      const i = t.provider;
      if (!i.user)
        return { accounts: [] };
      const { accounts: o, address: a } = i.user;
      return Promise.resolve({
        accounts: (o || [{ address: a, type: "eoa" }]).map((c) => me.createAccount("eip155", c.address, c.type))
      });
    }
    return {
      accounts: (await n.request({
        method: "eth_requestAccounts"
      })).map((i) => me.createAccount("eip155", i, "eoa"))
    };
  }
  async disconnect(e) {
    if (!e.provider || !e.providerType)
      throw new Error("Provider or providerType not provided");
    switch (e.providerType) {
      case "WALLET_CONNECT":
        e.provider.session && e.provider.disconnect();
        break;
      case "AUTH":
        await e.provider.disconnect();
        break;
      case "ANNOUNCED":
      case "EXTERNAL":
        await this.revokeProviderPermissions(e.provider);
        break;
      default:
        throw new Error("Unsupported provider type");
    }
  }
  async getBalance(e) {
    const t = e.address, n = this.getCaipNetworks().find((s) => s.id === e.chainId);
    if (!t)
      return Promise.resolve({ balance: "0.00", symbol: "ETH" });
    if (n && n.chainNamespace === "eip155") {
      const s = `${n.caipNetworkId}:${t}`, i = this.balancePromises[s];
      if (i)
        return i;
      const o = te.getNativeBalanceCacheForCaipAddress(s);
      if (o)
        return { balance: o.balance, symbol: o.symbol };
      const a = new HJ(n.rpcUrls.default.http[0], {
        chainId: n.id,
        name: n.name
      });
      if (a)
        try {
          return this.balancePromises[s] = new Promise(async (c) => {
            const l = await a.getBalance(t), u = PW(l);
            te.updateNativeBalanceCache({
              caipAddress: s,
              balance: u,
              symbol: n.nativeCurrency.symbol,
              timestamp: Date.now()
            }), c({ balance: u, symbol: n.nativeCurrency.symbol });
          }).finally(() => {
            delete this.balancePromises[s];
          }), this.balancePromises[s] || { balance: "0.00", symbol: "ETH" };
        } catch {
          return { balance: "0.00", symbol: "ETH" };
        }
    }
    return { balance: "0.00", symbol: "ETH" };
  }
  listenProviderEvents(e) {
    const t = () => {
      this.removeProviderListeners(e), this.emit("disconnect");
    }, n = (i) => {
      i.length > 0 ? this.emit("accountChanged", {
        address: i[0]
      }) : t();
    }, s = (i) => {
      const o = typeof i == "string" ? Pl.hexStringToNumber(i) : Number(i);
      this.emit("switchNetwork", { chainId: o });
    };
    e.on("disconnect", t), e.on("accountsChanged", n), e.on("chainChanged", s), this.providerHandlers = {
      disconnect: t,
      accountsChanged: n,
      chainChanged: s
    };
  }
  removeProviderListeners(e) {
    this.providerHandlers && (e.removeListener("disconnect", this.providerHandlers.disconnect), e.removeListener("accountsChanged", this.providerHandlers.accountsChanged), e.removeListener("chainChanged", this.providerHandlers.chainChanged), this.providerHandlers = null);
  }
  async switchNetwork(e) {
    var i, o;
    const { caipNetwork: t, provider: n, providerType: s } = e;
    if (s === "AUTH") {
      await super.switchNetwork(e);
      return;
    }
    try {
      await n.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: Pl.numberToHexString(t.id) }]
      });
    } catch (a) {
      if (a.code === Di.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || a.code === Di.ERROR_INVALID_CHAIN_ID || a.code === Di.ERROR_CODE_DEFAULT || ((o = (i = a == null ? void 0 : a.data) == null ? void 0 : i.originalError) == null ? void 0 : o.code) === Di.ERROR_CODE_UNRECOGNIZED_CHAIN_ID)
        await Pl.addEthereumChain(n, t);
      else if (s === "ANNOUNCED" || s === "EXTERNAL" || s === "INJECTED")
        throw new Error("Chain is not supported");
    }
  }
  getWalletConnectProvider() {
    var e;
    return (e = this.connectors.find((t) => t.type === "WALLET_CONNECT")) == null ? void 0 : e.provider;
  }
  async revokeProviderPermissions(e) {
    try {
      (await e.request({
        method: "wallet_getPermissions"
      })).find((s) => s.parentCapability === "eth_accounts") && await e.request({
        method: "wallet_revokePermissions",
        params: [{ eth_accounts: {} }]
      });
    } catch (t) {
      console.info("Could not revoke permissions from wallet. Disconnecting...", t);
    }
  }
  async getCapabilities(e) {
    var s, i;
    const t = Ze.getProvider(W.CHAIN.EVM);
    if (!t)
      throw new Error("Provider is undefined");
    const n = (i = (s = t.session) == null ? void 0 : s.sessionProperties) == null ? void 0 : i.capabilities;
    if (n) {
      const a = da.parseWalletCapabilities(n)[e];
      if (a)
        return a;
    }
    return await t.request({ method: "wallet_getCapabilities", params: [e] });
  }
  async grantPermissions(e) {
    const t = Ze.getProvider(W.CHAIN.EVM);
    if (!t)
      throw new Error("Provider is undefined");
    return await t.request({ method: "wallet_grantPermissions", params: e });
  }
  async revokePermissions(e) {
    const t = Ze.getProvider(W.CHAIN.EVM);
    if (!t)
      throw new Error("Provider is undefined");
    return await t.request({ method: "wallet_revokePermissions", params: [e] });
  }
  async walletGetAssets(e) {
    const t = Ze.getProvider(W.CHAIN.EVM);
    if (!t)
      throw new Error("Provider is undefined");
    return await t.request({
      method: "wallet_getAssets",
      params: [e]
    });
  }
}
export {
  Sn as $,
  X as A,
  vs as B,
  re as C,
  _ as D,
  Uh as E,
  ct as F,
  ds as G,
  ZY as H,
  $x as I,
  Cn as J,
  ue as K,
  IO as L,
  nt as M,
  ft as N,
  K as O,
  Dq as P,
  Zr as Q,
  Ce as R,
  WJ as S,
  Xr as T,
  kq as U,
  te as V,
  rr as W,
  Rr as X,
  XT as Y,
  tt as Z,
  WC as _,
  ZC as a,
  _t as a0,
  ve as a1,
  Rx as a2,
  L0 as a3,
  GC as a4,
  Tr as a5,
  fr as a6,
  ye as a7,
  Jw as a8,
  Ah as a9,
  YJ as aA,
  Zx as aB,
  aO as aC,
  QJ as aD,
  tQ as aE,
  nQ as aF,
  eQ as aG,
  us as aa,
  tn as ab,
  nx as ac,
  Ze as ad,
  Rp as ae,
  Qh as af,
  Nd as ag,
  XY as ah,
  Gy as ai,
  qO as aj,
  Hh as ak,
  JY as al,
  Xt as am,
  YY as an,
  NS as ao,
  Ky as ap,
  Tu as aq,
  oO as ar,
  JJ as as,
  D0 as at,
  t_ as au,
  lE as av,
  vu as aw,
  Gp as ax,
  tY as ay,
  XJ as az,
  Lx as b,
  Hx as c,
  e_ as d,
  Vn as e,
  ec as f,
  qT as g,
  XC as h,
  Bx as i,
  js as j,
  c_ as k,
  rY as l,
  P0 as m,
  zx as n,
  ZJ as o,
  R0 as p,
  Cl as q,
  kp as r,
  oE as s,
  aE as t,
  Ri as u,
  at as v,
  QY as w,
  KY as x,
  W as y,
  me as z
};
