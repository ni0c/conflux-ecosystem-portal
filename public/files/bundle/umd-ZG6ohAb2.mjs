var CG = Object.defineProperty;
var AG = (r, e, t) => e in r ? CG(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var _e = (r, e, t) => (AG(r, typeof e != "symbol" ? e + "" : e, t), t), C5 = (r, e, t) => {
  if (!e.has(r))
    throw TypeError("Cannot " + t);
};
var j = (r, e, t) => (C5(r, e, "read from private field"), t ? t.call(r) : e.get(r)), ye = (r, e, t) => {
  if (e.has(r))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(r) : e.set(r, t);
}, ie = (r, e, t, n) => (C5(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t);
var S1 = (r, e, t, n) => ({
  set _(i) {
    ie(r, e, i, t);
  },
  get _() {
    return j(r, e, n);
  }
}), ke = (r, e, t) => (C5(r, e, "access private method"), t);
const IG = Symbol(), rR = Object.getPrototypeOf, x6 = /* @__PURE__ */ new WeakMap(), RG = (r) => r && (x6.has(r) ? x6.get(r) : rR(r) === Object.prototype || rR(r) === Array.prototype), TG = (r) => RG(r) && r[IG] || null, nR = (r, e = !0) => {
  x6.set(r, e);
};
var Jb = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const A5 = (r) => typeof r == "object" && r !== null, uu = /* @__PURE__ */ new WeakMap(), G1 = /* @__PURE__ */ new WeakSet(), OG = (r = Object.is, e = (u, f) => new Proxy(u, f), t = (u) => A5(u) && !G1.has(u) && (Array.isArray(u) || !(Symbol.iterator in u)) && !(u instanceof WeakMap) && !(u instanceof WeakSet) && !(u instanceof Error) && !(u instanceof Number) && !(u instanceof Date) && !(u instanceof String) && !(u instanceof RegExp) && !(u instanceof ArrayBuffer), n = (u) => {
  switch (u.status) {
    case "fulfilled":
      return u.value;
    case "rejected":
      throw u.reason;
    default:
      throw u;
  }
}, i = /* @__PURE__ */ new WeakMap(), s = (u, f, d = n) => {
  const m = i.get(u);
  if ((m == null ? void 0 : m[0]) === f)
    return m[1];
  const y = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u));
  return nR(y, !0), i.set(u, [f, y]), Reflect.ownKeys(u).forEach((b) => {
    if (Object.getOwnPropertyDescriptor(y, b))
      return;
    const I = Reflect.get(u, b), k = {
      value: I,
      enumerable: !0,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: !0
    };
    if (G1.has(I))
      nR(I, !1);
    else if (I instanceof Promise)
      delete k.value, k.get = () => d(I);
    else if (uu.has(I)) {
      const [R, T] = uu.get(
        I
      );
      k.value = s(
        R,
        T(),
        d
      );
    }
    Object.defineProperty(y, b, k);
  }), Object.preventExtensions(y);
}, o = /* @__PURE__ */ new WeakMap(), a = [1, 1], c = (u) => {
  if (!A5(u))
    throw new Error("object required");
  const f = o.get(u);
  if (f)
    return f;
  let d = a[0];
  const m = /* @__PURE__ */ new Set(), y = (X, te = ++a[0]) => {
    d !== te && (d = te, m.forEach((se) => se(X, te)));
  };
  let b = a[1];
  const I = (X = ++a[1]) => (b !== X && !m.size && (b = X, R.forEach(([te]) => {
    const se = te[1](X);
    se > d && (d = se);
  })), d), k = (X) => (te, se) => {
    const we = [...te];
    we[1] = [X, ...we[1]], y(we, se);
  }, R = /* @__PURE__ */ new Map(), T = (X, te) => {
    if ((Jb ? "production" : void 0) !== "production" && R.has(X))
      throw new Error("prop listener already exists");
    if (m.size) {
      const se = te[3](k(X));
      R.set(X, [te, se]);
    } else
      R.set(X, [te]);
  }, $ = (X) => {
    var te;
    const se = R.get(X);
    se && (R.delete(X), (te = se[1]) == null || te.call(se));
  }, D = (X) => (m.add(X), m.size === 1 && R.forEach(([se, we], H) => {
    if ((Jb ? "production" : void 0) !== "production" && we)
      throw new Error("remove already exists");
    const p = se[3](k(H));
    R.set(H, [se, p]);
  }), () => {
    m.delete(X), m.size === 0 && R.forEach(([se, we], H) => {
      we && (we(), R.set(H, [se]));
    });
  }), L = Array.isArray(u) ? [] : Object.create(Object.getPrototypeOf(u)), v = e(L, {
    deleteProperty(X, te) {
      const se = Reflect.get(X, te);
      $(te);
      const we = Reflect.deleteProperty(X, te);
      return we && y(["delete", [te], se]), we;
    },
    set(X, te, se, we) {
      const H = Reflect.has(X, te), p = Reflect.get(X, te, we);
      if (H && (r(p, se) || o.has(se) && r(p, o.get(se))))
        return !0;
      $(te), A5(se) && (se = TG(se) || se);
      let w = se;
      if (se instanceof Promise)
        se.then((x) => {
          se.status = "fulfilled", se.value = x, y(["resolve", [te], x]);
        }).catch((x) => {
          se.status = "rejected", se.reason = x, y(["reject", [te], x]);
        });
      else {
        !uu.has(se) && t(se) && (w = c(se));
        const x = !G1.has(w) && uu.get(w);
        x && T(te, x);
      }
      return Reflect.set(X, te, w, we), y(["set", [te], se, p]), !0;
    }
  });
  o.set(u, v);
  const F = [
    L,
    I,
    s,
    D
  ];
  return uu.set(v, F), Reflect.ownKeys(u).forEach((X) => {
    const te = Object.getOwnPropertyDescriptor(
      u,
      X
    );
    "value" in te && (v[X] = u[X], delete te.value, delete te.writable), Object.defineProperty(L, X, te);
  }), v;
}) => [
  // public functions
  c,
  // shared state
  uu,
  G1,
  // internal things
  r,
  e,
  t,
  n,
  i,
  s,
  o,
  a
], [NG] = OG();
function ji(r = {}) {
  return NG(r);
}
function Mc(r, e, t) {
  const n = uu.get(r);
  (Jb ? "production" : void 0) !== "production" && !n && console.warn("Please use proxy object");
  let i;
  const s = [], o = n[3];
  let a = !1;
  const u = o((f) => {
    if (s.push(f), t) {
      e(s.splice(0));
      return;
    }
    i || (i = Promise.resolve().then(() => {
      i = void 0, a && e(s.splice(0));
    }));
  });
  return a = !0, () => {
    a = !1, u();
  };
}
function AP(r, e) {
  const t = uu.get(r);
  (Jb ? "production" : void 0) !== "production" && !t && console.warn("Please use proxy object");
  const [n, i, s] = t;
  return s(n, i(), e);
}
function V0(r) {
  return G1.add(r), r;
}
function Wo(r, e, t, n) {
  let i = r[e];
  return Mc(
    r,
    () => {
      const s = r[e];
      Object.is(i, s) || t(i = s);
    },
    n
  );
}
var ze = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ed(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function La(r) {
  if (r.__esModule)
    return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(t, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), t;
}
const I5 = "https://secure.web3modal.com", Cl = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  ONE_SEC_MS: 1e3,
  SECURE_SITE: I5,
  SECURE_SITE_DASHBOARD: `${I5}/dashboard`,
  SECURE_SITE_FAVICON: `${I5}/images/favicon.png`,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet"
  }
}, vt = {
  isMobile() {
    return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
  },
  isAndroid() {
    const r = window.navigator.userAgent.toLowerCase();
    return vt.isMobile() && r.includes("android");
  },
  isIos() {
    const r = window.navigator.userAgent.toLowerCase();
    return vt.isMobile() && (r.includes("iphone") || r.includes("ipad"));
  },
  isClient() {
    return typeof window < "u";
  },
  isPairingExpired(r) {
    return r ? r - Date.now() <= Cl.TEN_SEC_MS : !0;
  },
  isAllowedRetry(r) {
    return Date.now() - r >= Cl.ONE_SEC_MS;
  },
  copyToClopboard(r) {
    navigator.clipboard.writeText(r);
  },
  getPairingExpiry() {
    return Date.now() + Cl.FOUR_MINUTES_MS;
  },
  getPlainAddress(r) {
    return r.split(":")[2];
  },
  async wait(r) {
    return new Promise((e) => {
      setTimeout(e, r);
    });
  },
  debounce(r, e = 500) {
    let t;
    return (...n) => {
      function i() {
        r(...n);
      }
      t && clearTimeout(t), t = setTimeout(i, e);
    };
  },
  isHttpUrl(r) {
    return r.startsWith("http://") || r.startsWith("https://");
  },
  formatNativeUrl(r, e) {
    if (vt.isHttpUrl(r))
      return this.formatUniversalUrl(r, e);
    let t = r;
    t.includes("://") || (t = r.replaceAll("/", "").replaceAll(":", ""), t = `${t}://`), t.endsWith("/") || (t = `${t}/`);
    const n = encodeURIComponent(e);
    return {
      redirect: `${t}wc?uri=${n}`,
      href: t
    };
  },
  formatUniversalUrl(r, e) {
    if (!vt.isHttpUrl(r))
      return this.formatNativeUrl(r, e);
    let t = r;
    t.endsWith("/") || (t = `${t}/`);
    const n = encodeURIComponent(e);
    return {
      redirect: `${t}wc?uri=${n}`,
      href: t
    };
  },
  openHref(r, e) {
    window.open(r, e, "noreferrer noopener");
  },
  async preloadImage(r) {
    const e = new Promise((t, n) => {
      const i = new Image();
      i.onload = t, i.onerror = n, i.crossOrigin = "anonymous", i.src = r;
    });
    return Promise.race([e, vt.wait(2e3)]);
  },
  formatBalance(r, e) {
    var n;
    let t;
    if (r === "0")
      t = "0.000";
    else if (typeof r == "string") {
      const i = Number(r);
      i && (t = (n = i.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : n[0]);
    }
    return t ? `${t} ${e}` : `0.000 ${e}`;
  },
  isRestrictedRegion() {
    try {
      const { timeZone: r } = new Intl.DateTimeFormat().resolvedOptions(), e = r.toUpperCase();
      return Cl.RESTRICTED_TIMEZONES.includes(e);
    } catch {
      return !1;
    }
  },
  getApiUrl() {
    return vt.isRestrictedRegion() ? "https://api.web3modal.org" : "https://api.web3modal.com";
  },
  getBlockchainApiUrl() {
    return vt.isRestrictedRegion() ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com";
  },
  getAnalyticsUrl() {
    return vt.isRestrictedRegion() ? "https://pulse.walletconnect.org" : "https://pulse.walletconnect.com";
  },
  getUUID() {
    return crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (r) => {
      const e = Math.random() * 16 | 0;
      return (r === "x" ? e : e & 3 | 8).toString(16);
    });
  },
  parseError(r) {
    var e, t;
    return typeof r == "string" ? r : typeof ((t = (e = r == null ? void 0 : r.issues) == null ? void 0 : e[0]) == null ? void 0 : t.message) == "string" ? r.issues[0].message : r instanceof Error ? r.message : "Unknown error";
  }
}, jn = ji({
  isConnected: !1
}), xr = {
  state: jn,
  subscribe(r) {
    return Mc(jn, () => r(jn));
  },
  subscribeKey(r, e) {
    return Wo(jn, r, e);
  },
  setIsConnected(r) {
    jn.isConnected = r;
  },
  setCaipAddress(r) {
    jn.caipAddress = r, jn.address = r ? vt.getPlainAddress(r) : void 0;
  },
  setBalance(r, e) {
    jn.balance = r, jn.balanceSymbol = e;
  },
  setProfileName(r) {
    jn.profileName = r;
  },
  setProfileImage(r) {
    jn.profileImage = r;
  },
  setAddressExplorerUrl(r) {
    jn.addressExplorerUrl = r;
  },
  resetAccount() {
    jn.isConnected = !1, jn.caipAddress = void 0, jn.address = void 0, jn.balance = void 0, jn.balanceSymbol = void 0, jn.profileName = void 0, jn.profileImage = void 0, jn.addressExplorerUrl = void 0;
  }
};
class ES {
  constructor({ baseUrl: e }) {
    this.baseUrl = e;
  }
  async get({ headers: e, ...t }) {
    const n = this.createUrl(t);
    return (await fetch(n, { method: "GET", headers: e })).json();
  }
  async getBlob({ headers: e, ...t }) {
    const n = this.createUrl(t);
    return (await fetch(n, { method: "GET", headers: e })).blob();
  }
  async post({ body: e, headers: t, ...n }) {
    const i = this.createUrl(n);
    return (await fetch(i, {
      method: "POST",
      headers: t,
      body: e ? JSON.stringify(e) : void 0
    })).json();
  }
  async put({ body: e, headers: t, ...n }) {
    const i = this.createUrl(n);
    return (await fetch(i, {
      method: "PUT",
      headers: t,
      body: e ? JSON.stringify(e) : void 0
    })).json();
  }
  async delete({ body: e, headers: t, ...n }) {
    const i = this.createUrl(n);
    return (await fetch(i, {
      method: "DELETE",
      headers: t,
      body: e ? JSON.stringify(e) : void 0
    })).json();
  }
  createUrl({ path: e, params: t }) {
    const n = new URL(e, this.baseUrl);
    return t && Object.entries(t).forEach(([i, s]) => {
      s && n.searchParams.append(i, s);
    }), n;
  }
}
const R5 = "WALLETCONNECT_DEEPLINK_CHOICE", iR = "@w3m/recent", sR = "@w3m/connected_wallet_image_url", oR = "@w3m/connected_connector", ns = {
  setWalletConnectDeepLink({ href: r, name: e }) {
    try {
      localStorage.setItem(R5, JSON.stringify({ href: r, name: e }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const r = localStorage.getItem(R5);
      if (r)
        return JSON.parse(r);
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
  },
  deleteWalletConnectDeepLink() {
    try {
      localStorage.removeItem(R5);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setWeb3ModalRecent(r) {
    try {
      const e = ns.getRecentWallets();
      e.find((n) => n.id === r.id) || (e.unshift(r), e.length > 2 && e.pop(), localStorage.setItem(iR, JSON.stringify(e)));
    } catch {
      console.info("Unable to set Web3Modal recent");
    }
  },
  getRecentWallets() {
    try {
      const r = localStorage.getItem(iR);
      return r ? JSON.parse(r) : [];
    } catch {
      console.info("Unable to get Web3Modal recent");
    }
    return [];
  },
  setConnectedWalletImageUrl(r) {
    try {
      localStorage.setItem(sR, r);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
  },
  getConnectedWalletImageUrl() {
    try {
      return localStorage.getItem(sR);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
  },
  setConnectedConnector(r) {
    try {
      localStorage.setItem(oR, r);
    } catch {
      console.info("Unable to set Connected Connector");
    }
  },
  getConnectedConnector() {
    try {
      return localStorage.getItem(oR);
    } catch {
      console.info("Unable to get Connected Connector");
    }
  }
}, nu = ji({
  walletImages: {},
  networkImages: {},
  connectorImages: {},
  tokenImages: {}
}), jp = {
  state: nu,
  subscribeNetworkImages(r) {
    return Mc(nu.networkImages, () => r(nu.networkImages));
  },
  subscribeKey(r, e) {
    return Wo(nu, r, e);
  },
  setWalletImage(r, e) {
    nu.walletImages[r] = e;
  },
  setNetworkImage(r, e) {
    nu.networkImages[r] = e;
  },
  setConnectorImage(r, e) {
    nu.connectorImages[r] = e;
  },
  setTokenImage(r, e) {
    nu.tokenImages[r] = e;
  }
}, zs = ji({
  projectId: "",
  sdkType: "w3m",
  sdkVersion: "html-wagmi-undefined"
}), Rr = {
  state: zs,
  subscribeKey(r, e) {
    return Wo(zs, r, e);
  },
  setProjectId(r) {
    zs.projectId = r;
  },
  setIncludeWalletIds(r) {
    zs.includeWalletIds = r;
  },
  setExcludeWalletIds(r) {
    zs.excludeWalletIds = r;
  },
  setFeaturedWalletIds(r) {
    zs.featuredWalletIds = r;
  },
  setTokens(r) {
    zs.tokens = r;
  },
  setTermsConditionsUrl(r) {
    zs.termsConditionsUrl = r;
  },
  setPrivacyPolicyUrl(r) {
    zs.privacyPolicyUrl = r;
  },
  setCustomWallets(r) {
    zs.customWallets = r;
  },
  setEnableAnalytics(r) {
    zs.enableAnalytics = r;
  },
  setSdkVersion(r) {
    zs.sdkVersion = r;
  },
  setMetadata(r) {
    zs.metadata = r;
  }
}, $h = ji({
  connectors: []
}), Yr = {
  state: $h,
  subscribeKey(r, e) {
    return Wo($h, r, e);
  },
  setConnectors(r) {
    $h.connectors = r.map((e) => V0(e));
  },
  addConnector(r) {
    var e, t;
    if ($h.connectors.push(V0(r)), r.id === "w3mEmail") {
      const n = r, i = AP(Rr.state);
      (t = (e = n == null ? void 0 : n.provider) == null ? void 0 : e.syncDappData) == null || t.call(e, {
        metadata: i.metadata,
        sdkVersion: i.sdkVersion,
        projectId: i.projectId
      });
    }
  },
  getEmailConnector() {
    return $h.connectors.find((r) => r.type === "EMAIL");
  },
  getAnnouncedConnectorRdns() {
    return $h.connectors.filter((r) => r.type === "ANNOUNCED").map((r) => {
      var e;
      return (e = r.info) == null ? void 0 : e.rdns;
    });
  },
  getConnectors() {
    return $h.connectors;
  }
}, C1 = ji({
  open: !1,
  selectedNetworkId: void 0
}), q0 = {
  state: C1,
  subscribe(r) {
    return Mc(C1, () => r(C1));
  },
  set(r) {
    Object.assign(C1, { ...C1, ...r });
  }
}, Si = ji({
  supportsAllNetworks: !0,
  isDefaultCaipNetwork: !1
}), An = {
  state: Si,
  subscribeKey(r, e) {
    return Wo(Si, r, e);
  },
  _getClient() {
    if (!Si._client)
      throw new Error("NetworkController client not set");
    return Si._client;
  },
  setClient(r) {
    Si._client = V0(r);
  },
  setCaipNetwork(r) {
    Si.caipNetwork = r, q0.set({ selectedNetworkId: r == null ? void 0 : r.id });
  },
  setDefaultCaipNetwork(r) {
    Si.caipNetwork = r, q0.set({ selectedNetworkId: r == null ? void 0 : r.id }), Si.isDefaultCaipNetwork = !0;
  },
  setRequestedCaipNetworks(r) {
    Si.requestedCaipNetworks = r;
  },
  async getApprovedCaipNetworksData() {
    const r = await this._getClient().getApprovedCaipNetworksData();
    Si.supportsAllNetworks = r.supportsAllNetworks, Si.approvedCaipNetworkIds = r.approvedCaipNetworkIds;
  },
  async switchActiveNetwork(r) {
    await this._getClient().switchCaipNetwork(r), Si.caipNetwork = r;
  },
  resetNetwork() {
    Si.isDefaultCaipNetwork || (Si.caipNetwork = void 0), Si.approvedCaipNetworkIds = void 0, Si.supportsAllNetworks = !0;
  }
}, PG = vt.getApiUrl(), Ja = new ES({ baseUrl: PG }), MG = "40", aR = "4", Gi = ji({
  page: 1,
  count: 0,
  featured: [],
  recommended: [],
  wallets: [],
  search: []
}), lr = {
  state: Gi,
  subscribeKey(r, e) {
    return Wo(Gi, r, e);
  },
  _getApiHeaders() {
    const { projectId: r, sdkType: e, sdkVersion: t } = Rr.state;
    return {
      "x-project-id": r,
      "x-sdk-type": e,
      "x-sdk-version": t
    };
  },
  async _fetchWalletImage(r) {
    const e = `${Ja.baseUrl}/getWalletImage/${r}`, t = await Ja.getBlob({ path: e, headers: lr._getApiHeaders() });
    jp.setWalletImage(r, URL.createObjectURL(t));
  },
  async _fetchNetworkImage(r) {
    const e = `${Ja.baseUrl}/public/getAssetImage/${r}`, t = await Ja.getBlob({ path: e, headers: lr._getApiHeaders() });
    jp.setNetworkImage(r, URL.createObjectURL(t));
  },
  async _fetchConnectorImage(r) {
    const e = `${Ja.baseUrl}/public/getAssetImage/${r}`, t = await Ja.getBlob({ path: e, headers: lr._getApiHeaders() });
    jp.setConnectorImage(r, URL.createObjectURL(t));
  },
  async fetchNetworkImages() {
    const { requestedCaipNetworks: r } = An.state, e = r == null ? void 0 : r.map(({ imageId: t }) => t).filter(Boolean);
    e && await Promise.allSettled(e.map((t) => lr._fetchNetworkImage(t)));
  },
  async fetchConnectorImages() {
    const { connectors: r } = Yr.state, e = r.map(({ imageId: t }) => t).filter(Boolean);
    await Promise.allSettled(e.map((t) => lr._fetchConnectorImage(t)));
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds: r } = Rr.state;
    if (r != null && r.length) {
      const { data: e } = await Ja.get({
        path: "/getWallets",
        headers: lr._getApiHeaders(),
        params: {
          page: "1",
          entries: r != null && r.length ? String(r.length) : aR,
          include: r == null ? void 0 : r.join(",")
        }
      });
      e.sort((n, i) => r.indexOf(n.id) - r.indexOf(i.id));
      const t = e.map((n) => n.image_id).filter(Boolean);
      await Promise.allSettled(t.map((n) => lr._fetchWalletImage(n))), Gi.featured = e;
    }
  },
  async fetchRecommendedWallets() {
    const { includeWalletIds: r, excludeWalletIds: e, featuredWalletIds: t } = Rr.state, n = [...e ?? [], ...t ?? []].filter(Boolean), { data: i, count: s } = await Ja.get({
      path: "/getWallets",
      headers: lr._getApiHeaders(),
      params: {
        page: "1",
        entries: aR,
        include: r == null ? void 0 : r.join(","),
        exclude: n == null ? void 0 : n.join(",")
      }
    }), o = ns.getRecentWallets(), a = i.map((u) => u.image_id).filter(Boolean), c = o.map((u) => u.image_id).filter(Boolean);
    await Promise.allSettled([...a, ...c].map((u) => lr._fetchWalletImage(u))), Gi.recommended = i, Gi.count = s ?? 0;
  },
  async fetchWallets({ page: r }) {
    const { includeWalletIds: e, excludeWalletIds: t, featuredWalletIds: n } = Rr.state, i = [
      ...Gi.recommended.map(({ id: c }) => c),
      ...t ?? [],
      ...n ?? []
    ].filter(Boolean), { data: s, count: o } = await Ja.get({
      path: "/getWallets",
      headers: lr._getApiHeaders(),
      params: {
        page: String(r),
        entries: MG,
        include: e == null ? void 0 : e.join(","),
        exclude: i.join(",")
      }
    }), a = s.map((c) => c.image_id).filter(Boolean);
    await Promise.allSettled([
      ...a.map((c) => lr._fetchWalletImage(c)),
      vt.wait(300)
    ]), Gi.wallets = [...Gi.wallets, ...s], Gi.count = o > Gi.count ? o : Gi.count, Gi.page = r;
  },
  async searchWallet({ search: r }) {
    const { includeWalletIds: e, excludeWalletIds: t } = Rr.state;
    Gi.search = [];
    const { data: n } = await Ja.get({
      path: "/getWallets",
      headers: lr._getApiHeaders(),
      params: {
        page: "1",
        entries: "100",
        search: r,
        include: e == null ? void 0 : e.join(","),
        exclude: t == null ? void 0 : t.join(",")
      }
    }), i = n.map((s) => s.image_id).filter(Boolean);
    await Promise.allSettled([
      ...i.map((s) => lr._fetchWalletImage(s)),
      vt.wait(300)
    ]), Gi.search = n;
  },
  prefetch() {
    Gi.prefetchPromise = Promise.race([
      Promise.allSettled([
        lr.fetchFeaturedWallets(),
        lr.fetchRecommendedWallets(),
        lr.fetchNetworkImages(),
        lr.fetchConnectorImages()
      ]),
      vt.wait(3e3)
    ]);
  }
}, DG = vt.getAnalyticsUrl(), kG = new ES({ baseUrl: DG }), $G = ["MODAL_CREATED"], ap = ji({
  timestamp: Date.now(),
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
}), Ht = {
  state: ap,
  subscribe(r) {
    return Mc(ap, () => r(ap));
  },
  _getApiHeaders() {
    const { projectId: r, sdkType: e, sdkVersion: t } = Rr.state;
    return {
      "x-project-id": r,
      "x-sdk-type": e,
      "x-sdk-version": t
    };
  },
  async _sendAnalyticsEvent(r) {
    try {
      if ($G.includes(r.data.event) || typeof window > "u")
        return;
      await kG.post({
        path: "/e",
        headers: Ht._getApiHeaders(),
        body: {
          eventId: vt.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: r.timestamp,
          props: r.data
        }
      });
    } catch {
    }
  },
  sendEvent(r) {
    ap.timestamp = Date.now(), ap.data = r, Rr.state.enableAnalytics && Ht._sendAnalyticsEvent(ap);
  }
}, un = ji({
  view: "Connect",
  history: ["Connect"]
}), ut = {
  state: un,
  subscribeKey(r, e) {
    return Wo(un, r, e);
  },
  push(r, e) {
    r !== un.view && (un.view = r, un.history.push(r), un.data = e);
  },
  reset(r) {
    un.view = r, un.history = [r];
  },
  replace(r, e) {
    un.history.length > 1 && un.history.at(-1) !== r && (un.view = r, un.history[un.history.length - 1] = r, un.data = e);
  },
  goBack() {
    if (un.history.length > 1) {
      un.history.pop();
      const [r] = un.history.slice(-1);
      r && (un.view = r);
    }
  },
  goBackToIndex(r) {
    if (un.history.length > 1) {
      un.history = un.history.slice(0, r + 1);
      const [e] = un.history.slice(-1);
      e && (un.view = e);
    }
  }
}, Lh = ji({
  loading: !1,
  open: !1
}), Xr = {
  state: Lh,
  subscribe(r) {
    return Mc(Lh, () => r(Lh));
  },
  subscribeKey(r, e) {
    return Wo(Lh, r, e);
  },
  async open(r) {
    await lr.state.prefetchPromise, r != null && r.view ? ut.reset(r.view) : xr.state.isConnected ? ut.reset("Account") : ut.reset("Connect"), Lh.open = !0, q0.set({ open: !0 }), Ht.sendEvent({ type: "track", event: "MODAL_OPEN" });
  },
  close() {
    Lh.open = !1, q0.set({ open: !1 }), Ht.sendEvent({ type: "track", event: "MODAL_CLOSE" });
  },
  setLoading(r) {
    Lh.loading = r;
  }
}, LG = vt.getBlockchainApiUrl(), cR = new ES({ baseUrl: LG }), IP = {
  fetchIdentity({ caipChainId: r, address: e }) {
    return cR.get({
      path: `/v1/identity/${e}`,
      params: {
        chainId: r,
        projectId: Rr.state.projectId
      }
    });
  },
  fetchTransactions({ account: r, projectId: e, cursor: t }) {
    const n = t ? { cursor: t } : {};
    return cR.get({
      path: `/v1/account/${r}/history?projectId=${e}`,
      params: n
    });
  }
}, Kc = ji({
  message: "",
  variant: "success",
  open: !1
}), In = {
  state: Kc,
  subscribeKey(r, e) {
    return Wo(Kc, r, e);
  },
  showSuccess(r) {
    Kc.message = r, Kc.variant = "success", Kc.open = !0;
  },
  showError(r) {
    const e = vt.parseError(r);
    Kc.message = e, Kc.variant = "error", Kc.open = !0;
  },
  hide() {
    Kc.open = !1;
  }
}, Wn = ji({
  transactions: [],
  transactionsByYear: {},
  loading: !1,
  empty: !1,
  next: void 0
}), oa = {
  state: Wn,
  subscribe(r) {
    return Mc(Wn, () => r(Wn));
  },
  async fetchTransactions(r) {
    const { projectId: e } = Rr.state;
    if (!e || !r)
      throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
    Wn.loading = !0;
    try {
      const t = await IP.fetchTransactions({
        account: r,
        projectId: e,
        cursor: Wn.next
      }), n = this.filterSpamTransactions(t.data), i = [...Wn.transactions, ...n];
      Wn.loading = !1, Wn.transactions = i, Wn.transactionsByYear = this.groupTransactionsByYear(Wn.transactionsByYear, n), Wn.empty = i.length === 0, Wn.next = t.next ? t.next : void 0;
    } catch {
      Ht.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: r,
          projectId: e,
          cursor: Wn.next
        }
      }), In.showError("Failed to fetch transactions"), Wn.loading = !1, Wn.empty = !0;
    }
  },
  groupTransactionsByYear(r = {}, e = []) {
    const t = r;
    return e.forEach((n) => {
      var s;
      const i = new Date(n.metadata.minedAt).getFullYear();
      t[i] || (t[i] = []), (s = t[i]) == null || s.push(n);
    }), t;
  },
  filterSpamTransactions(r) {
    return r.filter((e) => !e.transfers.every((n) => {
      var i;
      return ((i = n.nft_info) == null ? void 0 : i.flags.is_spam) === !0;
    }));
  },
  resetTransactions() {
    Wn.transactions = [], Wn.transactionsByYear = {}, Wn.loading = !1, Wn.empty = !1, Wn.next = void 0;
  }
}, Xn = ji({
  wcError: !1,
  buffering: !1
}), wr = {
  state: Xn,
  subscribeKey(r, e) {
    return Wo(Xn, r, e);
  },
  _getClient() {
    if (!Xn._client)
      throw new Error("ConnectionController client not set");
    return Xn._client;
  },
  setClient(r) {
    Xn._client = V0(r);
  },
  connectWalletConnect() {
    Xn.wcPromise = this._getClient().connectWalletConnect((r) => {
      Xn.wcUri = r, Xn.wcPairingExpiry = vt.getPairingExpiry();
    });
  },
  async connectExternal(r) {
    var e, t;
    await ((t = (e = this._getClient()).connectExternal) == null ? void 0 : t.call(e, r)), ns.setConnectedConnector(r.type);
  },
  async signMessage(r) {
    return this._getClient().signMessage(r);
  },
  checkInstalled(r) {
    var e, t;
    return (t = (e = this._getClient()).checkInstalled) == null ? void 0 : t.call(e, r);
  },
  resetWcConnection() {
    Xn.wcUri = void 0, Xn.wcPairingExpiry = void 0, Xn.wcPromise = void 0, Xn.wcLinking = void 0, Xn.recentWallet = void 0, oa.resetTransactions(), ns.deleteWalletConnectDeepLink();
  },
  setWcLinking(r) {
    Xn.wcLinking = r;
  },
  setWcError(r) {
    Xn.wcError = r, Xn.buffering = !1;
  },
  setRecentWallet(r) {
    Xn.recentWallet = r;
  },
  setBuffering(r) {
    Xn.buffering = r;
  },
  async disconnect() {
    await this._getClient().disconnect(), this.resetWcConnection();
  }
}, Vs = ji({
  status: "uninitialized",
  isSiweEnabled: !1
}), Dn = {
  state: Vs,
  subscribeKey(r, e) {
    return Wo(Vs, r, e);
  },
  subscribe(r) {
    return Mc(Vs, () => r(Vs));
  },
  _getClient() {
    if (!Vs._client)
      throw new Error("SIWEController client not set");
    return Vs._client;
  },
  async getNonce() {
    const e = await this._getClient().getNonce();
    return this.setNonce(e), e;
  },
  async getSession() {
    const e = await this._getClient().getSession();
    return e && (this.setSession(e), this.setStatus("success")), e;
  },
  createMessage(r) {
    const t = this._getClient().createMessage(r);
    return this.setMessage(t), t;
  },
  async verifyMessage(r) {
    return await this._getClient().verifyMessage(r);
  },
  async signIn() {
    return await this._getClient().signIn();
  },
  async signOut() {
    var e;
    const r = this._getClient();
    await r.signOut(), this.setStatus("ready"), (e = r.onSignOut) == null || e.call(r);
  },
  onSignIn(r) {
    var t;
    const e = this._getClient();
    (t = e.onSignIn) == null || t.call(e, r);
  },
  onSignOut() {
    var e;
    const r = this._getClient();
    (e = r.onSignOut) == null || e.call(r);
  },
  setSIWEClient(r) {
    Vs._client = V0(r), Vs.status = "ready", Vs.isSiweEnabled = r.options.enabled;
  },
  setNonce(r) {
    Vs.nonce = r;
  },
  setStatus(r) {
    Vs.status = r;
  },
  setMessage(r) {
    Vs.message = r;
  },
  setSession(r) {
    Vs.session = r;
  }
}, Bh = ji({
  themeMode: "dark",
  themeVariables: {}
}), Cs = {
  state: Bh,
  subscribe(r) {
    return Mc(Bh, () => r(Bh));
  },
  setThemeMode(r) {
    Bh.themeMode = r;
  },
  setThemeVariables(r) {
    Bh.themeVariables = { ...Bh.themeVariables, ...r };
  },
  getSnapshot() {
    return AP(Bh);
  }
}, Sn = {
  getWalletImage(r) {
    if (r != null && r.image_url)
      return r == null ? void 0 : r.image_url;
    if (r != null && r.image_id)
      return jp.state.walletImages[r.image_id];
  },
  getNetworkImage(r) {
    if (r != null && r.imageUrl)
      return r == null ? void 0 : r.imageUrl;
    if (r != null && r.imageId)
      return jp.state.networkImages[r.imageId];
  },
  getConnectorImage(r) {
    if (r != null && r.imageUrl)
      return r.imageUrl;
    if (r != null && r.imageId)
      return jp.state.connectorImages[r.imageId];
  }
}, RP = {
  goBackOrCloseModal() {
    ut.state.history.length > 1 ? ut.goBack() : Xr.close();
  },
  navigateAfterNetworkSwitch() {
    const { history: r } = ut.state, e = r.findIndex((t) => t === "Networks");
    e >= 1 ? ut.goBackToIndex(e - 1) : Xr.close();
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ab = globalThis, xS = Ab.ShadowRoot && (Ab.ShadyCSS === void 0 || Ab.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, SS = Symbol(), lR = /* @__PURE__ */ new WeakMap();
let TP = class {
  constructor(e, t, n) {
    if (this._$cssResult$ = !0, n !== SS)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (xS && e === void 0) {
      const n = t !== void 0 && t.length === 1;
      n && (e = lR.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), n && lR.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const nc = (r) => new TP(typeof r == "string" ? r : r + "", void 0, SS), mt = (r, ...e) => {
  const t = r.length === 1 ? r[0] : e.reduce((n, i, s) => n + ((o) => {
    if (o._$cssResult$ === !0)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + r[s + 1], r[0]);
  return new TP(t, r, SS);
}, BG = (r, e) => {
  if (xS)
    r.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of e) {
      const n = document.createElement("style"), i = Ab.litNonce;
      i !== void 0 && n.setAttribute("nonce", i), n.textContent = t.cssText, r.appendChild(n);
    }
}, uR = xS ? (r) => r : (r) => r instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const n of e.cssRules)
    t += n.cssText;
  return nc(t);
})(r) : r;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: FG, defineProperty: UG, getOwnPropertyDescriptor: jG, getOwnPropertyNames: WG, getOwnPropertySymbols: HG, getPrototypeOf: zG } = Object, Wu = globalThis, hR = Wu.trustedTypes, VG = hR ? hR.emptyScript : "", T5 = Wu.reactiveElementPolyfillSupport, nm = (r, e) => r, Qb = { toAttribute(r, e) {
  switch (e) {
    case Boolean:
      r = r ? VG : null;
      break;
    case Object:
    case Array:
      r = r == null ? r : JSON.stringify(r);
  }
  return r;
}, fromAttribute(r, e) {
  let t = r;
  switch (e) {
    case Boolean:
      t = r !== null;
      break;
    case Number:
      t = r === null ? null : Number(r);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(r);
      } catch {
        t = null;
      }
  }
  return t;
} }, CS = (r, e) => !FG(r, e), fR = { attribute: !0, type: String, converter: Qb, reflect: !1, hasChanged: CS };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Wu.litPropertyMetadata ?? (Wu.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let _p = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = fR) {
    if (t.state && (t.attribute = !1), this._$Ei(), this.elementProperties.set(e, t), !t.noAccessor) {
      const n = Symbol(), i = this.getPropertyDescriptor(e, n, t);
      i !== void 0 && UG(this.prototype, e, i);
    }
  }
  static getPropertyDescriptor(e, t, n) {
    const { get: i, set: s } = jG(this.prototype, e) ?? { get() {
      return this[t];
    }, set(o) {
      this[t] = o;
    } };
    return { get() {
      return i == null ? void 0 : i.call(this);
    }, set(o) {
      const a = i == null ? void 0 : i.call(this);
      s.call(this, o), this.requestUpdate(e, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? fR;
  }
  static _$Ei() {
    if (this.hasOwnProperty(nm("elementProperties")))
      return;
    const e = zG(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(nm("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(nm("properties"))) {
      const t = this.properties, n = [...WG(t), ...HG(t)];
      for (const i of n)
        this.createProperty(i, t[i]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0)
        for (const [n, i] of t)
          this.elementProperties.set(n, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, n] of this.elementProperties) {
      const i = this._$Eu(t, n);
      i !== void 0 && this._$Eh.set(i, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const i of n)
        t.unshift(uR(i));
    } else
      e !== void 0 && t.push(uR(e));
    return t;
  }
  static _$Eu(e, t) {
    const n = t.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$Eg = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$ES(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$E_ ?? (this._$E_ = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$E_) == null || t.delete(e);
  }
  _$ES() {
    const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const n of t.keys())
      this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return BG(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$E_) == null || e.forEach((t) => {
      var n;
      return (n = t.hostConnected) == null ? void 0 : n.call(t);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$E_) == null || e.forEach((t) => {
      var n;
      return (n = t.hostDisconnected) == null ? void 0 : n.call(t);
    });
  }
  attributeChangedCallback(e, t, n) {
    this._$AK(e, n);
  }
  _$EO(e, t) {
    var s;
    const n = this.constructor.elementProperties.get(e), i = this.constructor._$Eu(e, n);
    if (i !== void 0 && n.reflect === !0) {
      const o = (((s = n.converter) == null ? void 0 : s.toAttribute) !== void 0 ? n.converter : Qb).toAttribute(t, n.type);
      this._$Em = e, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null;
    }
  }
  _$AK(e, t) {
    var s;
    const n = this.constructor, i = n._$Eh.get(e);
    if (i !== void 0 && this._$Em !== i) {
      const o = n.getPropertyOptions(i), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((s = o.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? o.converter : Qb;
      this._$Em = i, this[i] = a.fromAttribute(t, o.type), this._$Em = null;
    }
  }
  requestUpdate(e, t, n) {
    if (e !== void 0) {
      if (n ?? (n = this.constructor.getPropertyOptions(e)), !(n.hasChanged ?? CS)(this[e], t))
        return;
      this.C(e, t, n);
    }
    this.isUpdatePending === !1 && (this._$Eg = this._$EP());
  }
  C(e, t, n) {
    this._$AL.has(e) || this._$AL.set(e, t), n.reflect === !0 && this._$Em !== e && (this._$ET ?? (this._$ET = /* @__PURE__ */ new Set())).add(e);
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$Eg;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep)
          this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0)
        for (const [s, o] of i)
          o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.C(s, this[s], o);
    }
    let e = !1;
    const t = this._$AL;
    try {
      e = this.shouldUpdate(t), e ? (this.willUpdate(t), (n = this._$E_) == null || n.forEach((i) => {
        var s;
        return (s = i.hostUpdate) == null ? void 0 : s.call(i);
      }), this.update(t)) : this._$Ej();
    } catch (i) {
      throw e = !1, this._$Ej(), i;
    }
    e && this._$AE(t);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var t;
    (t = this._$E_) == null || t.forEach((n) => {
      var i;
      return (i = n.hostUpdated) == null ? void 0 : i.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$Ej() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Eg;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$ET && (this._$ET = this._$ET.forEach((t) => this._$EO(t, this[t]))), this._$Ej();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
_p.elementStyles = [], _p.shadowRootOptions = { mode: "open" }, _p[nm("elementProperties")] = /* @__PURE__ */ new Map(), _p[nm("finalized")] = /* @__PURE__ */ new Map(), T5 == null || T5({ ReactiveElement: _p }), (Wu.reactiveElementVersions ?? (Wu.reactiveElementVersions = [])).push("2.0.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const im = globalThis, Yb = im.trustedTypes, dR = Yb ? Yb.createPolicy("lit-html", { createHTML: (r) => r }) : void 0, OP = "$lit$", gu = `lit$${(Math.random() + "").slice(9)}$`, NP = "?" + gu, qG = `<${NP}>`, zf = document, Am = () => zf.createComment(""), Im = (r) => r === null || typeof r != "object" && typeof r != "function", PP = Array.isArray, GG = (r) => PP(r) || typeof (r == null ? void 0 : r[Symbol.iterator]) == "function", O5 = `[ 	
\f\r]`, A1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, pR = /-->/g, gR = />/g, Fh = RegExp(`>|${O5}(?:([^\\s"'>=/]+)(${O5}*=${O5}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), mR = /'/g, wR = /"/g, MP = /^(?:script|style|textarea|title)$/i, DP = (r) => (e, ...t) => ({ _$litType$: r, strings: e, values: t }), Ne = DP(1), Ke = DP(2), Vf = Symbol.for("lit-noChange"), kn = Symbol.for("lit-nothing"), yR = /* @__PURE__ */ new WeakMap(), nf = zf.createTreeWalker(zf, 129);
function kP(r, e) {
  if (!Array.isArray(r) || !r.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return dR !== void 0 ? dR.createHTML(e) : e;
}
const KG = (r, e) => {
  const t = r.length - 1, n = [];
  let i, s = e === 2 ? "<svg>" : "", o = A1;
  for (let a = 0; a < t; a++) {
    const c = r[a];
    let u, f, d = -1, m = 0;
    for (; m < c.length && (o.lastIndex = m, f = o.exec(c), f !== null); )
      m = o.lastIndex, o === A1 ? f[1] === "!--" ? o = pR : f[1] !== void 0 ? o = gR : f[2] !== void 0 ? (MP.test(f[2]) && (i = RegExp("</" + f[2], "g")), o = Fh) : f[3] !== void 0 && (o = Fh) : o === Fh ? f[0] === ">" ? (o = i ?? A1, d = -1) : f[1] === void 0 ? d = -2 : (d = o.lastIndex - f[2].length, u = f[1], o = f[3] === void 0 ? Fh : f[3] === '"' ? wR : mR) : o === wR || o === mR ? o = Fh : o === pR || o === gR ? o = A1 : (o = Fh, i = void 0);
    const y = o === Fh && r[a + 1].startsWith("/>") ? " " : "";
    s += o === A1 ? c + qG : d >= 0 ? (n.push(u), c.slice(0, d) + OP + c.slice(d) + gu + y) : c + gu + (d === -2 ? a : y);
  }
  return [kP(r, s + (r[t] || "<?>") + (e === 2 ? "</svg>" : "")), n];
};
let S6 = class $P {
  constructor({ strings: e, _$litType$: t }, n) {
    let i;
    this.parts = [];
    let s = 0, o = 0;
    const a = e.length - 1, c = this.parts, [u, f] = KG(e, t);
    if (this.el = $P.createElement(u, n), nf.currentNode = this.el.content, t === 2) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (i = nf.nextNode()) !== null && c.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes())
          for (const d of i.getAttributeNames())
            if (d.endsWith(OP)) {
              const m = f[o++], y = i.getAttribute(d).split(gu), b = /([.?@])?(.*)/.exec(m);
              c.push({ type: 1, index: s, name: b[2], strings: y, ctor: b[1] === "." ? JG : b[1] === "?" ? QG : b[1] === "@" ? YG : w_ }), i.removeAttribute(d);
            } else
              d.startsWith(gu) && (c.push({ type: 6, index: s }), i.removeAttribute(d));
        if (MP.test(i.tagName)) {
          const d = i.textContent.split(gu), m = d.length - 1;
          if (m > 0) {
            i.textContent = Yb ? Yb.emptyScript : "";
            for (let y = 0; y < m; y++)
              i.append(d[y], Am()), nf.nextNode(), c.push({ type: 2, index: ++s });
            i.append(d[m], Am());
          }
        }
      } else if (i.nodeType === 8)
        if (i.data === NP)
          c.push({ type: 2, index: s });
        else {
          let d = -1;
          for (; (d = i.data.indexOf(gu, d + 1)) !== -1; )
            c.push({ type: 7, index: s }), d += gu.length - 1;
        }
      s++;
    }
  }
  static createElement(e, t) {
    const n = zf.createElement("template");
    return n.innerHTML = e, n;
  }
};
function G0(r, e, t = r, n) {
  var o, a;
  if (e === Vf)
    return e;
  let i = n !== void 0 ? (o = t._$Co) == null ? void 0 : o[n] : t._$Cl;
  const s = Im(e) ? void 0 : e._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== s && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), s === void 0 ? i = void 0 : (i = new s(r), i._$AT(r, t, n)), n !== void 0 ? (t._$Co ?? (t._$Co = []))[n] = i : t._$Cl = i), i !== void 0 && (e = G0(r, i._$AS(r, e.values), i, n)), e;
}
let ZG = class {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: n } = this._$AD, i = ((e == null ? void 0 : e.creationScope) ?? zf).importNode(t, !0);
    nf.currentNode = i;
    let s = nf.nextNode(), o = 0, a = 0, c = n[0];
    for (; c !== void 0; ) {
      if (o === c.index) {
        let u;
        c.type === 2 ? u = new AS(s, s.nextSibling, this, e) : c.type === 1 ? u = new c.ctor(s, c.name, c.strings, this, e) : c.type === 6 && (u = new XG(s, this, e)), this._$AV.push(u), c = n[++a];
      }
      o !== (c == null ? void 0 : c.index) && (s = nf.nextNode(), o++);
    }
    return nf.currentNode = zf, i;
  }
  p(e) {
    let t = 0;
    for (const n of this._$AV)
      n !== void 0 && (n.strings !== void 0 ? (n._$AI(e, n, t), t += n.strings.length - 2) : n._$AI(e[t])), t++;
  }
}, AS = class LP {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, t, n, i) {
    this.type = 2, this._$AH = kn, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = n, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = G0(this, e, t), Im(e) ? e === kn || e == null || e === "" ? (this._$AH !== kn && this._$AR(), this._$AH = kn) : e !== this._$AH && e !== Vf && this._(e) : e._$litType$ !== void 0 ? this.g(e) : e.nodeType !== void 0 ? this.$(e) : GG(e) ? this.T(e) : this._(e);
  }
  k(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  $(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.k(e));
  }
  _(e) {
    this._$AH !== kn && Im(this._$AH) ? this._$AA.nextSibling.data = e : this.$(zf.createTextNode(e)), this._$AH = e;
  }
  g(e) {
    var s;
    const { values: t, _$litType$: n } = e, i = typeof n == "number" ? this._$AC(e) : (n.el === void 0 && (n.el = S6.createElement(kP(n.h, n.h[0]), this.options)), n);
    if (((s = this._$AH) == null ? void 0 : s._$AD) === i)
      this._$AH.p(t);
    else {
      const o = new ZG(i, this), a = o.u(this.options);
      o.p(t), this.$(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let t = yR.get(e.strings);
    return t === void 0 && yR.set(e.strings, t = new S6(e)), t;
  }
  T(e) {
    PP(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let n, i = 0;
    for (const s of e)
      i === t.length ? t.push(n = new LP(this.k(Am()), this.k(Am()), this, this.options)) : n = t[i], n._$AI(s), i++;
    i < t.length && (this._$AR(n && n._$AB.nextSibling, i), t.length = i);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, t); e && e !== this._$AB; ) {
      const i = e.nextSibling;
      e.remove(), e = i;
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 && (this._$Cv = e, (t = this._$AP) == null || t.call(this, e));
  }
}, w_ = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, n, i, s) {
    this.type = 1, this._$AH = kn, this._$AN = void 0, this.element = e, this.name = t, this._$AM = i, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = kn;
  }
  _$AI(e, t = this, n, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0)
      e = G0(this, e, t, 0), o = !Im(e) || e !== this._$AH && e !== Vf, o && (this._$AH = e);
    else {
      const a = e;
      let c, u;
      for (e = s[0], c = 0; c < s.length - 1; c++)
        u = G0(this, a[n + c], t, c), u === Vf && (u = this._$AH[c]), o || (o = !Im(u) || u !== this._$AH[c]), u === kn ? e = kn : e !== kn && (e += (u ?? "") + s[c + 1]), this._$AH[c] = u;
    }
    o && !i && this.O(e);
  }
  O(e) {
    e === kn ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}, JG = class extends w_ {
  constructor() {
    super(...arguments), this.type = 3;
  }
  O(e) {
    this.element[this.name] = e === kn ? void 0 : e;
  }
}, QG = class extends w_ {
  constructor() {
    super(...arguments), this.type = 4;
  }
  O(e) {
    this.element.toggleAttribute(this.name, !!e && e !== kn);
  }
}, YG = class extends w_ {
  constructor(e, t, n, i, s) {
    super(e, t, n, i, s), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = G0(this, e, t, 0) ?? kn) === Vf)
      return;
    const n = this._$AH, i = e === kn && n !== kn || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive, s = e !== kn && (n === kn || i);
    i && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var t;
    typeof this._$AH == "function" ? this._$AH.call(((t = this.options) == null ? void 0 : t.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}, XG = class {
  constructor(e, t, n) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    G0(this, e);
  }
};
const N5 = im.litHtmlPolyfillSupport;
N5 == null || N5(S6, AS), (im.litHtmlVersions ?? (im.litHtmlVersions = [])).push("3.1.1");
const eK = (r, e, t) => {
  const n = (t == null ? void 0 : t.renderBefore) ?? e;
  let i = n._$litPart$;
  if (i === void 0) {
    const s = (t == null ? void 0 : t.renderBefore) ?? null;
    n._$litPart$ = i = new AS(e.insertBefore(Am(), s), s, void 0, t ?? {});
  }
  return i._$AI(r), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let bt = class extends _p {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = eK(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return Vf;
  }
};
var xP;
bt._$litElement$ = !0, bt.finalized = !0, (xP = globalThis.litElementHydrateSupport) == null || xP.call(globalThis, { LitElement: bt });
const P5 = globalThis.litElementPolyfillSupport;
P5 == null || P5({ LitElement: bt });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.3");
let sm, Hu, zu;
function BP(r, e) {
  sm = document.createElement("style"), Hu = document.createElement("style"), zu = document.createElement("style"), sm.textContent = Wp(r).core.cssText, Hu.textContent = Wp(r).dark.cssText, zu.textContent = Wp(r).light.cssText, document.head.appendChild(sm), document.head.appendChild(Hu), document.head.appendChild(zu), IS(e);
}
function IS(r) {
  Hu && zu && (r === "light" ? (Hu.removeAttribute("media"), zu.media = "enabled") : (zu.removeAttribute("media"), Hu.media = "enabled"));
}
function FP(r) {
  sm && Hu && zu && (sm.textContent = Wp(r).core.cssText, Hu.textContent = Wp(r).dark.cssText, zu.textContent = Wp(r).light.cssText);
}
function Wp(r) {
  return {
    core: mt`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      :root {
        --w3m-color-mix-strength: ${nc(r != null && r["--w3m-color-mix-strength"] ? `${r["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${nc((r == null ? void 0 : r["--w3m-font-family"]) || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${nc((r == null ? void 0 : r["--w3m-font-size-master"]) || "10px")};
        --w3m-border-radius-master: ${nc((r == null ? void 0 : r["--w3m-border-radius-master"]) || "4px")};
        --w3m-z-index: ${nc((r == null ? void 0 : r["--w3m-z-index"]) || 100)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-blue-100: var(--wui-color-blue-base-100);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-accent-glass-090: var(--wui-accent-glass-base-090);
        --wui-accent-glass-080: var(--wui-accent-glass-base-080);
        --wui-accent-glass-020: var(--wui-accent-glass-base-020);
        --wui-accent-glass-015: var(--wui-accent-glass-base-015);
        --wui-accent-glass-010: var(--wui-accent-glass-base-010);
        --wui-accent-glass-005: var(--wui-accent-glass-base-005);
        --wui-accent-glass-002: var(--wui-accent-glass-base-002);

        --wui-color-fg-100: var(--wui-color-fg-base-100);
        --wui-color-fg-125: var(--wui-color-fg-base-125);
        --wui-color-fg-150: var(--wui-color-fg-base-150);
        --wui-color-fg-175: var(--wui-color-fg-base-175);
        --wui-color-fg-200: var(--wui-color-fg-base-200);
        --wui-color-fg-225: var(--wui-color-fg-base-225);
        --wui-color-fg-250: var(--wui-color-fg-base-250);
        --wui-color-fg-275: var(--wui-color-fg-base-275);
        --wui-color-fg-300: var(--wui-color-fg-base-300);

        --wui-color-bg-100: var(--wui-color-bg-base-100);
        --wui-color-bg-125: var(--wui-color-bg-base-125);
        --wui-color-bg-150: var(--wui-color-bg-base-150);
        --wui-color-bg-175: var(--wui-color-bg-base-175);
        --wui-color-bg-200: var(--wui-color-bg-base-200);
        --wui-color-bg-225: var(--wui-color-bg-base-225);
        --wui-color-bg-250: var(--wui-color-bg-base-250);
        --wui-color-bg-275: var(--wui-color-bg-base-275);
        --wui-color-bg-300: var(--wui-color-bg-base-300);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-base-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: rgba(71, 161, 255, 0.16);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 16%, transparent);

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            var(--w3m-default)
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            var(--w3m-default)
          );

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );

          --wui-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-base-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
    light: mt`
      :root {
        --w3m-color-mix: ${nc((r == null ? void 0 : r["--w3m-color-mix"]) || "#fff")};
        --w3m-accent: ${nc((r == null ? void 0 : r["--w3m-accent"]) || "#47a1ff")};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: #191a1a;

        --wui-color-blue-base-100: #47a1ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #59aaff;
        --wui-color-accent-base-080: #6cb4ff;

        --wui-accent-glass-base-090: rgba(71, 161, 255, 0.9);
        --wui-accent-glass-base-080: rgba(71, 161, 255, 0.8);
        --wui-accent-glass-base-020: rgba(71, 161, 255, 0.2);
        --wui-accent-glass-base-015: rgba(71, 161, 255, 0.15);
        --wui-accent-glass-base-010: rgba(71, 161, 255, 0.1);
        --wui-accent-glass-base-005: rgba(71, 161, 255, 0.05);
        --wui-accent-glass-base-002: rgba(71, 161, 255, 0.02);

        --wui-color-fg-base-100: #e4e7e7;
        --wui-color-fg-base-125: #d0d5d5;
        --wui-color-fg-base-150: #a8b1b1;
        --wui-color-fg-base-175: #a8b0b0;
        --wui-color-fg-base-200: #949e9e;
        --wui-color-fg-base-225: #868f8f;
        --wui-color-fg-base-250: #788080;
        --wui-color-fg-base-275: #788181;
        --wui-color-fg-base-300: #6e7777;

        --wui-color-bg-base-100: #141414;
        --wui-color-bg-base-125: #191a1a;
        --wui-color-bg-base-150: #1e1f1f;
        --wui-color-bg-base-175: #222525;
        --wui-color-bg-base-200: #272a2a;
        --wui-color-bg-base-225: #2c3030;
        --wui-color-bg-base-250: #313535;
        --wui-color-bg-base-275: #363b3b;
        --wui-color-bg-base-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: var(--wui-success-glass-015);
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-base-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-gray-glass-080: rgba(255, 255, 255, 0.8);
      }
    `,
    dark: mt`
      :root {
        --w3m-color-mix: ${nc((r == null ? void 0 : r["--w3m-color-mix"]) || "#000")};
        --w3m-accent: ${nc((r == null ? void 0 : r["--w3m-accent"]) || "#3396ff")};
        --w3m-default: #000;

        --wui-color-modal-bg-base: #fff;

        --wui-color-blue-base-100: #3396ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #2d7dd2;
        --wui-color-accent-base-080: #2978cc;

        --wui-accent-glass-base-090: rgba(51, 150, 255, 0.9);
        --wui-accent-glass-base-080: rgba(51, 150, 255, 0.8);
        --wui-accent-glass-base-020: rgba(51, 150, 255, 0.2);
        --wui-accent-glass-base-015: rgba(51, 150, 255, 0.15);
        --wui-accent-glass-base-010: rgba(51, 150, 255, 0.1);
        --wui-accent-glass-base-005: rgba(51, 150, 255, 0.05);
        --wui-accent-glass-base-002: rgba(51, 150, 255, 0.02);

        --wui-color-fg-base-100: #141414;
        --wui-color-fg-base-125: #2d3131;
        --wui-color-fg-base-150: #474d4d;
        --wui-color-fg-base-175: #636d6d;
        --wui-color-fg-base-200: #798686;
        --wui-color-fg-base-225: #828f8f;
        --wui-color-fg-base-250: #8b9797;
        --wui-color-fg-base-275: #95a0a0;
        --wui-color-fg-base-300: #9ea9a9;

        --wui-color-bg-base-100: #ffffff;
        --wui-color-bg-base-125: #f5fafa;
        --wui-color-bg-base-150: #f3f8f8;
        --wui-color-bg-base-175: #eef4f4;
        --wui-color-bg-base-200: #eaf1f1;
        --wui-color-bg-base-225: #e5eded;
        --wui-color-bg-base-250: #e1e9e9;
        --wui-color-bg-base-275: #dce7e7;
        --wui-color-bg-base-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-base-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-gray-glass-080: rgba(0, 0, 0, 0.8);
      }
    `
  };
}
const Pt = mt`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`, vn = mt`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    outline: none;
    border: 1px solid transparent;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-005);
    }

    button:active:enabled {
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
      background-color: var(--wui-gray-glass-010);
    }

    button[data-variant='fill']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='accentBg']:hover:enabled {
      background: var(--wui-accent-glass-015);
    }

    button[data-variant='accentBg']:active:enabled {
      background: var(--wui-accent-glass-020);
    }
  }

  button:disabled {
    cursor: not-allowed;
    background-color: var(--wui-gray-glass-005);
  }

  button[data-variant='shade']:disabled,
  button[data-variant='accent']:disabled,
  button[data-variant='accentBg']:disabled {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-gray-glass-015);
    filter: grayscale(1);
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  button:focus-visible,
  a:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  button[data-variant='fill']:disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
  }

  button[data-variant='fill']:disabled > wui-icon {
    color: var(--wui-gray-glass-015);
  }

  button[data-variant='shade'] {
    color: var(--wui-color-fg-200);
  }

  button[data-variant='accent'],
  button[data-variant='accentBg'] {
    color: var(--wui-color-accent-100);
  }

  button[data-variant='accentBg'] {
    background: var(--wui-accent-glass-010);
    border: 1px solid var(--wui-accent-glass-010);
  }

  button[data-variant='fullWidth'] {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    height: 56px;
    border: none;
    background-color: var(--wui-gray-glass-002);
    color: var(--wui-color-fg-200);
    gap: var(--wui-spacing-xs);
  }

  button:active:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='fill']:active:enabled {
    background-color: var(--wui-color-accent-080);
    border: 1px solid var(--wui-gray-glass-010);
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`, RS = mt`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;
function tK(r, e) {
  const { kind: t, elements: n } = e;
  return {
    kind: t,
    elements: n,
    finisher(i) {
      customElements.get(r) || customElements.define(r, i);
    }
  };
}
function rK(r, e) {
  return customElements.get(r) || customElements.define(r, e), e;
}
function $e(r) {
  return function(t) {
    return typeof t == "function" ? rK(r, t) : tK(r, t);
  };
}
const nK = mt`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;
var iK = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Xb = class extends bt {
  render() {
    return Ne`<slot></slot>`;
  }
};
Xb.styles = [Pt, nK];
Xb = iK([
  $e("wui-card")
], Xb);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const sK = { attribute: !0, type: String, converter: Qb, reflect: !1, hasChanged: CS }, oK = (r = sK, e, t) => {
  const { kind: n, metadata: i } = t;
  let s = globalThis.litPropertyMetadata.get(i);
  if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = /* @__PURE__ */ new Map()), s.set(t.name, r), n === "accessor") {
    const { name: o } = t;
    return { set(a) {
      const c = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(o, c, r);
    }, init(a) {
      return a !== void 0 && this.C(o, void 0, r), a;
    } };
  }
  if (n === "setter") {
    const { name: o } = t;
    return function(a) {
      const c = this[o];
      e.call(this, a), this.requestUpdate(o, c, r);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function he(r) {
  return (e, t) => typeof t == "object" ? oK(r, e, t) : ((n, i, s) => {
    const o = i.hasOwnProperty(s);
    return i.constructor.createProperty(s, o ? { ...n, wrapped: !0 } : n), o ? Object.getOwnPropertyDescriptor(i, s) : void 0;
  })(r, e, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function y_(r) {
  return he({ ...r, state: !0, attribute: !1 });
}
const aK = mt`
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`, cK = Ke`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`, lK = Ke`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`, uK = Ke`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`, hK = Ke`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`, fK = Ke`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`, dK = Ke`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`, pK = Ke`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`, gK = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`, mK = Ke`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.04 2.65c.47.3.6.91.3 1.38l-5.78 9a1 1 0 0 1-1.61.1L1.73 9.27A1 1 0 1 1 3.27 8L5.6 10.8l5.05-7.85a1 1 0 0 1 1.38-.3Z"
    clip-rule="evenodd"
  />
</svg>`, wK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`, yK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`, vK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`, bK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`, _K = Ke`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`, EK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`, xK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`, SK = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`, CK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`, AK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.5 0h1.67c.68 0 1.26 0 1.73.04.5.05.97.14 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73V6.5c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.43.03-.95.03-1.57.03 0 .62 0 1.14-.04 1.57-.04.5-.14.97-.4 1.42-.29.52-.72.95-1.24 1.24-.44.26-.92.35-1.41.4-.48.04-1.05.04-1.74.04H4.83c-.68 0-1.26 0-1.73-.04-.5-.05-.97-.14-1.42-.4-.52-.3-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.42A20.9 20.9 0 0 1 0 11.17V9.5c0-.69 0-1.26.04-1.74.05-.5.14-.97.4-1.41.3-.52.72-.95 1.24-1.25.45-.25.92-.35 1.42-.4.43-.03.95-.03 1.57-.03 0-.62 0-1.14.04-1.57.04-.5.14-.97.4-1.42.29-.52.72-.95 1.24-1.24.44-.26.92-.35 1.41-.4A20.9 20.9 0 0 1 9.5 0ZM4.67 6.67c-.63 0-1.06 0-1.4.03-.35.03-.5.09-.6.14-.2.12-.38.3-.5.5-.05.1-.1.24-.14.6C2 8.32 2 8.8 2 9.54v1.59c0 .73 0 1.22.03 1.6.04.35.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h1.58c.74 0 1.22 0 1.6-.03.36-.04.5-.1.6-.15.2-.11.38-.29.5-.5.05-.09.1-.24.14-.6.03-.33.03-.76.03-1.39-.6 0-1.13 0-1.57-.04-.5-.04-.97-.14-1.41-.4-.52-.29-.95-.72-1.25-1.24a3.39 3.39 0 0 1-.4-1.41c-.03-.44-.03-.96-.03-1.57Zm3.27-4.64c-.36.04-.5.1-.6.15-.2.11-.38.29-.5.5-.05.09-.1.24-.14.6-.03.37-.03.86-.03 1.6v1.58c0 .74 0 1.22.03 1.6.03.36.09.5.14.6.12.2.3.38.5.5.1.05.24.1.6.14.38.03.86.03 1.6.03h1.59c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6V4.87c0-.73 0-1.22-.03-1.6a1.46 1.46 0 0 0-.15-.6c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.14-.37-.03-.86-.03-1.6-.03H9.55c-.74 0-1.22 0-1.6.03Z"
    clip-rule="evenodd"
  />
</svg>`, IK = Ke` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`, RK = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`, TK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`, OK = Ke`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`, NK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`, PK = Ke`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`, MK = Ke`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`, DK = Ke`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`, kK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`, $K = Ke`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`, LK = Ke`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#fff" fill-opacity=".05" />
      <g clip-path="url(#c)">
        <path
          fill="#4285F4"
          d="M20 17.7v4.65h6.46a5.53 5.53 0 0 1-2.41 3.61l3.9 3.02c2.26-2.09 3.57-5.17 3.57-8.82 0-.85-.08-1.67-.22-2.46H20Z"
        />
        <path
          fill="#34A853"
          d="m13.27 22.17-.87.67-3.11 2.42A12 12 0 0 0 20 31.9c3.24 0 5.96-1.07 7.94-2.9l-3.9-3.03A7.15 7.15 0 0 1 20 27.12a7.16 7.16 0 0 1-6.72-4.94v-.01Z"
        />
        <path
          fill="#FBBC05"
          d="M9.29 14.5a11.85 11.85 0 0 0 0 10.76l3.99-3.1a7.19 7.19 0 0 1 0-4.55l-4-3.1Z"
        />
        <path
          fill="#EA4335"
          d="M20 12.66c1.77 0 3.34.61 4.6 1.8l3.43-3.44A11.51 11.51 0 0 0 20 7.89c-4.7 0-8.74 2.69-10.71 6.62l3.99 3.1A7.16 7.16 0 0 1 20 12.66Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`, BK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`, FK = Ke`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`, UK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`, jK = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`, WK = Ke`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`, HK = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`, zK = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`, VK = Ke` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`, qK = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`, GK = Ke`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`, KK = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`, ZK = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`, JK = Ke`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`, QK = Ke`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`, YK = Ke`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg> `, XK = Ke`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`, eZ = Ke`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1D9BF0" />
      <path
        fill="#fff"
        d="M30 13.81c-.74.33-1.53.55-2.36.65.85-.51 1.5-1.32 1.8-2.27-.79.47-1.66.8-2.6 1a4.1 4.1 0 0 0-7 3.73c-3.4-.17-6.42-1.8-8.45-4.28a4.1 4.1 0 0 0 1.27 5.47c-.67-.02-1.3-.2-1.86-.5a4.1 4.1 0 0 0 3.3 4.07c-.58.15-1.21.19-1.86.07a4.1 4.1 0 0 0 3.83 2.85A8.25 8.25 0 0 1 10 26.3a11.62 11.62 0 0 0 6.29 1.84c7.62 0 11.92-6.44 11.66-12.2.8-.59 1.5-1.3 2.05-2.13Z"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`, tZ = Ke`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`, rZ = Ke`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`, nZ = Ke`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`, iZ = Ke`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`, sZ = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`, oZ = Ke`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`, aZ = Ke`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`, cZ = Ke`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="12" viewBox="0 0 14 12" fill="none">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.687 0.557043C11.1462 0.671832 11.4254 1.13706 11.3106 1.59615C11.2044 2.02082 11.0975 2.51184 10.9822 3.04102C10.7176 4.25623 10.4091 5.6727 9.96482 6.94907C10.1435 7.58939 10.3065 8.16905 10.4935 8.68429C10.6447 9.10072 10.7858 9.39487 10.9179 9.58289C11.0055 9.70747 11.0597 9.74443 11.0748 9.75277C11.096 9.75724 11.1075 9.75764 11.1531 9.71916C11.2342 9.65067 11.3386 9.50891 11.4426 9.28357C11.5416 9.06892 11.614 8.8366 11.662 8.6497C11.6854 8.55831 11.7019 8.48242 11.7122 8.43111C11.7174 8.40555 11.7209 8.38638 11.723 8.37476L11.725 8.36363C11.8 7.89659 12.2395 7.57864 12.7068 7.65342C13.1742 7.72822 13.4925 8.16766 13.4177 8.63494C13.4153 8.64924 13.42 8.62063 13.4177 8.63494L13.4175 8.63596L13.4173 8.63721L13.4168 8.64037L13.4153 8.64924L13.4105 8.67692C13.4064 8.69961 13.4006 8.73069 13.3929 8.76891C13.3776 8.84516 13.3545 8.95091 13.3224 9.07586C13.2593 9.32166 13.1564 9.66085 12.9992 10.0015C12.8469 10.3315 12.6139 10.7288 12.2595 11.0282C11.8757 11.3523 11.35 11.5553 10.7293 11.4312C10.1645 11.3183 9.77597 10.939 9.51527 10.5681C9.2535 10.1957 9.05129 9.7349 8.88212 9.26898C8.87877 9.25975 8.87542 9.25049 8.87208 9.2412C8.03954 10.4941 6.83375 11.4479 5.03926 11.4479C3.48049 11.4479 2.31021 10.7159 1.56788 9.63945C0.846767 8.5938 0.544023 7.25403 0.573206 5.9702C0.60242 4.68505 0.966023 3.36073 1.69055 2.33272C2.42915 1.28475 3.5614 0.531453 5.03927 0.531453C6.44937 0.531453 7.4408 1.29593 8.1276 2.27567C8.48261 2.7821 8.77248 3.36668 9.0177 3.97383C9.1059 3.59106 9.18901 3.20908 9.27086 2.83294C9.39492 2.26277 9.51606 1.70605 9.64752 1.18046C9.76235 0.721369 10.2277 0.442254 10.687 0.557043ZM8.16354 6.87693C8.08689 6.60534 8.01003 6.33741 7.93241 6.08076C7.59522 4.96581 7.22132 3.969 6.72371 3.25914C6.24674 2.57873 5.72135 2.24516 5.03927 2.24516C4.21565 2.24516 3.56947 2.6422 3.09195 3.31975C2.60035 4.01725 2.31013 4.99361 2.28705 6.00913C2.26393 7.02599 2.51041 7.9869 2.97927 8.66676C3.42691 9.31586 4.08734 9.73417 5.03926 9.73417C6.48097 9.73417 7.4216 8.72164 8.14437 6.9249C8.15079 6.90893 8.15718 6.89294 8.16354 6.87693Z" fill="#47A1FF"/>
</svg>`;
var v_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const lZ = {
  allWallets: cK,
  alpha: cZ,
  appStore: lK,
  chromeStore: _K,
  apple: uK,
  arrowBottom: hK,
  arrowLeft: fK,
  arrowRight: dK,
  arrowTop: pK,
  browser: gK,
  checkmark: mK,
  chevronBottom: wK,
  chevronLeft: yK,
  chevronRight: vK,
  chevronTop: bK,
  clock: EK,
  close: xK,
  compass: CK,
  coinPlaceholder: SK,
  copy: AK,
  cursor: IK,
  desktop: RK,
  disconnect: TK,
  discord: OK,
  etherscan: NK,
  extension: PK,
  externalLink: MK,
  facebook: DK,
  filters: kK,
  github: $K,
  google: LK,
  helpCircle: BK,
  infoCircle: FK,
  mail: UK,
  mobile: jK,
  networkPlaceholder: WK,
  nftPlaceholder: HK,
  off: zK,
  playStore: VK,
  qrCode: qK,
  refresh: GK,
  search: KK,
  swapHorizontal: ZK,
  swapHorizontalBold: JK,
  swapVertical: QK,
  telegram: YK,
  twitch: XK,
  twitter: eZ,
  twitterIcon: tZ,
  verify: rZ,
  verifyFilled: nZ,
  wallet: sZ,
  walletConnect: oZ,
  walletPlaceholder: iZ,
  warningCircle: aZ
};
let qf = class extends bt {
  constructor() {
    super(...arguments), this.size = "md", this.name = "copy", this.color = "fg-300";
  }
  render() {
    return this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `, Ne`${lZ[this.name]}`;
  }
};
qf.styles = [Pt, RS, aK];
v_([
  he()
], qf.prototype, "size", void 0);
v_([
  he()
], qf.prototype, "name", void 0);
v_([
  he()
], qf.prototype, "color", void 0);
qf = v_([
  $e("wui-icon")
], qf);
const uZ = mt`
  :host {
    display: block;
    width: 100%;
    height: 100%;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var TS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let K0 = class extends bt {
  constructor() {
    super(...arguments), this.src = "./path/to/image.jpg", this.alt = "Image";
  }
  render() {
    return Ne`<img src=${this.src} alt=${this.alt} />`;
  }
};
K0.styles = [Pt, RS, uZ];
TS([
  he()
], K0.prototype, "src", void 0);
TS([
  he()
], K0.prototype, "alt", void 0);
K0 = TS([
  $e("wui-image")
], K0);
const hZ = mt`
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var fZ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let e2 = class extends bt {
  render() {
    return Ne`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `;
  }
};
e2.styles = [Pt, hZ];
e2 = fZ([
  $e("wui-loading-hexagon")
], e2);
const dZ = mt`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var OS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Z0 = class extends bt {
  constructor() {
    super(...arguments), this.color = "accent-100", this.size = "lg";
  }
  render() {
    return this.style.cssText = `--local-color: var(--wui-color-${this.color});`, this.dataset.size = this.size, Ne`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`;
  }
};
Z0.styles = [Pt, dZ];
OS([
  he()
], Z0.prototype, "color", void 0);
OS([
  he()
], Z0.prototype, "size", void 0);
Z0 = OS([
  $e("wui-loading-spinner")
], Z0);
const pZ = mt`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var UP = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Rm = class extends bt {
  constructor() {
    super(...arguments), this.radius = 36;
  }
  render() {
    return this.svgLoaderTemplate();
  }
  svgLoaderTemplate() {
    const e = this.radius > 50 ? 50 : this.radius, n = 36 - e, i = 116 + n, s = 245 + n, o = 360 + n * 1.75;
    return Ne`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${e}
          stroke-dasharray="${i} ${s}"
          stroke-dashoffset=${o}
        />
      </svg>
    `;
  }
};
Rm.styles = [Pt, pZ];
UP([
  he({ type: Number })
], Rm.prototype, "radius", void 0);
Rm = UP([
  $e("wui-loading-thumbnail")
], Rm);
const gZ = mt`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var b_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Gf = class extends bt {
  constructor() {
    super(...arguments), this.width = "", this.height = "", this.borderRadius = "m";
  }
  render() {
    return this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `, Ne`<slot></slot>`;
  }
};
Gf.styles = [gZ];
b_([
  he()
], Gf.prototype, "width", void 0);
b_([
  he()
], Gf.prototype, "height", void 0);
b_([
  he()
], Gf.prototype, "borderRadius", void 0);
Gf = b_([
  $e("wui-shimmer")
], Gf);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const jP = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, WP = (r) => (...e) => ({ _$litDirective$: r, values: e });
let HP = class {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, t, n) {
    this._$Ct = e, this._$AM = t, this._$Ci = n;
  }
  _$AS(e, t) {
    return this.update(e, t);
  }
  update(e, t) {
    return this.render(...t);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const mZ = WP(class extends HP {
  constructor(r) {
    var e;
    if (super(r), r.type !== jP.ATTRIBUTE || r.name !== "class" || ((e = r.strings) == null ? void 0 : e.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(r) {
    return " " + Object.keys(r).filter((e) => r[e]).join(" ") + " ";
  }
  update(r, [e]) {
    var n, i;
    if (this.it === void 0) {
      this.it = /* @__PURE__ */ new Set(), r.strings !== void 0 && (this.st = new Set(r.strings.join(" ").split(/\s/).filter((s) => s !== "")));
      for (const s in e)
        e[s] && !((n = this.st) != null && n.has(s)) && this.it.add(s);
      return this.render(e);
    }
    const t = r.element.classList;
    for (const s of this.it)
      s in e || (t.remove(s), this.it.delete(s));
    for (const s in e) {
      const o = !!e[s];
      o === this.it.has(s) || (i = this.st) != null && i.has(s) || (o ? (t.add(s), this.it.add(s)) : (t.remove(s), this.it.delete(s)));
    }
    return Vf;
  }
}), wZ = mt`
  :host {
    display: flex !important;
  }

  slot {
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-small-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }
`;
var __ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Kf = class extends bt {
  constructor() {
    super(...arguments), this.variant = "paragraph-500", this.color = "fg-300", this.align = "left";
  }
  render() {
    const e = {
      [`wui-font-${this.variant}`]: !0,
      [`wui-color-${this.color}`]: !0
    };
    return this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `, Ne`<slot class=${mZ(e)}></slot>`;
  }
};
Kf.styles = [Pt, wZ];
__([
  he()
], Kf.prototype, "variant", void 0);
__([
  he()
], Kf.prototype, "color", void 0);
__([
  he()
], Kf.prototype, "align", void 0);
Kf = __([
  $e("wui-text")
], Kf);
const yZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `, vZ = Ke`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `, bZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`, _Z = Ke`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `, EZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `, xZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`, SZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`, CZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `, AZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`, IZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `, RZ = Ke`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`, TZ = Ke`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `, OZ = Ke`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `, NZ = mt`
  :host {
    display: block;
    width: 55px;
    height: 55px;
  }
`;
var zP = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const PZ = {
  browser: yZ,
  dao: vZ,
  defi: bZ,
  defiAlt: _Z,
  eth: EZ,
  layers: xZ,
  lock: SZ,
  login: CZ,
  network: AZ,
  nft: IZ,
  noun: RZ,
  profile: TZ,
  system: OZ
};
let Tm = class extends bt {
  constructor() {
    super(...arguments), this.name = "browser";
  }
  render() {
    return Ne`${PZ[this.name]}`;
  }
};
Tm.styles = [Pt, NZ];
zP([
  he()
], Tm.prototype, "name", void 0);
Tm = zP([
  $e("wui-visual")
], Tm);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const xc = (r) => r ?? kn, jr = {
  getSpacingStyles(r, e) {
    if (Array.isArray(r))
      return r[e] ? `var(--wui-spacing-${r[e]})` : void 0;
    if (typeof r == "string")
      return `var(--wui-spacing-${r})`;
  },
  getFormattedDate(r) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(r);
  },
  getHostName(r) {
    return new URL(r).hostname;
  },
  getTruncateString({ string: r, charsStart: e, charsEnd: t, truncate: n }) {
    return r.length <= e + t ? r : n === "end" ? `${r.substring(0, e)}...` : n === "start" ? `...${r.substring(r.length - t)}` : `${r.substring(0, Math.floor(e))}...${r.substring(r.length - Math.floor(t))}`;
  },
  generateAvatarColors(r) {
    const t = r.toLowerCase().replace(/^0x/iu, "").substring(0, 6), n = this.hexToRgb(t), i = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master"), o = 100 - 3 * Number(i == null ? void 0 : i.replace("px", "")), a = `${o}% ${o}% at 65% 40%`, c = [];
    for (let u = 0; u < 5; u += 1) {
      const f = this.tintColor(n, 0.15 * u);
      c.push(`rgb(${f[0]}, ${f[1]}, ${f[2]})`);
    }
    return `
    --local-color-1: ${c[0]};
    --local-color-2: ${c[1]};
    --local-color-3: ${c[2]};
    --local-color-4: ${c[3]};
    --local-color-5: ${c[4]};
    --local-radial-circle: ${a}
   `;
  },
  hexToRgb(r) {
    const e = parseInt(r, 16), t = e >> 16 & 255, n = e >> 8 & 255, i = e & 255;
    return [t, n, i];
  },
  tintColor(r, e) {
    const [t, n, i] = r, s = Math.round(t + (255 - t) * e), o = Math.round(n + (255 - n) * e), a = Math.round(i + (255 - i) * e);
    return [s, o, a];
  },
  isNumber(r) {
    return {
      number: /^[0-9]+$/u
    }.number.test(r);
  },
  getColorTheme(r) {
    return r || (typeof window < "u" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : "dark");
  }
}, MZ = mt`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var so = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Bi = class extends bt {
  render() {
    return this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && jr.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && jr.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && jr.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && jr.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && jr.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && jr.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && jr.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && jr.getSpacingStyles(this.margin, 3)};
    `, Ne`<slot></slot>`;
  }
};
Bi.styles = [Pt, MZ];
so([
  he()
], Bi.prototype, "flexDirection", void 0);
so([
  he()
], Bi.prototype, "flexWrap", void 0);
so([
  he()
], Bi.prototype, "flexBasis", void 0);
so([
  he()
], Bi.prototype, "flexGrow", void 0);
so([
  he()
], Bi.prototype, "flexShrink", void 0);
so([
  he()
], Bi.prototype, "alignItems", void 0);
so([
  he()
], Bi.prototype, "justifyContent", void 0);
so([
  he()
], Bi.prototype, "columnGap", void 0);
so([
  he()
], Bi.prototype, "rowGap", void 0);
so([
  he()
], Bi.prototype, "gap", void 0);
so([
  he()
], Bi.prototype, "padding", void 0);
so([
  he()
], Bi.prototype, "margin", void 0);
Bi = so([
  $e("wui-flex")
], Bi);
const DZ = mt`
  :host {
    display: block;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var E_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Zf = class extends bt {
  constructor() {
    super(...arguments), this.imageSrc = void 0, this.alt = void 0, this.address = void 0;
  }
  render() {
    return Ne`${this.visualTemplate()}`;
  }
  visualTemplate() {
    if (this.imageSrc)
      return this.dataset.variant = "image", Ne`<wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></wui-image>`;
    if (this.address) {
      this.dataset.variant = "generated";
      const e = jr.generateAvatarColors(this.address);
      return this.style.cssText = e, null;
    }
    return this.dataset.variant = "default", null;
  }
};
Zf.styles = [Pt, DZ];
E_([
  he()
], Zf.prototype, "imageSrc", void 0);
E_([
  he()
], Zf.prototype, "alt", void 0);
E_([
  he()
], Zf.prototype, "address", void 0);
Zf = E_([
  $e("wui-avatar")
], Zf);
const kZ = mt`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-gray-glass-020);
    border-radius: var(--local-border-radius);
    box-shadow: 0 0 0 1px var(--local-border);
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var Fl = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Fo = class extends bt {
  constructor() {
    super(...arguments), this.size = "md", this.backgroundColor = "accent-100", this.iconColor = "accent-100", this.background = "transparent", this.border = !1, this.borderColor = "wui-color-bg-125", this.icon = "copy";
  }
  render() {
    const e = this.iconSize || this.size, t = this.size === "lg", n = this.size === "xl", i = t ? "12%" : "16%", s = t ? "xxs" : n ? "s" : "3xl", o = this.background === "gray", a = this.background === "opaque", c = this.backgroundColor === "accent-100" && a || this.backgroundColor === "success-100" && a || this.backgroundColor === "error-100" && a || this.backgroundColor === "inverse-100" && a;
    let u = `var(--wui-color-${this.backgroundColor})`;
    return c ? u = `var(--wui-icon-box-bg-${this.backgroundColor})` : o && (u = `var(--wui-gray-${this.backgroundColor})`), this.style.cssText = `
       --local-bg-value: ${u};
       --local-bg-mix: ${c || o ? "100%" : i};
       --local-border-radius: var(--wui-border-radius-${s});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? "2px" : "1px"} solid ${this.border ? `var(--${this.borderColor})` : "transparent"}
   `, Ne` <wui-icon color=${this.iconColor} size=${e} name=${this.icon}></wui-icon> `;
  }
};
Fo.styles = [Pt, vn, kZ];
Fl([
  he()
], Fo.prototype, "size", void 0);
Fl([
  he()
], Fo.prototype, "backgroundColor", void 0);
Fl([
  he()
], Fo.prototype, "iconColor", void 0);
Fl([
  he()
], Fo.prototype, "iconSize", void 0);
Fl([
  he()
], Fo.prototype, "background", void 0);
Fl([
  he({ type: Boolean })
], Fo.prototype, "border", void 0);
Fl([
  he()
], Fo.prototype, "borderColor", void 0);
Fl([
  he()
], Fo.prototype, "icon", void 0);
Fo = Fl([
  $e("wui-icon-box")
], Fo);
const $Z = mt`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    wui-image,
    wui-icon-box,
    button > wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var Ul = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Uo = class extends bt {
  constructor() {
    super(...arguments), this.networkSrc = void 0, this.avatarSrc = void 0, this.balance = void 0, this.disabled = !1, this.isProfileName = !1, this.address = "", this.charsStart = 4, this.charsEnd = 6;
  }
  render() {
    return Ne`
      <button
        ?disabled=${this.disabled}
        class=${xc(this.balance ? void 0 : "local-no-balance")}
      >
        ${this.balanceTemplate()}
        <wui-flex gap="xxs" alignItems="center">
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${jr.getTruncateString({
      string: this.address,
      charsStart: this.isProfileName ? 18 : this.charsStart,
      charsEnd: this.isProfileName ? 0 : this.charsEnd,
      truncate: this.isProfileName ? "end" : "middle"
    })}
          </wui-text>
        </wui-flex>
      </button>
    `;
  }
  balanceTemplate() {
    if (this.balance) {
      const e = this.networkSrc ? Ne`<wui-image src=${this.networkSrc}></wui-image>` : Ne`
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
      return Ne`
        ${e}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance} </wui-text>
      `;
    }
    return null;
  }
};
Uo.styles = [Pt, vn, $Z];
Ul([
  he()
], Uo.prototype, "networkSrc", void 0);
Ul([
  he()
], Uo.prototype, "avatarSrc", void 0);
Ul([
  he()
], Uo.prototype, "balance", void 0);
Ul([
  he({ type: Boolean })
], Uo.prototype, "disabled", void 0);
Ul([
  he({ type: Boolean })
], Uo.prototype, "isProfileName", void 0);
Ul([
  he()
], Uo.prototype, "address", void 0);
Ul([
  he()
], Uo.prototype, "charsStart", void 0);
Ul([
  he()
], Uo.prototype, "charsEnd", void 0);
Uo = Ul([
  $e("wui-account-button")
], Uo);
const LZ = mt`
  :host {
    position: relative;
    background-color: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-base-150, #1e1f1f);
    padding: 1px;
  }
`;
var xd = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Sc = class extends bt {
  constructor() {
    super(...arguments), this.size = "md", this.name = "", this.installed = !1, this.badgeSize = "xs";
  }
  render() {
    let e = "xxs";
    return this.size === "lg" ? e = "m" : this.size === "md" ? e = "xs" : e = "xxs", this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${e});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `, this.walletIcon && (this.dataset.walletIcon = this.walletIcon), Ne`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `;
  }
  templateVisual() {
    return this.imageSrc ? Ne`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : this.walletIcon ? Ne`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>` : Ne`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
Sc.styles = [Pt, LZ];
xd([
  he()
], Sc.prototype, "size", void 0);
xd([
  he()
], Sc.prototype, "name", void 0);
xd([
  he()
], Sc.prototype, "imageSrc", void 0);
xd([
  he()
], Sc.prototype, "walletIcon", void 0);
xd([
  he({ type: Boolean })
], Sc.prototype, "installed", void 0);
xd([
  he()
], Sc.prototype, "badgeSize", void 0);
Sc = xd([
  $e("wui-wallet-image")
], Sc);
const BZ = mt`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
var VP = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const M5 = 4;
let Om = class extends bt {
  constructor() {
    super(...arguments), this.walletImages = [];
  }
  render() {
    const e = this.walletImages.length < M5;
    return Ne`${this.walletImages.slice(0, M5).map(({ src: t, walletName: n }) => Ne`
            <wui-wallet-image
              size="inherit"
              imageSrc=${t}
              name=${xc(n)}
            ></wui-wallet-image>
          `)}
      ${e ? [...Array(M5 - this.walletImages.length)].map(() => Ne` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`;
  }
};
Om.styles = [Pt, BZ];
VP([
  he({ type: Array })
], Om.prototype, "walletImages", void 0);
Om = VP([
  $e("wui-all-wallets-image")
], Om);
const FZ = mt`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    width: var(--local-width);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-010);
  }

  button[data-size='sm'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s);
  }

  button[data-size='sm'][data-icon-left='true'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  button[data-size='sm'][data-icon-right='true'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-xs) var(--wui-spacing-xxs)
      var(--wui-spacing-s);
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'][data-icon-left='true'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transition: all 200ms ease-in-out;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var ch = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Ta = class extends bt {
  constructor() {
    super(...arguments), this.size = "md", this.disabled = !1, this.fullWidth = !1, this.loading = !1, this.variant = "fill", this.hasIconLeft = !1, this.hasIconRight = !1;
  }
  render() {
    this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};`;
    const e = this.size === "md" ? "paragraph-600" : "small-600";
    return Ne`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled || this.loading}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
        <wui-text variant=${e} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
      </button>
    `;
  }
  handleSlotLeftChange() {
    this.hasIconLeft = !0;
  }
  handleSlotRightChange() {
    this.hasIconRight = !0;
  }
  loadingTemplate() {
    return this.loading ? Ne`<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : Ne``;
  }
};
Ta.styles = [Pt, vn, FZ];
ch([
  he()
], Ta.prototype, "size", void 0);
ch([
  he({ type: Boolean })
], Ta.prototype, "disabled", void 0);
ch([
  he({ type: Boolean })
], Ta.prototype, "fullWidth", void 0);
ch([
  he({ type: Boolean })
], Ta.prototype, "loading", void 0);
ch([
  he()
], Ta.prototype, "variant", void 0);
ch([
  he({ type: Boolean })
], Ta.prototype, "hasIconLeft", void 0);
ch([
  he({ type: Boolean })
], Ta.prototype, "hasIconRight", void 0);
Ta = ch([
  $e("wui-button")
], Ta);
const qP = Ke`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`, UZ = mt`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-gray-glass-010);
    stroke-width: 1px;
  }
`;
var GP = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Nm = class extends bt {
  constructor() {
    super(...arguments), this.type = "wallet";
  }
  render() {
    return Ne`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `;
  }
  shimmerTemplate() {
    return this.type === "network" ? Ne` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${qP}` : Ne`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
  }
};
Nm.styles = [Pt, vn, UZ];
GP([
  he()
], Nm.prototype, "type", void 0);
Nm = GP([
  $e("wui-card-select-loader")
], Nm);
const jZ = Ke`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`, WZ = mt`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
    transition: stroke var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var Kw = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Gu = class extends bt {
  constructor() {
    super(...arguments), this.size = "md", this.name = "uknown", this.selected = !1;
  }
  render() {
    const e = this.size === "lg";
    return this.style.cssText = `
      --local-stroke: ${this.selected ? "var(--wui-color-accent-100)" : "var(--wui-gray-glass-010)"};
      --local-path: ${e ? "var(--wui-path-network-lg)" : "var(--wui-path-network)"};
      --local-width: ${e ? "86px" : "48px"};
      --local-height: ${e ? "96px" : "54px"};
      --local-icon-size: ${e ? "42px" : "24px"};
    `, Ne`${this.templateVisual()} ${e ? jZ : qP}`;
  }
  templateVisual() {
    return this.imageSrc ? Ne`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : Ne`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
Gu.styles = [Pt, WZ];
Kw([
  he()
], Gu.prototype, "size", void 0);
Kw([
  he()
], Gu.prototype, "name", void 0);
Kw([
  he()
], Gu.prototype, "imageSrc", void 0);
Kw([
  he({ type: Boolean })
], Gu.prototype, "selected", void 0);
Gu = Kw([
  $e("wui-network-image")
], Gu);
const HZ = mt`
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-accent-glass-010);
  }
`;
var Sd = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Cc = class extends bt {
  constructor() {
    super(...arguments), this.name = "Unknown", this.type = "wallet", this.imageSrc = void 0, this.disabled = !1, this.selected = !1, this.installed = !1;
  }
  render() {
    return Ne`
      <button data-selected=${xc(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
          ${this.name}
        </wui-text>
      </button>
    `;
  }
  imageTemplate() {
    return this.type === "network" ? Ne`
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${xc(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      ` : Ne`
      <wui-wallet-image
        size="md"
        imageSrc=${xc(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
  }
};
Cc.styles = [Pt, vn, HZ];
Sd([
  he()
], Cc.prototype, "name", void 0);
Sd([
  he()
], Cc.prototype, "type", void 0);
Sd([
  he()
], Cc.prototype, "imageSrc", void 0);
Sd([
  he({ type: Boolean })
], Cc.prototype, "disabled", void 0);
Sd([
  he({ type: Boolean })
], Cc.prototype, "selected", void 0);
Sd([
  he({ type: Boolean })
], Cc.prototype, "installed", void 0);
Cc = Sd([
  $e("wui-card-select")
], Cc);
const zZ = mt`
  a {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-success-glass-010);
    background-color: var(--wui-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image,
  a[data-variant='success'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon,
  a[data-variant='success'] > wui-icon,
  a[data-variant='shadeSmall'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-success-glass-015);
  }

  a.disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-success-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-success-glass-020);
  }
`;
var Cd = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Ac = class extends bt {
  constructor() {
    super(...arguments), this.variant = "fill", this.imageSrc = void 0, this.disabled = !1, this.icon = "externalLink", this.href = "", this.text = void 0;
  }
  render() {
    const t = this.variant === "success" || this.variant === "transparent" || this.variant === "shadeSmall" ? "small-600" : "paragraph-600";
    return Ne`
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${t} color="inherit">
          ${this.title ? this.title : jr.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `;
  }
  imageTemplate() {
    return this.imageSrc ? Ne`<wui-image src=${this.imageSrc}></wui-image>` : null;
  }
};
Ac.styles = [Pt, vn, zZ];
Cd([
  he()
], Ac.prototype, "variant", void 0);
Cd([
  he()
], Ac.prototype, "imageSrc", void 0);
Cd([
  he({ type: Boolean })
], Ac.prototype, "disabled", void 0);
Cd([
  he()
], Ac.prototype, "icon", void 0);
Cd([
  he()
], Ac.prototype, "href", void 0);
Cd([
  he()
], Ac.prototype, "text", void 0);
Ac = Cd([
  $e("wui-chip")
], Ac);
const VZ = mt`
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var NS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let J0 = class extends bt {
  constructor() {
    super(...arguments), this.size = "md", this.loading = !1;
  }
  render() {
    const e = this.size === "md" ? "paragraph-600" : "small-600";
    return Ne`
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${e} color=${this.loading ? "accent-100" : "inherit"}>
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  loadingTemplate() {
    return this.loading ? Ne`<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>` : null;
  }
};
J0.styles = [Pt, vn, VZ];
NS([
  he()
], J0.prototype, "size", void 0);
NS([
  he({ type: Boolean })
], J0.prototype, "loading", void 0);
J0 = NS([
  $e("wui-connect-button")
], J0);
const qZ = mt`
  wui-flex {
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var x_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Jf = class extends bt {
  constructor() {
    super(...arguments), this.disabled = !1, this.label = "", this.buttonLabel = "";
  }
  render() {
    return Ne`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-button size="sm" variant="accent">
          ${this.buttonLabel}
          <wui-icon size="xs" color="inherit" slot="iconRight" name="chevronRight"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
Jf.styles = [Pt, vn, qZ];
x_([
  he({ type: Boolean })
], Jf.prototype, "disabled", void 0);
x_([
  he()
], Jf.prototype, "label", void 0);
x_([
  he()
], Jf.prototype, "buttonLabel", void 0);
Jf = x_([
  $e("wui-cta-button")
], Jf);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const GZ = (r) => r.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const om = (r, e) => {
  var n;
  const t = r._$AN;
  if (t === void 0)
    return !1;
  for (const i of t)
    (n = i._$AO) == null || n.call(i, e, !1), om(i, e);
  return !0;
}, t2 = (r) => {
  let e, t;
  do {
    if ((e = r._$AM) === void 0)
      break;
    t = e._$AN, t.delete(r), r = e;
  } while ((t == null ? void 0 : t.size) === 0);
}, KP = (r) => {
  for (let e; e = r._$AM; r = e) {
    let t = e._$AN;
    if (t === void 0)
      e._$AN = t = /* @__PURE__ */ new Set();
    else if (t.has(r))
      break;
    t.add(r), JZ(e);
  }
};
function KZ(r) {
  this._$AN !== void 0 ? (t2(this), this._$AM = r, KP(this)) : this._$AM = r;
}
function ZZ(r, e = !1, t = 0) {
  const n = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0)
    if (e)
      if (Array.isArray(n))
        for (let s = t; s < n.length; s++)
          om(n[s], !1), t2(n[s]);
      else
        n != null && (om(n, !1), t2(n));
    else
      om(this, r);
}
const JZ = (r) => {
  r.type == jP.CHILD && (r._$AP ?? (r._$AP = ZZ), r._$AQ ?? (r._$AQ = KZ));
};
let QZ = class extends HP {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(e, t, n) {
    super._$AT(e, t, n), KP(this), this.isConnected = e._$AU;
  }
  _$AO(e, t = !0) {
    var n, i;
    e !== this.isConnected && (this.isConnected = e, e ? (n = this.reconnected) == null || n.call(this) : (i = this.disconnected) == null || i.call(this)), t && (om(this, e), t2(this));
  }
  setValue(e) {
    if (GZ(this._$Ct))
      this._$Ct._$AI(e, this);
    else {
      const t = [...this._$Ct._$AH];
      t[this._$Ci] = e, this._$Ct._$AI(t, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ZP = () => new YZ();
let YZ = class {
};
const D5 = /* @__PURE__ */ new WeakMap(), JP = WP(class extends QZ {
  render(r) {
    return kn;
  }
  update(r, [e]) {
    var n;
    const t = e !== this.G;
    return t && this.G !== void 0 && this.ot(void 0), (t || this.rt !== this.lt) && (this.G = e, this.ct = (n = r.options) == null ? void 0 : n.host, this.ot(this.lt = r.element)), kn;
  }
  ot(r) {
    if (typeof this.G == "function") {
      const e = this.ct ?? globalThis;
      let t = D5.get(e);
      t === void 0 && (t = /* @__PURE__ */ new WeakMap(), D5.set(e, t)), t.get(this.G) !== void 0 && this.G.call(this.ct, void 0), t.set(this.G, r), r !== void 0 && this.G.call(this.ct, r);
    } else
      this.G.value = r;
  }
  get rt() {
    var r, e;
    return typeof this.G == "function" ? (r = D5.get(this.ct ?? globalThis)) == null ? void 0 : r.get(this.G) : (e = this.G) == null ? void 0 : e.value;
  }
  disconnected() {
    this.rt === this.lt && this.ot(void 0);
  }
  reconnected() {
    this.ot(this.lt);
  }
}), XZ = mt`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    font-size: var(--wui-font-size-paragraph);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px 40px;
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var lh = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Oa = class extends bt {
  constructor() {
    super(...arguments), this.inputElementRef = ZP(), this.size = "md", this.disabled = !1, this.placeholder = "", this.type = "text";
  }
  render() {
    const e = `wui-size-${this.size}`;
    return Ne` ${this.templateIcon()}
      <input
        ${JP(this.inputElementRef)}
        class=${e}
        type=${this.type}
        enterkeyhint=${xc(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        value=${xc(this.value)}
      />
      <slot></slot>`;
  }
  templateIcon() {
    return this.icon ? Ne`<wui-icon
        data-input=${this.size}
        size="sm"
        color="inherit"
        name=${this.icon}
      ></wui-icon>` : null;
  }
  dispatchInputChangeEvent() {
    var e;
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: (e = this.inputElementRef.value) == null ? void 0 : e.value,
      bubbles: !0,
      composed: !0
    }));
  }
};
Oa.styles = [Pt, vn, XZ];
lh([
  he()
], Oa.prototype, "size", void 0);
lh([
  he()
], Oa.prototype, "icon", void 0);
lh([
  he({ type: Boolean })
], Oa.prototype, "disabled", void 0);
lh([
  he()
], Oa.prototype, "placeholder", void 0);
lh([
  he()
], Oa.prototype, "type", void 0);
lh([
  he()
], Oa.prototype, "keyHint", void 0);
lh([
  he()
], Oa.prototype, "value", void 0);
Oa = lh([
  $e("wui-input-text")
], Oa);
const eJ = mt`
  :host {
    position: relative;
    display: inline-block;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var S_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Qf = class extends bt {
  constructor() {
    super(...arguments), this.disabled = !1;
  }
  render() {
    return Ne`
      <wui-input-text
        placeholder="Email"
        icon="mail"
        size="md"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
      ></wui-input-text>
      ${this.templateError()}
    `;
  }
  templateError() {
    return this.errorMessage ? Ne`<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>` : null;
  }
};
Qf.styles = [Pt, eJ];
S_([
  he()
], Qf.prototype, "errorMessage", void 0);
S_([
  he({ type: Boolean })
], Qf.prototype, "disabled", void 0);
S_([
  he()
], Qf.prototype, "value", void 0);
Qf = S_([
  $e("wui-email-input")
], Qf);
const tJ = mt`
  button {
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-fg-100);
    padding: var(--wui-spacing-2xs);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var Zw = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Ku = class extends bt {
  constructor() {
    super(...arguments), this.size = "md", this.disabled = !1, this.icon = "copy", this.iconColor = "inherit";
  }
  render() {
    return Ne`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
Ku.styles = [Pt, vn, RS, tJ];
Zw([
  he()
], Ku.prototype, "size", void 0);
Zw([
  he({ type: Boolean })
], Ku.prototype, "disabled", void 0);
Zw([
  he()
], Ku.prototype, "icon", void 0);
Zw([
  he()
], Ku.prototype, "iconColor", void 0);
Ku = Zw([
  $e("wui-icon-link")
], Ku);
const rJ = mt`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  button:active:enabled {
    background-color: var(--wui-color-fg-225);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }
  }
`;
var QP = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Pm = class extends bt {
  constructor() {
    super(...arguments), this.icon = "copy";
  }
  render() {
    return Ne`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
Pm.styles = [Pt, vn, rJ];
QP([
  he()
], Pm.prototype, "icon", void 0);
Pm = QP([
  $e("wui-input-element")
], Pm);
const nJ = mt`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-005);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }
  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }
`;
var PS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Q0 = class extends bt {
  constructor() {
    super(...arguments), this.disabled = !1, this.value = "";
  }
  render() {
    return Ne`<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
      value=${this.value}
    /> `;
  }
};
Q0.styles = [Pt, vn, nJ];
PS([
  he({ type: Boolean })
], Q0.prototype, "disabled", void 0);
PS([
  he({ type: String })
], Q0.prototype, "value", void 0);
Q0 = PS([
  $e("wui-input-numeric")
], Q0);
const iJ = mt`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-gray-glass-015);
  }
`;
var MS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Y0 = class extends bt {
  constructor() {
    super(...arguments), this.disabled = !1, this.color = "inherit";
  }
  render() {
    return Ne`
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
  }
};
Y0.styles = [Pt, vn, iJ];
MS([
  he({ type: Boolean })
], Y0.prototype, "disabled", void 0);
MS([
  he()
], Y0.prototype, "color", void 0);
Y0 = MS([
  $e("wui-link")
], Y0);
const sJ = mt`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button[data-loading='true'] > wui-icon {
    transition: opacity 200ms ease-in-out;
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var Dc = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let io = class extends bt {
  constructor() {
    super(...arguments), this.variant = "icon", this.disabled = !1, this.imageSrc = void 0, this.alt = void 0, this.chevron = !1, this.loading = !1;
  }
  render() {
    return Ne`
      <button
        ?disabled=${this.loading ? !0 : !!this.disabled}
        data-loading=${this.loading}
        data-iconvariant=${xc(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
  }
  visualTemplate() {
    if (this.variant === "image" && this.imageSrc)
      return Ne`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
    if (this.iconVariant === "square" && this.icon && this.variant === "icon")
      return Ne`<wui-icon name=${this.icon}></wui-icon>`;
    if (this.variant === "icon" && this.icon && this.iconVariant) {
      const e = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200", t = this.iconVariant === "square-blue" ? "mdl" : "md", n = this.iconSize ? this.iconSize : t;
      return Ne`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${n}
          background="transparent"
          iconColor=${e}
          backgroundColor=${e}
          size=${t}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  loadingTemplate() {
    return this.loading ? Ne`<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : Ne``;
  }
  chevronTemplate() {
    return this.chevron ? Ne`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>` : null;
  }
};
io.styles = [Pt, vn, sJ];
Dc([
  he()
], io.prototype, "icon", void 0);
Dc([
  he()
], io.prototype, "iconSize", void 0);
Dc([
  he()
], io.prototype, "variant", void 0);
Dc([
  he()
], io.prototype, "iconVariant", void 0);
Dc([
  he({ type: Boolean })
], io.prototype, "disabled", void 0);
Dc([
  he()
], io.prototype, "imageSrc", void 0);
Dc([
  he()
], io.prototype, "alt", void 0);
Dc([
  he({ type: Boolean })
], io.prototype, "chevron", void 0);
Dc([
  he({ type: Boolean })
], io.prototype, "loading", void 0);
io = Dc([
  $e("wui-list-item")
], io);
var C6;
(function(r) {
  r.approve = "approved", r.bought = "bought", r.borrow = "borrowed", r.burn = "burnt", r.cancel = "canceled", r.claim = "claimed", r.deploy = "deployed", r.deposit = "deposited", r.execute = "executed", r.mint = "minted", r.receive = "received", r.repay = "repaid", r.send = "sent", r.sell = "sold", r.stake = "staked", r.trade = "swapped", r.unstake = "unstaked", r.withdraw = "withdrawn";
})(C6 || (C6 = {}));
const oJ = mt`
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
    z-index: -1;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var Ad = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Ic = class extends bt {
  constructor() {
    super(...arguments), this.images = [], this.secondImage = {
      type: void 0,
      url: ""
    };
  }
  render() {
    const [e, t] = this.images, n = (e == null ? void 0 : e.type) === "NFT", i = t != null && t.url ? t.type === "NFT" : n, s = n ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)", o = i ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    return this.style.cssText = `
    --local-left-border-radius: ${s};
    --local-right-border-radius: ${o};
    `, Ne`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`;
  }
  templateVisual() {
    const [e, t] = this.images, n = e == null ? void 0 : e.type;
    return this.images.length === 2 && (e != null && e.url || t != null && t.url) ? Ne`<div class="swap-images-container">
        ${e != null && e.url ? Ne`<wui-image src=${e.url} alt="Transaction image"></wui-image>` : null}
        ${t != null && t.url ? Ne`<wui-image src=${t.url} alt="Transaction image"></wui-image>` : null}
      </div>` : e != null && e.url ? Ne`<wui-image src=${e.url} alt="Transaction image"></wui-image>` : n === "NFT" ? Ne`<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>` : Ne`<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`;
  }
  templateIcon() {
    let e = "accent-100", t;
    return t = this.getIcon(), this.status && (e = this.getStatusColor()), t ? Ne`
      <wui-icon-box
        size="xxs"
        iconColor=${e}
        backgroundColor=${e}
        background="opaque"
        icon=${t}
        ?border=${!0}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    ` : null;
  }
  getDirectionIcon() {
    switch (this.direction) {
      case "in":
        return "arrowBottom";
      case "out":
        return "arrowTop";
      default:
        return;
    }
  }
  getIcon() {
    return this.onlyDirectionIcon ? this.getDirectionIcon() : this.type === "trade" ? "swapHorizontalBold" : this.type === "approve" ? "checkmark" : this.type === "cancel" ? "close" : this.getDirectionIcon();
  }
  getStatusColor() {
    switch (this.status) {
      case "confirmed":
        return "success-100";
      case "failed":
        return "error-100";
      case "pending":
        return "inverse-100";
      default:
        return "accent-100";
    }
  }
};
Ic.styles = [oJ];
Ad([
  he()
], Ic.prototype, "type", void 0);
Ad([
  he()
], Ic.prototype, "status", void 0);
Ad([
  he()
], Ic.prototype, "direction", void 0);
Ad([
  he({ type: Boolean })
], Ic.prototype, "onlyDirectionIcon", void 0);
Ad([
  he({ type: Array })
], Ic.prototype, "images", void 0);
Ad([
  he({ type: Object })
], Ic.prototype, "secondImage", void 0);
Ic = Ad([
  $e("wui-transaction-visual")
], Ic);
const aJ = mt`
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var uh = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Na = class extends bt {
  constructor() {
    super(...arguments), this.type = "approve", this.onlyDirectionIcon = !1, this.images = [];
  }
  render() {
    return Ne`
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${xc(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${xc(this.onlyDirectionIcon)}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${C6[this.type]}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `;
  }
  templateDescription() {
    var t;
    const e = (t = this.descriptions) == null ? void 0 : t[0];
    return e ? Ne`
          <wui-text variant="small-500" color="fg-200">
            <span>${e}</span>
          </wui-text>
        ` : null;
  }
  templateSecondDescription() {
    var t;
    const e = (t = this.descriptions) == null ? void 0 : t[1];
    return e ? Ne`
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${e}</span>
          </wui-text>
        ` : null;
  }
};
Na.styles = [Pt, aJ];
uh([
  he()
], Na.prototype, "type", void 0);
uh([
  he({ type: Array })
], Na.prototype, "descriptions", void 0);
uh([
  he()
], Na.prototype, "date", void 0);
uh([
  he({ type: Boolean })
], Na.prototype, "onlyDirectionIcon", void 0);
uh([
  he()
], Na.prototype, "status", void 0);
uh([
  he()
], Na.prototype, "direction", void 0);
uh([
  he({ type: Array })
], Na.prototype, "images", void 0);
Na = uh([
  $e("wui-transaction-list-item")
], Na);
const cJ = mt`
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;
var lJ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let r2 = class extends bt {
  render() {
    return Ne`
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `;
  }
};
r2.styles = [Pt, cJ];
r2 = lJ([
  $e("wui-transaction-list-item-loader")
], r2);
const uJ = mt`
  :host {
    display: block;
    padding: 3.5px 5px !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }
`;
var YP = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Mm = class extends bt {
  constructor() {
    super(...arguments), this.variant = "main";
  }
  render() {
    return this.dataset.variant = this.variant, Ne`
      <wui-text data-variant=${this.variant} variant="micro-700" color="inherit">
        <slot></slot>
      </wui-text>
    `;
  }
};
Mm.styles = [Pt, uJ];
YP([
  he()
], Mm.prototype, "variant", void 0);
Mm = YP([
  $e("wui-tag")
], Mm);
const hJ = mt`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var Ba = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Ds = class extends bt {
  constructor() {
    super(...arguments), this.walletImages = [], this.imageSrc = "", this.name = "", this.installed = !1, this.disabled = !1, this.showAllWallets = !1;
  }
  render() {
    return Ne`
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `;
  }
  templateAllWallets() {
    return this.showAllWallets && this.imageSrc ? Ne` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> ` : this.showAllWallets && this.walletIcon ? Ne` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> ` : null;
  }
  templateWalletImage() {
    return !this.showAllWallets && this.imageSrc ? Ne`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>` : !this.showAllWallets && !this.imageSrc ? Ne`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>` : null;
  }
  templateStatus() {
    return this.tagLabel && this.tagVariant ? Ne`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>` : this.icon ? Ne`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>` : null;
  }
};
Ds.styles = [Pt, vn, hJ];
Ba([
  he({ type: Array })
], Ds.prototype, "walletImages", void 0);
Ba([
  he()
], Ds.prototype, "imageSrc", void 0);
Ba([
  he()
], Ds.prototype, "name", void 0);
Ba([
  he()
], Ds.prototype, "tagLabel", void 0);
Ba([
  he()
], Ds.prototype, "tagVariant", void 0);
Ba([
  he()
], Ds.prototype, "icon", void 0);
Ba([
  he()
], Ds.prototype, "walletIcon", void 0);
Ba([
  he({ type: Boolean })
], Ds.prototype, "installed", void 0);
Ba([
  he({ type: Boolean })
], Ds.prototype, "disabled", void 0);
Ba([
  he({ type: Boolean })
], Ds.prototype, "showAllWallets", void 0);
Ds = Ba([
  $e("wui-list-wallet")
], Ds);
const fJ = mt`
  :host {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-010);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var XP = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Dm = class extends bt {
  constructor() {
    super(...arguments), this.logo = "google";
  }
  render() {
    return Ne`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `;
  }
};
Dm.styles = [Pt, fJ];
XP([
  he()
], Dm.prototype, "logo", void 0);
Dm = XP([
  $e("wui-logo")
], Dm);
const dJ = mt`
  :host {
    display: block;
  }

  button {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var DS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let X0 = class extends bt {
  constructor() {
    super(...arguments), this.logo = "google", this.disabled = !1;
  }
  render() {
    return Ne`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `;
  }
};
X0.styles = [Pt, vn, dJ];
DS([
  he()
], X0.prototype, "logo", void 0);
DS([
  he({ type: Boolean })
], X0.prototype, "disabled", void 0);
X0 = DS([
  $e("wui-logo-select")
], X0);
const pJ = mt`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }
`;
var kS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let eg = class extends bt {
  constructor() {
    super(...arguments), this.imageSrc = void 0, this.disabled = !1;
  }
  render() {
    return Ne`
      <button ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  visualTemplate() {
    return this.imageSrc ? Ne`<wui-image src=${this.imageSrc}></wui-image>` : Ne`
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
eg.styles = [Pt, vn, pJ];
kS([
  he()
], eg.prototype, "imageSrc", void 0);
kS([
  he({ type: Boolean })
], eg.prototype, "disabled", void 0);
eg = kS([
  $e("wui-network-button")
], eg);
const gJ = mt`
  :host {
    position: relative;
    display: block;
  }
`;
var C_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Yf = class extends bt {
  constructor() {
    super(...arguments), this.length = 6, this.otp = "", this.values = Array.from({ length: this.length }).map(() => ""), this.numerics = [], this.shouldInputBeEnabled = (e) => this.values.slice(0, e).every((n) => n !== ""), this.handleKeyDown = (e, t) => {
      const n = e.target, i = this.getInputElement(n), s = ["ArrowLeft", "ArrowRight", "Shift", "Delete"];
      if (!i)
        return;
      s.includes(e.key) && e.preventDefault();
      const o = i.selectionStart;
      switch (e.key) {
        case "ArrowLeft":
          o && i.setSelectionRange(o + 1, o + 1), this.focusInputField("prev", t);
          break;
        case "ArrowRight":
          this.focusInputField("next", t);
          break;
        case "Shift":
          this.focusInputField("next", t);
          break;
        case "Delete":
          i.value === "" ? this.focusInputField("prev", t) : this.updateInput(i, t, "");
          break;
        case "Backspace":
          i.value === "" ? this.focusInputField("prev", t) : this.updateInput(i, t, "");
          break;
      }
    }, this.focusInputField = (e, t) => {
      if (e === "next") {
        const n = t + 1;
        if (!this.shouldInputBeEnabled(n))
          return;
        const i = this.numerics[n < this.length ? n : t], s = i ? this.getInputElement(i) : void 0;
        s && (s.disabled = !1, s.focus());
      }
      if (e === "prev") {
        const n = t - 1, i = this.numerics[n > -1 ? n : t], s = i ? this.getInputElement(i) : void 0;
        s && s.focus();
      }
    };
  }
  firstUpdated() {
    var t, n;
    this.otp && (this.values = this.otp.split(""));
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelectorAll("wui-input-numeric");
    e && (this.numerics = Array.from(e)), (n = this.numerics[0]) == null || n.focus();
  }
  render() {
    return Ne`
      <wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({ length: this.length }).map((e, t) => Ne`
            <wui-input-numeric
              @input=${(n) => this.handleInput(n, t)}
              @keydown=${(n) => this.handleKeyDown(n, t)}
              .disabled=${!this.shouldInputBeEnabled(t)}
              .value=${this.values[t] || ""}
            >
            </wui-input-numeric>
          `)}
      </wui-flex>
    `;
  }
  updateInput(e, t, n) {
    const i = this.numerics[t], s = e || (i ? this.getInputElement(i) : void 0);
    s && (s.value = n, this.values = this.values.map((o, a) => a === t ? n : o));
  }
  handleInput(e, t) {
    const n = e.target, i = this.getInputElement(n);
    if (i) {
      const s = i.value;
      e.inputType === "insertFromPaste" ? this.handlePaste(i, s, t) : jr.isNumber(s) && e.data ? (this.updateInput(i, t, e.data), this.focusInputField("next", t)) : this.updateInput(i, t, "");
    }
    this.dispatchInputChangeEvent();
  }
  handlePaste(e, t, n) {
    const i = t[0];
    if (i && jr.isNumber(i)) {
      this.updateInput(e, n, i);
      const o = t.substring(1);
      if (n + 1 < this.length && o.length) {
        const a = this.numerics[n + 1], c = a ? this.getInputElement(a) : void 0;
        c && this.handlePaste(c, o, n + 1);
      } else
        this.focusInputField("next", n);
    } else
      this.updateInput(e, n, "");
  }
  getInputElement(e) {
    var t;
    return (t = e.shadowRoot) != null && t.querySelector("input") ? e.shadowRoot.querySelector("input") : null;
  }
  dispatchInputChangeEvent() {
    const e = this.values.join("");
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: e,
      bubbles: !0,
      composed: !0
    }));
  }
};
Yf.styles = [Pt, gJ];
C_([
  he({ type: Number })
], Yf.prototype, "length", void 0);
C_([
  he({ type: String })
], Yf.prototype, "otp", void 0);
C_([
  y_()
], Yf.prototype, "values", void 0);
Yf = C_([
  $e("wui-otp")
], Yf);
var Jw = {}, mJ = function() {
  return typeof Promise == "function" && Promise.prototype && Promise.prototype.then;
}, eM = {}, oo = {};
let $S;
const wJ = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
oo.getSymbolSize = function(e) {
  if (!e)
    throw new Error('"version" cannot be null or undefined');
  if (e < 1 || e > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return e * 4 + 17;
};
oo.getSymbolTotalCodewords = function(e) {
  return wJ[e];
};
oo.getBCHDigit = function(r) {
  let e = 0;
  for (; r !== 0; )
    e++, r >>>= 1;
  return e;
};
oo.setToSJISFunction = function(e) {
  if (typeof e != "function")
    throw new Error('"toSJISFunc" is not a valid function.');
  $S = e;
};
oo.isKanjiModeEnabled = function() {
  return typeof $S < "u";
};
oo.toSJIS = function(e) {
  return $S(e);
};
var A_ = {};
(function(r) {
  r.L = { bit: 1 }, r.M = { bit: 0 }, r.Q = { bit: 3 }, r.H = { bit: 2 };
  function e(t) {
    if (typeof t != "string")
      throw new Error("Param is not a string");
    switch (t.toLowerCase()) {
      case "l":
      case "low":
        return r.L;
      case "m":
      case "medium":
        return r.M;
      case "q":
      case "quartile":
        return r.Q;
      case "h":
      case "high":
        return r.H;
      default:
        throw new Error("Unknown EC Level: " + t);
    }
  }
  r.isValid = function(n) {
    return n && typeof n.bit < "u" && n.bit >= 0 && n.bit < 4;
  }, r.from = function(n, i) {
    if (r.isValid(n))
      return n;
    try {
      return e(n);
    } catch {
      return i;
    }
  };
})(A_);
function tM() {
  this.buffer = [], this.length = 0;
}
tM.prototype = {
  get: function(r) {
    const e = Math.floor(r / 8);
    return (this.buffer[e] >>> 7 - r % 8 & 1) === 1;
  },
  put: function(r, e) {
    for (let t = 0; t < e; t++)
      this.putBit((r >>> e - t - 1 & 1) === 1);
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(r) {
    const e = Math.floor(this.length / 8);
    this.buffer.length <= e && this.buffer.push(0), r && (this.buffer[e] |= 128 >>> this.length % 8), this.length++;
  }
};
var yJ = tM;
function Qw(r) {
  if (!r || r < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = r, this.data = new Uint8Array(r * r), this.reservedBit = new Uint8Array(r * r);
}
Qw.prototype.set = function(r, e, t, n) {
  const i = r * this.size + e;
  this.data[i] = t, n && (this.reservedBit[i] = !0);
};
Qw.prototype.get = function(r, e) {
  return this.data[r * this.size + e];
};
Qw.prototype.xor = function(r, e, t) {
  this.data[r * this.size + e] ^= t;
};
Qw.prototype.isReserved = function(r, e) {
  return this.reservedBit[r * this.size + e];
};
var vJ = Qw, rM = {};
(function(r) {
  const e = oo.getSymbolSize;
  r.getRowColCoords = function(n) {
    if (n === 1)
      return [];
    const i = Math.floor(n / 7) + 2, s = e(n), o = s === 145 ? 26 : Math.ceil((s - 13) / (2 * i - 2)) * 2, a = [s - 7];
    for (let c = 1; c < i - 1; c++)
      a[c] = a[c - 1] - o;
    return a.push(6), a.reverse();
  }, r.getPositions = function(n) {
    const i = [], s = r.getRowColCoords(n), o = s.length;
    for (let a = 0; a < o; a++)
      for (let c = 0; c < o; c++)
        a === 0 && c === 0 || // top-left
        a === 0 && c === o - 1 || // bottom-left
        a === o - 1 && c === 0 || i.push([s[a], s[c]]);
    return i;
  };
})(rM);
var nM = {};
const bJ = oo.getSymbolSize, vR = 7;
nM.getPositions = function(e) {
  const t = bJ(e);
  return [
    // top-left
    [0, 0],
    // top-right
    [t - vR, 0],
    // bottom-left
    [0, t - vR]
  ];
};
var iM = {};
(function(r) {
  r.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const e = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  r.isValid = function(i) {
    return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7;
  }, r.from = function(i) {
    return r.isValid(i) ? parseInt(i, 10) : void 0;
  }, r.getPenaltyN1 = function(i) {
    const s = i.size;
    let o = 0, a = 0, c = 0, u = null, f = null;
    for (let d = 0; d < s; d++) {
      a = c = 0, u = f = null;
      for (let m = 0; m < s; m++) {
        let y = i.get(d, m);
        y === u ? a++ : (a >= 5 && (o += e.N1 + (a - 5)), u = y, a = 1), y = i.get(m, d), y === f ? c++ : (c >= 5 && (o += e.N1 + (c - 5)), f = y, c = 1);
      }
      a >= 5 && (o += e.N1 + (a - 5)), c >= 5 && (o += e.N1 + (c - 5));
    }
    return o;
  }, r.getPenaltyN2 = function(i) {
    const s = i.size;
    let o = 0;
    for (let a = 0; a < s - 1; a++)
      for (let c = 0; c < s - 1; c++) {
        const u = i.get(a, c) + i.get(a, c + 1) + i.get(a + 1, c) + i.get(a + 1, c + 1);
        (u === 4 || u === 0) && o++;
      }
    return o * e.N2;
  }, r.getPenaltyN3 = function(i) {
    const s = i.size;
    let o = 0, a = 0, c = 0;
    for (let u = 0; u < s; u++) {
      a = c = 0;
      for (let f = 0; f < s; f++)
        a = a << 1 & 2047 | i.get(u, f), f >= 10 && (a === 1488 || a === 93) && o++, c = c << 1 & 2047 | i.get(f, u), f >= 10 && (c === 1488 || c === 93) && o++;
    }
    return o * e.N3;
  }, r.getPenaltyN4 = function(i) {
    let s = 0;
    const o = i.data.length;
    for (let c = 0; c < o; c++)
      s += i.data[c];
    return Math.abs(Math.ceil(s * 100 / o / 5) - 10) * e.N4;
  };
  function t(n, i, s) {
    switch (n) {
      case r.Patterns.PATTERN000:
        return (i + s) % 2 === 0;
      case r.Patterns.PATTERN001:
        return i % 2 === 0;
      case r.Patterns.PATTERN010:
        return s % 3 === 0;
      case r.Patterns.PATTERN011:
        return (i + s) % 3 === 0;
      case r.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(s / 3)) % 2 === 0;
      case r.Patterns.PATTERN101:
        return i * s % 2 + i * s % 3 === 0;
      case r.Patterns.PATTERN110:
        return (i * s % 2 + i * s % 3) % 2 === 0;
      case r.Patterns.PATTERN111:
        return (i * s % 3 + (i + s) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + n);
    }
  }
  r.applyMask = function(i, s) {
    const o = s.size;
    for (let a = 0; a < o; a++)
      for (let c = 0; c < o; c++)
        s.isReserved(c, a) || s.xor(c, a, t(i, c, a));
  }, r.getBestMask = function(i, s) {
    const o = Object.keys(r.Patterns).length;
    let a = 0, c = 1 / 0;
    for (let u = 0; u < o; u++) {
      s(u), r.applyMask(u, i);
      const f = r.getPenaltyN1(i) + r.getPenaltyN2(i) + r.getPenaltyN3(i) + r.getPenaltyN4(i);
      r.applyMask(u, i), f < c && (c = f, a = u);
    }
    return a;
  };
})(iM);
var I_ = {};
const Fu = A_, zv = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
], Vv = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
I_.getBlocksCount = function(e, t) {
  switch (t) {
    case Fu.L:
      return zv[(e - 1) * 4 + 0];
    case Fu.M:
      return zv[(e - 1) * 4 + 1];
    case Fu.Q:
      return zv[(e - 1) * 4 + 2];
    case Fu.H:
      return zv[(e - 1) * 4 + 3];
    default:
      return;
  }
};
I_.getTotalCodewordsCount = function(e, t) {
  switch (t) {
    case Fu.L:
      return Vv[(e - 1) * 4 + 0];
    case Fu.M:
      return Vv[(e - 1) * 4 + 1];
    case Fu.Q:
      return Vv[(e - 1) * 4 + 2];
    case Fu.H:
      return Vv[(e - 1) * 4 + 3];
    default:
      return;
  }
};
var sM = {}, R_ = {};
const am = new Uint8Array(512), n2 = new Uint8Array(256);
(function() {
  let e = 1;
  for (let t = 0; t < 255; t++)
    am[t] = e, n2[e] = t, e <<= 1, e & 256 && (e ^= 285);
  for (let t = 255; t < 512; t++)
    am[t] = am[t - 255];
})();
R_.log = function(e) {
  if (e < 1)
    throw new Error("log(" + e + ")");
  return n2[e];
};
R_.exp = function(e) {
  return am[e];
};
R_.mul = function(e, t) {
  return e === 0 || t === 0 ? 0 : am[n2[e] + n2[t]];
};
(function(r) {
  const e = R_;
  r.mul = function(n, i) {
    const s = new Uint8Array(n.length + i.length - 1);
    for (let o = 0; o < n.length; o++)
      for (let a = 0; a < i.length; a++)
        s[o + a] ^= e.mul(n[o], i[a]);
    return s;
  }, r.mod = function(n, i) {
    let s = new Uint8Array(n);
    for (; s.length - i.length >= 0; ) {
      const o = s[0];
      for (let c = 0; c < i.length; c++)
        s[c] ^= e.mul(i[c], o);
      let a = 0;
      for (; a < s.length && s[a] === 0; )
        a++;
      s = s.slice(a);
    }
    return s;
  }, r.generateECPolynomial = function(n) {
    let i = new Uint8Array([1]);
    for (let s = 0; s < n; s++)
      i = r.mul(i, new Uint8Array([1, e.exp(s)]));
    return i;
  };
})(sM);
const oM = sM;
function LS(r) {
  this.genPoly = void 0, this.degree = r, this.degree && this.initialize(this.degree);
}
LS.prototype.initialize = function(e) {
  this.degree = e, this.genPoly = oM.generateECPolynomial(this.degree);
};
LS.prototype.encode = function(e) {
  if (!this.genPoly)
    throw new Error("Encoder not initialized");
  const t = new Uint8Array(e.length + this.degree);
  t.set(e);
  const n = oM.mod(t, this.genPoly), i = this.degree - n.length;
  if (i > 0) {
    const s = new Uint8Array(this.degree);
    return s.set(n, i), s;
  }
  return n;
};
var _J = LS, aM = {}, hh = {}, BS = {};
BS.isValid = function(e) {
  return !isNaN(e) && e >= 1 && e <= 40;
};
var kc = {};
const cM = "[0-9]+", EJ = "[A-Z $%*+\\-./:]+";
let km = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
km = km.replace(/u/g, "\\u");
const xJ = "(?:(?![A-Z0-9 $%*+\\-./:]|" + km + `)(?:.|[\r
]))+`;
kc.KANJI = new RegExp(km, "g");
kc.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
kc.BYTE = new RegExp(xJ, "g");
kc.NUMERIC = new RegExp(cM, "g");
kc.ALPHANUMERIC = new RegExp(EJ, "g");
const SJ = new RegExp("^" + km + "$"), CJ = new RegExp("^" + cM + "$"), AJ = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
kc.testKanji = function(e) {
  return SJ.test(e);
};
kc.testNumeric = function(e) {
  return CJ.test(e);
};
kc.testAlphanumeric = function(e) {
  return AJ.test(e);
};
(function(r) {
  const e = BS, t = kc;
  r.NUMERIC = {
    id: "Numeric",
    bit: 1,
    ccBits: [10, 12, 14]
  }, r.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 2,
    ccBits: [9, 11, 13]
  }, r.BYTE = {
    id: "Byte",
    bit: 4,
    ccBits: [8, 16, 16]
  }, r.KANJI = {
    id: "Kanji",
    bit: 8,
    ccBits: [8, 10, 12]
  }, r.MIXED = {
    bit: -1
  }, r.getCharCountIndicator = function(s, o) {
    if (!s.ccBits)
      throw new Error("Invalid mode: " + s);
    if (!e.isValid(o))
      throw new Error("Invalid version: " + o);
    return o >= 1 && o < 10 ? s.ccBits[0] : o < 27 ? s.ccBits[1] : s.ccBits[2];
  }, r.getBestModeForData = function(s) {
    return t.testNumeric(s) ? r.NUMERIC : t.testAlphanumeric(s) ? r.ALPHANUMERIC : t.testKanji(s) ? r.KANJI : r.BYTE;
  }, r.toString = function(s) {
    if (s && s.id)
      return s.id;
    throw new Error("Invalid mode");
  }, r.isValid = function(s) {
    return s && s.bit && s.ccBits;
  };
  function n(i) {
    if (typeof i != "string")
      throw new Error("Param is not a string");
    switch (i.toLowerCase()) {
      case "numeric":
        return r.NUMERIC;
      case "alphanumeric":
        return r.ALPHANUMERIC;
      case "kanji":
        return r.KANJI;
      case "byte":
        return r.BYTE;
      default:
        throw new Error("Unknown mode: " + i);
    }
  }
  r.from = function(s, o) {
    if (r.isValid(s))
      return s;
    try {
      return n(s);
    } catch {
      return o;
    }
  };
})(hh);
(function(r) {
  const e = oo, t = I_, n = A_, i = hh, s = BS, o = 7973, a = e.getBCHDigit(o);
  function c(m, y, b) {
    for (let I = 1; I <= 40; I++)
      if (y <= r.getCapacity(I, b, m))
        return I;
  }
  function u(m, y) {
    return i.getCharCountIndicator(m, y) + 4;
  }
  function f(m, y) {
    let b = 0;
    return m.forEach(function(I) {
      const k = u(I.mode, y);
      b += k + I.getBitsLength();
    }), b;
  }
  function d(m, y) {
    for (let b = 1; b <= 40; b++)
      if (f(m, b) <= r.getCapacity(b, y, i.MIXED))
        return b;
  }
  r.from = function(y, b) {
    return s.isValid(y) ? parseInt(y, 10) : b;
  }, r.getCapacity = function(y, b, I) {
    if (!s.isValid(y))
      throw new Error("Invalid QR Code version");
    typeof I > "u" && (I = i.BYTE);
    const k = e.getSymbolTotalCodewords(y), R = t.getTotalCodewordsCount(y, b), T = (k - R) * 8;
    if (I === i.MIXED)
      return T;
    const $ = T - u(I, y);
    switch (I) {
      case i.NUMERIC:
        return Math.floor($ / 10 * 3);
      case i.ALPHANUMERIC:
        return Math.floor($ / 11 * 2);
      case i.KANJI:
        return Math.floor($ / 13);
      case i.BYTE:
      default:
        return Math.floor($ / 8);
    }
  }, r.getBestVersionForData = function(y, b) {
    let I;
    const k = n.from(b, n.M);
    if (Array.isArray(y)) {
      if (y.length > 1)
        return d(y, k);
      if (y.length === 0)
        return 1;
      I = y[0];
    } else
      I = y;
    return c(I.mode, I.getLength(), k);
  }, r.getEncodedBits = function(y) {
    if (!s.isValid(y) || y < 7)
      throw new Error("Invalid QR Code version");
    let b = y << 12;
    for (; e.getBCHDigit(b) - a >= 0; )
      b ^= o << e.getBCHDigit(b) - a;
    return y << 12 | b;
  };
})(aM);
var lM = {};
const A6 = oo, uM = 1335, IJ = 21522, bR = A6.getBCHDigit(uM);
lM.getEncodedBits = function(e, t) {
  const n = e.bit << 3 | t;
  let i = n << 10;
  for (; A6.getBCHDigit(i) - bR >= 0; )
    i ^= uM << A6.getBCHDigit(i) - bR;
  return (n << 10 | i) ^ IJ;
};
var hM = {};
const RJ = hh;
function tg(r) {
  this.mode = RJ.NUMERIC, this.data = r.toString();
}
tg.getBitsLength = function(e) {
  return 10 * Math.floor(e / 3) + (e % 3 ? e % 3 * 3 + 1 : 0);
};
tg.prototype.getLength = function() {
  return this.data.length;
};
tg.prototype.getBitsLength = function() {
  return tg.getBitsLength(this.data.length);
};
tg.prototype.write = function(e) {
  let t, n, i;
  for (t = 0; t + 3 <= this.data.length; t += 3)
    n = this.data.substr(t, 3), i = parseInt(n, 10), e.put(i, 10);
  const s = this.data.length - t;
  s > 0 && (n = this.data.substr(t), i = parseInt(n, 10), e.put(i, s * 3 + 1));
};
var TJ = tg;
const OJ = hh, k5 = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function rg(r) {
  this.mode = OJ.ALPHANUMERIC, this.data = r;
}
rg.getBitsLength = function(e) {
  return 11 * Math.floor(e / 2) + 6 * (e % 2);
};
rg.prototype.getLength = function() {
  return this.data.length;
};
rg.prototype.getBitsLength = function() {
  return rg.getBitsLength(this.data.length);
};
rg.prototype.write = function(e) {
  let t;
  for (t = 0; t + 2 <= this.data.length; t += 2) {
    let n = k5.indexOf(this.data[t]) * 45;
    n += k5.indexOf(this.data[t + 1]), e.put(n, 11);
  }
  this.data.length % 2 && e.put(k5.indexOf(this.data[t]), 6);
};
var NJ = rg, PJ = function(e) {
  for (var t = [], n = e.length, i = 0; i < n; i++) {
    var s = e.charCodeAt(i);
    if (s >= 55296 && s <= 56319 && n > i + 1) {
      var o = e.charCodeAt(i + 1);
      o >= 56320 && o <= 57343 && (s = (s - 55296) * 1024 + o - 56320 + 65536, i += 1);
    }
    if (s < 128) {
      t.push(s);
      continue;
    }
    if (s < 2048) {
      t.push(s >> 6 | 192), t.push(s & 63 | 128);
      continue;
    }
    if (s < 55296 || s >= 57344 && s < 65536) {
      t.push(s >> 12 | 224), t.push(s >> 6 & 63 | 128), t.push(s & 63 | 128);
      continue;
    }
    if (s >= 65536 && s <= 1114111) {
      t.push(s >> 18 | 240), t.push(s >> 12 & 63 | 128), t.push(s >> 6 & 63 | 128), t.push(s & 63 | 128);
      continue;
    }
    t.push(239, 191, 189);
  }
  return new Uint8Array(t).buffer;
};
const MJ = PJ, DJ = hh;
function ng(r) {
  this.mode = DJ.BYTE, typeof r == "string" && (r = MJ(r)), this.data = new Uint8Array(r);
}
ng.getBitsLength = function(e) {
  return e * 8;
};
ng.prototype.getLength = function() {
  return this.data.length;
};
ng.prototype.getBitsLength = function() {
  return ng.getBitsLength(this.data.length);
};
ng.prototype.write = function(r) {
  for (let e = 0, t = this.data.length; e < t; e++)
    r.put(this.data[e], 8);
};
var kJ = ng;
const $J = hh, LJ = oo;
function ig(r) {
  this.mode = $J.KANJI, this.data = r;
}
ig.getBitsLength = function(e) {
  return e * 13;
};
ig.prototype.getLength = function() {
  return this.data.length;
};
ig.prototype.getBitsLength = function() {
  return ig.getBitsLength(this.data.length);
};
ig.prototype.write = function(r) {
  let e;
  for (e = 0; e < this.data.length; e++) {
    let t = LJ.toSJIS(this.data[e]);
    if (t >= 33088 && t <= 40956)
      t -= 33088;
    else if (t >= 57408 && t <= 60351)
      t -= 49472;
    else
      throw new Error(
        "Invalid SJIS character: " + this.data[e] + `
Make sure your charset is UTF-8`
      );
    t = (t >>> 8 & 255) * 192 + (t & 255), r.put(t, 13);
  }
};
var BJ = ig, fM = { exports: {} };
(function(r) {
  var e = {
    single_source_shortest_paths: function(t, n, i) {
      var s = {}, o = {};
      o[n] = 0;
      var a = e.PriorityQueue.make();
      a.push(n, 0);
      for (var c, u, f, d, m, y, b, I, k; !a.empty(); ) {
        c = a.pop(), u = c.value, d = c.cost, m = t[u] || {};
        for (f in m)
          m.hasOwnProperty(f) && (y = m[f], b = d + y, I = o[f], k = typeof o[f] > "u", (k || I > b) && (o[f] = b, a.push(f, b), s[f] = u));
      }
      if (typeof i < "u" && typeof o[i] > "u") {
        var R = ["Could not find a path from ", n, " to ", i, "."].join("");
        throw new Error(R);
      }
      return s;
    },
    extract_shortest_path_from_predecessor_list: function(t, n) {
      for (var i = [], s = n; s; )
        i.push(s), t[s], s = t[s];
      return i.reverse(), i;
    },
    find_path: function(t, n, i) {
      var s = e.single_source_shortest_paths(t, n, i);
      return e.extract_shortest_path_from_predecessor_list(
        s,
        i
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(t) {
        var n = e.PriorityQueue, i = {}, s;
        t = t || {};
        for (s in n)
          n.hasOwnProperty(s) && (i[s] = n[s]);
        return i.queue = [], i.sorter = t.sorter || n.default_sorter, i;
      },
      default_sorter: function(t, n) {
        return t.cost - n.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(t, n) {
        var i = { value: t, cost: n };
        this.queue.push(i), this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  r.exports = e;
})(fM);
var FJ = fM.exports;
(function(r) {
  const e = hh, t = TJ, n = NJ, i = kJ, s = BJ, o = kc, a = oo, c = FJ;
  function u(R) {
    return unescape(encodeURIComponent(R)).length;
  }
  function f(R, T, $) {
    const D = [];
    let L;
    for (; (L = R.exec($)) !== null; )
      D.push({
        data: L[0],
        index: L.index,
        mode: T,
        length: L[0].length
      });
    return D;
  }
  function d(R) {
    const T = f(o.NUMERIC, e.NUMERIC, R), $ = f(o.ALPHANUMERIC, e.ALPHANUMERIC, R);
    let D, L;
    return a.isKanjiModeEnabled() ? (D = f(o.BYTE, e.BYTE, R), L = f(o.KANJI, e.KANJI, R)) : (D = f(o.BYTE_KANJI, e.BYTE, R), L = []), T.concat($, D, L).sort(function(v, F) {
      return v.index - F.index;
    }).map(function(v) {
      return {
        data: v.data,
        mode: v.mode,
        length: v.length
      };
    });
  }
  function m(R, T) {
    switch (T) {
      case e.NUMERIC:
        return t.getBitsLength(R);
      case e.ALPHANUMERIC:
        return n.getBitsLength(R);
      case e.KANJI:
        return s.getBitsLength(R);
      case e.BYTE:
        return i.getBitsLength(R);
    }
  }
  function y(R) {
    return R.reduce(function(T, $) {
      const D = T.length - 1 >= 0 ? T[T.length - 1] : null;
      return D && D.mode === $.mode ? (T[T.length - 1].data += $.data, T) : (T.push($), T);
    }, []);
  }
  function b(R) {
    const T = [];
    for (let $ = 0; $ < R.length; $++) {
      const D = R[$];
      switch (D.mode) {
        case e.NUMERIC:
          T.push([
            D,
            { data: D.data, mode: e.ALPHANUMERIC, length: D.length },
            { data: D.data, mode: e.BYTE, length: D.length }
          ]);
          break;
        case e.ALPHANUMERIC:
          T.push([
            D,
            { data: D.data, mode: e.BYTE, length: D.length }
          ]);
          break;
        case e.KANJI:
          T.push([
            D,
            { data: D.data, mode: e.BYTE, length: u(D.data) }
          ]);
          break;
        case e.BYTE:
          T.push([
            { data: D.data, mode: e.BYTE, length: u(D.data) }
          ]);
      }
    }
    return T;
  }
  function I(R, T) {
    const $ = {}, D = { start: {} };
    let L = ["start"];
    for (let P = 0; P < R.length; P++) {
      const v = R[P], F = [];
      for (let X = 0; X < v.length; X++) {
        const te = v[X], se = "" + P + X;
        F.push(se), $[se] = { node: te, lastCount: 0 }, D[se] = {};
        for (let we = 0; we < L.length; we++) {
          const H = L[we];
          $[H] && $[H].node.mode === te.mode ? (D[H][se] = m($[H].lastCount + te.length, te.mode) - m($[H].lastCount, te.mode), $[H].lastCount += te.length) : ($[H] && ($[H].lastCount = te.length), D[H][se] = m(te.length, te.mode) + 4 + e.getCharCountIndicator(te.mode, T));
        }
      }
      L = F;
    }
    for (let P = 0; P < L.length; P++)
      D[L[P]].end = 0;
    return { map: D, table: $ };
  }
  function k(R, T) {
    let $;
    const D = e.getBestModeForData(R);
    if ($ = e.from(T, D), $ !== e.BYTE && $.bit < D.bit)
      throw new Error('"' + R + '" cannot be encoded with mode ' + e.toString($) + `.
 Suggested mode is: ` + e.toString(D));
    switch ($ === e.KANJI && !a.isKanjiModeEnabled() && ($ = e.BYTE), $) {
      case e.NUMERIC:
        return new t(R);
      case e.ALPHANUMERIC:
        return new n(R);
      case e.KANJI:
        return new s(R);
      case e.BYTE:
        return new i(R);
    }
  }
  r.fromArray = function(T) {
    return T.reduce(function($, D) {
      return typeof D == "string" ? $.push(k(D, null)) : D.data && $.push(k(D.data, D.mode)), $;
    }, []);
  }, r.fromString = function(T, $) {
    const D = d(T, a.isKanjiModeEnabled()), L = b(D), P = I(L, $), v = c.find_path(P.map, "start", "end"), F = [];
    for (let X = 1; X < v.length - 1; X++)
      F.push(P.table[v[X]].node);
    return r.fromArray(y(F));
  }, r.rawSplit = function(T) {
    return r.fromArray(
      d(T, a.isKanjiModeEnabled())
    );
  };
})(hM);
const T_ = oo, $5 = A_, UJ = yJ, jJ = vJ, WJ = rM, HJ = nM, I6 = iM, R6 = I_, zJ = _J, i2 = aM, VJ = lM, qJ = hh, L5 = hM;
function GJ(r, e) {
  const t = r.size, n = HJ.getPositions(e);
  for (let i = 0; i < n.length; i++) {
    const s = n[i][0], o = n[i][1];
    for (let a = -1; a <= 7; a++)
      if (!(s + a <= -1 || t <= s + a))
        for (let c = -1; c <= 7; c++)
          o + c <= -1 || t <= o + c || (a >= 0 && a <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (a === 0 || a === 6) || a >= 2 && a <= 4 && c >= 2 && c <= 4 ? r.set(s + a, o + c, !0, !0) : r.set(s + a, o + c, !1, !0));
  }
}
function KJ(r) {
  const e = r.size;
  for (let t = 8; t < e - 8; t++) {
    const n = t % 2 === 0;
    r.set(t, 6, n, !0), r.set(6, t, n, !0);
  }
}
function ZJ(r, e) {
  const t = WJ.getPositions(e);
  for (let n = 0; n < t.length; n++) {
    const i = t[n][0], s = t[n][1];
    for (let o = -2; o <= 2; o++)
      for (let a = -2; a <= 2; a++)
        o === -2 || o === 2 || a === -2 || a === 2 || o === 0 && a === 0 ? r.set(i + o, s + a, !0, !0) : r.set(i + o, s + a, !1, !0);
  }
}
function JJ(r, e) {
  const t = r.size, n = i2.getEncodedBits(e);
  let i, s, o;
  for (let a = 0; a < 18; a++)
    i = Math.floor(a / 3), s = a % 3 + t - 8 - 3, o = (n >> a & 1) === 1, r.set(i, s, o, !0), r.set(s, i, o, !0);
}
function B5(r, e, t) {
  const n = r.size, i = VJ.getEncodedBits(e, t);
  let s, o;
  for (s = 0; s < 15; s++)
    o = (i >> s & 1) === 1, s < 6 ? r.set(s, 8, o, !0) : s < 8 ? r.set(s + 1, 8, o, !0) : r.set(n - 15 + s, 8, o, !0), s < 8 ? r.set(8, n - s - 1, o, !0) : s < 9 ? r.set(8, 15 - s - 1 + 1, o, !0) : r.set(8, 15 - s - 1, o, !0);
  r.set(n - 8, 8, 1, !0);
}
function QJ(r, e) {
  const t = r.size;
  let n = -1, i = t - 1, s = 7, o = 0;
  for (let a = t - 1; a > 0; a -= 2)
    for (a === 6 && a--; ; ) {
      for (let c = 0; c < 2; c++)
        if (!r.isReserved(i, a - c)) {
          let u = !1;
          o < e.length && (u = (e[o] >>> s & 1) === 1), r.set(i, a - c, u), s--, s === -1 && (o++, s = 7);
        }
      if (i += n, i < 0 || t <= i) {
        i -= n, n = -n;
        break;
      }
    }
}
function YJ(r, e, t) {
  const n = new UJ();
  t.forEach(function(c) {
    n.put(c.mode.bit, 4), n.put(c.getLength(), qJ.getCharCountIndicator(c.mode, r)), c.write(n);
  });
  const i = T_.getSymbolTotalCodewords(r), s = R6.getTotalCodewordsCount(r, e), o = (i - s) * 8;
  for (n.getLengthInBits() + 4 <= o && n.put(0, 4); n.getLengthInBits() % 8 !== 0; )
    n.putBit(0);
  const a = (o - n.getLengthInBits()) / 8;
  for (let c = 0; c < a; c++)
    n.put(c % 2 ? 17 : 236, 8);
  return XJ(n, r, e);
}
function XJ(r, e, t) {
  const n = T_.getSymbolTotalCodewords(e), i = R6.getTotalCodewordsCount(e, t), s = n - i, o = R6.getBlocksCount(e, t), a = n % o, c = o - a, u = Math.floor(n / o), f = Math.floor(s / o), d = f + 1, m = u - f, y = new zJ(m);
  let b = 0;
  const I = new Array(o), k = new Array(o);
  let R = 0;
  const T = new Uint8Array(r.buffer);
  for (let v = 0; v < o; v++) {
    const F = v < c ? f : d;
    I[v] = T.slice(b, b + F), k[v] = y.encode(I[v]), b += F, R = Math.max(R, F);
  }
  const $ = new Uint8Array(n);
  let D = 0, L, P;
  for (L = 0; L < R; L++)
    for (P = 0; P < o; P++)
      L < I[P].length && ($[D++] = I[P][L]);
  for (L = 0; L < m; L++)
    for (P = 0; P < o; P++)
      $[D++] = k[P][L];
  return $;
}
function eQ(r, e, t, n) {
  let i;
  if (Array.isArray(r))
    i = L5.fromArray(r);
  else if (typeof r == "string") {
    let u = e;
    if (!u) {
      const f = L5.rawSplit(r);
      u = i2.getBestVersionForData(f, t);
    }
    i = L5.fromString(r, u || 40);
  } else
    throw new Error("Invalid data");
  const s = i2.getBestVersionForData(i, t);
  if (!s)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (!e)
    e = s;
  else if (e < s)
    throw new Error(
      `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + s + `.
`
    );
  const o = YJ(e, t, i), a = T_.getSymbolSize(e), c = new jJ(a);
  return GJ(c, e), KJ(c), ZJ(c, e), B5(c, t, 0), e >= 7 && JJ(c, e), QJ(c, o), isNaN(n) && (n = I6.getBestMask(
    c,
    B5.bind(null, c, t)
  )), I6.applyMask(n, c), B5(c, t, n), {
    modules: c,
    version: e,
    errorCorrectionLevel: t,
    maskPattern: n,
    segments: i
  };
}
eM.create = function(e, t) {
  if (typeof e > "u" || e === "")
    throw new Error("No input text");
  let n = $5.M, i, s;
  return typeof t < "u" && (n = $5.from(t.errorCorrectionLevel, $5.M), i = i2.from(t.version), s = I6.from(t.maskPattern), t.toSJISFunc && T_.setToSJISFunction(t.toSJISFunc)), eQ(e, i, n, s);
};
var dM = {}, FS = {};
(function(r) {
  function e(t) {
    if (typeof t == "number" && (t = t.toString()), typeof t != "string")
      throw new Error("Color should be defined as hex string");
    let n = t.slice().replace("#", "").split("");
    if (n.length < 3 || n.length === 5 || n.length > 8)
      throw new Error("Invalid hex color: " + t);
    (n.length === 3 || n.length === 4) && (n = Array.prototype.concat.apply([], n.map(function(s) {
      return [s, s];
    }))), n.length === 6 && n.push("F", "F");
    const i = parseInt(n.join(""), 16);
    return {
      r: i >> 24 & 255,
      g: i >> 16 & 255,
      b: i >> 8 & 255,
      a: i & 255,
      hex: "#" + n.slice(0, 6).join("")
    };
  }
  r.getOptions = function(n) {
    n || (n = {}), n.color || (n.color = {});
    const i = typeof n.margin > "u" || n.margin === null || n.margin < 0 ? 4 : n.margin, s = n.width && n.width >= 21 ? n.width : void 0, o = n.scale || 4;
    return {
      width: s,
      scale: s ? 4 : o,
      margin: i,
      color: {
        dark: e(n.color.dark || "#000000ff"),
        light: e(n.color.light || "#ffffffff")
      },
      type: n.type,
      rendererOpts: n.rendererOpts || {}
    };
  }, r.getScale = function(n, i) {
    return i.width && i.width >= n + i.margin * 2 ? i.width / (n + i.margin * 2) : i.scale;
  }, r.getImageWidth = function(n, i) {
    const s = r.getScale(n, i);
    return Math.floor((n + i.margin * 2) * s);
  }, r.qrToImageData = function(n, i, s) {
    const o = i.modules.size, a = i.modules.data, c = r.getScale(o, s), u = Math.floor((o + s.margin * 2) * c), f = s.margin * c, d = [s.color.light, s.color.dark];
    for (let m = 0; m < u; m++)
      for (let y = 0; y < u; y++) {
        let b = (m * u + y) * 4, I = s.color.light;
        if (m >= f && y >= f && m < u - f && y < u - f) {
          const k = Math.floor((m - f) / c), R = Math.floor((y - f) / c);
          I = d[a[k * o + R] ? 1 : 0];
        }
        n[b++] = I.r, n[b++] = I.g, n[b++] = I.b, n[b] = I.a;
      }
  };
})(FS);
(function(r) {
  const e = FS;
  function t(i, s, o) {
    i.clearRect(0, 0, s.width, s.height), s.style || (s.style = {}), s.height = o, s.width = o, s.style.height = o + "px", s.style.width = o + "px";
  }
  function n() {
    try {
      return document.createElement("canvas");
    } catch {
      throw new Error("You need to specify a canvas element");
    }
  }
  r.render = function(s, o, a) {
    let c = a, u = o;
    typeof c > "u" && (!o || !o.getContext) && (c = o, o = void 0), o || (u = n()), c = e.getOptions(c);
    const f = e.getImageWidth(s.modules.size, c), d = u.getContext("2d"), m = d.createImageData(f, f);
    return e.qrToImageData(m.data, s, c), t(d, u, f), d.putImageData(m, 0, 0), u;
  }, r.renderToDataURL = function(s, o, a) {
    let c = a;
    typeof c > "u" && (!o || !o.getContext) && (c = o, o = void 0), c || (c = {});
    const u = r.render(s, o, c), f = c.type || "image/png", d = c.rendererOpts || {};
    return u.toDataURL(f, d.quality);
  };
})(dM);
var pM = {};
const tQ = FS;
function _R(r, e) {
  const t = r.a / 255, n = e + '="' + r.hex + '"';
  return t < 1 ? n + " " + e + '-opacity="' + t.toFixed(2).slice(1) + '"' : n;
}
function F5(r, e, t) {
  let n = r + e;
  return typeof t < "u" && (n += " " + t), n;
}
function rQ(r, e, t) {
  let n = "", i = 0, s = !1, o = 0;
  for (let a = 0; a < r.length; a++) {
    const c = Math.floor(a % e), u = Math.floor(a / e);
    !c && !s && (s = !0), r[a] ? (o++, a > 0 && c > 0 && r[a - 1] || (n += s ? F5("M", c + t, 0.5 + u + t) : F5("m", i, 0), i = 0, s = !1), c + 1 < e && r[a + 1] || (n += F5("h", o), o = 0)) : i++;
  }
  return n;
}
pM.render = function(e, t, n) {
  const i = tQ.getOptions(t), s = e.modules.size, o = e.modules.data, a = s + i.margin * 2, c = i.color.light.a ? "<path " + _R(i.color.light, "fill") + ' d="M0 0h' + a + "v" + a + 'H0z"/>' : "", u = "<path " + _R(i.color.dark, "stroke") + ' d="' + rQ(o, s, i.margin) + '"/>', f = 'viewBox="0 0 ' + a + " " + a + '"', m = '<svg xmlns="http://www.w3.org/2000/svg" ' + (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") + f + ' shape-rendering="crispEdges">' + c + u + `</svg>
`;
  return typeof n == "function" && n(null, m), m;
};
const nQ = mJ, T6 = eM, gM = dM, iQ = pM;
function US(r, e, t, n, i) {
  const s = [].slice.call(arguments, 1), o = s.length, a = typeof s[o - 1] == "function";
  if (!a && !nQ())
    throw new Error("Callback required as last argument");
  if (a) {
    if (o < 2)
      throw new Error("Too few arguments provided");
    o === 2 ? (i = t, t = e, e = n = void 0) : o === 3 && (e.getContext && typeof i > "u" ? (i = n, n = void 0) : (i = n, n = t, t = e, e = void 0));
  } else {
    if (o < 1)
      throw new Error("Too few arguments provided");
    return o === 1 ? (t = e, e = n = void 0) : o === 2 && !e.getContext && (n = t, t = e, e = void 0), new Promise(function(c, u) {
      try {
        const f = T6.create(t, n);
        c(r(f, e, n));
      } catch (f) {
        u(f);
      }
    });
  }
  try {
    const c = T6.create(t, n);
    i(null, r(c, e, n));
  } catch (c) {
    i(c);
  }
}
Jw.create = T6.create;
Jw.toCanvas = US.bind(null, gM.render);
Jw.toDataURL = US.bind(null, gM.renderToDataURL);
Jw.toString = US.bind(null, function(r, e, t) {
  return iQ.render(r, t);
});
const sQ = 0.1, ER = 2.5, Zc = 7;
function U5(r, e, t) {
  return r === e ? !1 : (r - e < 0 ? e - r : r - e) <= t + sQ;
}
function oQ(r, e) {
  const t = Array.prototype.slice.call(Jw.create(r, { errorCorrectionLevel: e }).modules.data, 0), n = Math.sqrt(t.length);
  return t.reduce((i, s, o) => (o % n === 0 ? i.push([s]) : i[i.length - 1].push(s)) && i, []);
}
const aQ = {
  generate(r, e, t) {
    const n = "#141414", i = "transparent", o = [], a = oQ(r, "Q"), c = e / a.length, u = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    u.forEach(({ x: I, y: k }) => {
      const R = (a.length - Zc) * c * I, T = (a.length - Zc) * c * k, $ = 0.45;
      for (let D = 0; D < u.length; D += 1) {
        const L = c * (Zc - D * 2);
        o.push(Ke`
            <rect
              fill=${D === 2 ? n : i}
              width=${D === 0 ? L - 5 : L}
              rx= ${D === 0 ? (L - 5) * $ : L * $}
              ry= ${D === 0 ? (L - 5) * $ : L * $}
              stroke=${n}
              stroke-width=${D === 0 ? 5 : 0}
              height=${D === 0 ? L - 5 : L}
              x= ${D === 0 ? T + c * D + 5 / 2 : T + c * D}
              y= ${D === 0 ? R + c * D + 5 / 2 : R + c * D}
            />
          `);
      }
    });
    const f = Math.floor((t + 25) / c), d = a.length / 2 - f / 2, m = a.length / 2 + f / 2 - 1, y = [];
    a.forEach((I, k) => {
      I.forEach((R, T) => {
        if (a[k][T] && !(k < Zc && T < Zc || k > a.length - (Zc + 1) && T < Zc || k < Zc && T > a.length - (Zc + 1)) && !(k > d && k < m && T > d && T < m)) {
          const $ = k * c + c / 2, D = T * c + c / 2;
          y.push([$, D]);
        }
      });
    });
    const b = {};
    return y.forEach(([I, k]) => {
      var R;
      b[I] ? (R = b[I]) == null || R.push(k) : b[I] = [k];
    }), Object.entries(b).map(([I, k]) => {
      const R = k.filter((T) => k.every(($) => !U5(T, $, c)));
      return [Number(I), R];
    }).forEach(([I, k]) => {
      k.forEach((R) => {
        o.push(Ke`<circle cx=${I} cy=${R} fill=${n} r=${c / ER} />`);
      });
    }), Object.entries(b).filter(([I, k]) => k.length > 1).map(([I, k]) => {
      const R = k.filter((T) => k.some(($) => U5(T, $, c)));
      return [Number(I), R];
    }).map(([I, k]) => {
      k.sort((T, $) => T < $ ? -1 : 1);
      const R = [];
      for (const T of k) {
        const $ = R.find((D) => D.some((L) => U5(T, L, c)));
        $ ? $.push(T) : R.push([T]);
      }
      return [I, R.map((T) => [T[0], T[T.length - 1]])];
    }).forEach(([I, k]) => {
      k.forEach(([R, T]) => {
        o.push(Ke`
              <line
                x1=${I}
                x2=${I}
                y1=${R}
                y2=${T}
                stroke=${n}
                stroke-width=${c / (ER / 2)}
                stroke-linecap="round"
              />
            `);
      });
    }), o;
  }
}, cQ = mt`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var Lg = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Pl = class extends bt {
  constructor() {
    super(...arguments), this.uri = "", this.size = 0, this.theme = "dark", this.imageSrc = void 0, this.alt = void 0;
  }
  render() {
    return this.dataset.theme = this.theme, this.style.cssText = `--local-size: ${this.size}px`, Ne`${this.templateVisual()} ${this.templateSvg()}`;
  }
  templateSvg() {
    const e = this.theme === "light" ? this.size : this.size - 32;
    return Ke`
      <svg height=${e} width=${e}>
        ${aQ.generate(this.uri, e, e / 4)}
      </svg>
    `;
  }
  templateVisual() {
    return this.imageSrc ? Ne`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>` : Ne`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
  }
};
Pl.styles = [Pt, cQ];
Lg([
  he()
], Pl.prototype, "uri", void 0);
Lg([
  he({ type: Number })
], Pl.prototype, "size", void 0);
Lg([
  he()
], Pl.prototype, "theme", void 0);
Lg([
  he()
], Pl.prototype, "imageSrc", void 0);
Lg([
  he()
], Pl.prototype, "alt", void 0);
Pl = Lg([
  $e("wui-qr-code")
], Pl);
const lQ = mt`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var uQ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let s2 = class extends bt {
  constructor() {
    super(...arguments), this.inputComponentRef = ZP();
  }
  render() {
    return Ne`
      <wui-input-text
        ${JP(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `;
  }
  clearValue() {
    const e = this.inputComponentRef.value, t = e == null ? void 0 : e.inputElementRef.value;
    t && (t.value = "", t.focus(), t.dispatchEvent(new Event("input")));
  }
};
s2.styles = [Pt, lQ];
s2 = uQ([
  $e("wui-search-bar")
], s2);
const hQ = mt`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }
`;
var Yw = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Zu = class extends bt {
  constructor() {
    super(...arguments), this.backgroundColor = "accent-100", this.iconColor = "accent-100", this.icon = "checkmark", this.message = "";
  }
  render() {
    return Ne`
      <wui-icon-box
        size="sm"
        iconSize="xs"
        iconColor=${this.iconColor}
        backgroundColor=${this.backgroundColor}
        icon=${this.icon}
        background="opaque"
      ></wui-icon-box>
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `;
  }
};
Zu.styles = [Pt, hQ];
Yw([
  he()
], Zu.prototype, "backgroundColor", void 0);
Yw([
  he()
], Zu.prototype, "iconColor", void 0);
Yw([
  he()
], Zu.prototype, "icon", void 0);
Yw([
  he()
], Zu.prototype, "message", void 0);
Zu = Yw([
  $e("wui-snackbar")
], Zu);
const fQ = mt`
  :host {
    display: inline-flex;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  button {
    width: var(--local-tab-width);
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var fh = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Pa = class extends bt {
  constructor() {
    super(...arguments), this.tabs = [], this.onTabChange = () => null, this.buttons = [], this.disabled = !1, this.activeTab = 0, this.localTabWidth = "100px", this.isDense = !1;
  }
  render() {
    return this.isDense = this.tabs.length > 3, this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `, this.dataset.type = this.isDense ? "flex" : "block", this.tabs.map((e, t) => {
      const n = t === this.activeTab;
      return Ne`
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(t)}
          data-active=${n}
        >
          <wui-icon size="xs" color="inherit" name=${e.icon}></wui-icon>
          <wui-text variant="small-600" color="inherit"> ${e.label} </wui-text>
        </button>
      `;
    });
  }
  firstUpdated() {
    this.shadowRoot && this.isDense && (this.buttons = [...this.shadowRoot.querySelectorAll("button")], setTimeout(() => {
      this.animateTabs(0, !0);
    }, 0));
  }
  onTabClick(e) {
    this.buttons && this.animateTabs(e, !1), this.activeTab = e, this.onTabChange(e);
  }
  animateTabs(e, t) {
    const n = this.buttons[this.activeTab], i = this.buttons[e], s = n == null ? void 0 : n.querySelector("wui-text"), o = i == null ? void 0 : i.querySelector("wui-text"), a = i == null ? void 0 : i.getBoundingClientRect(), c = o == null ? void 0 : o.getBoundingClientRect();
    n && s && !t && e !== this.activeTab && (s.animate([{ opacity: 0 }], {
      duration: 50,
      easing: "ease",
      fill: "forwards"
    }), n.animate([{ width: "34px" }], {
      duration: 500,
      easing: "ease",
      fill: "forwards"
    })), i && a && c && o && (e !== this.activeTab || t) && (this.localTabWidth = `${Math.round(a.width + c.width) + 6}px`, i.animate([{ width: `${a.width + c.width}px` }], {
      duration: t ? 0 : 500,
      fill: "forwards",
      easing: "ease"
    }), o.animate([{ opacity: 1 }], {
      duration: t ? 0 : 125,
      delay: t ? 0 : 200,
      fill: "forwards",
      easing: "ease"
    }));
  }
};
Pa.styles = [Pt, vn, fQ];
fh([
  he({ type: Array })
], Pa.prototype, "tabs", void 0);
fh([
  he()
], Pa.prototype, "onTabChange", void 0);
fh([
  he({ type: Array })
], Pa.prototype, "buttons", void 0);
fh([
  he({ type: Boolean })
], Pa.prototype, "disabled", void 0);
fh([
  y_()
], Pa.prototype, "activeTab", void 0);
fh([
  y_()
], Pa.prototype, "localTabWidth", void 0);
fh([
  y_()
], Pa.prototype, "isDense", void 0);
Pa = fh([
  $e("wui-tabs")
], Pa);
const dQ = mt`
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    background-color: var(--wui-color-fg-100);
    color: var(--wui-color-bg-100);
    position: relative;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var jS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let sg = class extends bt {
  constructor() {
    super(...arguments), this.placement = "top", this.message = "";
  }
  render() {
    return Ne`<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name="cursor"
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`;
  }
};
sg.styles = [Pt, vn, dQ];
jS([
  he()
], sg.prototype, "placement", void 0);
jS([
  he()
], sg.prototype, "message", void 0);
sg = jS([
  $e("wui-tooltip")
], sg);
const pQ = mt`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var O_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Xf = class extends bt {
  render() {
    return this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"};`, Ne`${this.templateVisual()}`;
  }
  templateVisual() {
    return this.imageSrc ? Ne`<wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></wui-image>` : Ne`<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
Xf.styles = [Pt, pQ];
O_([
  he()
], Xf.prototype, "imageSrc", void 0);
O_([
  he()
], Xf.prototype, "alt", void 0);
O_([
  he({ type: Boolean })
], Xf.prototype, "borderRadiusFull", void 0);
Xf = O_([
  $e("wui-visual-thumbnail")
], Xf);
const gQ = mt`
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-accent-glass-015);
  }

  button:hover {
    background-color: var(--wui-accent-glass-010) !important;
  }

  button:active {
    background-color: var(--wui-accent-glass-020) !important;
  }
`;
var N_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let ed = class extends bt {
  constructor() {
    super(...arguments), this.label = "", this.description = "", this.icon = "wallet";
  }
  render() {
    return Ne`
      <button>
        <wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></wui-icon-box>

          <wui-flex flexDirection="column" gap="3xs">
            <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
            <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
          </wui-flex>

          <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
        </wui-flex>
      </button>
    `;
  }
};
ed.styles = [Pt, vn, gQ];
N_([
  he()
], ed.prototype, "label", void 0);
N_([
  he()
], ed.prototype, "description", void 0);
N_([
  he()
], ed.prototype, "icon", void 0);
ed = N_([
  $e("wui-notice-card")
], ed);
const mQ = mt`
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-200), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;
var WS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const j5 = 100;
let og = class extends bt {
  constructor() {
    super(...arguments), this.textTitle = "", this.overflowedContent = "", this.toggled = !1, this.enableAccordion = !1, this.scrollElement = void 0, this.scrollHeightElement = 0;
  }
  firstUpdated() {
    setTimeout(() => {
      var t;
      const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector(".heightContent");
      if (e) {
        this.scrollElement = e;
        const n = e == null ? void 0 : e.scrollHeight;
        n && n > j5 && (this.enableAccordion = !0, this.scrollHeightElement = n, this.requestUpdate());
      }
    }, 0);
  }
  render() {
    return Ne`
      <button ontouchstart @click=${() => this.onClick()}>
        <wui-flex justifyContent="space-between" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
          ${this.chevronTemplate()}
        </wui-flex>
        <div
          data-active=${this.enableAccordion ? !!this.toggled : !0}
          class="overflowedContent"
        >
          <div class="heightContent">
            <wui-text variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </wui-text>
          </div>
        </div>
      </button>
    `;
  }
  onClick() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector("wui-icon");
    this.enableAccordion && (this.toggled = !this.toggled, this.requestUpdate(), this.scrollElement && this.scrollElement.animate([
      { maxHeight: this.toggled ? `${j5}px` : `${this.scrollHeightElement}px` },
      { maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${j5}px` }
    ], {
      duration: 300,
      fill: "forwards",
      easing: "ease"
    }), e && e.animate([
      { transform: this.toggled ? "rotate(0deg)" : "rotate(180deg)" },
      { transform: this.toggled ? "rotate(180deg)" : "rotate(0deg)" }
    ], {
      duration: 300,
      fill: "forwards",
      easing: "ease"
    }));
  }
  chevronTemplate() {
    return this.enableAccordion ? Ne` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>` : null;
  }
};
og.styles = [Pt, vn, mQ];
WS([
  he()
], og.prototype, "textTitle", void 0);
WS([
  he()
], og.prototype, "overflowedContent", void 0);
og = WS([
  $e("wui-list-accordion")
], og);
const wQ = mt`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var P_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let td = class extends bt {
  constructor() {
    super(...arguments), this.imageSrc = void 0, this.textTitle = "", this.textValue = void 0;
  }
  render() {
    return Ne`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color=${this.textValue ? "fg-200" : "fg-100"}>
          ${this.textTitle}
        </wui-text>
        ${this.templateContent()}
      </wui-flex>
    `;
  }
  templateContent() {
    return this.imageSrc ? Ne`<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>` : this.textValue ? Ne` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>` : Ne`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
td.styles = [Pt, vn, wQ];
P_([
  he()
], td.prototype, "imageSrc", void 0);
P_([
  he()
], td.prototype, "textTitle", void 0);
P_([
  he()
], td.prototype, "textValue", void 0);
td = P_([
  $e("wui-list-content")
], td);
const yQ = mt`
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var Xw = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Ju = class extends bt {
  constructor() {
    super(...arguments), this.amount = "", this.networkCurreny = "", this.networkImageUrl = "", this.receiverAddress = "";
  }
  render() {
    return Ne`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </wui-text>
          ${this.templateNetworkVisual()}
        </wui-flex>
      </wui-flex>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
        <wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.receiverAddress}
          title=${this.receiverAddress}
        ></wui-chip>
      </wui-flex>
    `;
  }
  templateNetworkVisual() {
    return this.networkImageUrl ? Ne`<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>` : Ne`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
Ju.styles = [Pt, vn, yQ];
Xw([
  he()
], Ju.prototype, "amount", void 0);
Xw([
  he()
], Ju.prototype, "networkCurreny", void 0);
Xw([
  he()
], Ju.prototype, "networkImageUrl", void 0);
Xw([
  he()
], Ju.prototype, "receiverAddress", void 0);
Ju = Xw([
  $e("wui-list-wallet-transaction")
], Ju);
const vQ = mt`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var Ho = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let cs = class extends bt {
  render() {
    return this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && jr.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && jr.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && jr.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && jr.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && jr.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && jr.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && jr.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && jr.getSpacingStyles(this.margin, 3)};
    `, Ne`<slot></slot>`;
  }
};
cs.styles = [Pt, vQ];
Ho([
  he()
], cs.prototype, "gridTemplateRows", void 0);
Ho([
  he()
], cs.prototype, "gridTemplateColumns", void 0);
Ho([
  he()
], cs.prototype, "justifyItems", void 0);
Ho([
  he()
], cs.prototype, "alignItems", void 0);
Ho([
  he()
], cs.prototype, "justifyContent", void 0);
Ho([
  he()
], cs.prototype, "alignContent", void 0);
Ho([
  he()
], cs.prototype, "columnGap", void 0);
Ho([
  he()
], cs.prototype, "rowGap", void 0);
Ho([
  he()
], cs.prototype, "gap", void 0);
Ho([
  he()
], cs.prototype, "padding", void 0);
Ho([
  he()
], cs.prototype, "margin", void 0);
cs = Ho([
  $e("wui-grid")
], cs);
const bQ = mt`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
  }
`;
var mM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let $m = class extends bt {
  constructor() {
    super(...arguments), this.text = "";
  }
  render() {
    return Ne`${this.template()}`;
  }
  template() {
    return this.text ? Ne`<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>` : null;
  }
};
$m.styles = [Pt, bQ];
mM([
  he()
], $m.prototype, "text", void 0);
$m = mM([
  $e("wui-separator")
], $m);
var wM = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(ze, function() {
    var t = 1e3, n = 6e4, i = 36e5, s = "millisecond", o = "second", a = "minute", c = "hour", u = "day", f = "week", d = "month", m = "quarter", y = "year", b = "date", I = "Invalid Date", k = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, R = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, T = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(p) {
      var w = ["th", "st", "nd", "rd"], x = p % 100;
      return "[" + p + (w[(x - 20) % 10] || w[x] || w[0]) + "]";
    } }, $ = function(p, w, x) {
      var N = String(p);
      return !N || N.length >= w ? p : "" + Array(w + 1 - N.length).join(x) + p;
    }, D = { s: $, z: function(p) {
      var w = -p.utcOffset(), x = Math.abs(w), N = Math.floor(x / 60), O = x % 60;
      return (w <= 0 ? "+" : "-") + $(N, 2, "0") + ":" + $(O, 2, "0");
    }, m: function p(w, x) {
      if (w.date() < x.date())
        return -p(x, w);
      var N = 12 * (x.year() - w.year()) + (x.month() - w.month()), O = w.clone().add(N, d), U = x - O < 0, q = w.clone().add(N + (U ? -1 : 1), d);
      return +(-(N + (x - O) / (U ? O - q : q - O)) || 0);
    }, a: function(p) {
      return p < 0 ? Math.ceil(p) || 0 : Math.floor(p);
    }, p: function(p) {
      return { M: d, y, w: f, d: u, D: b, h: c, m: a, s: o, ms: s, Q: m }[p] || String(p || "").toLowerCase().replace(/s$/, "");
    }, u: function(p) {
      return p === void 0;
    } }, L = "en", P = {};
    P[L] = T;
    var v = "$isDayjsObject", F = function(p) {
      return p instanceof we || !(!p || !p[v]);
    }, X = function p(w, x, N) {
      var O;
      if (!w)
        return L;
      if (typeof w == "string") {
        var U = w.toLowerCase();
        P[U] && (O = U), x && (P[U] = x, O = U);
        var q = w.split("-");
        if (!O && q.length > 1)
          return p(q[0]);
      } else {
        var B = w.name;
        P[B] = w, O = B;
      }
      return !N && O && (L = O), O || !N && L;
    }, te = function(p, w) {
      if (F(p))
        return p.clone();
      var x = typeof w == "object" ? w : {};
      return x.date = p, x.args = arguments, new we(x);
    }, se = D;
    se.l = X, se.i = F, se.w = function(p, w) {
      return te(p, { locale: w.$L, utc: w.$u, x: w.$x, $offset: w.$offset });
    };
    var we = function() {
      function p(x) {
        this.$L = X(x.locale, null, !0), this.parse(x), this.$x = this.$x || x.x || {}, this[v] = !0;
      }
      var w = p.prototype;
      return w.parse = function(x) {
        this.$d = function(N) {
          var O = N.date, U = N.utc;
          if (O === null)
            return /* @__PURE__ */ new Date(NaN);
          if (se.u(O))
            return /* @__PURE__ */ new Date();
          if (O instanceof Date)
            return new Date(O);
          if (typeof O == "string" && !/Z$/i.test(O)) {
            var q = O.match(k);
            if (q) {
              var B = q[2] - 1 || 0, E = (q[7] || "0").substring(0, 3);
              return U ? new Date(Date.UTC(q[1], B, q[3] || 1, q[4] || 0, q[5] || 0, q[6] || 0, E)) : new Date(q[1], B, q[3] || 1, q[4] || 0, q[5] || 0, q[6] || 0, E);
            }
          }
          return new Date(O);
        }(x), this.init();
      }, w.init = function() {
        var x = this.$d;
        this.$y = x.getFullYear(), this.$M = x.getMonth(), this.$D = x.getDate(), this.$W = x.getDay(), this.$H = x.getHours(), this.$m = x.getMinutes(), this.$s = x.getSeconds(), this.$ms = x.getMilliseconds();
      }, w.$utils = function() {
        return se;
      }, w.isValid = function() {
        return this.$d.toString() !== I;
      }, w.isSame = function(x, N) {
        var O = te(x);
        return this.startOf(N) <= O && O <= this.endOf(N);
      }, w.isAfter = function(x, N) {
        return te(x) < this.startOf(N);
      }, w.isBefore = function(x, N) {
        return this.endOf(N) < te(x);
      }, w.$g = function(x, N, O) {
        return se.u(x) ? this[N] : this.set(O, x);
      }, w.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, w.valueOf = function() {
        return this.$d.getTime();
      }, w.startOf = function(x, N) {
        var O = this, U = !!se.u(N) || N, q = se.p(x), B = function(ee, S) {
          var M = se.w(O.$u ? Date.UTC(O.$y, S, ee) : new Date(O.$y, S, ee), O);
          return U ? M : M.endOf(u);
        }, E = function(ee, S) {
          return se.w(O.toDate()[ee].apply(O.toDate("s"), (U ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(S)), O);
        }, V = this.$W, be = this.$M, ve = this.$D, ne = "set" + (this.$u ? "UTC" : "");
        switch (q) {
          case y:
            return U ? B(1, 0) : B(31, 11);
          case d:
            return U ? B(1, be) : B(0, be + 1);
          case f:
            var K = this.$locale().weekStart || 0, Y = (V < K ? V + 7 : V) - K;
            return B(U ? ve - Y : ve + (6 - Y), be);
          case u:
          case b:
            return E(ne + "Hours", 0);
          case c:
            return E(ne + "Minutes", 1);
          case a:
            return E(ne + "Seconds", 2);
          case o:
            return E(ne + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, w.endOf = function(x) {
        return this.startOf(x, !1);
      }, w.$set = function(x, N) {
        var O, U = se.p(x), q = "set" + (this.$u ? "UTC" : ""), B = (O = {}, O[u] = q + "Date", O[b] = q + "Date", O[d] = q + "Month", O[y] = q + "FullYear", O[c] = q + "Hours", O[a] = q + "Minutes", O[o] = q + "Seconds", O[s] = q + "Milliseconds", O)[U], E = U === u ? this.$D + (N - this.$W) : N;
        if (U === d || U === y) {
          var V = this.clone().set(b, 1);
          V.$d[B](E), V.init(), this.$d = V.set(b, Math.min(this.$D, V.daysInMonth())).$d;
        } else
          B && this.$d[B](E);
        return this.init(), this;
      }, w.set = function(x, N) {
        return this.clone().$set(x, N);
      }, w.get = function(x) {
        return this[se.p(x)]();
      }, w.add = function(x, N) {
        var O, U = this;
        x = Number(x);
        var q = se.p(N), B = function(be) {
          var ve = te(U);
          return se.w(ve.date(ve.date() + Math.round(be * x)), U);
        };
        if (q === d)
          return this.set(d, this.$M + x);
        if (q === y)
          return this.set(y, this.$y + x);
        if (q === u)
          return B(1);
        if (q === f)
          return B(7);
        var E = (O = {}, O[a] = n, O[c] = i, O[o] = t, O)[q] || 1, V = this.$d.getTime() + x * E;
        return se.w(V, this);
      }, w.subtract = function(x, N) {
        return this.add(-1 * x, N);
      }, w.format = function(x) {
        var N = this, O = this.$locale();
        if (!this.isValid())
          return O.invalidDate || I;
        var U = x || "YYYY-MM-DDTHH:mm:ssZ", q = se.z(this), B = this.$H, E = this.$m, V = this.$M, be = O.weekdays, ve = O.months, ne = O.meridiem, K = function(S, M, G, ue) {
          return S && (S[M] || S(N, U)) || G[M].slice(0, ue);
        }, Y = function(S) {
          return se.s(B % 12 || 12, S, "0");
        }, ee = ne || function(S, M, G) {
          var ue = S < 12 ? "AM" : "PM";
          return G ? ue.toLowerCase() : ue;
        };
        return U.replace(R, function(S, M) {
          return M || function(G) {
            switch (G) {
              case "YY":
                return String(N.$y).slice(-2);
              case "YYYY":
                return se.s(N.$y, 4, "0");
              case "M":
                return V + 1;
              case "MM":
                return se.s(V + 1, 2, "0");
              case "MMM":
                return K(O.monthsShort, V, ve, 3);
              case "MMMM":
                return K(ve, V);
              case "D":
                return N.$D;
              case "DD":
                return se.s(N.$D, 2, "0");
              case "d":
                return String(N.$W);
              case "dd":
                return K(O.weekdaysMin, N.$W, be, 2);
              case "ddd":
                return K(O.weekdaysShort, N.$W, be, 3);
              case "dddd":
                return be[N.$W];
              case "H":
                return String(B);
              case "HH":
                return se.s(B, 2, "0");
              case "h":
                return Y(1);
              case "hh":
                return Y(2);
              case "a":
                return ee(B, E, !0);
              case "A":
                return ee(B, E, !1);
              case "m":
                return String(E);
              case "mm":
                return se.s(E, 2, "0");
              case "s":
                return String(N.$s);
              case "ss":
                return se.s(N.$s, 2, "0");
              case "SSS":
                return se.s(N.$ms, 3, "0");
              case "Z":
                return q;
            }
            return null;
          }(S) || q.replace(":", "");
        });
      }, w.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, w.diff = function(x, N, O) {
        var U, q = this, B = se.p(N), E = te(x), V = (E.utcOffset() - this.utcOffset()) * n, be = this - E, ve = function() {
          return se.m(q, E);
        };
        switch (B) {
          case y:
            U = ve() / 12;
            break;
          case d:
            U = ve();
            break;
          case m:
            U = ve() / 3;
            break;
          case f:
            U = (be - V) / 6048e5;
            break;
          case u:
            U = (be - V) / 864e5;
            break;
          case c:
            U = be / i;
            break;
          case a:
            U = be / n;
            break;
          case o:
            U = be / t;
            break;
          default:
            U = be;
        }
        return O ? U : se.a(U);
      }, w.daysInMonth = function() {
        return this.endOf(d).$D;
      }, w.$locale = function() {
        return P[this.$L];
      }, w.locale = function(x, N) {
        if (!x)
          return this.$L;
        var O = this.clone(), U = X(x, N, !0);
        return U && (O.$L = U), O;
      }, w.clone = function() {
        return se.w(this.$d, this);
      }, w.toDate = function() {
        return new Date(this.valueOf());
      }, w.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, w.toISOString = function() {
        return this.$d.toISOString();
      }, w.toString = function() {
        return this.$d.toUTCString();
      }, p;
    }(), H = we.prototype;
    return te.prototype = H, [["$ms", s], ["$s", o], ["$m", a], ["$H", c], ["$W", u], ["$M", d], ["$y", y], ["$D", b]].forEach(function(p) {
      H[p[1]] = function(w) {
        return this.$g(w, p[0], p[1]);
      };
    }), te.extend = function(p, w) {
      return p.$i || (p(w, we, te), p.$i = !0), te;
    }, te.locale = X, te.isDayjs = F, te.unix = function(p) {
      return te(1e3 * p);
    }, te.en = P[L], te.Ls = P, te.p = {}, te;
  });
})(wM);
var _Q = wM.exports;
const Lm = /* @__PURE__ */ Ed(_Q);
var yM = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(ze, function() {
    return function(t, n, i) {
      i.updateLocale = function(s, o) {
        var a = i.Ls[s];
        if (a)
          return (o ? Object.keys(o) : []).forEach(function(c) {
            a[c] = o[c];
          }), a;
      };
    };
  });
})(yM);
var EQ = yM.exports;
const xQ = /* @__PURE__ */ Ed(EQ);
var vM = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(ze, function() {
    return function(t, n, i) {
      t = t || {};
      var s = n.prototype, o = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function a(u, f, d, m) {
        return s.fromToBase(u, f, d, m);
      }
      i.en.relativeTime = o, s.fromToBase = function(u, f, d, m, y) {
        for (var b, I, k, R = d.$locale().relativeTime || o, T = t.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], $ = T.length, D = 0; D < $; D += 1) {
          var L = T[D];
          L.d && (b = m ? i(u).diff(d, L.d, !0) : d.diff(u, L.d, !0));
          var P = (t.rounding || Math.round)(Math.abs(b));
          if (k = b > 0, P <= L.r || !L.r) {
            P <= 1 && D > 0 && (L = T[D - 1]);
            var v = R[L.l];
            y && (P = y("" + P)), I = typeof v == "string" ? v.replace("%d", P) : v(P, f, L.l, k);
            break;
          }
        }
        if (f)
          return I;
        var F = k ? R.future : R.past;
        return typeof F == "function" ? F(I) : F.replace("%s", I);
      }, s.to = function(u, f) {
        return a(u, f, this, !0);
      }, s.from = function(u, f) {
        return a(u, f, this);
      };
      var c = function(u) {
        return u.$u ? i.utc() : i();
      };
      s.toNow = function(u) {
        return this.to(c(this), u);
      }, s.fromNow = function(u) {
        return this.from(c(this), u);
      };
    };
  });
})(vM);
var SQ = vM.exports;
const CQ = /* @__PURE__ */ Ed(SQ);
Lm.extend(CQ);
Lm.extend(xQ);
Lm.updateLocale("en", {
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "%s sec",
    m: "1 min",
    mm: "%d min",
    h: "1 hr",
    hh: "%d hrs",
    d: "1 d",
    dd: "%d d",
    M: "1 mo",
    MM: "%d mo",
    y: "1 yr",
    yy: "%d yr"
  }
});
const bM = {
  getYear(r = (/* @__PURE__ */ new Date()).toISOString()) {
    return Lm(r).year();
  },
  getRelativeDateFromNow(r) {
    return Lm(r).fromNow(!0);
  }
}, AQ = 3, IQ = ["receive", "deposit", "borrow", "claim"], RQ = ["withdraw", "repay", "burn"], sf = {
  getTransactionGroupTitle(r) {
    const e = bM.getYear();
    return r === e ? "This Year" : r;
  },
  getTransactionImages(r) {
    const [e, t] = r, n = !!e && (r == null ? void 0 : r.every((o) => !!o.nft_info)), i = (r == null ? void 0 : r.length) > 1;
    return (r == null ? void 0 : r.length) === 2 && !n ? [this.getTransactionImage(e), this.getTransactionImage(t)] : i ? r.map((o) => this.getTransactionImage(o)) : [this.getTransactionImage(e)];
  },
  getTransactionImage(r) {
    return {
      type: sf.getTransactionTransferTokenType(r),
      url: sf.getTransactionImageURL(r)
    };
  },
  getTransactionImageURL(r) {
    var i, s, o, a, c;
    let e = null;
    const t = !!(r != null && r.nft_info), n = !!(r != null && r.fungible_info);
    return r && t ? e = (o = (s = (i = r == null ? void 0 : r.nft_info) == null ? void 0 : i.content) == null ? void 0 : s.preview) == null ? void 0 : o.url : r && n && (e = (c = (a = r == null ? void 0 : r.fungible_info) == null ? void 0 : a.icon) == null ? void 0 : c.url), e;
  },
  getTransactionTransferTokenType(r) {
    return r != null && r.fungible_info ? "FUNGIBLE" : r != null && r.nft_info ? "NFT" : null;
  },
  getTransactionDescriptions(r) {
    var d, m, y;
    const e = (d = r.metadata) == null ? void 0 : d.operationType, t = r.transfers, n = ((m = r.transfers) == null ? void 0 : m.length) > 0, i = ((y = r.transfers) == null ? void 0 : y.length) > 1, s = n && (t == null ? void 0 : t.every((b) => !!b.fungible_info)), [o, a] = t;
    let c = this.getTransferDescription(o), u = this.getTransferDescription(a);
    if (!n)
      return (e === "send" || e === "receive") && s ? (c = jr.getTruncateString({
        string: r.metadata.sentFrom,
        charsStart: 4,
        charsEnd: 6,
        truncate: "middle"
      }), u = jr.getTruncateString({
        string: r.metadata.sentTo,
        charsStart: 4,
        charsEnd: 6,
        truncate: "middle"
      }), [c, u]) : [r.metadata.status];
    if (i)
      return t.map((b) => this.getTransferDescription(b));
    let f = "";
    return IQ.includes(e) ? f = "+" : RQ.includes(e) && (f = "-"), c = f.concat(c), [c];
  },
  getTransferDescription(r) {
    var t;
    let e = "";
    return r && (r != null && r.nft_info ? e = ((t = r == null ? void 0 : r.nft_info) == null ? void 0 : t.name) || "-" : r != null && r.fungible_info && (e = this.getFungibleTransferDescription(r) || "-")), e;
  },
  getFungibleTransferDescription(r) {
    var n;
    return r ? [this.getQuantityFixedValue(r == null ? void 0 : r.quantity.numeric), (n = r == null ? void 0 : r.fungible_info) == null ? void 0 : n.symbol].join(" ").trim() : null;
  },
  getQuantityFixedValue(r) {
    return r ? parseFloat(r).toFixed(AQ) : null;
  }
}, TQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TransactionUtil: sf,
  UiHelperUtil: jr,
  get WuiAccountButton() {
    return Uo;
  },
  get WuiAllWalletsImage() {
    return Om;
  },
  get WuiAvatar() {
    return Zf;
  },
  get WuiButton() {
    return Ta;
  },
  get WuiCard() {
    return Xb;
  },
  get WuiCardSelect() {
    return Cc;
  },
  get WuiCardSelectLoader() {
    return Nm;
  },
  get WuiChip() {
    return Ac;
  },
  get WuiConnectButton() {
    return J0;
  },
  get WuiCtaButton() {
    return Jf;
  },
  get WuiEmailInput() {
    return Qf;
  },
  get WuiFlex() {
    return Bi;
  },
  get WuiGrid() {
    return cs;
  },
  get WuiIcon() {
    return qf;
  },
  get WuiIconBox() {
    return Fo;
  },
  get WuiIconLink() {
    return Ku;
  },
  get WuiImage() {
    return K0;
  },
  get WuiInputElement() {
    return Pm;
  },
  get WuiInputNumeric() {
    return Q0;
  },
  get WuiInputText() {
    return Oa;
  },
  get WuiLink() {
    return Y0;
  },
  get WuiListAccordion() {
    return og;
  },
  get WuiListContent() {
    return td;
  },
  get WuiListItem() {
    return io;
  },
  get WuiListWallet() {
    return Ds;
  },
  get WuiListWalletTransaction() {
    return Ju;
  },
  get WuiLoadingHexagon() {
    return e2;
  },
  get WuiLoadingSpinner() {
    return Z0;
  },
  get WuiLoadingThumbnail() {
    return Rm;
  },
  get WuiLogo() {
    return Dm;
  },
  get WuiLogoSelect() {
    return X0;
  },
  get WuiNetworkButton() {
    return eg;
  },
  get WuiNetworkImage() {
    return Gu;
  },
  get WuiNoticeCard() {
    return ed;
  },
  get WuiOtp() {
    return Yf;
  },
  get WuiQrCode() {
    return Pl;
  },
  get WuiSearchBar() {
    return s2;
  },
  get WuiSeparator() {
    return $m;
  },
  get WuiShimmer() {
    return Gf;
  },
  get WuiSnackbar() {
    return Zu;
  },
  get WuiTabs() {
    return Pa;
  },
  get WuiTag() {
    return Mm;
  },
  get WuiText() {
    return Kf;
  },
  get WuiTooltip() {
    return sg;
  },
  get WuiTransactionListItem() {
    return Na;
  },
  get WuiTransactionListItemLoader() {
    return r2;
  },
  get WuiTransactionVisual() {
    return Ic;
  },
  get WuiVisual() {
    return Tm;
  },
  get WuiVisualThumbnail() {
    return Xf;
  },
  get WuiWalletImage() {
    return Sc;
  },
  customElement: $e,
  initializeTheming: BP,
  setColorTheme: IS,
  setThemeVariables: FP
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ib = globalThis, HS = Ib.ShadowRoot && (Ib.ShadyCSS === void 0 || Ib.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, zS = Symbol(), xR = /* @__PURE__ */ new WeakMap();
let _M = class {
  constructor(e, t, n) {
    if (this._$cssResult$ = !0, n !== zS)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (HS && e === void 0) {
      const n = t !== void 0 && t.length === 1;
      n && (e = xR.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), n && xR.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const OQ = (r) => new _M(typeof r == "string" ? r : r + "", void 0, zS), cn = (r, ...e) => {
  const t = r.length === 1 ? r[0] : e.reduce((n, i, s) => n + ((o) => {
    if (o._$cssResult$ === !0)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + r[s + 1], r[0]);
  return new _M(t, r, zS);
}, NQ = (r, e) => {
  if (HS)
    r.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of e) {
      const n = document.createElement("style"), i = Ib.litNonce;
      i !== void 0 && n.setAttribute("nonce", i), n.textContent = t.cssText, r.appendChild(n);
    }
}, SR = HS ? (r) => r : (r) => r instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const n of e.cssRules)
    t += n.cssText;
  return OQ(t);
})(r) : r;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: PQ, defineProperty: MQ, getOwnPropertyDescriptor: DQ, getOwnPropertyNames: kQ, getOwnPropertySymbols: $Q, getPrototypeOf: LQ } = Object, Vu = globalThis, CR = Vu.trustedTypes, BQ = CR ? CR.emptyScript : "", W5 = Vu.reactiveElementPolyfillSupport, cm = (r, e) => r, o2 = { toAttribute(r, e) {
  switch (e) {
    case Boolean:
      r = r ? BQ : null;
      break;
    case Object:
    case Array:
      r = r == null ? r : JSON.stringify(r);
  }
  return r;
}, fromAttribute(r, e) {
  let t = r;
  switch (e) {
    case Boolean:
      t = r !== null;
      break;
    case Number:
      t = r === null ? null : Number(r);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(r);
      } catch {
        t = null;
      }
  }
  return t;
} }, VS = (r, e) => !PQ(r, e), AR = { attribute: !0, type: String, converter: o2, reflect: !1, hasChanged: VS };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Vu.litPropertyMetadata ?? (Vu.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let Ep = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = AR) {
    if (t.state && (t.attribute = !1), this._$Ei(), this.elementProperties.set(e, t), !t.noAccessor) {
      const n = Symbol(), i = this.getPropertyDescriptor(e, n, t);
      i !== void 0 && MQ(this.prototype, e, i);
    }
  }
  static getPropertyDescriptor(e, t, n) {
    const { get: i, set: s } = DQ(this.prototype, e) ?? { get() {
      return this[t];
    }, set(o) {
      this[t] = o;
    } };
    return { get() {
      return i == null ? void 0 : i.call(this);
    }, set(o) {
      const a = i == null ? void 0 : i.call(this);
      s.call(this, o), this.requestUpdate(e, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? AR;
  }
  static _$Ei() {
    if (this.hasOwnProperty(cm("elementProperties")))
      return;
    const e = LQ(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(cm("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(cm("properties"))) {
      const t = this.properties, n = [...kQ(t), ...$Q(t)];
      for (const i of n)
        this.createProperty(i, t[i]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0)
        for (const [n, i] of t)
          this.elementProperties.set(n, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, n] of this.elementProperties) {
      const i = this._$Eu(t, n);
      i !== void 0 && this._$Eh.set(i, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const i of n)
        t.unshift(SR(i));
    } else
      e !== void 0 && t.push(SR(e));
    return t;
  }
  static _$Eu(e, t) {
    const n = t.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$Eg = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$ES(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$E_ ?? (this._$E_ = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$E_) == null || t.delete(e);
  }
  _$ES() {
    const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const n of t.keys())
      this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return NQ(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$E_) == null || e.forEach((t) => {
      var n;
      return (n = t.hostConnected) == null ? void 0 : n.call(t);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$E_) == null || e.forEach((t) => {
      var n;
      return (n = t.hostDisconnected) == null ? void 0 : n.call(t);
    });
  }
  attributeChangedCallback(e, t, n) {
    this._$AK(e, n);
  }
  _$EO(e, t) {
    var s;
    const n = this.constructor.elementProperties.get(e), i = this.constructor._$Eu(e, n);
    if (i !== void 0 && n.reflect === !0) {
      const o = (((s = n.converter) == null ? void 0 : s.toAttribute) !== void 0 ? n.converter : o2).toAttribute(t, n.type);
      this._$Em = e, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null;
    }
  }
  _$AK(e, t) {
    var s;
    const n = this.constructor, i = n._$Eh.get(e);
    if (i !== void 0 && this._$Em !== i) {
      const o = n.getPropertyOptions(i), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((s = o.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? o.converter : o2;
      this._$Em = i, this[i] = a.fromAttribute(t, o.type), this._$Em = null;
    }
  }
  requestUpdate(e, t, n) {
    if (e !== void 0) {
      if (n ?? (n = this.constructor.getPropertyOptions(e)), !(n.hasChanged ?? VS)(this[e], t))
        return;
      this.C(e, t, n);
    }
    this.isUpdatePending === !1 && (this._$Eg = this._$EP());
  }
  C(e, t, n) {
    this._$AL.has(e) || this._$AL.set(e, t), n.reflect === !0 && this._$Em !== e && (this._$ET ?? (this._$ET = /* @__PURE__ */ new Set())).add(e);
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$Eg;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep)
          this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0)
        for (const [s, o] of i)
          o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.C(s, this[s], o);
    }
    let e = !1;
    const t = this._$AL;
    try {
      e = this.shouldUpdate(t), e ? (this.willUpdate(t), (n = this._$E_) == null || n.forEach((i) => {
        var s;
        return (s = i.hostUpdate) == null ? void 0 : s.call(i);
      }), this.update(t)) : this._$Ej();
    } catch (i) {
      throw e = !1, this._$Ej(), i;
    }
    e && this._$AE(t);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var t;
    (t = this._$E_) == null || t.forEach((n) => {
      var i;
      return (i = n.hostUpdated) == null ? void 0 : i.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$Ej() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Eg;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$ET && (this._$ET = this._$ET.forEach((t) => this._$EO(t, this[t]))), this._$Ej();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
Ep.elementStyles = [], Ep.shadowRootOptions = { mode: "open" }, Ep[cm("elementProperties")] = /* @__PURE__ */ new Map(), Ep[cm("finalized")] = /* @__PURE__ */ new Map(), W5 == null || W5({ ReactiveElement: Ep }), (Vu.reactiveElementVersions ?? (Vu.reactiveElementVersions = [])).push("2.0.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const lm = globalThis, a2 = lm.trustedTypes, IR = a2 ? a2.createPolicy("lit-html", { createHTML: (r) => r }) : void 0, EM = "$lit$", mu = `lit$${(Math.random() + "").slice(9)}$`, xM = "?" + mu, FQ = `<${xM}>`, rd = document, Bm = () => rd.createComment(""), Fm = (r) => r === null || typeof r != "object" && typeof r != "function", SM = Array.isArray, UQ = (r) => SM(r) || typeof (r == null ? void 0 : r[Symbol.iterator]) == "function", H5 = `[ 	
\f\r]`, I1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, RR = /-->/g, TR = />/g, Uh = RegExp(`>|${H5}(?:([^\\s"'>=/]+)(${H5}*=${H5}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), OR = /'/g, NR = /"/g, CM = /^(?:script|style|textarea|title)$/i, jQ = (r) => (e, ...t) => ({ _$litType$: r, strings: e, values: t }), Ae = jQ(1), ag = Symbol.for("lit-noChange"), $n = Symbol.for("lit-nothing"), PR = /* @__PURE__ */ new WeakMap(), of = rd.createTreeWalker(rd, 129);
function AM(r, e) {
  if (!Array.isArray(r) || !r.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return IR !== void 0 ? IR.createHTML(e) : e;
}
const WQ = (r, e) => {
  const t = r.length - 1, n = [];
  let i, s = e === 2 ? "<svg>" : "", o = I1;
  for (let a = 0; a < t; a++) {
    const c = r[a];
    let u, f, d = -1, m = 0;
    for (; m < c.length && (o.lastIndex = m, f = o.exec(c), f !== null); )
      m = o.lastIndex, o === I1 ? f[1] === "!--" ? o = RR : f[1] !== void 0 ? o = TR : f[2] !== void 0 ? (CM.test(f[2]) && (i = RegExp("</" + f[2], "g")), o = Uh) : f[3] !== void 0 && (o = Uh) : o === Uh ? f[0] === ">" ? (o = i ?? I1, d = -1) : f[1] === void 0 ? d = -2 : (d = o.lastIndex - f[2].length, u = f[1], o = f[3] === void 0 ? Uh : f[3] === '"' ? NR : OR) : o === NR || o === OR ? o = Uh : o === RR || o === TR ? o = I1 : (o = Uh, i = void 0);
    const y = o === Uh && r[a + 1].startsWith("/>") ? " " : "";
    s += o === I1 ? c + FQ : d >= 0 ? (n.push(u), c.slice(0, d) + EM + c.slice(d) + mu + y) : c + mu + (d === -2 ? a : y);
  }
  return [AM(r, s + (r[t] || "<?>") + (e === 2 ? "</svg>" : "")), n];
};
let O6 = class IM {
  constructor({ strings: e, _$litType$: t }, n) {
    let i;
    this.parts = [];
    let s = 0, o = 0;
    const a = e.length - 1, c = this.parts, [u, f] = WQ(e, t);
    if (this.el = IM.createElement(u, n), of.currentNode = this.el.content, t === 2) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (i = of.nextNode()) !== null && c.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes())
          for (const d of i.getAttributeNames())
            if (d.endsWith(EM)) {
              const m = f[o++], y = i.getAttribute(d).split(mu), b = /([.?@])?(.*)/.exec(m);
              c.push({ type: 1, index: s, name: b[2], strings: y, ctor: b[1] === "." ? zQ : b[1] === "?" ? VQ : b[1] === "@" ? qQ : M_ }), i.removeAttribute(d);
            } else
              d.startsWith(mu) && (c.push({ type: 6, index: s }), i.removeAttribute(d));
        if (CM.test(i.tagName)) {
          const d = i.textContent.split(mu), m = d.length - 1;
          if (m > 0) {
            i.textContent = a2 ? a2.emptyScript : "";
            for (let y = 0; y < m; y++)
              i.append(d[y], Bm()), of.nextNode(), c.push({ type: 2, index: ++s });
            i.append(d[m], Bm());
          }
        }
      } else if (i.nodeType === 8)
        if (i.data === xM)
          c.push({ type: 2, index: s });
        else {
          let d = -1;
          for (; (d = i.data.indexOf(mu, d + 1)) !== -1; )
            c.push({ type: 7, index: s }), d += mu.length - 1;
        }
      s++;
    }
  }
  static createElement(e, t) {
    const n = rd.createElement("template");
    return n.innerHTML = e, n;
  }
};
function cg(r, e, t = r, n) {
  var o, a;
  if (e === ag)
    return e;
  let i = n !== void 0 ? (o = t._$Co) == null ? void 0 : o[n] : t._$Cl;
  const s = Fm(e) ? void 0 : e._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== s && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), s === void 0 ? i = void 0 : (i = new s(r), i._$AT(r, t, n)), n !== void 0 ? (t._$Co ?? (t._$Co = []))[n] = i : t._$Cl = i), i !== void 0 && (e = cg(r, i._$AS(r, e.values), i, n)), e;
}
let HQ = class {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: n } = this._$AD, i = ((e == null ? void 0 : e.creationScope) ?? rd).importNode(t, !0);
    of.currentNode = i;
    let s = of.nextNode(), o = 0, a = 0, c = n[0];
    for (; c !== void 0; ) {
      if (o === c.index) {
        let u;
        c.type === 2 ? u = new qS(s, s.nextSibling, this, e) : c.type === 1 ? u = new c.ctor(s, c.name, c.strings, this, e) : c.type === 6 && (u = new GQ(s, this, e)), this._$AV.push(u), c = n[++a];
      }
      o !== (c == null ? void 0 : c.index) && (s = of.nextNode(), o++);
    }
    return of.currentNode = rd, i;
  }
  p(e) {
    let t = 0;
    for (const n of this._$AV)
      n !== void 0 && (n.strings !== void 0 ? (n._$AI(e, n, t), t += n.strings.length - 2) : n._$AI(e[t])), t++;
  }
}, qS = class RM {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, t, n, i) {
    this.type = 2, this._$AH = $n, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = n, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = cg(this, e, t), Fm(e) ? e === $n || e == null || e === "" ? (this._$AH !== $n && this._$AR(), this._$AH = $n) : e !== this._$AH && e !== ag && this._(e) : e._$litType$ !== void 0 ? this.g(e) : e.nodeType !== void 0 ? this.$(e) : UQ(e) ? this.T(e) : this._(e);
  }
  k(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  $(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.k(e));
  }
  _(e) {
    this._$AH !== $n && Fm(this._$AH) ? this._$AA.nextSibling.data = e : this.$(rd.createTextNode(e)), this._$AH = e;
  }
  g(e) {
    var s;
    const { values: t, _$litType$: n } = e, i = typeof n == "number" ? this._$AC(e) : (n.el === void 0 && (n.el = O6.createElement(AM(n.h, n.h[0]), this.options)), n);
    if (((s = this._$AH) == null ? void 0 : s._$AD) === i)
      this._$AH.p(t);
    else {
      const o = new HQ(i, this), a = o.u(this.options);
      o.p(t), this.$(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let t = PR.get(e.strings);
    return t === void 0 && PR.set(e.strings, t = new O6(e)), t;
  }
  T(e) {
    SM(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let n, i = 0;
    for (const s of e)
      i === t.length ? t.push(n = new RM(this.k(Bm()), this.k(Bm()), this, this.options)) : n = t[i], n._$AI(s), i++;
    i < t.length && (this._$AR(n && n._$AB.nextSibling, i), t.length = i);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, t); e && e !== this._$AB; ) {
      const i = e.nextSibling;
      e.remove(), e = i;
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 && (this._$Cv = e, (t = this._$AP) == null || t.call(this, e));
  }
}, M_ = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, n, i, s) {
    this.type = 1, this._$AH = $n, this._$AN = void 0, this.element = e, this.name = t, this._$AM = i, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = $n;
  }
  _$AI(e, t = this, n, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0)
      e = cg(this, e, t, 0), o = !Fm(e) || e !== this._$AH && e !== ag, o && (this._$AH = e);
    else {
      const a = e;
      let c, u;
      for (e = s[0], c = 0; c < s.length - 1; c++)
        u = cg(this, a[n + c], t, c), u === ag && (u = this._$AH[c]), o || (o = !Fm(u) || u !== this._$AH[c]), u === $n ? e = $n : e !== $n && (e += (u ?? "") + s[c + 1]), this._$AH[c] = u;
    }
    o && !i && this.O(e);
  }
  O(e) {
    e === $n ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}, zQ = class extends M_ {
  constructor() {
    super(...arguments), this.type = 3;
  }
  O(e) {
    this.element[this.name] = e === $n ? void 0 : e;
  }
}, VQ = class extends M_ {
  constructor() {
    super(...arguments), this.type = 4;
  }
  O(e) {
    this.element.toggleAttribute(this.name, !!e && e !== $n);
  }
}, qQ = class extends M_ {
  constructor(e, t, n, i, s) {
    super(e, t, n, i, s), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = cg(this, e, t, 0) ?? $n) === ag)
      return;
    const n = this._$AH, i = e === $n && n !== $n || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive, s = e !== $n && (n === $n || i);
    i && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var t;
    typeof this._$AH == "function" ? this._$AH.call(((t = this.options) == null ? void 0 : t.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}, GQ = class {
  constructor(e, t, n) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    cg(this, e);
  }
};
const z5 = lm.litHtmlPolyfillSupport;
z5 == null || z5(O6, qS), (lm.litHtmlVersions ?? (lm.litHtmlVersions = [])).push("3.1.1");
const KQ = (r, e, t) => {
  const n = (t == null ? void 0 : t.renderBefore) ?? e;
  let i = n._$litPart$;
  if (i === void 0) {
    const s = (t == null ? void 0 : t.renderBefore) ?? null;
    n._$litPart$ = i = new qS(e.insertBefore(Bm(), s), s, void 0, t ?? {});
  }
  return i._$AI(r), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Xt = class extends Ep {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = KQ(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return ag;
  }
};
var SP;
Xt._$litElement$ = !0, Xt.finalized = !0, (SP = globalThis.litElementHydrateSupport) == null || SP.call(globalThis, { LitElement: Xt });
const V5 = globalThis.litElementPolyfillSupport;
V5 == null || V5({ LitElement: Xt });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ZQ = { attribute: !0, type: String, converter: o2, reflect: !1, hasChanged: VS }, JQ = (r = ZQ, e, t) => {
  const { kind: n, metadata: i } = t;
  let s = globalThis.litPropertyMetadata.get(i);
  if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = /* @__PURE__ */ new Map()), s.set(t.name, r), n === "accessor") {
    const { name: o } = t;
    return { set(a) {
      const c = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(o, c, r);
    }, init(a) {
      return a !== void 0 && this.C(o, void 0, r), a;
    } };
  }
  if (n === "setter") {
    const { name: o } = t;
    return function(a) {
      const c = this[o];
      e.call(this, a), this.requestUpdate(o, c, r);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function bn(r) {
  return (e, t) => typeof t == "object" ? JQ(r, e, t) : ((n, i, s) => {
    const o = i.hasOwnProperty(s);
    return i.constructor.createProperty(s, o ? { ...n, wrapped: !0 } : n), o ? Object.getOwnPropertyDescriptor(i, s) : void 0;
  })(r, e, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function ot(r) {
  return bn({ ...r, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Sr = (r) => r ?? $n;
var Fa = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let jo = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.disabled = !1, this.balance = "show", this.charsStart = 4, this.charsEnd = 6, this.address = xr.state.address, this.balanceVal = xr.state.balance, this.balanceSymbol = xr.state.balanceSymbol, this.profileName = xr.state.profileName, this.profileImage = xr.state.profileImage, this.network = An.state.caipNetwork, this.unsubscribe.push(xr.subscribe((e) => {
      e.isConnected ? (this.address = e.address, this.balanceVal = e.balance, this.profileName = e.profileName, this.profileImage = e.profileImage, this.balanceSymbol = e.balanceSymbol) : (this.address = "", this.balanceVal = "", this.profileName = "", this.profileImage = "", this.balanceSymbol = "");
    }), An.subscribeKey("caipNetwork", (e) => this.network = e));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    const e = Sn.getNetworkImage(this.network), t = this.balance === "show";
    return Ae`
      <wui-account-button
        .disabled=${!!this.disabled}
        address=${Sr(this.profileName ?? this.address)}
        ?isProfileName=${!!this.profileName}
        networkSrc=${Sr(e)}
        avatarSrc=${Sr(this.profileImage)}
        balance=${t ? vt.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `;
  }
  onClick() {
    Xr.open();
  }
};
Fa([
  bn({ type: Boolean })
], jo.prototype, "disabled", void 0);
Fa([
  bn()
], jo.prototype, "balance", void 0);
Fa([
  bn()
], jo.prototype, "charsStart", void 0);
Fa([
  bn()
], jo.prototype, "charsEnd", void 0);
Fa([
  ot()
], jo.prototype, "address", void 0);
Fa([
  ot()
], jo.prototype, "balanceVal", void 0);
Fa([
  ot()
], jo.prototype, "balanceSymbol", void 0);
Fa([
  ot()
], jo.prototype, "profileName", void 0);
Fa([
  ot()
], jo.prototype, "profileImage", void 0);
Fa([
  ot()
], jo.prototype, "network", void 0);
jo = Fa([
  $e("w3m-account-button")
], jo);
const QQ = cn`
  :host {
    display: block;
    width: max-content;
  }
`;
var jl = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Ma = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.disabled = !1, this.balance = void 0, this.size = void 0, this.label = void 0, this.loadingLabel = void 0, this.charsStart = 4, this.charsEnd = 6, this.isAccount = xr.state.isConnected, this.unsubscribe.push(xr.subscribeKey("isConnected", (e) => {
      this.isAccount = e;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    return this.isAccount ? Ae`
          <w3m-account-button
            .disabled=${!!this.disabled}
            balance=${Sr(this.balance)}
            .charsStart=${Sr(this.charsStart)}
            .charsEnd=${Sr(this.charsEnd)}
          >
          </w3m-account-button>
        ` : Ae`
          <w3m-connect-button
            size=${Sr(this.size)}
            label=${Sr(this.label)}
            loadingLabel=${Sr(this.loadingLabel)}
          ></w3m-connect-button>
        `;
  }
};
Ma.styles = QQ;
jl([
  bn({ type: Boolean })
], Ma.prototype, "disabled", void 0);
jl([
  bn()
], Ma.prototype, "balance", void 0);
jl([
  bn()
], Ma.prototype, "size", void 0);
jl([
  bn()
], Ma.prototype, "label", void 0);
jl([
  bn()
], Ma.prototype, "loadingLabel", void 0);
jl([
  bn()
], Ma.prototype, "charsStart", void 0);
jl([
  bn()
], Ma.prototype, "charsEnd", void 0);
jl([
  ot()
], Ma.prototype, "isAccount", void 0);
Ma = jl([
  $e("w3m-button")
], Ma);
var Bg = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let nd = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.size = "md", this.label = "Connect Wallet", this.loadingLabel = "Connecting...", this.open = Xr.state.open, this.loading = Xr.state.loading, this.unsubscribe.push(Xr.subscribe((e) => {
      this.open = e.open, this.loading = e.loading;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    const e = this.loading || this.open;
    return Ae`
      <wui-connect-button
        size=${Sr(this.size)}
        .loading=${e}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${e ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
  }
  onClick() {
    this.open ? Xr.close() : this.loading || Xr.open();
  }
};
Bg([
  bn()
], nd.prototype, "size", void 0);
Bg([
  bn()
], nd.prototype, "label", void 0);
Bg([
  bn()
], nd.prototype, "loadingLabel", void 0);
Bg([
  ot()
], nd.prototype, "open", void 0);
Bg([
  ot()
], nd.prototype, "loading", void 0);
nd = Bg([
  $e("w3m-connect-button")
], nd);
const YQ = cn`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: 360px;
    width: 100%;
    position: relative;
    animation-delay: 0.3s;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;
var D_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const MR = "scroll-lock";
let id = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.abortController = void 0, this.open = Xr.state.open, this.caipAddress = xr.state.address, this.isSiweEnabled = Dn.state.isSiweEnabled, this.initializeTheming(), lr.prefetch(), this.unsubscribe.push(Xr.subscribeKey("open", (e) => e ? this.onOpen() : this.onClose()), Dn.subscribeKey("isSiweEnabled", (e) => {
      this.isSiweEnabled = e;
    }), xr.subscribe((e) => this.onNewAccountState(e))), Ht.sendEvent({ type: "track", event: "MODAL_LOADED" });
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e()), this.onRemoveKeyboardListener();
  }
  render() {
    return this.open ? Ae`
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
        ` : null;
  }
  async onOverlayClick(e) {
    e.target === e.currentTarget && await this.handleClose();
  }
  async handleClose() {
    this.isSiweEnabled && Dn.state.status !== "success" && await wr.disconnect(), Xr.close();
  }
  initializeTheming() {
    const { themeVariables: e, themeMode: t } = Cs.state, n = jr.getColorTheme(t);
    BP(e, n);
  }
  async onClose() {
    this.onScrollUnlock(), await this.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards"
    }).finished, In.hide(), this.open = !1, this.onRemoveKeyboardListener();
  }
  async onOpen() {
    this.onScrollLock(), this.open = !0, await this.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards",
      delay: 300
    }).finished, this.onAddKeyboardListener();
  }
  onScrollLock() {
    const e = document.createElement("style");
    e.dataset.w3m = MR, e.textContent = `
      html, body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `, document.head.appendChild(e);
  }
  onScrollUnlock() {
    const e = document.head.querySelector(`style[data-w3m="${MR}"]`);
    e && e.remove();
  }
  onAddKeyboardListener() {
    var t;
    this.abortController = new AbortController();
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector("wui-card");
    e == null || e.focus(), window.addEventListener("keydown", (n) => {
      if (n.key === "Escape")
        this.handleClose();
      else if (n.key === "Tab") {
        const { tagName: i } = n.target;
        i && !i.includes("W3M-") && !i.includes("WUI-") && (e == null || e.focus());
      }
    }, this.abortController);
  }
  onRemoveKeyboardListener() {
    var e;
    (e = this.abortController) == null || e.abort(), this.abortController = void 0;
  }
  async onNewAccountState(e) {
    const { isConnected: t, caipAddress: n } = e;
    if (this.isSiweEnabled) {
      t && !this.caipAddress && (this.caipAddress = n), t && n && this.caipAddress !== n && (await Dn.signOut(), this.onSiweNavigation(), this.caipAddress = n);
      try {
        const i = await Dn.getSession();
        i && !t ? await Dn.signOut() : t && !i && this.onSiweNavigation();
      } catch {
        t && this.onSiweNavigation();
      }
    }
  }
  onSiweNavigation() {
    this.open ? ut.push("ConnectingSiwe") : Xr.open({
      view: "ConnectingSiwe"
    });
  }
};
id.styles = YQ;
D_([
  ot()
], id.prototype, "open", void 0);
D_([
  ot()
], id.prototype, "caipAddress", void 0);
D_([
  ot()
], id.prototype, "isSiweEnabled", void 0);
id = D_([
  $e("w3m-modal")
], id);
const XQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get W3mModal() {
    return id;
  }
}, Symbol.toStringTag, { value: "Module" })), eY = cn`
  :host {
    display: block;
    width: max-content;
  }
`;
var ey = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let sd = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.disabled = !1, this.network = An.state.caipNetwork, this.connected = xr.state.isConnected, this.loading = Xr.state.loading, this.unsubscribe.push(An.subscribeKey("caipNetwork", (e) => this.network = e), xr.subscribeKey("isConnected", (e) => this.connected = e), Xr.subscribeKey("loading", (e) => this.loading = e));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    var e;
    return Ae`
      <wui-network-button
        .disabled=${!!(this.disabled || this.loading)}
        imageSrc=${Sr(Sn.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${((e = this.network) == null ? void 0 : e.name) ?? (this.connected ? "Unknown Network" : "Select Network")}
      </wui-network-button>
    `;
  }
  onClick() {
    this.loading || Xr.open({ view: "Networks" });
  }
};
sd.styles = eY;
ey([
  bn({ type: Boolean })
], sd.prototype, "disabled", void 0);
ey([
  ot()
], sd.prototype, "network", void 0);
ey([
  ot()
], sd.prototype, "connected", void 0);
ey([
  ot()
], sd.prototype, "loading", void 0);
sd = ey([
  $e("w3m-network-button")
], sd);
const tY = cn`
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;
var TM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let c2 = class extends Xt {
  constructor() {
    super(), this.resizeObserver = void 0, this.prevHeight = "0px", this.prevHistoryLength = 1, this.unsubscribe = [], this.view = ut.state.view, this.unsubscribe.push(ut.subscribeKey("view", (e) => this.onViewChange(e)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(async ([e]) => {
      const t = `${e == null ? void 0 : e.contentRect.height}px`;
      this.prevHeight !== "0px" && (await this.animate([{ height: this.prevHeight }, { height: t }], {
        duration: 150,
        easing: "ease",
        fill: "forwards"
      }).finished, this.style.height = "auto"), this.prevHeight = t;
    }), this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    var e;
    (e = this.resizeObserver) == null || e.unobserve(this.getWrapper()), this.unsubscribe.forEach((t) => t());
  }
  render() {
    return Ae`<div>${this.viewTemplate()}</div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "Connect":
        return Ae`<w3m-connect-view></w3m-connect-view>`;
      case "ConnectingWalletConnect":
        return Ae`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
      case "ConnectingExternal":
        return Ae`<w3m-connecting-external-view></w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return Ae`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
      case "AllWallets":
        return Ae`<w3m-all-wallets-view></w3m-all-wallets-view>`;
      case "Networks":
        return Ae`<w3m-networks-view></w3m-networks-view>`;
      case "SwitchNetwork":
        return Ae`<w3m-network-switch-view></w3m-network-switch-view>`;
      case "Account":
        return Ae`<w3m-account-view></w3m-account-view>`;
      case "WhatIsAWallet":
        return Ae`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
      case "WhatIsANetwork":
        return Ae`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
      case "GetWallet":
        return Ae`<w3m-get-wallet-view></w3m-get-wallet-view>`;
      case "Downloads":
        return Ae`<w3m-downloads-view></w3m-downloads-view>`;
      case "EmailVerifyOtp":
        return Ae`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
      case "EmailVerifyDevice":
        return Ae`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
      case "ApproveTransaction":
        return Ae`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
      case "Transactions":
        return Ae`<w3m-transactions-view></w3m-transactions-view>`;
      case "UpgradeEmailWallet":
        return Ae`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
      case "UpdateEmailWallet":
        return Ae`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
      case "UpdateEmailWalletWaiting":
        return Ae`<w3m-update-email-wallet-waiting-view></w3m-update-email-wallet-waiting-view>`;
      default:
        return Ae`<w3m-connect-view></w3m-connect-view>`;
    }
  }
  async onViewChange(e) {
    const { history: t } = ut.state;
    let n = -10, i = 10;
    t.length < this.prevHistoryLength && (n = 10, i = -10), this.prevHistoryLength = t.length, await this.animate([
      { opacity: 1, transform: "translateX(0px)" },
      { opacity: 0, transform: `translateX(${n}px)` }
    ], { duration: 150, easing: "ease", fill: "forwards" }).finished, this.view = e, await this.animate([
      { opacity: 0, transform: `translateX(${i}px)` },
      { opacity: 1, transform: "translateX(0px)" }
    ], { duration: 150, easing: "ease", fill: "forwards", delay: 50 }).finished;
  }
  getWrapper() {
    var e;
    return (e = this.shadowRoot) == null ? void 0 : e.querySelector("div");
  }
};
c2.styles = tY;
TM([
  ot()
], c2.prototype, "view", void 0);
c2 = TM([
  $e("w3m-router")
], c2);
const rY = cn`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }
`;
var dh = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Rc = class extends Xt {
  constructor() {
    super(), this.usubscribe = [], this.address = xr.state.address, this.profileImage = xr.state.profileImage, this.profileName = xr.state.profileName, this.balance = xr.state.balance, this.balanceSymbol = xr.state.balanceSymbol, this.network = An.state.caipNetwork, this.disconecting = !1, this.usubscribe.push(xr.subscribe((e) => {
      e.address ? (this.address = e.address, this.profileImage = e.profileImage, this.profileName = e.profileName, this.balance = e.balance, this.balanceSymbol = e.balanceSymbol) : Xr.close();
    }), An.subscribeKey("caipNetwork", (e) => {
      e != null && e.id && (this.network = e);
    }));
  }
  disconnectedCallback() {
    this.usubscribe.forEach((e) => e());
  }
  render() {
    var t;
    if (!this.address)
      throw new Error("w3m-account-view: No account provided");
    const e = Sn.getNetworkImage(this.network);
    return Ae`
      <wui-flex
        flexDirection="column"
        .padding=${["0", "s", "m", "s"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${Sr(this.profileImage === null ? void 0 : this.profileImage)}
        ></wui-avatar>

        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100">
              ${this.profileName ? jr.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : jr.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-flex gap="s" flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-200">
              ${vt.formatBalance(this.balance, this.balanceSymbol)}
            </wui-text>

            ${this.explorerBtnTemplate()}
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.emailCardTemplate()} ${this.emailBtnTemplate()}

        <wui-list-item
          .variant=${e ? "image" : "icon"}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${Sr(e)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
          data-testid="w3m-account-select-network"
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${((t = this.network) == null ? void 0 : t.name) ?? "Unknown"}
          </wui-text>
        </wui-list-item>
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalBold"
          iconSize="sm"
          ?chevron=${!0}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${!1}
          .loading=${this.disconecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>
    `;
  }
  emailCardTemplate() {
    const e = ns.getConnectedConnector(), t = Yr.getEmailConnector(), { origin: n } = location;
    return !t || e !== "EMAIL" || n.includes(Cl.SECURE_SITE) ? null : Ae`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a non-custodial wallet"
        icon="wallet"
      ></wui-notice-card>
    `;
  }
  emailBtnTemplate() {
    const e = ns.getConnectedConnector(), t = Yr.getEmailConnector();
    if (!t || e !== "EMAIL")
      return null;
    const n = t.provider.getEmail() ?? "";
    return Ae`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="mail"
        iconSize="sm"
        ?chevron=${!0}
        @click=${() => this.onGoToUpdateEmail(n)}
      >
        <wui-text variant="paragraph-500" color="fg-100">${n}</wui-text>
      </wui-list-item>
    `;
  }
  explorerBtnTemplate() {
    const { addressExplorerUrl: e } = xr.state;
    return e ? Ae`
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    ` : null;
  }
  isAllowedNetworkSwitch() {
    const { requestedCaipNetworks: e } = An.state, t = e ? e.length > 1 : !1, n = e == null ? void 0 : e.find(({ id: i }) => {
      var s;
      return i === ((s = this.network) == null ? void 0 : s.id);
    });
    return t || !n;
  }
  onCopyAddress() {
    try {
      this.address && (vt.copyToClopboard(this.address), In.showSuccess("Address copied"));
    } catch {
      In.showError("Failed to copy");
    }
  }
  onNetworks() {
    this.isAllowedNetworkSwitch() && ut.push("Networks");
  }
  onTransactions() {
    Ht.sendEvent({ type: "track", event: "CLICK_TRANSACTIONS" }), ut.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconecting = !0, await wr.disconnect(), Ht.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" }), Xr.close();
    } catch {
      Ht.sendEvent({ type: "track", event: "DISCONNECT_ERROR" }), In.showError("Failed to disconnect");
    } finally {
      this.disconecting = !1;
    }
  }
  onExplorer() {
    const { addressExplorerUrl: e } = xr.state;
    e && vt.openHref(e, "_blank");
  }
  onGoToUpgradeView() {
    Ht.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" }), ut.push("UpgradeEmailWallet");
  }
  onGoToUpdateEmail(e) {
    ut.push("UpdateEmailWallet", { email: e });
  }
};
Rc.styles = rY;
dh([
  ot()
], Rc.prototype, "address", void 0);
dh([
  ot()
], Rc.prototype, "profileImage", void 0);
dh([
  ot()
], Rc.prototype, "profileName", void 0);
dh([
  ot()
], Rc.prototype, "balance", void 0);
dh([
  ot()
], Rc.prototype, "balanceSymbol", void 0);
dh([
  ot()
], Rc.prototype, "network", void 0);
dh([
  ot()
], Rc.prototype, "disconecting", void 0);
Rc = dh([
  $e("w3m-account-view")
], Rc);
var OM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let N6 = class extends Xt {
  constructor() {
    super(...arguments), this.search = "", this.onDebouncedSearch = vt.debounce((e) => {
      this.search = e;
    });
  }
  render() {
    const e = this.search.length >= 2;
    return Ae`
      <wui-flex padding="s" gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${e ? Ae`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : Ae`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `;
  }
  onInputChange(e) {
    this.onDebouncedSearch(e.detail);
  }
  qrButtonTemplate() {
    return vt.isMobile() ? Ae`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      ` : null;
  }
  onWalletConnectQr() {
    ut.push("ConnectingWalletConnect");
  }
};
OM([
  ot()
], N6.prototype, "search", void 0);
N6 = OM([
  $e("w3m-all-wallets-view")
], N6);
const nY = cn`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var NM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let l2 = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.connectors = Yr.state.connectors, this.unsubscribe.push(Yr.subscribeKey("connectors", (e) => this.connectors = e));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    return Ae`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-email-login-widget></w3m-email-login-widget>

        ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
        ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
        ${this.customTemplate()} ${this.recommendedTemplate()} ${this.connectorsTemplate()}
        ${this.allWalletsTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  walletConnectConnectorTemplate() {
    if (vt.isMobile())
      return null;
    const e = this.connectors.find((t) => t.type === "WALLET_CONNECT");
    return e ? Ae`
      <wui-list-wallet
        imageSrc=${Sr(Sn.getConnectorImage(e))}
        name=${e.name ?? "Unknown"}
        @click=${() => this.onConnector(e)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    ` : null;
  }
  customTemplate() {
    const { customWallets: e } = Rr.state;
    return e != null && e.length ? this.filterOutDuplicateWallets(e).map((n) => Ae`
        <wui-list-wallet
          imageSrc=${Sr(Sn.getWalletImage(n))}
          name=${n.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(n)}
        >
        </wui-list-wallet>
      `) : null;
  }
  featuredTemplate() {
    if (!this.connectors.find((i) => i.type === "WALLET_CONNECT"))
      return null;
    const { featured: t } = lr.state;
    return t.length ? this.filterOutDuplicateWallets(t).map((i) => Ae`
        <wui-list-wallet
          imageSrc=${Sr(Sn.getWalletImage(i))}
          name=${i.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(i)}
        >
        </wui-list-wallet>
      `) : null;
  }
  recentTemplate() {
    return ns.getRecentWallets().map((t) => Ae`
        <wui-list-wallet
          imageSrc=${Sr(Sn.getWalletImage(t))}
          name=${t.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(t)}
          tagLabel="recent"
          tagVariant="shade"
        >
        </wui-list-wallet>
      `);
  }
  announcedTemplate() {
    return this.connectors.map((e) => e.type !== "ANNOUNCED" ? null : Ae`
        <wui-list-wallet
          imageSrc=${Sr(Sn.getConnectorImage(e))}
          name=${e.name ?? "Unknown"}
          @click=${() => this.onConnector(e)}
          tagVariant="success"
          .installed=${!0}
        >
        </wui-list-wallet>
      `);
  }
  injectedTemplate() {
    const e = this.connectors.find((t) => t.type === "ANNOUNCED");
    return this.connectors.map((t) => t.type !== "INJECTED" || !wr.checkInstalled() ? null : Ae`
        <wui-list-wallet
          imageSrc=${Sr(Sn.getConnectorImage(t))}
          .installed=${!!e}
          name=${t.name ?? "Unknown"}
          @click=${() => this.onConnector(t)}
        >
        </wui-list-wallet>
      `);
  }
  connectorsTemplate() {
    const e = Yr.getAnnouncedConnectorRdns();
    return this.connectors.map((t) => ["WALLET_CONNECT", "INJECTED", "ANNOUNCED", "EMAIL"].includes(t.type) || e.includes(Cl.CONNECTOR_RDNS_MAP[t.id]) ? null : Ae`
        <wui-list-wallet
          imageSrc=${Sr(Sn.getConnectorImage(t))}
          name=${t.name ?? "Unknown"}
          @click=${() => this.onConnector(t)}
        >
        </wui-list-wallet>
      `);
  }
  allWalletsTemplate() {
    if (!this.connectors.find((a) => a.type === "WALLET_CONNECT"))
      return null;
    const t = lr.state.count, n = lr.state.featured.length, i = t + n, s = i < 10 ? i : Math.floor(i / 10) * 10, o = s < i ? `${s}+` : `${s}`;
    return Ae`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${o}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `;
  }
  recommendedTemplate() {
    if (!this.connectors.find((d) => d.type === "WALLET_CONNECT"))
      return null;
    const { recommended: t } = lr.state, { customWallets: n, featuredWalletIds: i } = Rr.state, { connectors: s } = Yr.state, o = ns.getRecentWallets(), a = s.filter((d) => d.type === "ANNOUNCED");
    if (i || n || !t.length)
      return null;
    const c = a.length + o.length, u = Math.max(0, 2 - c);
    return this.filterOutDuplicateWallets(t).slice(0, u).map((d) => Ae`
        <wui-list-wallet
          imageSrc=${Sr(Sn.getWalletImage(d))}
          name=${(d == null ? void 0 : d.name) ?? "Unknown"}
          @click=${() => this.onConnectWallet(d)}
        >
        </wui-list-wallet>
      `);
  }
  onConnector(e) {
    e.type === "WALLET_CONNECT" ? vt.isMobile() ? ut.push("AllWallets") : ut.push("ConnectingWalletConnect") : ut.push("ConnectingExternal", { connector: e });
  }
  filterOutDuplicateWallets(e) {
    const { connectors: t } = Yr.state, i = ns.getRecentWallets().map((a) => a.id), s = t.map((a) => {
      var c;
      return (c = a.info) == null ? void 0 : c.rdns;
    }).filter(Boolean);
    return e.filter((a) => !i.includes(a.id) && !s.includes(a.rdns ?? void 0));
  }
  onAllWallets() {
    Ht.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" }), ut.push("AllWallets");
  }
  onConnectWallet(e) {
    ut.push("ConnectingWalletConnect", { wallet: e });
  }
};
l2.styles = nY;
NM([
  ot()
], l2.prototype, "connectors", void 0);
l2 = NM([
  $e("w3m-connect-view")
], l2);
const iY = cn`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
var Id = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
class $s extends Xt {
  constructor() {
    var e, t, n, i;
    super(), this.wallet = (e = ut.state.data) == null ? void 0 : e.wallet, this.connector = (t = ut.state.data) == null ? void 0 : t.connector, this.timeout = void 0, this.secondaryBtnLabel = "Try again", this.secondaryBtnIcon = "refresh", this.secondaryLabel = "Accept connection request in the wallet", this.onConnect = void 0, this.onRender = void 0, this.onAutoConnect = void 0, this.isWalletConnect = !0, this.unsubscribe = [], this.imageSrc = Sn.getWalletImage(this.wallet) ?? Sn.getConnectorImage(this.connector), this.name = ((n = this.wallet) == null ? void 0 : n.name) ?? ((i = this.connector) == null ? void 0 : i.name) ?? "Wallet", this.isRetrying = !1, this.uri = wr.state.wcUri, this.error = wr.state.wcError, this.ready = !1, this.showRetry = !1, this.buffering = !1, this.isMobile = !1, this.onRetry = void 0, this.unsubscribe.push(wr.subscribeKey("wcUri", (s) => {
      var o;
      this.uri = s, this.isRetrying && this.onRetry && (this.isRetrying = !1, (o = this.onConnect) == null || o.call(this));
    }), wr.subscribeKey("wcError", (s) => this.error = s), wr.subscribeKey("buffering", (s) => this.buffering = s));
  }
  firstUpdated() {
    var e;
    (e = this.onAutoConnect) == null || e.call(this), this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e()), clearTimeout(this.timeout);
  }
  render() {
    var n;
    (n = this.onRender) == null || n.call(this), this.onShowRetry();
    const e = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let t = `Continue in ${this.name}`;
    return this.buffering && (t = "Connecting..."), this.error && (t = "Connection declined"), Ae`
      <wui-flex
        data-error=${Sr(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${Sr(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${t}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${e}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? Ae`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onShowRetry() {
    var e;
    if (this.error && !this.showRetry) {
      this.showRetry = !0;
      const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("wui-button");
      t == null || t.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    var e, t;
    this.buffering || (wr.setWcError(!1), this.onRetry ? (this.isRetrying = !0, (e = this.onRetry) == null || e.call(this)) : (t = this.onConnect) == null || t.call(this));
  }
  loaderTemplate() {
    const e = Cs.state.themeVariables["--w3m-border-radius-master"], t = e ? parseInt(e.replace("px", ""), 10) : 4;
    return Ae`<wui-loading-thumbnail radius=${t * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      this.uri && (vt.copyToClopboard(this.uri), In.showSuccess("Link copied"));
    } catch {
      In.showError("Failed to copy");
    }
  }
}
$s.styles = iY;
Id([
  ot()
], $s.prototype, "uri", void 0);
Id([
  ot()
], $s.prototype, "error", void 0);
Id([
  ot()
], $s.prototype, "ready", void 0);
Id([
  ot()
], $s.prototype, "showRetry", void 0);
Id([
  ot()
], $s.prototype, "buffering", void 0);
Id([
  bn({ type: Boolean })
], $s.prototype, "isMobile", void 0);
Id([
  bn()
], $s.prototype, "onRetry", void 0);
var sY = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const oY = {
  INJECTED: "browser",
  ANNOUNCED: "browser"
};
let DR = class extends $s {
  constructor() {
    if (super(), !this.connector)
      throw new Error("w3m-connecting-view: No connector provided");
    Ht.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: oY[this.connector.type] ?? "external"
      }
    }), this.onConnect = this.onConnectProxy.bind(this), this.onAutoConnect = this.onConnectProxy.bind(this), this.isWalletConnect = !1;
  }
  async onConnectProxy() {
    try {
      this.error = !1, this.connector && (this.connector.imageUrl && ns.setConnectedWalletImageUrl(this.connector.imageUrl), await wr.connectExternal(this.connector), Dn.state.isSiweEnabled ? ut.push("ConnectingSiwe") : Xr.close(), Ht.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "external" }
      }));
    } catch (e) {
      Ht.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (e == null ? void 0 : e.message) ?? "Unknown" }
      }), this.error = !0;
    }
  }
};
DR = sY([
  $e("w3m-connecting-external-view")
], DR);
var PM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let P6 = class extends Xt {
  constructor() {
    var e;
    super(...arguments), this.dappName = (e = Rr.state.metadata) == null ? void 0 : e.name, this.isSigning = !1;
  }
  render() {
    return Ae`
      <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="md"
          ?fullwidth=${!0}
          variant="shade"
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="md"
          ?fullwidth=${!0}
          variant="fill"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="w3m-connecting-siwe-sign"
        >
          ${this.isSigning ? "Signing..." : "Sign"}
        </wui-button>
      </wui-flex>
    `;
  }
  async onSign() {
    this.isSigning = !0, Ht.sendEvent({
      event: "CLICK_SIGN_SIWE_MESSAGE",
      type: "track"
    });
    try {
      Dn.setStatus("loading");
      const e = await Dn.signIn();
      return Dn.setStatus("success"), Ht.sendEvent({
        event: "SIWE_AUTH_SUCCESS",
        type: "track"
      }), e;
    } catch {
      return In.showError("Signature declined"), Dn.setStatus("error"), Ht.sendEvent({
        event: "SIWE_AUTH_ERROR",
        type: "track"
      });
    } finally {
      this.isSigning = !1;
    }
  }
  async onCancel() {
    const { isConnected: e } = xr.state;
    e ? (await wr.disconnect(), Xr.close()) : ut.push("Connect"), Ht.sendEvent({
      event: "CLICK_CANCEL_SIWE",
      type: "track"
    });
  }
};
PM([
  ot()
], P6.prototype, "isSigning", void 0);
P6 = PM([
  $e("w3m-connecting-siwe-view")
], P6);
var GS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let u2 = class extends Xt {
  constructor() {
    var e;
    super(), this.interval = void 0, this.lastRetry = Date.now(), this.wallet = (e = ut.state.data) == null ? void 0 : e.wallet, this.platform = void 0, this.platforms = [], this.initializeConnection(), this.interval = setInterval(this.initializeConnection.bind(this), Cl.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    return this.wallet ? (this.determinePlatforms(), Ae`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `) : Ae`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
  }
  async initializeConnection(e = !1) {
    try {
      const { wcPairingExpiry: t } = wr.state;
      if (e || vt.isPairingExpired(t)) {
        if (wr.connectWalletConnect(), this.wallet) {
          const n = Sn.getWalletImage(this.wallet);
          n && ns.setConnectedWalletImageUrl(n);
        } else {
          const i = Yr.state.connectors.find((o) => o.type === "WALLET_CONNECT"), s = Sn.getConnectorImage(i);
          s && ns.setConnectedWalletImageUrl(s);
        }
        await wr.state.wcPromise, this.finalizeConnection(), Dn.state.isSiweEnabled ? ut.push("ConnectingSiwe") : Xr.close();
      }
    } catch (t) {
      Ht.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (t == null ? void 0 : t.message) ?? "Unknown" }
      }), wr.setWcError(!0), vt.isAllowedRetry(this.lastRetry) && (In.showError("Declined"), this.lastRetry = Date.now(), this.initializeConnection(!0));
    }
  }
  finalizeConnection() {
    const { wcLinking: e, recentWallet: t } = wr.state;
    e && ns.setWalletConnectDeepLink(e), t && ns.setWeb3ModalRecent(t), Ht.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: e ? "mobile" : "qrcode"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet)
      throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
    if (this.platform)
      return;
    const { mobile_link: e, desktop_link: t, webapp_link: n, injected: i, rdns: s } = this.wallet, o = i == null ? void 0 : i.map(({ injected_id: b }) => b).filter(Boolean), a = s ? [s] : o ?? [], c = a.length, u = e, f = n, d = wr.checkInstalled(a), m = c && d, y = t && !vt.isMobile();
    m && this.platforms.push("browser"), u && this.platforms.push(vt.isMobile() ? "mobile" : "qrcode"), f && this.platforms.push("web"), y && this.platforms.push("desktop"), !m && c && this.platforms.push("unsupported"), this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return Ae`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
      case "desktop":
        return Ae`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(!0)}>
          </w3m-connecting-wc-desktop>
        `;
      case "web":
        return Ae`
          <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(!0)}>
          </w3m-connecting-wc-web>
        `;
      case "mobile":
        return Ae`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(!0)}>
          </w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return Ae`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
      default:
        return Ae`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    return this.platforms.length > 1 ? Ae`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    ` : null;
  }
  async onSelectPlatform(e) {
    var n;
    const t = (n = this.shadowRoot) == null ? void 0 : n.querySelector("div");
    t && (await t.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      fill: "forwards",
      easing: "ease"
    }).finished, this.platform = e, t.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: 200,
      fill: "forwards",
      easing: "ease"
    }));
  }
};
GS([
  ot()
], u2.prototype, "platform", void 0);
GS([
  ot()
], u2.prototype, "platforms", void 0);
u2 = GS([
  $e("w3m-connecting-wc-view")
], u2);
var aY = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let kR = class extends Xt {
  constructor() {
    var e;
    super(...arguments), this.wallet = (e = ut.state.data) == null ? void 0 : e.wallet;
  }
  render() {
    if (!this.wallet)
      throw new Error("w3m-downloads-view");
    return Ae`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
  }
  chromeTemplate() {
    var e;
    return (e = this.wallet) != null && e.chrome_store ? Ae`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>` : null;
  }
  iosTemplate() {
    var e;
    return (e = this.wallet) != null && e.app_store ? Ae`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>` : null;
  }
  androidTemplate() {
    var e;
    return (e = this.wallet) != null && e.play_store ? Ae`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>` : null;
  }
  homepageTemplate() {
    var e;
    return (e = this.wallet) != null && e.homepage ? Ae`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    ` : null;
  }
  onChromeStore() {
    var e;
    (e = this.wallet) != null && e.chrome_store && vt.openHref(this.wallet.chrome_store, "_blank");
  }
  onAppStore() {
    var e;
    (e = this.wallet) != null && e.app_store && vt.openHref(this.wallet.app_store, "_blank");
  }
  onPlayStore() {
    var e;
    (e = this.wallet) != null && e.play_store && vt.openHref(this.wallet.play_store, "_blank");
  }
  onHomePage() {
    var e;
    (e = this.wallet) != null && e.homepage && vt.openHref(this.wallet.homepage, "_blank");
  }
};
kR = aY([
  $e("w3m-downloads-view")
], kR);
var cY = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const lY = "https://walletconnect.com/explorer";
let $R = class extends Xt {
  render() {
    return Ae`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      vt.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></wui-list-wallet>
      </wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended: e, featured: t } = lr.state, { customWallets: n } = Rr.state;
    return [...t, ...n ?? [], ...e].slice(0, 4).map((s) => Ae`
        <wui-list-wallet
          name=${s.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${Sr(Sn.getWalletImage(s))}
          @click=${() => {
      vt.openHref(s.homepage ?? lY, "_blank");
    }}
        ></wui-list-wallet>
      `);
  }
};
$R = cY([
  $e("w3m-get-wallet-view")
], $R);
const uY = cn`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
var KS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Um = class extends Xt {
  constructor() {
    var e;
    super(), this.network = (e = ut.state.data) == null ? void 0 : e.network, this.unsubscribe = [], this.showRetry = !1, this.error = !1;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network)
      throw new Error("w3m-network-switch-view: No network provided");
    this.onShowRetry();
    const e = this.error ? "Switch declined" : "Approve in wallet", t = this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
    return Ae`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${Sr(Sn.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : Ae`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${!0}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${e}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${t}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="fill"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
  }
  onShowRetry() {
    var e;
    if (this.error && !this.showRetry) {
      this.showRetry = !0;
      const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("wui-button");
      t == null || t.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = !1, this.network && (await An.switchActiveNetwork(this.network), Dn.state.isSiweEnabled || RP.navigateAfterNetworkSwitch());
    } catch {
      this.error = !0;
    }
  }
};
Um.styles = uY;
KS([
  ot()
], Um.prototype, "showRetry", void 0);
KS([
  ot()
], Um.prototype, "error", void 0);
Um = KS([
  $e("w3m-network-switch-view")
], Um);
const hY = cn`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var MM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let h2 = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.caipNetwork = An.state.caipNetwork, this.unsubscribe.push(An.subscribeKey("caipNetwork", (e) => this.caipNetwork = e));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    return Ae`
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
  }
  onNetworkHelp() {
    Ht.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" }), ut.push("WhatIsANetwork");
  }
  networksTemplate() {
    const { approvedCaipNetworkIds: e, requestedCaipNetworks: t, supportsAllNetworks: n } = An.state, i = e, s = t, o = {};
    return s && i && (i.forEach((a, c) => {
      o[a] = c;
    }), s.sort((a, c) => {
      const u = o[a.id], f = o[c.id];
      return u !== void 0 && f !== void 0 ? u - f : u !== void 0 ? -1 : f !== void 0 ? 1 : 0;
    })), s == null ? void 0 : s.map((a) => {
      var c;
      return Ae`
        <wui-card-select
          .selected=${((c = this.caipNetwork) == null ? void 0 : c.id) === a.id}
          imageSrc=${Sr(Sn.getNetworkImage(a))}
          type="network"
          name=${a.name ?? a.id}
          @click=${() => this.onSwitchNetwork(a)}
          .disabled=${!n && !(i != null && i.includes(a.id))}
          data-testid=${`w3m-network-switch-${a.name ?? a.id}`}
        ></wui-card-select>
      `;
    });
  }
  async onSwitchNetwork(e) {
    const { isConnected: t } = xr.state, { approvedCaipNetworkIds: n, supportsAllNetworks: i, caipNetwork: s } = An.state, { data: o } = ut.state;
    t && (s == null ? void 0 : s.id) !== e.id ? n != null && n.includes(e.id) ? (await An.switchActiveNetwork(e), RP.navigateAfterNetworkSwitch()) : i && ut.push("SwitchNetwork", { ...o, network: e }) : t || (An.setCaipNetwork(e), ut.push("Connect"));
  }
};
h2.styles = hY;
MM([
  ot()
], h2.prototype, "caipNetwork", void 0);
h2 = MM([
  $e("w3m-networks-view")
], h2);
const fY = cn`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }
`;
var Rd = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const qv = "last-transaction", dY = 7;
let Ml = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.paginationObserver = void 0, this.address = xr.state.address, this.transactions = oa.state.transactions, this.transactionsByYear = oa.state.transactionsByYear, this.loading = oa.state.loading, this.empty = oa.state.empty, this.next = oa.state.next, this.unsubscribe.push(xr.subscribe((e) => {
      e.isConnected && this.address !== e.address && (this.address = e.address, oa.resetTransactions(), oa.fetchTransactions(e.address));
    }), oa.subscribe((e) => {
      this.transactions = e.transactions, this.transactionsByYear = e.transactionsByYear, this.loading = e.loading, this.empty = e.empty, this.next = e.next;
    }));
  }
  firstUpdated() {
    this.transactions.length === 0 && oa.fetchTransactions(this.address), this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    return Ae`
      <wui-flex flexDirection="column" padding="s" gap="s">
        ${this.empty ? null : this.templateTransactionsByYear()}
        ${this.loading ? this.templateLoading() : null}
        ${!this.loading && this.empty ? this.templateEmpty() : null}
      </wui-flex>
    `;
  }
  templateTransactionsByYear() {
    const e = Object.keys(this.transactionsByYear).sort().reverse();
    return e.map((t, n) => {
      const i = n === e.length - 1, s = parseInt(t, 10), o = sf.getTransactionGroupTitle(s), a = this.transactionsByYear[s];
      return a ? Ae`
        <wui-flex flexDirection="column" gap="s">
          <wui-flex
            alignItems="center"
            flexDirection="row"
            .padding=${["xs", "s", "s", "s"]}
          >
            <wui-text variant="paragraph-500" color="fg-200">${o}</wui-text>
          </wui-flex>
          <wui-flex flexDirection="column" gap="xs">
            ${this.templateTransactions(a, i)}
          </wui-flex>
        </wui-flex>
      ` : null;
    });
  }
  templateRenderTransaction(e, t) {
    const { date: n, descriptions: i, direction: s, isAllNFT: o, images: a, status: c, transfers: u, type: f } = this.getTransactionListItemProps(e), d = (u == null ? void 0 : u.length) > 1;
    return (u == null ? void 0 : u.length) === 2 && !o ? Ae`
        <wui-transaction-list-item
          date=${n}
          .direction=${s}
          id=${t && this.next ? qv : ""}
          status=${c}
          type=${f}
          .images=${a}
          .descriptions=${i}
        ></wui-transaction-list-item>
      ` : d ? u.map((y, b) => {
      const I = sf.getTransferDescription(y), k = t && b === u.length - 1;
      return Ae` <wui-transaction-list-item
          date=${n}
          direction=${y.direction}
          id=${k && this.next ? qv : ""}
          status=${c}
          type=${f}
          .onlyDirectionIcon=${!0}
          .images=${[a == null ? void 0 : a[b]]}
          .descriptions=${[I]}
        ></wui-transaction-list-item>`;
    }) : Ae`
      <wui-transaction-list-item
        date=${n}
        .direction=${s}
        id=${t && this.next ? qv : ""}
        status=${c}
        type=${f}
        .images=${a}
        .descriptions=${i}
      ></wui-transaction-list-item>
    `;
  }
  templateTransactions(e, t) {
    return e.map((n, i) => {
      const s = t && i === e.length - 1;
      return Ae`${this.templateRenderTransaction(n, s)}`;
    });
  }
  templateEmpty() {
    return Ae`
      <wui-flex
        flexGrow="1"
        flexDirection="column"
        justifyContent="center"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-icon-box
          backgroundColor="glass-005"
          background="gray"
          iconColor="fg-200"
          icon="wallet"
          size="lg"
          ?border=${!0}
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >No Transactions yet</wui-text
          >
          <wui-text align="center" variant="small-500" color="fg-200"
            >Start trading on dApps <br />
            to grow your wallet!</wui-text
          >
        </wui-flex>
      </wui-flex>
    `;
  }
  templateLoading() {
    return Array(dY).fill(Ae` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((e) => e);
  }
  createPaginationObserver() {
    const { projectId: e } = Rr.state;
    this.paginationObserver = new IntersectionObserver(([t]) => {
      t != null && t.isIntersecting && !this.loading && (oa.fetchTransactions(this.address), Ht.sendEvent({
        type: "track",
        event: "LOAD_MORE_TRANSACTIONS",
        properties: {
          address: this.address,
          projectId: e,
          cursor: this.next
        }
      }));
    }, {}), this.setPaginationObserver();
  }
  setPaginationObserver() {
    var t, n, i;
    (t = this.paginationObserver) == null || t.disconnect();
    const e = (n = this.shadowRoot) == null ? void 0 : n.querySelector(`#${qv}`);
    e && ((i = this.paginationObserver) == null || i.observe(e));
  }
  getTransactionListItemProps(e) {
    var c, u, f, d, m;
    const t = bM.getRelativeDateFromNow((c = e == null ? void 0 : e.metadata) == null ? void 0 : c.minedAt), n = sf.getTransactionDescriptions(e), i = e == null ? void 0 : e.transfers, s = (u = e == null ? void 0 : e.transfers) == null ? void 0 : u[0], o = !!s && ((f = e == null ? void 0 : e.transfers) == null ? void 0 : f.every((y) => !!y.nft_info)), a = sf.getTransactionImages(i);
    return {
      date: t,
      direction: s == null ? void 0 : s.direction,
      descriptions: n,
      isAllNFT: o,
      images: a,
      status: (d = e.metadata) == null ? void 0 : d.status,
      transfers: i,
      type: (m = e.metadata) == null ? void 0 : m.operationType
    };
  }
};
Ml.styles = fY;
Rd([
  ot()
], Ml.prototype, "address", void 0);
Rd([
  ot()
], Ml.prototype, "transactions", void 0);
Rd([
  ot()
], Ml.prototype, "transactionsByYear", void 0);
Rd([
  ot()
], Ml.prototype, "loading", void 0);
Rd([
  ot()
], Ml.prototype, "empty", void 0);
Rd([
  ot()
], Ml.prototype, "next", void 0);
Ml = Rd([
  $e("w3m-transactions-view")
], Ml);
var pY = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const gY = [
  {
    images: ["network", "layers", "system"],
    title: "The systems nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
let LR = class extends Xt {
  render() {
    return Ae`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${gY}></w3m-help-widget>
        <wui-button
          variant="fill"
          size="sm"
          @click=${() => {
      vt.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
LR = pY([
  $e("w3m-what-is-a-network-view")
], LR);
var mY = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const wY = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
let BR = class extends Xt {
  render() {
    return Ae`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${wY}></w3m-help-widget>
        <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
  }
  onGetWallet() {
    Ht.sendEvent({ type: "track", event: "CLICK_GET_WALLET" }), ut.push("GetWallet");
  }
};
BR = mY([
  $e("w3m-what-is-a-wallet-view")
], BR);
const yY = cn`
  wui-loading-spinner {
    margin: 9px auto;
  }
`, ct = {
  SECURE_SITE_SDK: "https://secure.web3modal.com/sdk",
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@w3m-storage/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_AWAIT_UPDATE_EMAIL_SUCCESS: "@w3m-frame/AWAIT_UPDATE_EMAIL_SUCCESS",
  FRAME_AWAIT_UPDATE_EMAIL_ERROR: "@w3m-frame/AWAIT_UPDATE_EMAIL_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR"
}, DM = {
  SAFE_RPC_METHODS: ["eth_blockNumber", "eth_estimateGas", "eth_getTransactionByHash"],
  GET_CHAIN_ID: "eth_chainId"
};
var Cr;
(function(r) {
  r.assertEqual = (i) => i;
  function e(i) {
  }
  r.assertIs = e;
  function t(i) {
    throw new Error();
  }
  r.assertNever = t, r.arrayToEnum = (i) => {
    const s = {};
    for (const o of i)
      s[o] = o;
    return s;
  }, r.getValidEnumValues = (i) => {
    const s = r.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), o = {};
    for (const a of s)
      o[a] = i[a];
    return r.objectValues(o);
  }, r.objectValues = (i) => r.objectKeys(i).map(function(s) {
    return i[s];
  }), r.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const s = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && s.push(o);
    return s;
  }, r.find = (i, s) => {
    for (const o of i)
      if (s(o))
        return o;
  }, r.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, s = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(s);
  }
  r.joinValues = n, r.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s;
})(Cr || (Cr = {}));
var M6;
(function(r) {
  r.mergeShapes = (e, t) => ({
    ...e,
    ...t
    // second overwrites first
  });
})(M6 || (M6 = {}));
const Xe = Cr.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), wu = (r) => {
  switch (typeof r) {
    case "undefined":
      return Xe.undefined;
    case "string":
      return Xe.string;
    case "number":
      return isNaN(r) ? Xe.nan : Xe.number;
    case "boolean":
      return Xe.boolean;
    case "function":
      return Xe.function;
    case "bigint":
      return Xe.bigint;
    case "symbol":
      return Xe.symbol;
    case "object":
      return Array.isArray(r) ? Xe.array : r === null ? Xe.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? Xe.promise : typeof Map < "u" && r instanceof Map ? Xe.map : typeof Set < "u" && r instanceof Set ? Xe.set : typeof Date < "u" && r instanceof Date ? Xe.date : Xe.object;
    default:
      return Xe.unknown;
  }
}, Be = Cr.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), vY = (r) => JSON.stringify(r, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ia extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const t = e || function(s) {
      return s.message;
    }, n = { _errors: [] }, i = (s) => {
      for (const o of s.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          n._errors.push(t(o));
        else {
          let a = n, c = 0;
          for (; c < o.path.length; ) {
            const u = o.path[c];
            c === o.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(t(o))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return i(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Cr.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (t[i.path[0]] = t[i.path[0]] || [], t[i.path[0]].push(e(i))) : n.push(e(i));
    return { formErrors: n, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ia.create = (r) => new Ia(r);
const jm = (r, e) => {
  let t;
  switch (r.code) {
    case Be.invalid_type:
      r.received === Xe.undefined ? t = "Required" : t = `Expected ${r.expected}, received ${r.received}`;
      break;
    case Be.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(r.expected, Cr.jsonStringifyReplacer)}`;
      break;
    case Be.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${Cr.joinValues(r.keys, ", ")}`;
      break;
    case Be.invalid_union:
      t = "Invalid input";
      break;
    case Be.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${Cr.joinValues(r.options)}`;
      break;
    case Be.invalid_enum_value:
      t = `Invalid enum value. Expected ${Cr.joinValues(r.options)}, received '${r.received}'`;
      break;
    case Be.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case Be.invalid_return_type:
      t = "Invalid function return type";
      break;
    case Be.invalid_date:
      t = "Invalid date";
      break;
    case Be.invalid_string:
      typeof r.validation == "object" ? "includes" in r.validation ? (t = `Invalid input: must include "${r.validation.includes}"`, typeof r.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith" in r.validation ? t = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? t = `Invalid input: must end with "${r.validation.endsWith}"` : Cr.assertNever(r.validation) : r.validation !== "regex" ? t = `Invalid ${r.validation}` : t = "Invalid";
      break;
    case Be.too_small:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : t = "Invalid input";
      break;
    case Be.too_big:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? t = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : t = "Invalid input";
      break;
    case Be.custom:
      t = "Invalid input";
      break;
    case Be.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case Be.not_multiple_of:
      t = `Number must be a multiple of ${r.multipleOf}`;
      break;
    case Be.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, Cr.assertNever(r);
  }
  return { message: t };
};
let kM = jm;
function bY(r) {
  kM = r;
}
function f2() {
  return kM;
}
const d2 = (r) => {
  const { data: e, path: t, errorMaps: n, issueData: i } = r, s = [...t, ...i.path || []], o = {
    ...i,
    path: s
  };
  let a = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    a = u(o, { data: e, defaultError: a }).message;
  return {
    ...i,
    path: s,
    message: i.message || a
  };
}, _Y = [];
function rt(r, e) {
  const t = d2({
    issueData: e,
    data: r.data,
    path: r.path,
    errorMaps: [
      r.common.contextualErrorMap,
      r.schemaErrorMap,
      f2(),
      jm
      // then global default map
    ].filter((n) => !!n)
  });
  r.common.issues.push(t);
}
class Fi {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const n = [];
    for (const i of t) {
      if (i.status === "aborted")
        return zt;
      i.status === "dirty" && e.dirty(), n.push(i.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, t) {
    const n = [];
    for (const i of t)
      n.push({
        key: await i.key,
        value: await i.value
      });
    return Fi.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, t) {
    const n = {};
    for (const i of t) {
      const { key: s, value: o } = i;
      if (s.status === "aborted" || o.status === "aborted")
        return zt;
      s.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), s.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (n[s.value] = o.value);
    }
    return { status: e.value, value: n };
  }
}
const zt = Object.freeze({
  status: "aborted"
}), $M = (r) => ({ status: "dirty", value: r }), ls = (r) => ({ status: "valid", value: r }), D6 = (r) => r.status === "aborted", k6 = (r) => r.status === "dirty", Wm = (r) => r.status === "valid", p2 = (r) => typeof Promise < "u" && r instanceof Promise;
var _t;
(function(r) {
  r.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, r.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(_t || (_t = {}));
class Tc {
  constructor(e, t, n, i) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const FR = (r, e) => {
  if (Wm(e))
    return { success: !0, data: e.value };
  if (!r.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const t = new Ia(r.common.issues);
      return this._error = t, this._error;
    }
  };
};
function Gt(r) {
  if (!r)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: n, description: i } = r;
  if (e && (t || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: i } : { errorMap: (o, a) => o.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: n ?? a.defaultError } : { message: t ?? a.defaultError }, description: i };
}
class er {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return wu(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: wu(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new Fi(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: wu(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (p2(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const n = this.safeParse(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, t) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = t == null ? void 0 : t.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: wu(e)
    }, s = this._parseSync({ data: e, path: i.path, parent: i });
    return FR(i, s);
  }
  async parseAsync(e, t) {
    const n = await this.safeParseAsync(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, t) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: !0
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: wu(e)
    }, i = this._parse({ data: e, path: n.path, parent: n }), s = await (p2(i) ? i : Promise.resolve(i));
    return FR(n, s);
  }
  refine(e, t) {
    const n = (i) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(i) : t;
    return this._refinement((i, s) => {
      const o = e(i), a = () => s.addIssue({
        code: Be.custom,
        ...n(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((n, i) => e(n) ? !0 : (i.addIssue(typeof t == "function" ? t(n, i) : t), !1));
  }
  _refinement(e) {
    return new Da({
      schema: this,
      typeName: Ot.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return Rl.create(this, this._def);
  }
  nullable() {
    return cd.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ra.create(this, this._def);
  }
  promise() {
    return ug.create(this, this._def);
  }
  or(e) {
    return qm.create([this, e], this._def);
  }
  and(e) {
    return Gm.create(this, e, this._def);
  }
  transform(e) {
    return new Da({
      ...Gt(this._def),
      schema: this,
      typeName: Ot.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new Ym({
      ...Gt(this._def),
      innerType: this,
      defaultValue: t,
      typeName: Ot.ZodDefault
    });
  }
  brand() {
    return new BM({
      typeName: Ot.ZodBranded,
      type: this,
      ...Gt(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new y2({
      ...Gt(this._def),
      innerType: this,
      catchValue: t,
      typeName: Ot.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return ty.create(this, e);
  }
  readonly() {
    return b2.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const EY = /^c[^\s-]{8,}$/i, xY = /^[a-z][a-z0-9]*$/, SY = /^[0-9A-HJKMNP-TV-Z]{26}$/, CY = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, AY = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, IY = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let q5;
const RY = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, TY = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, OY = (r) => r.precision ? r.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${r.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${r.precision}}Z$`) : r.precision === 0 ? r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function NY(r, e) {
  return !!((e === "v4" || !e) && RY.test(r) || (e === "v6" || !e) && TY.test(r));
}
class Sa extends er {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== Xe.string) {
      const s = this._getOrReturnCtx(e);
      return rt(
        s,
        {
          code: Be.invalid_type,
          expected: Xe.string,
          received: s.parsedType
        }
        //
      ), zt;
    }
    const n = new Fi();
    let i;
    for (const s of this._def.checks)
      if (s.kind === "min")
        e.data.length < s.value && (i = this._getOrReturnCtx(e, i), rt(i, {
          code: Be.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "max")
        e.data.length > s.value && (i = this._getOrReturnCtx(e, i), rt(i, {
          code: Be.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), n.dirty());
      else if (s.kind === "length") {
        const o = e.data.length > s.value, a = e.data.length < s.value;
        (o || a) && (i = this._getOrReturnCtx(e, i), o ? rt(i, {
          code: Be.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : a && rt(i, {
          code: Be.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), n.dirty());
      } else if (s.kind === "email")
        AY.test(e.data) || (i = this._getOrReturnCtx(e, i), rt(i, {
          validation: "email",
          code: Be.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "emoji")
        q5 || (q5 = new RegExp(IY, "u")), q5.test(e.data) || (i = this._getOrReturnCtx(e, i), rt(i, {
          validation: "emoji",
          code: Be.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "uuid")
        CY.test(e.data) || (i = this._getOrReturnCtx(e, i), rt(i, {
          validation: "uuid",
          code: Be.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid")
        EY.test(e.data) || (i = this._getOrReturnCtx(e, i), rt(i, {
          validation: "cuid",
          code: Be.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid2")
        xY.test(e.data) || (i = this._getOrReturnCtx(e, i), rt(i, {
          validation: "cuid2",
          code: Be.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "ulid")
        SY.test(e.data) || (i = this._getOrReturnCtx(e, i), rt(i, {
          validation: "ulid",
          code: Be.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "url")
        try {
          new URL(e.data);
        } catch {
          i = this._getOrReturnCtx(e, i), rt(i, {
            validation: "url",
            code: Be.invalid_string,
            message: s.message
          }), n.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(e.data) || (i = this._getOrReturnCtx(e, i), rt(i, {
          validation: "regex",
          code: Be.invalid_string,
          message: s.message
        }), n.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (i = this._getOrReturnCtx(e, i), rt(i, {
          code: Be.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), n.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (i = this._getOrReturnCtx(e, i), rt(i, {
          code: Be.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (i = this._getOrReturnCtx(e, i), rt(i, {
          code: Be.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "datetime" ? OY(s).test(e.data) || (i = this._getOrReturnCtx(e, i), rt(i, {
          code: Be.invalid_string,
          validation: "datetime",
          message: s.message
        }), n.dirty()) : s.kind === "ip" ? NY(e.data, s.version) || (i = this._getOrReturnCtx(e, i), rt(i, {
          validation: "ip",
          code: Be.invalid_string,
          message: s.message
        }), n.dirty()) : Cr.assertNever(s);
    return { status: n.value, value: e.data };
  }
  _regex(e, t, n) {
    return this.refinement((i) => e.test(i), {
      validation: t,
      code: Be.invalid_string,
      ..._t.errToObj(n)
    });
  }
  _addCheck(e) {
    return new Sa({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ..._t.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ..._t.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ..._t.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ..._t.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ..._t.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ..._t.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ..._t.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ..._t.errToObj(e) });
  }
  datetime(e) {
    var t;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1,
      ..._t.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ..._t.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ..._t.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ..._t.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ..._t.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ..._t.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ..._t.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ..._t.errToObj(t)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e) {
    return this.min(1, _t.errToObj(e));
  }
  trim() {
    return new Sa({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Sa({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Sa({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
Sa.create = (r) => {
  var e;
  return new Sa({
    checks: [],
    typeName: Ot.ZodString,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : !1,
    ...Gt(r)
  });
};
function PY(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, i = t > n ? t : n, s = parseInt(r.toFixed(i).replace(".", "")), o = parseInt(e.toFixed(i).replace(".", ""));
  return s % o / Math.pow(10, i);
}
class Qu extends er {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== Xe.number) {
      const s = this._getOrReturnCtx(e);
      return rt(s, {
        code: Be.invalid_type,
        expected: Xe.number,
        received: s.parsedType
      }), zt;
    }
    let n;
    const i = new Fi();
    for (const s of this._def.checks)
      s.kind === "int" ? Cr.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), rt(n, {
        code: Be.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), i.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (n = this._getOrReturnCtx(e, n), rt(n, {
        code: Be.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (n = this._getOrReturnCtx(e, n), rt(n, {
        code: Be.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? PY(e.data, s.value) !== 0 && (n = this._getOrReturnCtx(e, n), rt(n, {
        code: Be.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), rt(n, {
        code: Be.not_finite,
        message: s.message
      }), i.dirty()) : Cr.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, _t.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, _t.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, _t.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, _t.toString(t));
  }
  setLimit(e, t, n, i) {
    return new Qu({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: _t.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Qu({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: _t.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: _t.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: _t.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: _t.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: _t.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: _t.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: _t.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: _t.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: _t.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Cr.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (t === null || n.value > t) && (t = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
}
Qu.create = (r) => new Qu({
  checks: [],
  typeName: Ot.ZodNumber,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...Gt(r)
});
class Yu extends er {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== Xe.bigint) {
      const s = this._getOrReturnCtx(e);
      return rt(s, {
        code: Be.invalid_type,
        expected: Xe.bigint,
        received: s.parsedType
      }), zt;
    }
    let n;
    const i = new Fi();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (n = this._getOrReturnCtx(e, n), rt(n, {
        code: Be.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (n = this._getOrReturnCtx(e, n), rt(n, {
        code: Be.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), rt(n, {
        code: Be.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : Cr.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, _t.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, _t.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, _t.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, _t.toString(t));
  }
  setLimit(e, t, n, i) {
    return new Yu({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: _t.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Yu({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: _t.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: _t.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: _t.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: _t.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: _t.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
Yu.create = (r) => {
  var e;
  return new Yu({
    checks: [],
    typeName: Ot.ZodBigInt,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : !1,
    ...Gt(r)
  });
};
class Hm extends er {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== Xe.boolean) {
      const n = this._getOrReturnCtx(e);
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.boolean,
        received: n.parsedType
      }), zt;
    }
    return ls(e.data);
  }
}
Hm.create = (r) => new Hm({
  typeName: Ot.ZodBoolean,
  coerce: (r == null ? void 0 : r.coerce) || !1,
  ...Gt(r)
});
class od extends er {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== Xe.date) {
      const s = this._getOrReturnCtx(e);
      return rt(s, {
        code: Be.invalid_type,
        expected: Xe.date,
        received: s.parsedType
      }), zt;
    }
    if (isNaN(e.data.getTime())) {
      const s = this._getOrReturnCtx(e);
      return rt(s, {
        code: Be.invalid_date
      }), zt;
    }
    const n = new Fi();
    let i;
    for (const s of this._def.checks)
      s.kind === "min" ? e.data.getTime() < s.value && (i = this._getOrReturnCtx(e, i), rt(i, {
        code: Be.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), n.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (i = this._getOrReturnCtx(e, i), rt(i, {
        code: Be.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), n.dirty()) : Cr.assertNever(s);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new od({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: _t.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: _t.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
od.create = (r) => new od({
  checks: [],
  coerce: (r == null ? void 0 : r.coerce) || !1,
  typeName: Ot.ZodDate,
  ...Gt(r)
});
class g2 extends er {
  _parse(e) {
    if (this._getType(e) !== Xe.symbol) {
      const n = this._getOrReturnCtx(e);
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.symbol,
        received: n.parsedType
      }), zt;
    }
    return ls(e.data);
  }
}
g2.create = (r) => new g2({
  typeName: Ot.ZodSymbol,
  ...Gt(r)
});
class zm extends er {
  _parse(e) {
    if (this._getType(e) !== Xe.undefined) {
      const n = this._getOrReturnCtx(e);
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.undefined,
        received: n.parsedType
      }), zt;
    }
    return ls(e.data);
  }
}
zm.create = (r) => new zm({
  typeName: Ot.ZodUndefined,
  ...Gt(r)
});
class Vm extends er {
  _parse(e) {
    if (this._getType(e) !== Xe.null) {
      const n = this._getOrReturnCtx(e);
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.null,
        received: n.parsedType
      }), zt;
    }
    return ls(e.data);
  }
}
Vm.create = (r) => new Vm({
  typeName: Ot.ZodNull,
  ...Gt(r)
});
class lg extends er {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return ls(e.data);
  }
}
lg.create = (r) => new lg({
  typeName: Ot.ZodAny,
  ...Gt(r)
});
class Ff extends er {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return ls(e.data);
  }
}
Ff.create = (r) => new Ff({
  typeName: Ot.ZodUnknown,
  ...Gt(r)
});
class Dl extends er {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return rt(t, {
      code: Be.invalid_type,
      expected: Xe.never,
      received: t.parsedType
    }), zt;
  }
}
Dl.create = (r) => new Dl({
  typeName: Ot.ZodNever,
  ...Gt(r)
});
class m2 extends er {
  _parse(e) {
    if (this._getType(e) !== Xe.undefined) {
      const n = this._getOrReturnCtx(e);
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.void,
        received: n.parsedType
      }), zt;
    }
    return ls(e.data);
  }
}
m2.create = (r) => new m2({
  typeName: Ot.ZodVoid,
  ...Gt(r)
});
class Ra extends er {
  _parse(e) {
    const { ctx: t, status: n } = this._processInputParams(e), i = this._def;
    if (t.parsedType !== Xe.array)
      return rt(t, {
        code: Be.invalid_type,
        expected: Xe.array,
        received: t.parsedType
      }), zt;
    if (i.exactLength !== null) {
      const o = t.data.length > i.exactLength.value, a = t.data.length < i.exactLength.value;
      (o || a) && (rt(t, {
        code: o ? Be.too_big : Be.too_small,
        minimum: a ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && t.data.length < i.minLength.value && (rt(t, {
      code: Be.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && t.data.length > i.maxLength.value && (rt(t, {
      code: Be.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), t.common.async)
      return Promise.all([...t.data].map((o, a) => i.type._parseAsync(new Tc(t, o, t.path, a)))).then((o) => Fi.mergeArray(n, o));
    const s = [...t.data].map((o, a) => i.type._parseSync(new Tc(t, o, t.path, a)));
    return Fi.mergeArray(n, s);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new Ra({
      ...this._def,
      minLength: { value: e, message: _t.toString(t) }
    });
  }
  max(e, t) {
    return new Ra({
      ...this._def,
      maxLength: { value: e, message: _t.toString(t) }
    });
  }
  length(e, t) {
    return new Ra({
      ...this._def,
      exactLength: { value: e, message: _t.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Ra.create = (r, e) => new Ra({
  type: r,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Ot.ZodArray,
  ...Gt(e)
});
function xp(r) {
  if (r instanceof fn) {
    const e = {};
    for (const t in r.shape) {
      const n = r.shape[t];
      e[t] = Rl.create(xp(n));
    }
    return new fn({
      ...r._def,
      shape: () => e
    });
  } else
    return r instanceof Ra ? new Ra({
      ...r._def,
      type: xp(r.element)
    }) : r instanceof Rl ? Rl.create(xp(r.unwrap())) : r instanceof cd ? cd.create(xp(r.unwrap())) : r instanceof Oc ? Oc.create(r.items.map((e) => xp(e))) : r;
}
class fn extends er {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = Cr.objectKeys(e);
    return this._cached = { shape: e, keys: t };
  }
  _parse(e) {
    if (this._getType(e) !== Xe.object) {
      const u = this._getOrReturnCtx(e);
      return rt(u, {
        code: Be.invalid_type,
        expected: Xe.object,
        received: u.parsedType
      }), zt;
    }
    const { status: n, ctx: i } = this._processInputParams(e), { shape: s, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof Dl && this._def.unknownKeys === "strip"))
      for (const u in i.data)
        o.includes(u) || a.push(u);
    const c = [];
    for (const u of o) {
      const f = s[u], d = i.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: f._parse(new Tc(i, d, i.path, u)),
        alwaysSet: u in i.data
      });
    }
    if (this._def.catchall instanceof Dl) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const f of a)
          c.push({
            key: { status: "valid", value: f },
            value: { status: "valid", value: i.data[f] }
          });
      else if (u === "strict")
        a.length > 0 && (rt(i, {
          code: Be.unrecognized_keys,
          keys: a
        }), n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const f of a) {
        const d = i.data[f];
        c.push({
          key: { status: "valid", value: f },
          value: u._parse(
            new Tc(i, d, i.path, f)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: f in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const f of c) {
        const d = await f.key;
        u.push({
          key: d,
          value: await f.value,
          alwaysSet: f.alwaysSet
        });
      }
      return u;
    }).then((u) => Fi.mergeObjectSync(n, u)) : Fi.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return _t.errToObj, new fn({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, n) => {
          var i, s, o, a;
          const c = (o = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, t, n).message) !== null && o !== void 0 ? o : n.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: (a = _t.errToObj(e).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new fn({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new fn({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new fn({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new fn({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: Ot.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new fn({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    return Cr.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (t[n] = this.shape[n]);
    }), new fn({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    return Cr.objectKeys(this.shape).forEach((n) => {
      e[n] || (t[n] = this.shape[n]);
    }), new fn({
      ...this._def,
      shape: () => t
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return xp(this);
  }
  partial(e) {
    const t = {};
    return Cr.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      e && !e[n] ? t[n] = i : t[n] = i.optional();
    }), new fn({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    return Cr.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        t[n] = this.shape[n];
      else {
        let s = this.shape[n];
        for (; s instanceof Rl; )
          s = s._def.innerType;
        t[n] = s;
      }
    }), new fn({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return LM(Cr.objectKeys(this.shape));
  }
}
fn.create = (r, e) => new fn({
  shape: () => r,
  unknownKeys: "strip",
  catchall: Dl.create(),
  typeName: Ot.ZodObject,
  ...Gt(e)
});
fn.strictCreate = (r, e) => new fn({
  shape: () => r,
  unknownKeys: "strict",
  catchall: Dl.create(),
  typeName: Ot.ZodObject,
  ...Gt(e)
});
fn.lazycreate = (r, e) => new fn({
  shape: r,
  unknownKeys: "strip",
  catchall: Dl.create(),
  typeName: Ot.ZodObject,
  ...Gt(e)
});
class qm extends er {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = this._def.options;
    function i(s) {
      for (const a of s)
        if (a.result.status === "valid")
          return a.result;
      for (const a of s)
        if (a.result.status === "dirty")
          return t.common.issues.push(...a.ctx.common.issues), a.result;
      const o = s.map((a) => new Ia(a.ctx.common.issues));
      return rt(t, {
        code: Be.invalid_union,
        unionErrors: o
      }), zt;
    }
    if (t.common.async)
      return Promise.all(n.map(async (s) => {
        const o = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: t.data,
            path: t.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let s;
      const o = [];
      for (const c of n) {
        const u = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, f = c._parseSync({
          data: t.data,
          path: t.path,
          parent: u
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !s && (s = { result: f, ctx: u }), u.common.issues.length && o.push(u.common.issues);
      }
      if (s)
        return t.common.issues.push(...s.ctx.common.issues), s.result;
      const a = o.map((c) => new Ia(c));
      return rt(t, {
        code: Be.invalid_union,
        unionErrors: a
      }), zt;
    }
  }
  get options() {
    return this._def.options;
  }
}
qm.create = (r, e) => new qm({
  options: r,
  typeName: Ot.ZodUnion,
  ...Gt(e)
});
const Rb = (r) => r instanceof Zm ? Rb(r.schema) : r instanceof Da ? Rb(r.innerType()) : r instanceof Jm ? [r.value] : r instanceof Xu ? r.options : r instanceof Qm ? Object.keys(r.enum) : r instanceof Ym ? Rb(r._def.innerType) : r instanceof zm ? [void 0] : r instanceof Vm ? [null] : null;
class k_ extends er {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== Xe.object)
      return rt(t, {
        code: Be.invalid_type,
        expected: Xe.object,
        received: t.parsedType
      }), zt;
    const n = this.discriminator, i = t.data[n], s = this.optionsMap.get(i);
    return s ? t.common.async ? s._parseAsync({
      data: t.data,
      path: t.path,
      parent: t
    }) : s._parseSync({
      data: t.data,
      path: t.path,
      parent: t
    }) : (rt(t, {
      code: Be.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), zt);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, t, n) {
    const i = /* @__PURE__ */ new Map();
    for (const s of t) {
      const o = Rb(s.shape[e]);
      if (!o)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const a of o) {
        if (i.has(a))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
        i.set(a, s);
      }
    }
    return new k_({
      typeName: Ot.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: i,
      ...Gt(n)
    });
  }
}
function $6(r, e) {
  const t = wu(r), n = wu(e);
  if (r === e)
    return { valid: !0, data: r };
  if (t === Xe.object && n === Xe.object) {
    const i = Cr.objectKeys(e), s = Cr.objectKeys(r).filter((a) => i.indexOf(a) !== -1), o = { ...r, ...e };
    for (const a of s) {
      const c = $6(r[a], e[a]);
      if (!c.valid)
        return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (t === Xe.array && n === Xe.array) {
    if (r.length !== e.length)
      return { valid: !1 };
    const i = [];
    for (let s = 0; s < r.length; s++) {
      const o = r[s], a = e[s], c = $6(o, a);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else
    return t === Xe.date && n === Xe.date && +r == +e ? { valid: !0, data: r } : { valid: !1 };
}
class Gm extends er {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), i = (s, o) => {
      if (D6(s) || D6(o))
        return zt;
      const a = $6(s.value, o.value);
      return a.valid ? ((k6(s) || k6(o)) && t.dirty(), { status: t.value, value: a.data }) : (rt(n, {
        code: Be.invalid_intersection_types
      }), zt);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([s, o]) => i(s, o)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Gm.create = (r, e, t) => new Gm({
  left: r,
  right: e,
  typeName: Ot.ZodIntersection,
  ...Gt(t)
});
class Oc extends er {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Xe.array)
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.array,
        received: n.parsedType
      }), zt;
    if (n.data.length < this._def.items.length)
      return rt(n, {
        code: Be.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), zt;
    !this._def.rest && n.data.length > this._def.items.length && (rt(n, {
      code: Be.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), t.dirty());
    const s = [...n.data].map((o, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new Tc(n, o, n.path, a)) : null;
    }).filter((o) => !!o);
    return n.common.async ? Promise.all(s).then((o) => Fi.mergeArray(t, o)) : Fi.mergeArray(t, s);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Oc({
      ...this._def,
      rest: e
    });
  }
}
Oc.create = (r, e) => {
  if (!Array.isArray(r))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Oc({
    items: r,
    typeName: Ot.ZodTuple,
    rest: null,
    ...Gt(e)
  });
};
class Km extends er {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Xe.object)
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.object,
        received: n.parsedType
      }), zt;
    const i = [], s = this._def.keyType, o = this._def.valueType;
    for (const a in n.data)
      i.push({
        key: s._parse(new Tc(n, a, n.path, a)),
        value: o._parse(new Tc(n, n.data[a], n.path, a))
      });
    return n.common.async ? Fi.mergeObjectAsync(t, i) : Fi.mergeObjectSync(t, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, n) {
    return t instanceof er ? new Km({
      keyType: e,
      valueType: t,
      typeName: Ot.ZodRecord,
      ...Gt(n)
    }) : new Km({
      keyType: Sa.create(),
      valueType: e,
      typeName: Ot.ZodRecord,
      ...Gt(t)
    });
  }
}
class w2 extends er {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Xe.map)
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.map,
        received: n.parsedType
      }), zt;
    const i = this._def.keyType, s = this._def.valueType, o = [...n.data.entries()].map(([a, c], u) => ({
      key: i._parse(new Tc(n, a, n.path, [u, "key"])),
      value: s._parse(new Tc(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const u = await c.key, f = await c.value;
          if (u.status === "aborted" || f.status === "aborted")
            return zt;
          (u.status === "dirty" || f.status === "dirty") && t.dirty(), a.set(u.value, f.value);
        }
        return { status: t.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of o) {
        const u = c.key, f = c.value;
        if (u.status === "aborted" || f.status === "aborted")
          return zt;
        (u.status === "dirty" || f.status === "dirty") && t.dirty(), a.set(u.value, f.value);
      }
      return { status: t.value, value: a };
    }
  }
}
w2.create = (r, e, t) => new w2({
  valueType: e,
  keyType: r,
  typeName: Ot.ZodMap,
  ...Gt(t)
});
class ad extends er {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Xe.set)
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.set,
        received: n.parsedType
      }), zt;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (rt(n, {
      code: Be.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), t.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (rt(n, {
      code: Be.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), t.dirty());
    const s = this._def.valueType;
    function o(c) {
      const u = /* @__PURE__ */ new Set();
      for (const f of c) {
        if (f.status === "aborted")
          return zt;
        f.status === "dirty" && t.dirty(), u.add(f.value);
      }
      return { status: t.value, value: u };
    }
    const a = [...n.data.values()].map((c, u) => s._parse(new Tc(n, c, n.path, u)));
    return n.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
  }
  min(e, t) {
    return new ad({
      ...this._def,
      minSize: { value: e, message: _t.toString(t) }
    });
  }
  max(e, t) {
    return new ad({
      ...this._def,
      maxSize: { value: e, message: _t.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ad.create = (r, e) => new ad({
  valueType: r,
  minSize: null,
  maxSize: null,
  typeName: Ot.ZodSet,
  ...Gt(e)
});
class Hp extends er {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== Xe.function)
      return rt(t, {
        code: Be.invalid_type,
        expected: Xe.function,
        received: t.parsedType
      }), zt;
    function n(a, c) {
      return d2({
        data: a,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          f2(),
          jm
        ].filter((u) => !!u),
        issueData: {
          code: Be.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function i(a, c) {
      return d2({
        data: a,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          f2(),
          jm
        ].filter((u) => !!u),
        issueData: {
          code: Be.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const s = { errorMap: t.common.contextualErrorMap }, o = t.data;
    if (this._def.returns instanceof ug) {
      const a = this;
      return ls(async function(...c) {
        const u = new Ia([]), f = await a._def.args.parseAsync(c, s).catch((y) => {
          throw u.addIssue(n(c, y)), u;
        }), d = await Reflect.apply(o, this, f);
        return await a._def.returns._def.type.parseAsync(d, s).catch((y) => {
          throw u.addIssue(i(d, y)), u;
        });
      });
    } else {
      const a = this;
      return ls(function(...c) {
        const u = a._def.args.safeParse(c, s);
        if (!u.success)
          throw new Ia([n(c, u.error)]);
        const f = Reflect.apply(o, this, u.data), d = a._def.returns.safeParse(f, s);
        if (!d.success)
          throw new Ia([i(f, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Hp({
      ...this._def,
      args: Oc.create(e).rest(Ff.create())
    });
  }
  returns(e) {
    return new Hp({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, n) {
    return new Hp({
      args: e || Oc.create([]).rest(Ff.create()),
      returns: t || Ff.create(),
      typeName: Ot.ZodFunction,
      ...Gt(n)
    });
  }
}
class Zm extends er {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
Zm.create = (r, e) => new Zm({
  getter: r,
  typeName: Ot.ZodLazy,
  ...Gt(e)
});
class Jm extends er {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return rt(t, {
        received: t.data,
        code: Be.invalid_literal,
        expected: this._def.value
      }), zt;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Jm.create = (r, e) => new Jm({
  value: r,
  typeName: Ot.ZodLiteral,
  ...Gt(e)
});
function LM(r, e) {
  return new Xu({
    values: r,
    typeName: Ot.ZodEnum,
    ...Gt(e)
  });
}
class Xu extends er {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return rt(t, {
        expected: Cr.joinValues(n),
        received: t.parsedType,
        code: Be.invalid_type
      }), zt;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return rt(t, {
        received: t.data,
        code: Be.invalid_enum_value,
        options: n
      }), zt;
    }
    return ls(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e) {
    return Xu.create(e);
  }
  exclude(e) {
    return Xu.create(this.options.filter((t) => !e.includes(t)));
  }
}
Xu.create = LM;
class Qm extends er {
  _parse(e) {
    const t = Cr.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== Xe.string && n.parsedType !== Xe.number) {
      const i = Cr.objectValues(t);
      return rt(n, {
        expected: Cr.joinValues(i),
        received: n.parsedType,
        code: Be.invalid_type
      }), zt;
    }
    if (t.indexOf(e.data) === -1) {
      const i = Cr.objectValues(t);
      return rt(n, {
        received: n.data,
        code: Be.invalid_enum_value,
        options: i
      }), zt;
    }
    return ls(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Qm.create = (r, e) => new Qm({
  values: r,
  typeName: Ot.ZodNativeEnum,
  ...Gt(e)
});
class ug extends er {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== Xe.promise && t.common.async === !1)
      return rt(t, {
        code: Be.invalid_type,
        expected: Xe.promise,
        received: t.parsedType
      }), zt;
    const n = t.parsedType === Xe.promise ? t.data : Promise.resolve(t.data);
    return ls(n.then((i) => this._def.type.parseAsync(i, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
}
ug.create = (r, e) => new ug({
  type: r,
  typeName: Ot.ZodPromise,
  ...Gt(e)
});
class Da extends er {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ot.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), i = this._def.effect || null, s = {
      addIssue: (o) => {
        rt(n, o), o.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), i.type === "preprocess") {
      const o = i.transform(n.data, s);
      return n.common.issues.length ? {
        status: "dirty",
        value: n.data
      } : n.common.async ? Promise.resolve(o).then((a) => this._def.schema._parseAsync({
        data: a,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: o,
        path: n.path,
        parent: n
      });
    }
    if (i.type === "refinement") {
      const o = (a) => {
        const c = i.refinement(a, s);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? zt : (a.status === "dirty" && t.dirty(), o(a.value), { status: t.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => a.status === "aborted" ? zt : (a.status === "dirty" && t.dirty(), o(a.value).then(() => ({ status: t.value, value: a.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!Wm(o))
          return o;
        const a = i.transform(o.value, s);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => Wm(o) ? Promise.resolve(i.transform(o.value, s)).then((a) => ({ status: t.value, value: a })) : o);
    Cr.assertNever(i);
  }
}
Da.create = (r, e, t) => new Da({
  schema: r,
  typeName: Ot.ZodEffects,
  effect: e,
  ...Gt(t)
});
Da.createWithPreprocess = (r, e, t) => new Da({
  schema: e,
  effect: { type: "preprocess", transform: r },
  typeName: Ot.ZodEffects,
  ...Gt(t)
});
class Rl extends er {
  _parse(e) {
    return this._getType(e) === Xe.undefined ? ls(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Rl.create = (r, e) => new Rl({
  innerType: r,
  typeName: Ot.ZodOptional,
  ...Gt(e)
});
class cd extends er {
  _parse(e) {
    return this._getType(e) === Xe.null ? ls(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
cd.create = (r, e) => new cd({
  innerType: r,
  typeName: Ot.ZodNullable,
  ...Gt(e)
});
class Ym extends er {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let n = t.data;
    return t.parsedType === Xe.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ym.create = (r, e) => new Ym({
  innerType: r,
  typeName: Ot.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...Gt(e)
});
class y2 extends er {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return p2(i) ? i.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Ia(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Ia(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
y2.create = (r, e) => new y2({
  innerType: r,
  typeName: Ot.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...Gt(e)
});
class v2 extends er {
  _parse(e) {
    if (this._getType(e) !== Xe.nan) {
      const n = this._getOrReturnCtx(e);
      return rt(n, {
        code: Be.invalid_type,
        expected: Xe.nan,
        received: n.parsedType
      }), zt;
    }
    return { status: "valid", value: e.data };
  }
}
v2.create = (r) => new v2({
  typeName: Ot.ZodNaN,
  ...Gt(r)
});
const MY = Symbol("zod_brand");
class BM extends er {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = t.data;
    return this._def.type._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ty extends er {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? zt : s.status === "dirty" ? (t.dirty(), $M(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? zt : i.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, t) {
    return new ty({
      in: e,
      out: t,
      typeName: Ot.ZodPipeline
    });
  }
}
class b2 extends er {
  _parse(e) {
    const t = this._def.innerType._parse(e);
    return Wm(t) && (t.value = Object.freeze(t.value)), t;
  }
}
b2.create = (r, e) => new b2({
  innerType: r,
  typeName: Ot.ZodReadonly,
  ...Gt(e)
});
const FM = (r, e = {}, t) => r ? lg.create().superRefine((n, i) => {
  var s, o;
  if (!r(n)) {
    const a = typeof e == "function" ? e(n) : typeof e == "string" ? { message: e } : e, c = (o = (s = a.fatal) !== null && s !== void 0 ? s : t) !== null && o !== void 0 ? o : !0, u = typeof a == "string" ? { message: a } : a;
    i.addIssue({ code: "custom", ...u, fatal: c });
  }
}) : lg.create(), DY = {
  object: fn.lazycreate
};
var Ot;
(function(r) {
  r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodSymbol = "ZodSymbol", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodCatch = "ZodCatch", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded", r.ZodPipeline = "ZodPipeline", r.ZodReadonly = "ZodReadonly";
})(Ot || (Ot = {}));
const kY = (r, e = {
  message: `Input not instance of ${r.name}`
}) => FM((t) => t instanceof r, e), UM = Sa.create, jM = Qu.create, $Y = v2.create, LY = Yu.create, WM = Hm.create, BY = od.create, FY = g2.create, UY = zm.create, jY = Vm.create, WY = lg.create, HY = Ff.create, zY = Dl.create, VY = m2.create, qY = Ra.create, GY = fn.create, KY = fn.strictCreate, ZY = qm.create, JY = k_.create, QY = Gm.create, YY = Oc.create, XY = Km.create, eX = w2.create, tX = ad.create, rX = Hp.create, nX = Zm.create, iX = Jm.create, sX = Xu.create, oX = Qm.create, aX = ug.create, UR = Da.create, cX = Rl.create, lX = cd.create, uX = Da.createWithPreprocess, hX = ty.create, fX = () => UM().optional(), dX = () => jM().optional(), pX = () => WM().optional(), gX = {
  string: (r) => Sa.create({ ...r, coerce: !0 }),
  number: (r) => Qu.create({ ...r, coerce: !0 }),
  boolean: (r) => Hm.create({
    ...r,
    coerce: !0
  }),
  bigint: (r) => Yu.create({ ...r, coerce: !0 }),
  date: (r) => od.create({ ...r, coerce: !0 })
}, mX = zt;
var xe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: jm,
  setErrorMap: bY,
  getErrorMap: f2,
  makeIssue: d2,
  EMPTY_PATH: _Y,
  addIssueToContext: rt,
  ParseStatus: Fi,
  INVALID: zt,
  DIRTY: $M,
  OK: ls,
  isAborted: D6,
  isDirty: k6,
  isValid: Wm,
  isAsync: p2,
  get util() {
    return Cr;
  },
  get objectUtil() {
    return M6;
  },
  ZodParsedType: Xe,
  getParsedType: wu,
  ZodType: er,
  ZodString: Sa,
  ZodNumber: Qu,
  ZodBigInt: Yu,
  ZodBoolean: Hm,
  ZodDate: od,
  ZodSymbol: g2,
  ZodUndefined: zm,
  ZodNull: Vm,
  ZodAny: lg,
  ZodUnknown: Ff,
  ZodNever: Dl,
  ZodVoid: m2,
  ZodArray: Ra,
  ZodObject: fn,
  ZodUnion: qm,
  ZodDiscriminatedUnion: k_,
  ZodIntersection: Gm,
  ZodTuple: Oc,
  ZodRecord: Km,
  ZodMap: w2,
  ZodSet: ad,
  ZodFunction: Hp,
  ZodLazy: Zm,
  ZodLiteral: Jm,
  ZodEnum: Xu,
  ZodNativeEnum: Qm,
  ZodPromise: ug,
  ZodEffects: Da,
  ZodTransformer: Da,
  ZodOptional: Rl,
  ZodNullable: cd,
  ZodDefault: Ym,
  ZodCatch: y2,
  ZodNaN: v2,
  BRAND: MY,
  ZodBranded: BM,
  ZodPipeline: ty,
  ZodReadonly: b2,
  custom: FM,
  Schema: er,
  ZodSchema: er,
  late: DY,
  get ZodFirstPartyTypeKind() {
    return Ot;
  },
  coerce: gX,
  any: WY,
  array: qY,
  bigint: LY,
  boolean: WM,
  date: BY,
  discriminatedUnion: JY,
  effect: UR,
  enum: sX,
  function: rX,
  instanceof: kY,
  intersection: QY,
  lazy: nX,
  literal: iX,
  map: eX,
  nan: $Y,
  nativeEnum: oX,
  never: zY,
  null: jY,
  nullable: lX,
  number: jM,
  object: GY,
  oboolean: pX,
  onumber: dX,
  optional: cX,
  ostring: fX,
  pipeline: hX,
  preprocess: uX,
  promise: aX,
  record: XY,
  set: tX,
  strictObject: KY,
  string: UM,
  symbol: FY,
  transformer: UR,
  tuple: YY,
  undefined: UY,
  union: ZY,
  unknown: HY,
  void: VY,
  NEVER: mX,
  ZodIssueCode: Be,
  quotelessJson: vY,
  ZodError: Ia
});
const qs = xe.object({ message: xe.string() });
function Yt(r) {
  return xe.literal(ct[r]);
}
xe.object({
  accessList: xe.array(xe.string()),
  blockHash: xe.string().nullable(),
  blockNumber: xe.string().nullable(),
  chainId: xe.string(),
  from: xe.string(),
  gas: xe.string(),
  hash: xe.string(),
  input: xe.string().nullable(),
  maxFeePerGas: xe.string(),
  maxPriorityFeePerGas: xe.string(),
  nonce: xe.string(),
  r: xe.string(),
  s: xe.string(),
  to: xe.string(),
  transactionIndex: xe.string().nullable(),
  type: xe.string(),
  v: xe.string(),
  value: xe.string()
});
const wX = xe.object({ chainId: xe.number() }), yX = xe.object({ email: xe.string().email() }), vX = xe.object({ otp: xe.string() }), bX = xe.object({ chainId: xe.optional(xe.number()) }), _X = xe.object({ email: xe.string().email() }), EX = xe.object({
  themeMode: xe.optional(xe.enum(["light", "dark"])),
  themeVariables: xe.optional(xe.record(xe.string(), xe.string().or(xe.number())))
}), xX = xe.object({
  metadata: xe.object({
    name: xe.string(),
    description: xe.string(),
    url: xe.string(),
    icons: xe.array(xe.string())
  }).optional(),
  sdkVersion: xe.string(),
  projectId: xe.string()
}), SX = xe.object({
  action: xe.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
}), CX = xe.object({
  email: xe.string().email(),
  address: xe.string(),
  chainId: xe.number()
}), AX = xe.object({ isConnected: xe.boolean() }), IX = xe.object({ chainId: xe.number() }), RX = xe.object({ chainId: xe.number() }), TX = xe.object({ email: xe.string().email() }), OX = xe.any(), NX = xe.object({
  method: xe.literal("personal_sign"),
  params: xe.array(xe.any())
}), PX = xe.object({
  method: xe.literal("eth_sendTransaction"),
  params: xe.array(xe.any())
}), MX = xe.object({
  method: xe.literal("eth_accounts")
}), DX = xe.object({
  method: xe.literal("eth_getBalance"),
  params: xe.array(xe.any())
}), kX = xe.object({
  method: xe.literal("eth_estimateGas"),
  params: xe.array(xe.any())
}), $X = xe.object({
  method: xe.literal("eth_gasPrice")
}), LX = xe.object({
  method: xe.literal("eth_signTypedData_v4"),
  params: xe.array(xe.any())
}), BX = xe.object({
  method: xe.literal("eth_getTransactionByHash"),
  params: xe.array(xe.any())
}), FX = xe.object({
  method: xe.literal("eth_blockNumber")
}), UX = xe.object({
  method: xe.literal("eth_chainId")
}), jR = xe.object({
  token: xe.string()
}), Gv = {
  appEvent: xe.object({ type: Yt("APP_SWITCH_NETWORK"), payload: wX }).or(xe.object({ type: Yt("APP_CONNECT_EMAIL"), payload: yX })).or(xe.object({ type: Yt("APP_CONNECT_DEVICE") })).or(xe.object({ type: Yt("APP_CONNECT_OTP"), payload: vX })).or(xe.object({ type: Yt("APP_GET_USER"), payload: xe.optional(bX) })).or(xe.object({ type: Yt("APP_SIGN_OUT") })).or(xe.object({ type: Yt("APP_IS_CONNECTED"), payload: xe.optional(jR) })).or(xe.object({ type: Yt("APP_GET_CHAIN_ID") })).or(xe.object({
    type: Yt("APP_RPC_REQUEST"),
    payload: NX.or(PX).or(MX).or(DX).or(kX).or($X).or(LX).or(FX).or(UX).or(BX)
  })).or(xe.object({ type: Yt("APP_UPDATE_EMAIL"), payload: _X })).or(xe.object({ type: Yt("APP_AWAIT_UPDATE_EMAIL") })).or(xe.object({ type: Yt("APP_SYNC_THEME"), payload: EX })).or(xe.object({ type: Yt("APP_SYNC_DAPP_DATA"), payload: xX })),
  frameEvent: xe.object({ type: Yt("FRAME_SWITCH_NETWORK_ERROR"), payload: qs }).or(xe.object({ type: Yt("FRAME_SWITCH_NETWORK_SUCCESS"), payload: RX })).or(xe.object({ type: Yt("FRAME_CONNECT_EMAIL_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_CONNECT_EMAIL_SUCCESS"), payload: SX })).or(xe.object({ type: Yt("FRAME_CONNECT_OTP_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_CONNECT_OTP_SUCCESS") })).or(xe.object({ type: Yt("FRAME_CONNECT_DEVICE_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_CONNECT_DEVICE_SUCCESS") })).or(xe.object({ type: Yt("FRAME_GET_USER_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_GET_USER_SUCCESS"), payload: CX })).or(xe.object({ type: Yt("FRAME_SIGN_OUT_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_SIGN_OUT_SUCCESS") })).or(xe.object({ type: Yt("FRAME_IS_CONNECTED_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_IS_CONNECTED_SUCCESS"), payload: AX })).or(xe.object({ type: Yt("FRAME_GET_CHAIN_ID_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_GET_CHAIN_ID_SUCCESS"), payload: IX })).or(xe.object({ type: Yt("FRAME_RPC_REQUEST_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_RPC_REQUEST_SUCCESS"), payload: OX })).or(xe.object({ type: Yt("FRAME_SESSION_UPDATE"), payload: jR })).or(xe.object({ type: Yt("FRAME_UPDATE_EMAIL_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_UPDATE_EMAIL_SUCCESS") })).or(xe.object({ type: Yt("FRAME_AWAIT_UPDATE_EMAIL_ERROR"), payload: qs })).or(xe.object({
    type: Yt("FRAME_AWAIT_UPDATE_EMAIL_SUCCESS"),
    payload: TX
  })).or(xe.object({ type: Yt("FRAME_SYNC_THEME_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_SYNC_THEME_SUCCESS") })).or(xe.object({ type: Yt("FRAME_SYNC_DAPP_DATA_ERROR"), payload: qs })).or(xe.object({ type: Yt("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
}, Zs = {
  set(r, e) {
    localStorage.setItem(`${ct.STORAGE_KEY}${r}`, e);
  },
  get(r) {
    return localStorage.getItem(`${ct.STORAGE_KEY}${r}`);
  },
  delete(r) {
    localStorage.removeItem(`${ct.STORAGE_KEY}${r}`);
  }
}, jX = [
  "ASIA/SHANGHAI",
  "ASIA/URUMQI",
  "ASIA/CHONGQING",
  "ASIA/HARBIN",
  "ASIA/KASHGAR",
  "ASIA/MACAU",
  "ASIA/HONG_KONG",
  "ASIA/MACAO",
  "ASIA/BEIJING",
  "ASIA/HARBIN"
], Kv = 30 * 1e3, zp = {
  getBlockchainApiUrl() {
    try {
      const { timeZone: r } = new Intl.DateTimeFormat().resolvedOptions(), e = r.toUpperCase();
      return jX.includes(e) ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com";
    } catch {
      return !1;
    }
  },
  checkIfAllowedToTriggerEmail() {
    const r = Zs.get(ct.LAST_EMAIL_LOGIN_TIME);
    if (r) {
      const e = Date.now() - Number(r);
      if (e < Kv) {
        const t = Math.ceil((Kv - e) / 1e3);
        throw new Error(`Please try again after ${t} seconds`);
      }
    }
  },
  getTimeToNextEmailLogin() {
    const r = Zs.get(ct.LAST_EMAIL_LOGIN_TIME);
    if (r) {
      const e = Date.now() - Number(r);
      if (e < Kv)
        return Math.ceil((Kv - e) / 1e3);
    }
    return 0;
  }
};
class WX {
  constructor(e, t = !1) {
    if (this.iframe = null, this.rpcUrl = zp.getBlockchainApiUrl(), this.events = {
      onFrameEvent: (n) => {
        window.addEventListener("message", ({ data: i }) => {
          var o;
          if (!((o = i.type) != null && o.includes(ct.FRAME_EVENT_KEY)))
            return;
          const s = Gv.frameEvent.parse(i);
          n(s);
        });
      },
      onAppEvent: (n) => {
        window.addEventListener("message", ({ data: i }) => {
          var o;
          if (!((o = i.type) != null && o.includes(ct.APP_EVENT_KEY)))
            return;
          const s = Gv.appEvent.parse(i);
          n(s);
        });
      },
      postAppEvent: (n) => {
        var i;
        if (!((i = this.iframe) != null && i.contentWindow))
          throw new Error("W3mFrame: iframe is not set");
        Gv.appEvent.parse(n), window.postMessage(n), this.iframe.contentWindow.postMessage(n, "*");
      },
      postFrameEvent: (n) => {
        if (!parent)
          throw new Error("W3mFrame: parent is not set");
        Gv.frameEvent.parse(n), parent.postMessage(n, "*");
      }
    }, this.projectId = e, this.frameLoadPromise = new Promise((n, i) => {
      this.frameLoadPromiseResolver = { resolve: n, reject: i };
    }), t) {
      this.frameLoadPromise = new Promise((i, s) => {
        this.frameLoadPromiseResolver = { resolve: i, reject: s };
      });
      const n = document.createElement("iframe");
      n.id = "w3m-iframe", n.src = `${ct.SECURE_SITE_SDK}?projectId=${e}`, n.style.position = "fixed", n.style.zIndex = "999999", n.style.display = "none", n.style.opacity = "0", n.style.borderRadius = "clamp(0px, var(--wui-border-radius-l), 44px)", document.body.appendChild(n), this.iframe = n, this.iframe.onload = () => {
        var i;
        (i = this.frameLoadPromiseResolver) == null || i.resolve(void 0);
      }, this.iframe.onerror = () => {
        var i;
        (i = this.frameLoadPromiseResolver) == null || i.reject("Unable to load email login dependency");
      };
    }
  }
  get networks() {
    const e = [
      1,
      5,
      11155111,
      10,
      420,
      42161,
      421613,
      137,
      80001,
      42220,
      1313161554,
      1313161555,
      56,
      97,
      43114,
      43113,
      324,
      280,
      100,
      8453,
      84531,
      7777777,
      999
    ].map((t) => ({
      [t]: {
        rpcUrl: `${this.rpcUrl}/v1/?chainId=eip155:${t}&projectId=${this.projectId}`,
        chainId: t
      }
    }));
    return Object.assign({}, ...e);
  }
}
class HX {
  constructor(e) {
    this.connectEmailResolver = void 0, this.connectDeviceResolver = void 0, this.connectOtpResolver = void 0, this.connectResolver = void 0, this.disconnectResolver = void 0, this.isConnectedResolver = void 0, this.getChainIdResolver = void 0, this.switchChainResolver = void 0, this.rpcRequestResolver = void 0, this.updateEmailResolver = void 0, this.awaitUpdateEmailResolver = void 0, this.syncThemeResolver = void 0, this.syncDappDataResolver = void 0, this.w3mFrame = new WX(e, !0), this.w3mFrame.events.onFrameEvent((t) => {
      switch (console.log(" received", t), t.type) {
        case ct.FRAME_CONNECT_EMAIL_SUCCESS:
          return this.onConnectEmailSuccess(t);
        case ct.FRAME_CONNECT_EMAIL_ERROR:
          return this.onConnectEmailError(t);
        case ct.FRAME_CONNECT_DEVICE_SUCCESS:
          return this.onConnectDeviceSuccess();
        case ct.FRAME_CONNECT_DEVICE_ERROR:
          return this.onConnectDeviceError(t);
        case ct.FRAME_CONNECT_OTP_SUCCESS:
          return this.onConnectOtpSuccess();
        case ct.FRAME_CONNECT_OTP_ERROR:
          return this.onConnectOtpError(t);
        case ct.FRAME_GET_USER_SUCCESS:
          return this.onConnectSuccess(t);
        case ct.FRAME_GET_USER_ERROR:
          return this.onConnectError(t);
        case ct.FRAME_IS_CONNECTED_SUCCESS:
          return this.onIsConnectedSuccess(t);
        case ct.FRAME_IS_CONNECTED_ERROR:
          return this.onIsConnectedError(t);
        case ct.FRAME_GET_CHAIN_ID_SUCCESS:
          return this.onGetChainIdSuccess(t);
        case ct.FRAME_GET_CHAIN_ID_ERROR:
          return this.onGetChainIdError(t);
        case ct.FRAME_SIGN_OUT_SUCCESS:
          return this.onSignOutSuccess();
        case ct.FRAME_SIGN_OUT_ERROR:
          return this.onSignOutError(t);
        case ct.FRAME_SWITCH_NETWORK_SUCCESS:
          return this.onSwitchChainSuccess(t);
        case ct.FRAME_SWITCH_NETWORK_ERROR:
          return this.onSwitchChainError(t);
        case ct.FRAME_RPC_REQUEST_SUCCESS:
          return this.onRpcRequestSuccess(t);
        case ct.FRAME_RPC_REQUEST_ERROR:
          return this.onRpcRequestError(t);
        case ct.FRAME_SESSION_UPDATE:
          return this.onSessionUpdate(t);
        case ct.FRAME_UPDATE_EMAIL_SUCCESS:
          return this.onUpdateEmailSuccess();
        case ct.FRAME_UPDATE_EMAIL_ERROR:
          return this.onUpdateEmailError(t);
        case ct.FRAME_AWAIT_UPDATE_EMAIL_SUCCESS:
          return this.onAwaitUpdateEmailSuccess(t);
        case ct.FRAME_AWAIT_UPDATE_EMAIL_ERROR:
          return this.onAwaitUpdateEmailError(t);
        case ct.FRAME_SYNC_THEME_SUCCESS:
          return this.onSyncThemeSuccess();
        case ct.FRAME_SYNC_THEME_ERROR:
          return this.onSyncThemeError(t);
        case ct.FRAME_SYNC_DAPP_DATA_SUCCESS:
          return this.onSyncDappDataSuccess();
        case ct.FRAME_SYNC_DAPP_DATA_ERROR:
          return this.onSyncDappDataError(t);
        default:
          return null;
      }
    });
  }
  getLoginEmailUsed() {
    return !!Zs.get(ct.EMAIL_LOGIN_USED_KEY);
  }
  getEmail() {
    return Zs.get(ct.EMAIL);
  }
  async connectEmail(e) {
    return await this.w3mFrame.frameLoadPromise, zp.checkIfAllowedToTriggerEmail(), this.w3mFrame.events.postAppEvent({ type: ct.APP_CONNECT_EMAIL, payload: e }), new Promise((t, n) => {
      this.connectEmailResolver = { resolve: t, reject: n };
    });
  }
  async connectDevice() {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({ type: ct.APP_CONNECT_DEVICE }), new Promise((e, t) => {
      this.connectDeviceResolver = { resolve: e, reject: t };
    });
  }
  async connectOtp(e) {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({ type: ct.APP_CONNECT_OTP, payload: e }), new Promise((t, n) => {
      this.connectOtpResolver = { resolve: t, reject: n };
    });
  }
  async isConnected() {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
      type: ct.APP_IS_CONNECTED,
      payload: void 0
    }), new Promise((e, t) => {
      this.isConnectedResolver = { resolve: e, reject: t };
    });
  }
  async getChainId() {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({ type: ct.APP_GET_CHAIN_ID }), new Promise((e, t) => {
      this.getChainIdResolver = { resolve: e, reject: t };
    });
  }
  async updateEmail(e) {
    return await this.w3mFrame.frameLoadPromise, zp.checkIfAllowedToTriggerEmail(), this.w3mFrame.events.postAppEvent({ type: ct.APP_UPDATE_EMAIL, payload: e }), new Promise((t, n) => {
      this.updateEmailResolver = { resolve: t, reject: n };
    });
  }
  async awaitUpdateEmail() {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({ type: ct.APP_AWAIT_UPDATE_EMAIL }), new Promise((e, t) => {
      this.awaitUpdateEmailResolver = { resolve: e, reject: t };
    });
  }
  async syncTheme(e) {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({ type: ct.APP_SYNC_THEME, payload: e }), new Promise((t, n) => {
      this.syncThemeResolver = { resolve: t, reject: n };
    });
  }
  async syncDappData(e) {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({ type: ct.APP_SYNC_DAPP_DATA, payload: e }), new Promise((t, n) => {
      this.syncDappDataResolver = { resolve: t, reject: n };
    });
  }
  async connect(e) {
    const t = (e == null ? void 0 : e.chainId) ?? this.getLastUsedChainId() ?? 1;
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
      type: ct.APP_GET_USER,
      payload: { chainId: t }
    }), new Promise((n, i) => {
      this.connectResolver = { resolve: n, reject: i };
    });
  }
  async switchNetwork(e) {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
      type: ct.APP_SWITCH_NETWORK,
      payload: { chainId: e }
    }), new Promise((t, n) => {
      this.switchChainResolver = { resolve: t, reject: n };
    });
  }
  async disconnect() {
    return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({ type: ct.APP_SIGN_OUT }), new Promise((e, t) => {
      this.disconnectResolver = { resolve: e, reject: t };
    });
  }
  async request(e) {
    return await this.w3mFrame.frameLoadPromise, DM.GET_CHAIN_ID === e.method ? this.getLastUsedChainId() : (this.w3mFrame.events.postAppEvent({
      type: ct.APP_RPC_REQUEST,
      payload: e
    }), new Promise((t, n) => {
      this.rpcRequestResolver = { resolve: t, reject: n };
    }));
  }
  onRpcRequest(e) {
    this.w3mFrame.events.onAppEvent((t) => {
      t.type.includes(ct.RPC_METHOD_KEY) && e(t);
    });
  }
  onRpcResponse(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type.includes(ct.RPC_METHOD_KEY) && e(t);
    });
  }
  onIsConnected(e) {
    this.w3mFrame.events.onFrameEvent((t) => {
      t.type === ct.FRAME_GET_USER_SUCCESS && e();
    });
  }
  onConnectEmailSuccess(e) {
    var t;
    (t = this.connectEmailResolver) == null || t.resolve(e.payload), this.setNewLastEmailLoginTime();
  }
  onConnectEmailError(e) {
    var t;
    (t = this.connectEmailResolver) == null || t.reject(e.payload.message);
  }
  onConnectDeviceSuccess() {
    var e;
    (e = this.connectDeviceResolver) == null || e.resolve(void 0);
  }
  onConnectDeviceError(e) {
    var t;
    (t = this.connectDeviceResolver) == null || t.reject(e.payload.message);
  }
  onConnectOtpSuccess() {
    var e;
    (e = this.connectOtpResolver) == null || e.resolve(void 0);
  }
  onConnectOtpError(e) {
    var t;
    (t = this.connectOtpResolver) == null || t.reject(e.payload.message);
  }
  onConnectSuccess(e) {
    var t;
    this.setEmailLoginSuccess(e.payload.email), this.setLastUsedChainId(e.payload.chainId), (t = this.connectResolver) == null || t.resolve(e.payload);
  }
  onConnectError(e) {
    var t;
    (t = this.connectResolver) == null || t.reject(e.payload.message);
  }
  onIsConnectedSuccess(e) {
    var t;
    e.payload.isConnected || this.deleteEmailLoginCache(), (t = this.isConnectedResolver) == null || t.resolve(e.payload);
  }
  onIsConnectedError(e) {
    var t;
    (t = this.isConnectedResolver) == null || t.reject(e.payload.message);
  }
  onGetChainIdSuccess(e) {
    var t;
    this.setLastUsedChainId(e.payload.chainId), (t = this.getChainIdResolver) == null || t.resolve(e.payload);
  }
  onGetChainIdError(e) {
    var t;
    (t = this.getChainIdResolver) == null || t.reject(e.payload.message);
  }
  onSignOutSuccess() {
    var e;
    (e = this.disconnectResolver) == null || e.resolve(void 0), this.deleteEmailLoginCache();
  }
  onSignOutError(e) {
    var t;
    (t = this.disconnectResolver) == null || t.reject(e.payload.message);
  }
  onSwitchChainSuccess(e) {
    var t;
    this.setLastUsedChainId(e.payload.chainId), (t = this.switchChainResolver) == null || t.resolve(e.payload);
  }
  onSwitchChainError(e) {
    var t;
    (t = this.switchChainResolver) == null || t.reject(e.payload.message);
  }
  onRpcRequestSuccess(e) {
    var t;
    (t = this.rpcRequestResolver) == null || t.resolve(e.payload);
  }
  onRpcRequestError(e) {
    var t;
    (t = this.rpcRequestResolver) == null || t.reject(e.payload.message);
  }
  onSessionUpdate(e) {
  }
  onUpdateEmailSuccess() {
    var e;
    (e = this.updateEmailResolver) == null || e.resolve(void 0), this.setNewLastEmailLoginTime();
  }
  onUpdateEmailError(e) {
    var t;
    (t = this.updateEmailResolver) == null || t.reject(e.payload.message);
  }
  onAwaitUpdateEmailSuccess(e) {
    var t;
    this.setEmailLoginSuccess(e.payload.email), (t = this.awaitUpdateEmailResolver) == null || t.resolve(e.payload);
  }
  onAwaitUpdateEmailError(e) {
    var t;
    (t = this.awaitUpdateEmailResolver) == null || t.reject(e.payload.message);
  }
  onSyncThemeSuccess() {
    var e;
    (e = this.syncThemeResolver) == null || e.resolve(void 0);
  }
  onSyncThemeError(e) {
    var t;
    (t = this.syncThemeResolver) == null || t.reject(e.payload.message);
  }
  onSyncDappDataSuccess() {
    var e;
    (e = this.syncDappDataResolver) == null || e.resolve(void 0);
  }
  onSyncDappDataError(e) {
    var t;
    (t = this.syncDappDataResolver) == null || t.reject(e.payload.message);
  }
  setNewLastEmailLoginTime() {
    Zs.set(ct.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
  }
  setEmailLoginSuccess(e) {
    Zs.set(ct.EMAIL, e), Zs.set(ct.EMAIL_LOGIN_USED_KEY, "true"), Zs.delete(ct.LAST_EMAIL_LOGIN_TIME);
  }
  deleteEmailLoginCache() {
    Zs.delete(ct.EMAIL_LOGIN_USED_KEY), Zs.delete(ct.EMAIL), Zs.delete(ct.LAST_USED_CHAIN_KEY);
  }
  setLastUsedChainId(e) {
    Zs.set(ct.LAST_USED_CHAIN_KEY, `${e}`);
  }
  getLastUsedChainId() {
    return Number(Zs.get(ct.LAST_USED_CHAIN_KEY));
  }
}
var $_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const zX = 6;
let hg = class extends Xt {
  constructor() {
    var e;
    super(...arguments), this.email = (e = ut.state.data) == null ? void 0 : e.email, this.emailConnector = Yr.getEmailConnector(), this.loading = !1, this.timeoutTimeLeft = zp.getTimeToNextEmailLogin(), this.error = "", this.otp = "";
  }
  firstUpdated() {
    this.startOTPTimeout();
  }
  disconnectedCallback() {
    clearTimeout(this.OTPTimeout);
  }
  render() {
    if (!this.email)
      throw new Error("w3m-email-verify-otp-view: No email provided");
    const e = !!this.timeoutTimeLeft;
    return Ae`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100"> Enter the code we sent to </wui-text>
          <wui-text variant="paragraph-500" color="fg-100">${this.email}</wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading ? Ae`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : Ae` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error ? Ae`<wui-text variant="small-400" color="error-100"
                    >${this.error}. Try Again</wui-text
                  >` : null}
            </wui-flex>`}

        <wui-flex alignItems="center">
          <wui-text variant="small-400" color="fg-200">Didn't receive it?</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${e}>
            Resend ${e ? `in ${this.timeoutTimeLeft}s` : "Code"}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
  }
  startOTPTimeout() {
    this.timeoutTimeLeft = zp.getTimeToNextEmailLogin(), this.OTPTimeout = setInterval(() => {
      this.timeoutTimeLeft > 0 ? this.timeoutTimeLeft = zp.getTimeToNextEmailLogin() : clearInterval(this.OTPTimeout);
    }, 1e3);
  }
  async onOtpInputChange(e) {
    try {
      this.loading || (this.otp = e.detail, this.emailConnector && this.otp.length === zX && (this.loading = !0, await this.emailConnector.provider.connectOtp({ otp: this.otp }), Ht.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" }), await wr.connectExternal(this.emailConnector), Xr.close(), Ht.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "email" }
      })));
    } catch (t) {
      Ht.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" }), this.error = vt.parseError(t), this.loading = !1;
    }
  }
  async onResendCode() {
    try {
      if (!this.loading && !this.timeoutTimeLeft) {
        this.error = "", this.otp = "";
        const e = Yr.getEmailConnector();
        if (!e || !this.email)
          throw new Error("w3m-email-login-widget: Unable to resend email");
        this.loading = !0, await e.provider.connectEmail({ email: this.email }), Ht.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" }), this.startOTPTimeout(), In.showSuccess("Code email resent");
      }
    } catch (e) {
      In.showError(e);
    } finally {
      this.loading = !1;
    }
  }
};
hg.styles = yY;
$_([
  ot()
], hg.prototype, "loading", void 0);
$_([
  ot()
], hg.prototype, "timeoutTimeLeft", void 0);
$_([
  ot()
], hg.prototype, "error", void 0);
hg = $_([
  $e("w3m-email-verify-otp-view")
], hg);
const VX = cn`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var HM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let _2 = class extends Xt {
  constructor() {
    var e;
    super(), this.email = (e = ut.state.data) == null ? void 0 : e.email, this.emailConnector = Yr.getEmailConnector(), this.loading = !1, this.listenForDeviceApproval();
  }
  render() {
    if (!this.email)
      throw new Error("w3m-email-verify-device-view: No email provided");
    if (!this.emailConnector)
      throw new Error("w3m-email-verify-device-view: No email connector provided");
    return Ae`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForDeviceApproval() {
    this.emailConnector && (await this.emailConnector.provider.connectDevice(), Ht.sendEvent({ type: "track", event: "DEVICE_REGISTERED_FOR_EMAIL" }), Ht.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" }), ut.replace("EmailVerifyOtp", { email: this.email }));
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.emailConnector || !this.email)
          throw new Error("w3m-email-login-widget: Unable to resend email");
        this.loading = !0, await this.emailConnector.provider.connectEmail({ email: this.email }), In.showSuccess("Code email resent");
      }
    } catch (e) {
      In.showError(e);
    } finally {
      this.loading = !1;
    }
  }
};
_2.styles = VX;
HM([
  ot()
], _2.prototype, "loading", void 0);
_2 = HM([
  $e("w3m-email-verify-device-view")
], _2);
const qX = cn`
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;
var zM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let E2 = class extends Xt {
  constructor() {
    super(), this.bodyObserver = void 0, this.unsubscribe = [], this.iframe = document.getElementById("w3m-iframe"), this.ready = !1, this.unsubscribe.push(Xr.subscribeKey("open", (e) => {
      e || this.onHideIframe();
    }));
  }
  disconnectedCallback() {
    var e;
    this.unsubscribe.forEach((t) => t()), (e = this.bodyObserver) == null || e.unobserve(window.document.body);
  }
  firstUpdated() {
    this.iframe.style.display = "block";
    const t = this.renderRoot.querySelector("div");
    this.bodyObserver = new ResizeObserver(() => {
      const i = (t == null ? void 0 : t.getBoundingClientRect()) ?? { left: 0, top: 0, width: 0, height: 0 };
      this.iframe.style.width = `${i.width}px`, this.iframe.style.height = `${i.height - 10}px`, this.iframe.style.left = `${i.left}px`, this.iframe.style.top = `${i.top + 10 / 2}px`, this.ready = !0;
    }), this.bodyObserver.observe(window.document.body);
  }
  render() {
    return this.ready && this.onShowIframe(), Ae`<div data-ready=${this.ready}></div>`;
  }
  onShowIframe() {
    const e = window.innerWidth <= 430;
    this.iframe.animate([
      { opacity: 0, transform: e ? "translateY(50px)" : "scale(.95)" },
      { opacity: 1, transform: e ? "translateY(0)" : "scale(1)" }
    ], { duration: 200, easing: "ease", fill: "forwards", delay: 300 });
  }
  async onHideIframe() {
    await this.iframe.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards"
    }).finished, this.iframe.style.display = "none";
  }
};
E2.styles = qX;
zM([
  ot()
], E2.prototype, "ready", void 0);
E2 = zM([
  $e("w3m-approve-transaction-view")
], E2);
var GX = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let WR = class extends Xt {
  render() {
    return Ae`
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${Cl.SECURE_SITE_DASHBOARD}
          imageSrc=${Cl.SECURE_SITE_FAVICON}
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `;
  }
};
WR = GX([
  $e("w3m-upgrade-wallet-view")
], WR);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const KX = (r) => r.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ZX = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, JX = (r) => (...e) => ({ _$litDirective$: r, values: e });
let QX = class {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, t, n) {
    this._$Ct = e, this._$AM = t, this._$Ci = n;
  }
  _$AS(e, t) {
    return this.update(e, t);
  }
  update(e, t) {
    return this.render(...t);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const um = (r, e) => {
  var n;
  const t = r._$AN;
  if (t === void 0)
    return !1;
  for (const i of t)
    (n = i._$AO) == null || n.call(i, e, !1), um(i, e);
  return !0;
}, x2 = (r) => {
  let e, t;
  do {
    if ((e = r._$AM) === void 0)
      break;
    t = e._$AN, t.delete(r), r = e;
  } while ((t == null ? void 0 : t.size) === 0);
}, VM = (r) => {
  for (let e; e = r._$AM; r = e) {
    let t = e._$AN;
    if (t === void 0)
      e._$AN = t = /* @__PURE__ */ new Set();
    else if (t.has(r))
      break;
    t.add(r), eee(e);
  }
};
function YX(r) {
  this._$AN !== void 0 ? (x2(this), this._$AM = r, VM(this)) : this._$AM = r;
}
function XX(r, e = !1, t = 0) {
  const n = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0)
    if (e)
      if (Array.isArray(n))
        for (let s = t; s < n.length; s++)
          um(n[s], !1), x2(n[s]);
      else
        n != null && (um(n, !1), x2(n));
    else
      um(this, r);
}
const eee = (r) => {
  r.type == ZX.CHILD && (r._$AP ?? (r._$AP = XX), r._$AQ ?? (r._$AQ = YX));
};
let tee = class extends QX {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(e, t, n) {
    super._$AT(e, t, n), VM(this), this.isConnected = e._$AU;
  }
  _$AO(e, t = !0) {
    var n, i;
    e !== this.isConnected && (this.isConnected = e, e ? (n = this.reconnected) == null || n.call(this) : (i = this.disconnected) == null || i.call(this)), t && (um(this, e), x2(this));
  }
  setValue(e) {
    if (KX(this._$Ct))
      this._$Ct._$AI(e, this);
    else {
      const t = [...this._$Ct._$AH];
      t[this._$Ci] = e, this._$Ct._$AI(t, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const qM = () => new ree();
let ree = class {
};
const G5 = /* @__PURE__ */ new WeakMap(), GM = JX(class extends tee {
  render(r) {
    return $n;
  }
  update(r, [e]) {
    var n;
    const t = e !== this.G;
    return t && this.G !== void 0 && this.ot(void 0), (t || this.rt !== this.lt) && (this.G = e, this.ct = (n = r.options) == null ? void 0 : n.host, this.ot(this.lt = r.element)), $n;
  }
  ot(r) {
    if (typeof this.G == "function") {
      const e = this.ct ?? globalThis;
      let t = G5.get(e);
      t === void 0 && (t = /* @__PURE__ */ new WeakMap(), G5.set(e, t)), t.get(this.G) !== void 0 && this.G.call(this.ct, void 0), t.set(this.G, r), r !== void 0 && this.G.call(this.ct, r);
    } else
      this.G.value = r;
  }
  get rt() {
    var r, e;
    return typeof this.G == "function" ? (r = G5.get(this.ct ?? globalThis)) == null ? void 0 : r.get(this.G) : (e = this.G) == null ? void 0 : e.value;
  }
  disconnected() {
    this.rt === this.lt && this.ot(void 0);
  }
  reconnected() {
    this.ot(this.lt);
  }
}), nee = cn`
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;
var ZS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let Xm = class extends Xt {
  constructor() {
    var e;
    super(...arguments), this.formRef = qM(), this.initialValue = ((e = ut.state.data) == null ? void 0 : e.email) ?? "", this.email = "", this.loading = !1;
  }
  firstUpdated() {
    var e;
    (e = this.formRef.value) == null || e.addEventListener("keydown", (t) => {
      t.key === "Enter" && this.onSubmitEmail(t);
    });
  }
  render() {
    const e = !this.loading && this.email.length > 3 && this.email !== this.initialValue;
    return Ae`
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${GM(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialValue}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="shade" fullWidth @click=${ut.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="fill"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!e}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  onEmailInputChange(e) {
    this.email = e.detail;
  }
  async onSubmitEmail(e) {
    try {
      if (this.loading)
        return;
      this.loading = !0, e.preventDefault();
      const t = Yr.getEmailConnector();
      if (!t)
        throw new Error("w3m-update-email-wallet: Email connector not found");
      await t.provider.updateEmail({ email: this.email }), Ht.sendEvent({ type: "track", event: "EMAIL_EDIT" }), ut.replace("UpdateEmailWalletWaiting", { email: this.email });
    } catch (t) {
      In.showError(t), this.loading = !1;
    }
  }
};
Xm.styles = nee;
ZS([
  ot()
], Xm.prototype, "email", void 0);
ZS([
  ot()
], Xm.prototype, "loading", void 0);
Xm = ZS([
  $e("w3m-update-email-wallet-view")
], Xm);
const iee = cn`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var KM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let S2 = class extends Xt {
  constructor() {
    var e;
    super(), this.email = (e = ut.state.data) == null ? void 0 : e.email, this.emailConnector = Yr.getEmailConnector(), this.loading = !1, this.listenForEmailUpdateApproval();
  }
  render() {
    if (!this.email)
      throw new Error("w3m-update-email-wallet-waiting-view: No email provided");
    if (!this.emailConnector)
      throw new Error("w3m-update-email-wallet-waiting-view: No email connector provided");
    return Ae`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="mail"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve verification link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100">${this.email}</wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            You will receive an approval request on your former mail to confirm the new one
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForEmailUpdateApproval() {
    this.emailConnector && (await this.emailConnector.provider.awaitUpdateEmail(), ut.replace("Account"), In.showSuccess("Email updated"));
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.emailConnector || !this.email)
          throw new Error("w3m-update-email-wallet-waiting-view: Unable to resend email");
        this.loading = !0, await this.emailConnector.provider.updateEmail({ email: this.email }), this.listenForEmailUpdateApproval(), In.showSuccess("Code email resent");
      }
    } catch (e) {
      In.showError(e);
    } finally {
      this.loading = !1;
    }
  }
};
S2.styles = iee;
KM([
  ot()
], S2.prototype, "loading", void 0);
S2 = KM([
  $e("w3m-update-email-wallet-waiting-view")
], S2);
const see = cn`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
function ZM(r) {
  const { connectors: e } = Yr.state, t = e.filter((s) => s.type === "ANNOUNCED").reduce((s, o) => {
    var a;
    return (a = o.info) != null && a.rdns && (s[o.info.rdns] = !0), s;
  }, {});
  return r.map((s) => ({
    ...s,
    installed: !!s.rdns && !!t[s.rdns ?? ""]
  })).sort((s, o) => Number(o.installed) - Number(s.installed));
}
var ry = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const HR = "local-paginator";
let ld = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.paginationObserver = void 0, this.initial = !lr.state.wallets.length, this.wallets = lr.state.wallets, this.recommended = lr.state.recommended, this.featured = lr.state.featured, this.unsubscribe.push(lr.subscribeKey("wallets", (e) => this.wallets = e), lr.subscribeKey("recommended", (e) => this.recommended = e), lr.subscribeKey("featured", (e) => this.featured = e));
  }
  firstUpdated() {
    this.initialFetch(), this.createPaginationObserver();
  }
  disconnectedCallback() {
    var e;
    this.unsubscribe.forEach((t) => t()), (e = this.paginationObserver) == null || e.disconnect();
  }
  render() {
    return Ae`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
  }
  async initialFetch() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector("wui-grid");
    this.initial && e && (await lr.fetchWallets({ page: 1 }), await e.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      fill: "forwards",
      easing: "ease"
    }).finished, this.initial = !1, e.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: 200,
      fill: "forwards",
      easing: "ease"
    }));
  }
  shimmerTemplate(e, t) {
    return [...Array(e)].map(() => Ae`
        <wui-card-select-loader type="wallet" id=${Sr(t)}></wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const e = [...this.featured, ...this.recommended, ...this.wallets];
    return ZM(e).map((n) => Ae`
        <wui-card-select
          imageSrc=${Sr(Sn.getWalletImage(n))}
          type="wallet"
          name=${n.name}
          @click=${() => this.onConnectWallet(n)}
          .installed=${n.installed}
        ></wui-card-select>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets: e, recommended: t, featured: n, count: i } = lr.state, s = window.innerWidth < 352 ? 3 : 4, o = e.length + t.length;
    let c = Math.ceil(o / s) * s - o + s;
    return c -= e.length ? n.length % s : 0, i === 0 && n.length > 0 ? null : i === 0 || [...n, ...e, ...t].length < i ? this.shimmerTemplate(c, HR) : null;
  }
  createPaginationObserver() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector(`#${HR}`);
    e && (this.paginationObserver = new IntersectionObserver(([n]) => {
      if (n != null && n.isIntersecting && !this.initial) {
        const { page: i, count: s, wallets: o } = lr.state;
        o.length < s && lr.fetchWallets({ page: i + 1 });
      }
    }), this.paginationObserver.observe(e));
  }
  onConnectWallet(e) {
    const { connectors: t } = Yr.state, n = t.find(({ explorerId: i }) => i === e.id);
    n ? ut.push("ConnectingExternal", { connector: n }) : ut.push("ConnectingWalletConnect", { wallet: e });
  }
};
ld.styles = see;
ry([
  ot()
], ld.prototype, "initial", void 0);
ry([
  ot()
], ld.prototype, "wallets", void 0);
ry([
  ot()
], ld.prototype, "recommended", void 0);
ry([
  ot()
], ld.prototype, "featured", void 0);
ld = ry([
  $e("w3m-all-wallets-list")
], ld);
const oee = cn`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;
var JS = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let ew = class extends Xt {
  constructor() {
    super(...arguments), this.prevQuery = "", this.loading = !0, this.query = "";
  }
  render() {
    return this.onSearch(), this.loading ? Ae`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    this.query !== this.prevQuery && (this.prevQuery = this.query, this.loading = !0, await lr.searchWallet({ search: this.query }), this.loading = !1);
  }
  walletsTemplate() {
    const { search: e } = lr.state, t = ZM(e);
    return e.length ? Ae`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${t.map((n) => Ae`
            <wui-card-select
              imageSrc=${Sr(Sn.getWalletImage(n))}
              type="wallet"
              name=${n.name}
              @click=${() => this.onConnectWallet(n)}
              .installed=${n.installed}
            ></wui-card-select>
          `)}
      </wui-grid>
    ` : Ae`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
  }
  onConnectWallet(e) {
    const { connectors: t } = Yr.state, n = t.find(({ explorerId: i }) => i === e.id);
    n ? ut.push("ConnectingExternal", { connector: n }) : ut.push("ConnectingWalletConnect", { wallet: e });
  }
};
ew.styles = oee;
JS([
  ot()
], ew.prototype, "loading", void 0);
JS([
  bn()
], ew.prototype, "query", void 0);
ew = JS([
  $e("w3m-all-wallets-search")
], ew);
var L_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let tw = class extends Xt {
  constructor() {
    super(), this.platformTabs = [], this.unsubscribe = [], this.platforms = [], this.onSelectPlatfrom = void 0, this.buffering = !1, this.unsubscribe.push(wr.subscribeKey("buffering", (e) => this.buffering = e));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    const e = this.generateTabs();
    return Ae`
      <wui-flex justifyContent="center" .padding=${["l", "0", "0", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${e}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
  }
  generateTabs() {
    const e = this.platforms.map((t) => t === "browser" ? { label: "Browser", icon: "extension", platform: "browser" } : t === "mobile" ? { label: "Mobile", icon: "mobile", platform: "mobile" } : t === "qrcode" ? { label: "Mobile", icon: "mobile", platform: "qrcode" } : t === "web" ? { label: "Webapp", icon: "browser", platform: "web" } : t === "desktop" ? { label: "Desktop", icon: "desktop", platform: "desktop" } : { label: "Browser", icon: "extension", platform: "unsupported" });
    return this.platformTabs = e.map(({ platform: t }) => t), e;
  }
  onTabChange(e) {
    var n;
    const t = this.platformTabs[e];
    t && ((n = this.onSelectPlatfrom) == null || n.call(this, t));
  }
};
L_([
  bn({ type: Array })
], tw.prototype, "platforms", void 0);
L_([
  bn()
], tw.prototype, "onSelectPlatfrom", void 0);
L_([
  ot()
], tw.prototype, "buffering", void 0);
tw = L_([
  $e("w3m-connecting-header")
], tw);
var aee = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let zR = class extends $s {
  constructor() {
    if (super(), !this.wallet)
      throw new Error("w3m-connecting-wc-browser: No wallet provided");
    this.onConnect = this.onConnectProxy.bind(this), this.onAutoConnect = this.onConnectProxy.bind(this), Ht.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  async onConnectProxy() {
    try {
      this.error = !1;
      const { connectors: e } = Yr.state, t = e.find((i) => {
        var s, o;
        return i.type === "ANNOUNCED" && ((s = i.info) == null ? void 0 : s.rdns) === ((o = this.wallet) == null ? void 0 : o.rdns);
      }), n = e.find((i) => i.type === "INJECTED");
      t ? await wr.connectExternal(t) : n && await wr.connectExternal(n), Xr.close(), Ht.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser" }
      });
    } catch (e) {
      Ht.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (e == null ? void 0 : e.message) ?? "Unknown" }
      }), this.error = !0;
    }
  }
};
zR = aee([
  $e("w3m-connecting-wc-browser")
], zR);
var cee = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let VR = class extends $s {
  constructor() {
    if (super(), !this.wallet)
      throw new Error("w3m-connecting-wc-desktop: No wallet provided");
    this.onConnect = this.onConnectProxy.bind(this), this.onRender = this.onRenderProxy.bind(this), Ht.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    !this.ready && this.uri && (this.ready = !0, this.timeout = setTimeout(() => {
      var e;
      (e = this.onConnect) == null || e.call(this);
    }, 200));
  }
  onConnectProxy() {
    var e;
    if ((e = this.wallet) != null && e.desktop_link && this.uri)
      try {
        this.error = !1;
        const { desktop_link: t, name: n } = this.wallet, { redirect: i, href: s } = vt.formatNativeUrl(t, this.uri);
        wr.setWcLinking({ name: n, href: s }), wr.setRecentWallet(this.wallet), vt.openHref(i, "_blank");
      } catch {
        this.error = !0;
      }
  }
};
VR = cee([
  $e("w3m-connecting-wc-desktop")
], VR);
var lee = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let qR = class extends $s {
  constructor() {
    if (super(), !this.wallet)
      throw new Error("w3m-connecting-wc-mobile: No wallet provided");
    this.onConnect = this.onConnectProxy.bind(this), this.onRender = this.onRenderProxy.bind(this), document.addEventListener("visibilitychange", this.onBuffering.bind(this)), Ht.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
  }
  onRenderProxy() {
    var e;
    !this.ready && this.uri && (this.ready = !0, (e = this.onConnect) == null || e.call(this));
  }
  onConnectProxy() {
    var e;
    if ((e = this.wallet) != null && e.mobile_link && this.uri)
      try {
        this.error = !1;
        const { mobile_link: t, name: n } = this.wallet, { redirect: i, href: s } = vt.formatNativeUrl(t, this.uri);
        wr.setWcLinking({ name: n, href: s }), wr.setRecentWallet(this.wallet), vt.openHref(i, "_self");
      } catch {
        this.error = !0;
      }
  }
  onBuffering() {
    const e = vt.isIos();
    (document == null ? void 0 : document.visibilityState) === "visible" && !this.error && e && (wr.setBuffering(!0), setTimeout(() => {
      wr.setBuffering(!1);
    }, 5e3));
  }
};
qR = lee([
  $e("w3m-connecting-wc-mobile")
], qR);
const uee = cn`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var hee = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let L6 = class extends $s {
  constructor() {
    var e;
    super(), this.forceUpdate = () => {
      this.requestUpdate();
    }, window.addEventListener("resize", this.forceUpdate), Ht.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: ((e = this.wallet) == null ? void 0 : e.name) ?? "WalletConnect", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    return this.onRenderProxy(), Ae`
      <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    !this.ready && this.uri && (this.timeout = setTimeout(() => {
      this.ready = !0;
    }, 200));
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready)
      return null;
    const e = this.getBoundingClientRect().width - 40, t = this.wallet ? this.wallet.name : void 0;
    return wr.setWcLinking(void 0), wr.setRecentWallet(this.wallet), Ae` <wui-qr-code
      size=${e}
      theme=${Cs.state.themeMode}
      uri=${this.uri}
      imageSrc=${Sr(Sn.getWalletImage(this.wallet))}
      alt=${Sr(t)}
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const e = !this.uri || !this.ready;
    return Ae`<wui-link
      .disabled=${e}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
};
L6.styles = uee;
L6 = hee([
  $e("w3m-connecting-wc-qrcode")
], L6);
const fee = cn`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;
var dee = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let B6 = class extends Xt {
  constructor() {
    var e;
    super(...arguments), this.dappImageUrl = (e = Rr.state.metadata) == null ? void 0 : e.icons, this.walletImageUrl = ns.getConnectedWalletImageUrl();
  }
  firstUpdated() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelectorAll("wui-visual-thumbnail");
    e != null && e[0] && this.createAnimation(e[0], "translate(18px)"), e != null && e[1] && this.createAnimation(e[1], "translate(-18px)");
  }
  render() {
    var e;
    return Ae`
      <wui-visual-thumbnail
        ?borderRadiusFull=${!0}
        .imageSrc=${(e = this.dappImageUrl) == null ? void 0 : e[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `;
  }
  createAnimation(e, t) {
    e.animate([{ transform: "translateX(0px)" }, { transform: t }], {
      duration: 1600,
      easing: "cubic-bezier(0.56, 0, 0.48, 1)",
      direction: "alternate",
      iterations: 1 / 0
    });
  }
};
B6.styles = fee;
B6 = dee([
  $e("w3m-connecting-siwe")
], B6);
var pee = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let GR = class extends Xt {
  constructor() {
    var e;
    if (super(), this.wallet = (e = ut.state.data) == null ? void 0 : e.wallet, !this.wallet)
      throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
    Ht.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return Ae`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${Sr(Sn.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
};
GR = pee([
  $e("w3m-connecting-wc-unsupported")
], GR);
var gee = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let KR = class extends $s {
  constructor() {
    if (super(), !this.wallet)
      throw new Error("w3m-connecting-wc-web: No wallet provided");
    this.onConnect = this.onConnectProxy.bind(this), this.secondaryBtnLabel = "Open", this.secondaryLabel = "Open and continue in a new browser tab", this.secondaryBtnIcon = "externalLink", Ht.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    var e;
    if ((e = this.wallet) != null && e.webapp_link && this.uri)
      try {
        this.error = !1;
        const { webapp_link: t, name: n } = this.wallet, { redirect: i, href: s } = vt.formatUniversalUrl(t, this.uri);
        wr.setWcLinking({ name: n, href: s }), wr.setRecentWallet(this.wallet), vt.openHref(i, "_blank");
      } catch {
        this.error = !0;
      }
  }
};
KR = gee([
  $e("w3m-connecting-wc-web")
], KR);
const mee = cn`
  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;
var B_ = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
function ZR() {
  var o, a, c, u, f, d, m;
  const r = (a = (o = ut.state.data) == null ? void 0 : o.connector) == null ? void 0 : a.name, e = (u = (c = ut.state.data) == null ? void 0 : c.wallet) == null ? void 0 : u.name, t = (d = (f = ut.state.data) == null ? void 0 : f.network) == null ? void 0 : d.name, n = e ?? r, i = Yr.getConnectors();
  return {
    Connect: `Connect ${i.length === 1 && ((m = i[0]) == null ? void 0 : m.id) === "w3m-email" ? "Email" : ""} Wallet`,
    Account: void 0,
    ConnectingExternal: n ?? "Connect Wallet",
    ConnectingWalletConnect: n ?? "WalletConnect",
    ConnectingSiwe: "Sign In",
    Networks: "Choose Network",
    SwitchNetwork: t ?? "Switch Network",
    AllWallets: "All Wallets",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    GetWallet: "Get a wallet",
    Downloads: n ? `Get ${n}` : "Downloads",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    ApproveTransaction: "Approve Transaction",
    Transactions: "Activity",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpdateEmailWallet: "Edit Email",
    UpdateEmailWalletWaiting: "Approve Email"
  };
}
let fg = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.heading = ZR()[ut.state.view], this.buffering = !1, this.showBack = !1, this.unsubscribe.push(ut.subscribeKey("view", (e) => {
      this.onViewChange(e), this.onHistoryChange();
    }), wr.subscribeKey("buffering", (e) => this.buffering = e));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  render() {
    return Ae`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${this.onClose.bind(this)}
          data-testid="w3m-header-close"
        ></wui-icon-link>
      </wui-flex>
      ${this.separatorTemplate()}
    `;
  }
  onWalletHelp() {
    Ht.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" }), ut.push("WhatIsAWallet");
  }
  async onClose() {
    Dn.state.isSiweEnabled && Dn.state.status !== "success" && await wr.disconnect(), Xr.close();
  }
  titleTemplate() {
    return Ae`<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`;
  }
  dynamicButtonTemplate() {
    const { view: e } = ut.state, t = e === "Connect", n = e === "ApproveTransaction";
    return this.showBack && !n ? Ae`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>` : Ae`<wui-icon-link
      data-hidden=${!t}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
  }
  separatorTemplate() {
    return this.heading ? Ae`<wui-separator></wui-separator>` : null;
  }
  getPadding() {
    return this.heading ? ["l", "2l", "l", "2l"] : ["l", "2l", "0", "2l"];
  }
  async onViewChange(e) {
    var n;
    const t = (n = this.shadowRoot) == null ? void 0 : n.querySelector("wui-text");
    if (t) {
      const i = ZR()[e];
      await t.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished, this.heading = i, t.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onHistoryChange() {
    var n;
    const { history: e } = ut.state, t = (n = this.shadowRoot) == null ? void 0 : n.querySelector("#dynamic");
    e.length > 1 && !this.showBack && t ? (await t.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      fill: "forwards",
      easing: "ease"
    }).finished, this.showBack = !0, t.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: 200,
      fill: "forwards",
      easing: "ease"
    })) : e.length <= 1 && this.showBack && t && (await t.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      fill: "forwards",
      easing: "ease"
    }).finished, this.showBack = !1, t.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: 200,
      fill: "forwards",
      easing: "ease"
    }));
  }
  onGoBack() {
    ut.state.view === "ConnectingSiwe" ? ut.push("Connect") : ut.goBack();
  }
};
fg.styles = [mee];
B_([
  ot()
], fg.prototype, "heading", void 0);
B_([
  ot()
], fg.prototype, "buffering", void 0);
B_([
  ot()
], fg.prototype, "showBack", void 0);
fg = B_([
  $e("w3m-header")
], fg);
var JM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let F6 = class extends Xt {
  constructor() {
    super(...arguments), this.data = [];
  }
  render() {
    return Ae`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((e) => Ae`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${e.images.map((t) => Ae`<wui-visual name=${t}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${e.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${e.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
JM([
  bn({ type: Array })
], F6.prototype, "data", void 0);
F6 = JM([
  $e("w3m-help-widget")
], F6);
const wee = cn`
  wui-flex {
    background-color: var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;
var yee = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let U6 = class extends Xt {
  render() {
    const { termsConditionsUrl: e, privacyPolicyUrl: t } = Rr.state;
    return !e && !t ? null : Ae`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl: e, privacyPolicyUrl: t } = Rr.state;
    return e && t ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl: e } = Rr.state;
    return e ? Ae`<a href=${e}>Terms of Service</a>` : null;
  }
  privacyTemplate() {
    const { privacyPolicyUrl: e } = Rr.state;
    return e ? Ae`<a href=${e}>Privacy Policy</a>` : null;
  }
};
U6.styles = [wee];
U6 = yee([
  $e("w3m-legal-footer")
], U6);
const vee = cn`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var QM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let C2 = class extends Xt {
  constructor() {
    super(...arguments), this.wallet = void 0;
  }
  render() {
    if (!this.wallet)
      return this.style.display = "none", null;
    const { name: e, app_store: t, play_store: n, chrome_store: i, homepage: s } = this.wallet, o = vt.isMobile(), a = vt.isIos(), c = vt.isAndroid(), u = [t, n, s, i].filter(Boolean).length > 1, f = jr.getTruncateString({
      string: e,
      charsStart: 12,
      charsEnd: 0,
      truncate: "end"
    });
    return u && !o ? Ae`
        <wui-cta-button
          label=${`Don't have ${f}?`}
          buttonLabel="Get"
          @click=${() => ut.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      ` : !u && s ? Ae`
        <wui-cta-button
          label=${`Don't have ${f}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      ` : t && a ? Ae`
        <wui-cta-button
          label=${`Don't have ${f}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      ` : n && c ? Ae`
        <wui-cta-button
          label=${`Don't have ${f}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      ` : (this.style.display = "none", null);
  }
  onAppStore() {
    var e;
    (e = this.wallet) != null && e.app_store && vt.openHref(this.wallet.app_store, "_blank");
  }
  onPlayStore() {
    var e;
    (e = this.wallet) != null && e.play_store && vt.openHref(this.wallet.play_store, "_blank");
  }
  onHomePage() {
    var e;
    (e = this.wallet) != null && e.homepage && vt.openHref(this.wallet.homepage, "_blank");
  }
};
C2.styles = [vee];
QM([
  bn({ type: Object })
], C2.prototype, "wallet", void 0);
C2 = QM([
  $e("w3m-mobile-download-links")
], C2);
const bee = cn`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
var YM = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
const _ee = {
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
let A2 = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.timeout = void 0, this.open = In.state.open, this.unsubscribe.push(In.subscribeKey("open", (e) => {
      this.open = e, this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout), this.unsubscribe.forEach((e) => e());
  }
  render() {
    const { message: e, variant: t } = In.state, n = _ee[t];
    return Ae`
      <wui-snackbar
        message=${e}
        backgroundColor=${n.backgroundColor}
        iconColor=${n.iconColor}
        icon=${n.icon}
      ></wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout), this.open ? (this.animate([
      { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
      { opacity: 1, transform: "translateX(-50%) scale(1)" }
    ], {
      duration: 150,
      fill: "forwards",
      easing: "ease"
    }), this.timeout = setTimeout(() => In.hide(), 2500)) : this.animate([
      { opacity: 1, transform: "translateX(-50%) scale(1)" },
      { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
    ], {
      duration: 150,
      fill: "forwards",
      easing: "ease"
    });
  }
};
A2.styles = bee;
YM([
  ot()
], A2.prototype, "open", void 0);
A2 = YM([
  $e("w3m-snackbar")
], A2);
const Eee = cn`
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 21px;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }

  .alphaBanner {
    padding: 10px 12px 10px 10px;
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-accent-glass-010);
    margin-bottom: var(--wui-spacing-s);
  }
`;
var ny = function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
};
let ud = class extends Xt {
  constructor() {
    super(), this.unsubscribe = [], this.formRef = qM(), this.connectors = Yr.state.connectors, this.email = "", this.loading = !1, this.error = "", this.unsubscribe.push(Yr.subscribeKey("connectors", (e) => this.connectors = e));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((e) => e());
  }
  firstUpdated() {
    var e;
    (e = this.formRef.value) == null || e.addEventListener("keydown", (t) => {
      t.key === "Enter" && this.onSubmitEmail(t);
    });
  }
  render() {
    const e = this.connectors.length > 1;
    return this.connectors.find((n) => n.type === "EMAIL") ? Ae`
      ${this.alphaWarningTemplate()}
      <form ${GM(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${e ? Ae`<wui-separator text="or"></wui-separator>` : null}
    ` : null;
  }
  alphaWarningTemplate() {
    return Ae`
          <wui-flex class="alphaBanner" gap="xs" alignItems="center" justifyContent="center">
            <wui-icon-box
              size="sm"
              icon="alpha"
              iconColor="accent-100"
              background="opaque"
              backgroundColor="accent-100"
            ></wui-icon-box>
            <wui-text variant="small-400" color="accent-100">
              This is an alpha version to test before launch
            </wui-text>
          </wui-flex>
        `;
  }
  submitButtonTemplate() {
    return !this.loading && this.email.length > 3 ? Ae`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  loadingTemplate() {
    return this.loading ? Ae`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  onEmailInputChange(e) {
    this.email = e.detail, this.error = "";
  }
  async onSubmitEmail(e) {
    try {
      if (this.loading)
        return;
      this.loading = !0, e.preventDefault();
      const t = Yr.getEmailConnector();
      if (!t)
        throw new Error("w3m-email-login-widget: Email connector not found");
      const { action: n } = await t.provider.connectEmail({ email: this.email });
      Ht.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" }), n === "VERIFY_OTP" ? (Ht.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" }), ut.push("EmailVerifyOtp", { email: this.email })) : n === "VERIFY_DEVICE" && ut.push("EmailVerifyDevice", { email: this.email });
    } catch (t) {
      const n = vt.parseError(t);
      n != null && n.includes("Invalid email") ? this.error = "Invalid email. Try again." : In.showError(t);
    } finally {
      this.loading = !1;
    }
  }
  onFocusEvent() {
    Ht.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
  }
};
ud.styles = Eee;
ny([
  ot()
], ud.prototype, "connectors", void 0);
ny([
  ot()
], ud.prototype, "email", void 0);
ny([
  ot()
], ud.prototype, "loading", void 0);
ny([
  ot()
], ud.prototype, "error", void 0);
ud = ny([
  $e("w3m-email-login-widget")
], ud);
let JR = !1;
class xee {
  constructor(e) {
    this.initPromise = void 0, this.setIsConnected = (t) => {
      xr.setIsConnected(t);
    }, this.setCaipAddress = (t) => {
      xr.setCaipAddress(t);
    }, this.setBalance = (t, n) => {
      xr.setBalance(t, n);
    }, this.setProfileName = (t) => {
      xr.setProfileName(t);
    }, this.setProfileImage = (t) => {
      xr.setProfileImage(t);
    }, this.resetAccount = () => {
      xr.resetAccount();
    }, this.setCaipNetwork = (t) => {
      An.setCaipNetwork(t);
    }, this.getCaipNetwork = () => An.state.caipNetwork, this.setRequestedCaipNetworks = (t) => {
      An.setRequestedCaipNetworks(t);
    }, this.getApprovedCaipNetworksData = () => An.getApprovedCaipNetworksData(), this.resetNetwork = () => {
      An.resetNetwork();
    }, this.setConnectors = (t) => {
      Yr.setConnectors(t);
    }, this.addConnector = (t) => {
      Yr.addConnector(t);
    }, this.getConnectors = () => Yr.getConnectors(), this.resetWcConnection = () => {
      wr.resetWcConnection();
    }, this.fetchIdentity = (t) => IP.fetchIdentity(t), this.setAddressExplorerUrl = (t) => {
      xr.setAddressExplorerUrl(t);
    }, this.setSIWENonce = (t) => {
      Dn.setNonce(t);
    }, this.setSIWESession = (t) => {
      Dn.setSession(t);
    }, this.setSIWEStatus = (t) => {
      Dn.setStatus(t);
    }, this.setSIWEMessage = (t) => {
      Dn.setMessage(t);
    }, this.initControllers(e), this.initOrContinue();
  }
  async open(e) {
    await this.initOrContinue(), Xr.open(e);
  }
  async close() {
    await this.initOrContinue(), Xr.close();
  }
  setLoading(e) {
    Xr.setLoading(e);
  }
  getThemeMode() {
    return Cs.state.themeMode;
  }
  getThemeVariables() {
    return Cs.state.themeVariables;
  }
  setThemeMode(e) {
    Cs.setThemeMode(e), IS(Cs.state.themeMode);
    try {
      const t = Yr.getEmailConnector();
      t && t.provider.syncTheme({
        themeMode: Cs.getSnapshot().themeMode
      });
    } catch {
      console.info("Unable to sync theme to email connector");
    }
  }
  setThemeVariables(e) {
    Cs.setThemeVariables(e), FP(Cs.state.themeVariables);
    try {
      const t = Yr.getEmailConnector();
      t && t.provider.syncTheme({
        themeVariables: Cs.getSnapshot().themeVariables
      });
    } catch {
      console.info("Unable to sync theme to email connector");
    }
  }
  subscribeTheme(e) {
    return Cs.subscribe(e);
  }
  getState() {
    return { ...q0.state };
  }
  subscribeState(e) {
    return q0.subscribe(e);
  }
  getEvent() {
    return { ...Ht.state };
  }
  subscribeEvents(e) {
    return Ht.subscribe(e);
  }
  subscribeSIWEState(e) {
    return Dn.subscribe(e);
  }
  initControllers(e) {
    if (An.setClient(e.networkControllerClient), An.setDefaultCaipNetwork(e.defaultChain), Rr.setProjectId(e.projectId), Rr.setIncludeWalletIds(e.includeWalletIds), Rr.setExcludeWalletIds(e.excludeWalletIds), Rr.setFeaturedWalletIds(e.featuredWalletIds), Rr.setTokens(e.tokens), Rr.setTermsConditionsUrl(e.termsConditionsUrl), Rr.setPrivacyPolicyUrl(e.privacyPolicyUrl), Rr.setCustomWallets(e.customWallets), Rr.setEnableAnalytics(e.enableAnalytics), Rr.setSdkVersion(e._sdkVersion), wr.setClient(e.connectionControllerClient), e.siweControllerClient) {
      const t = e.siweControllerClient;
      Dn.setSIWEClient(t);
    }
    e.metadata && Rr.setMetadata(e.metadata), e.themeMode && Cs.setThemeMode(e.themeMode), e.themeVariables && Cs.setThemeVariables(e.themeVariables);
  }
  async initOrContinue() {
    return !this.initPromise && !JR && vt.isClient() && (JR = !0, this.initPromise = new Promise(async (e) => {
      await Promise.all([Promise.resolve().then(() => TQ), Promise.resolve().then(() => XQ)]);
      const t = document.createElement("w3m-modal");
      document.body.insertAdjacentElement("beforeend", t), e();
    })), this.initPromise;
  }
}
const Je = {
  WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
  INJECTED_CONNECTOR_ID: "injected",
  COINBASE_CONNECTOR_ID: "coinbaseWallet",
  SAFE_CONNECTOR_ID: "safe",
  LEDGER_CONNECTOR_ID: "ledger",
  EIP6963_CONNECTOR_ID: "eip6963",
  EMAIL_CONNECTOR_ID: "w3mEmail",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  VERSION: "3.5.7"
}, Ti = {
  ConnectorExplorerIds: {
    [Je.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [Je.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [Je.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
  },
  EIP155NetworkImageIds: {
    1: "692ed6ba-e569-459a-556a-776476829e00",
    42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100"
  },
  ConnectorImageIds: {
    [Je.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [Je.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [Je.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [Je.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [Je.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [Je.INJECTED_CONNECTOR_ID]: "Browser Wallet",
    [Je.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
    [Je.COINBASE_CONNECTOR_ID]: "Coinbase",
    [Je.LEDGER_CONNECTOR_ID]: "Ledger",
    [Je.SAFE_CONNECTOR_ID]: "Safe"
  },
  ConnectorTypesMap: {
    [Je.INJECTED_CONNECTOR_ID]: "INJECTED",
    [Je.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
    [Je.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
    [Je.EMAIL_CONNECTOR_ID]: "EMAIL"
  },
  WalletConnectRpcChainIds: [
    1,
    5,
    11155111,
    10,
    420,
    42161,
    421613,
    137,
    80001,
    42220,
    1313161554,
    1313161555,
    56,
    97,
    43114,
    43113,
    100,
    8453,
    84531,
    7777777,
    999,
    324,
    280
  ]
}, Zv = {
  caipNetworkIdToNumber(r) {
    return r ? Number(r.split(":")[1]) : void 0;
  },
  getCaipTokens(r) {
    if (!r)
      return;
    const e = {};
    return Object.entries(r).forEach(([t, n]) => {
      e[`${Je.EIP155}:${t}`] = n;
    }), e;
  }
};
var QS = { exports: {} }, Vp = typeof Reflect == "object" ? Reflect : null, QR = Vp && typeof Vp.apply == "function" ? Vp.apply : function(e, t, n) {
  return Function.prototype.apply.call(e, t, n);
}, Tb;
Vp && typeof Vp.ownKeys == "function" ? Tb = Vp.ownKeys : Object.getOwnPropertySymbols ? Tb = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Tb = function(e) {
  return Object.getOwnPropertyNames(e);
};
function See(r) {
  console && console.warn && console.warn(r);
}
var XM = Number.isNaN || function(e) {
  return e !== e;
};
function Wr() {
  Wr.init.call(this);
}
QS.exports = Wr;
QS.exports.once = Ree;
Wr.EventEmitter = Wr;
Wr.prototype._events = void 0;
Wr.prototype._eventsCount = 0;
Wr.prototype._maxListeners = void 0;
var YR = 10;
function F_(r) {
  if (typeof r != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
}
Object.defineProperty(Wr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return YR;
  },
  set: function(r) {
    if (typeof r != "number" || r < 0 || XM(r))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
    YR = r;
  }
});
Wr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Wr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || XM(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function eD(r) {
  return r._maxListeners === void 0 ? Wr.defaultMaxListeners : r._maxListeners;
}
Wr.prototype.getMaxListeners = function() {
  return eD(this);
};
Wr.prototype.emit = function(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t.push(arguments[n]);
  var i = e === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var o;
    if (t.length > 0 && (o = t[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var c = s[e];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    QR(c, this, t);
  else
    for (var u = c.length, f = sD(c, u), n = 0; n < u; ++n)
      QR(f[n], this, t);
  return !0;
};
function tD(r, e, t, n) {
  var i, s, o;
  if (F_(t), s = r._events, s === void 0 ? (s = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (s.newListener !== void 0 && (r.emit(
    "newListener",
    e,
    t.listener ? t.listener : t
  ), s = r._events), o = s[e]), o === void 0)
    o = s[e] = t, ++r._eventsCount;
  else if (typeof o == "function" ? o = s[e] = n ? [t, o] : [o, t] : n ? o.unshift(t) : o.push(t), i = eD(r), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = r, a.type = e, a.count = o.length, See(a);
  }
  return r;
}
Wr.prototype.addListener = function(e, t) {
  return tD(this, e, t, !1);
};
Wr.prototype.on = Wr.prototype.addListener;
Wr.prototype.prependListener = function(e, t) {
  return tD(this, e, t, !0);
};
function Cee() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function rD(r, e, t) {
  var n = { fired: !1, wrapFn: void 0, target: r, type: e, listener: t }, i = Cee.bind(n);
  return i.listener = t, n.wrapFn = i, i;
}
Wr.prototype.once = function(e, t) {
  return F_(t), this.on(e, rD(this, e, t)), this;
};
Wr.prototype.prependOnceListener = function(e, t) {
  return F_(t), this.prependListener(e, rD(this, e, t)), this;
};
Wr.prototype.removeListener = function(e, t) {
  var n, i, s, o, a;
  if (F_(t), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === t || n.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
  else if (typeof n != "function") {
    for (s = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === t || n[o].listener === t) {
        a = n[o].listener, s = o;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : Aee(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || t);
  }
  return this;
};
Wr.prototype.off = Wr.prototype.removeListener;
Wr.prototype.removeAllListeners = function(e) {
  var t, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), o;
    for (i = 0; i < s.length; ++i)
      o = s[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = n[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (i = t.length - 1; i >= 0; i--)
      this.removeListener(e, t[i]);
  return this;
};
function nD(r, e, t) {
  var n = r._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? Iee(i) : sD(i, i.length);
}
Wr.prototype.listeners = function(e) {
  return nD(this, e, !0);
};
Wr.prototype.rawListeners = function(e) {
  return nD(this, e, !1);
};
Wr.listenerCount = function(r, e) {
  return typeof r.listenerCount == "function" ? r.listenerCount(e) : iD.call(r, e);
};
Wr.prototype.listenerCount = iD;
function iD(r) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[r];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
Wr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Tb(this._events) : [];
};
function sD(r, e) {
  for (var t = new Array(e), n = 0; n < e; ++n)
    t[n] = r[n];
  return t;
}
function Aee(r, e) {
  for (; e + 1 < r.length; e++)
    r[e] = r[e + 1];
  r.pop();
}
function Iee(r) {
  for (var e = new Array(r.length), t = 0; t < e.length; ++t)
    e[t] = r[t].listener || r[t];
  return e;
}
function Ree(r, e) {
  return new Promise(function(t, n) {
    function i(o) {
      r.removeListener(e, s), n(o);
    }
    function s() {
      typeof r.removeListener == "function" && r.removeListener("error", i), t([].slice.call(arguments));
    }
    oD(r, e, s, { once: !0 }), e !== "error" && Tee(r, i, { once: !0 });
  });
}
function Tee(r, e, t) {
  typeof r.on == "function" && oD(r, "error", e, t);
}
function oD(r, e, t, n) {
  if (typeof r.on == "function")
    n.once ? r.once(e, t) : r.on(e, t);
  else if (typeof r.addEventListener == "function")
    r.addEventListener(e, function i(s) {
      n.once && r.removeEventListener(e, i), t(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r);
}
var Wi = QS.exports;
const YS = /* @__PURE__ */ Ed(Wi);
var XS = {}, U_ = {}, Kt = {}, aD = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  function e(a, c) {
    var u = a >>> 16 & 65535, f = a & 65535, d = c >>> 16 & 65535, m = c & 65535;
    return f * m + (u * m + f * d << 16 >>> 0) | 0;
  }
  r.mul = Math.imul || e;
  function t(a, c) {
    return a + c | 0;
  }
  r.add = t;
  function n(a, c) {
    return a - c | 0;
  }
  r.sub = n;
  function i(a, c) {
    return a << c | a >>> 32 - c;
  }
  r.rotl = i;
  function s(a, c) {
    return a << 32 - c | a >>> c;
  }
  r.rotr = s;
  function o(a) {
    return typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  }
  r.isInteger = Number.isInteger || o, r.MAX_SAFE_INTEGER = 9007199254740991, r.isSafeInteger = function(a) {
    return r.isInteger(a) && a >= -r.MAX_SAFE_INTEGER && a <= r.MAX_SAFE_INTEGER;
  };
})(aD);
Object.defineProperty(Kt, "__esModule", { value: !0 });
var cD = aD;
function Oee(r, e) {
  return e === void 0 && (e = 0), (r[e + 0] << 8 | r[e + 1]) << 16 >> 16;
}
Kt.readInt16BE = Oee;
function Nee(r, e) {
  return e === void 0 && (e = 0), (r[e + 0] << 8 | r[e + 1]) >>> 0;
}
Kt.readUint16BE = Nee;
function Pee(r, e) {
  return e === void 0 && (e = 0), (r[e + 1] << 8 | r[e]) << 16 >> 16;
}
Kt.readInt16LE = Pee;
function Mee(r, e) {
  return e === void 0 && (e = 0), (r[e + 1] << 8 | r[e]) >>> 0;
}
Kt.readUint16LE = Mee;
function lD(r, e, t) {
  return e === void 0 && (e = new Uint8Array(2)), t === void 0 && (t = 0), e[t + 0] = r >>> 8, e[t + 1] = r >>> 0, e;
}
Kt.writeUint16BE = lD;
Kt.writeInt16BE = lD;
function uD(r, e, t) {
  return e === void 0 && (e = new Uint8Array(2)), t === void 0 && (t = 0), e[t + 0] = r >>> 0, e[t + 1] = r >>> 8, e;
}
Kt.writeUint16LE = uD;
Kt.writeInt16LE = uD;
function j6(r, e) {
  return e === void 0 && (e = 0), r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3];
}
Kt.readInt32BE = j6;
function W6(r, e) {
  return e === void 0 && (e = 0), (r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3]) >>> 0;
}
Kt.readUint32BE = W6;
function H6(r, e) {
  return e === void 0 && (e = 0), r[e + 3] << 24 | r[e + 2] << 16 | r[e + 1] << 8 | r[e];
}
Kt.readInt32LE = H6;
function z6(r, e) {
  return e === void 0 && (e = 0), (r[e + 3] << 24 | r[e + 2] << 16 | r[e + 1] << 8 | r[e]) >>> 0;
}
Kt.readUint32LE = z6;
function I2(r, e, t) {
  return e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0), e[t + 0] = r >>> 24, e[t + 1] = r >>> 16, e[t + 2] = r >>> 8, e[t + 3] = r >>> 0, e;
}
Kt.writeUint32BE = I2;
Kt.writeInt32BE = I2;
function R2(r, e, t) {
  return e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0), e[t + 0] = r >>> 0, e[t + 1] = r >>> 8, e[t + 2] = r >>> 16, e[t + 3] = r >>> 24, e;
}
Kt.writeUint32LE = R2;
Kt.writeInt32LE = R2;
function Dee(r, e) {
  e === void 0 && (e = 0);
  var t = j6(r, e), n = j6(r, e + 4);
  return t * 4294967296 + n - (n >> 31) * 4294967296;
}
Kt.readInt64BE = Dee;
function kee(r, e) {
  e === void 0 && (e = 0);
  var t = W6(r, e), n = W6(r, e + 4);
  return t * 4294967296 + n;
}
Kt.readUint64BE = kee;
function $ee(r, e) {
  e === void 0 && (e = 0);
  var t = H6(r, e), n = H6(r, e + 4);
  return n * 4294967296 + t - (t >> 31) * 4294967296;
}
Kt.readInt64LE = $ee;
function Lee(r, e) {
  e === void 0 && (e = 0);
  var t = z6(r, e), n = z6(r, e + 4);
  return n * 4294967296 + t;
}
Kt.readUint64LE = Lee;
function hD(r, e, t) {
  return e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0), I2(r / 4294967296 >>> 0, e, t), I2(r >>> 0, e, t + 4), e;
}
Kt.writeUint64BE = hD;
Kt.writeInt64BE = hD;
function fD(r, e, t) {
  return e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0), R2(r >>> 0, e, t), R2(r / 4294967296 >>> 0, e, t + 4), e;
}
Kt.writeUint64LE = fD;
Kt.writeInt64LE = fD;
function Bee(r, e, t) {
  if (t === void 0 && (t = 0), r % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (r / 8 > e.length - t)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = r / 8 + t - 1; s >= t; s--)
    n += e[s] * i, i *= 256;
  return n;
}
Kt.readUintBE = Bee;
function Fee(r, e, t) {
  if (t === void 0 && (t = 0), r % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (r / 8 > e.length - t)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = t; s < t + r / 8; s++)
    n += e[s] * i, i *= 256;
  return n;
}
Kt.readUintLE = Fee;
function Uee(r, e, t, n) {
  if (t === void 0 && (t = new Uint8Array(r / 8)), n === void 0 && (n = 0), r % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!cD.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = r / 8 + n - 1; s >= n; s--)
    t[s] = e / i & 255, i *= 256;
  return t;
}
Kt.writeUintBE = Uee;
function jee(r, e, t, n) {
  if (t === void 0 && (t = new Uint8Array(r / 8)), n === void 0 && (n = 0), r % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!cD.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = n; s < n + r / 8; s++)
    t[s] = e / i & 255, i *= 256;
  return t;
}
Kt.writeUintLE = jee;
function Wee(r, e) {
  e === void 0 && (e = 0);
  var t = new DataView(r.buffer, r.byteOffset, r.byteLength);
  return t.getFloat32(e);
}
Kt.readFloat32BE = Wee;
function Hee(r, e) {
  e === void 0 && (e = 0);
  var t = new DataView(r.buffer, r.byteOffset, r.byteLength);
  return t.getFloat32(e, !0);
}
Kt.readFloat32LE = Hee;
function zee(r, e) {
  e === void 0 && (e = 0);
  var t = new DataView(r.buffer, r.byteOffset, r.byteLength);
  return t.getFloat64(e);
}
Kt.readFloat64BE = zee;
function Vee(r, e) {
  e === void 0 && (e = 0);
  var t = new DataView(r.buffer, r.byteOffset, r.byteLength);
  return t.getFloat64(e, !0);
}
Kt.readFloat64LE = Vee;
function qee(r, e, t) {
  e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(t, r), e;
}
Kt.writeFloat32BE = qee;
function Gee(r, e, t) {
  e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(t, r, !0), e;
}
Kt.writeFloat32LE = Gee;
function Kee(r, e, t) {
  e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(t, r), e;
}
Kt.writeFloat64BE = Kee;
function Zee(r, e, t) {
  e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(t, r, !0), e;
}
Kt.writeFloat64LE = Zee;
var ao = {};
Object.defineProperty(ao, "__esModule", { value: !0 });
function Jee(r) {
  for (var e = 0; e < r.length; e++)
    r[e] = 0;
  return r;
}
ao.wipe = Jee;
Object.defineProperty(U_, "__esModule", { value: !0 });
var Ci = Kt, V6 = ao, Qee = 20;
function Yee(r, e, t) {
  for (var n = 1634760805, i = 857760878, s = 2036477234, o = 1797285236, a = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], c = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], u = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], f = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], d = t[19] << 24 | t[18] << 16 | t[17] << 8 | t[16], m = t[23] << 24 | t[22] << 16 | t[21] << 8 | t[20], y = t[27] << 24 | t[26] << 16 | t[25] << 8 | t[24], b = t[31] << 24 | t[30] << 16 | t[29] << 8 | t[28], I = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], k = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], R = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], T = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], $ = n, D = i, L = s, P = o, v = a, F = c, X = u, te = f, se = d, we = m, H = y, p = b, w = I, x = k, N = R, O = T, U = 0; U < Qee; U += 2)
    $ = $ + v | 0, w ^= $, w = w >>> 16 | w << 16, se = se + w | 0, v ^= se, v = v >>> 20 | v << 12, D = D + F | 0, x ^= D, x = x >>> 16 | x << 16, we = we + x | 0, F ^= we, F = F >>> 20 | F << 12, L = L + X | 0, N ^= L, N = N >>> 16 | N << 16, H = H + N | 0, X ^= H, X = X >>> 20 | X << 12, P = P + te | 0, O ^= P, O = O >>> 16 | O << 16, p = p + O | 0, te ^= p, te = te >>> 20 | te << 12, L = L + X | 0, N ^= L, N = N >>> 24 | N << 8, H = H + N | 0, X ^= H, X = X >>> 25 | X << 7, P = P + te | 0, O ^= P, O = O >>> 24 | O << 8, p = p + O | 0, te ^= p, te = te >>> 25 | te << 7, D = D + F | 0, x ^= D, x = x >>> 24 | x << 8, we = we + x | 0, F ^= we, F = F >>> 25 | F << 7, $ = $ + v | 0, w ^= $, w = w >>> 24 | w << 8, se = se + w | 0, v ^= se, v = v >>> 25 | v << 7, $ = $ + F | 0, O ^= $, O = O >>> 16 | O << 16, H = H + O | 0, F ^= H, F = F >>> 20 | F << 12, D = D + X | 0, w ^= D, w = w >>> 16 | w << 16, p = p + w | 0, X ^= p, X = X >>> 20 | X << 12, L = L + te | 0, x ^= L, x = x >>> 16 | x << 16, se = se + x | 0, te ^= se, te = te >>> 20 | te << 12, P = P + v | 0, N ^= P, N = N >>> 16 | N << 16, we = we + N | 0, v ^= we, v = v >>> 20 | v << 12, L = L + te | 0, x ^= L, x = x >>> 24 | x << 8, se = se + x | 0, te ^= se, te = te >>> 25 | te << 7, P = P + v | 0, N ^= P, N = N >>> 24 | N << 8, we = we + N | 0, v ^= we, v = v >>> 25 | v << 7, D = D + X | 0, w ^= D, w = w >>> 24 | w << 8, p = p + w | 0, X ^= p, X = X >>> 25 | X << 7, $ = $ + F | 0, O ^= $, O = O >>> 24 | O << 8, H = H + O | 0, F ^= H, F = F >>> 25 | F << 7;
  Ci.writeUint32LE($ + n | 0, r, 0), Ci.writeUint32LE(D + i | 0, r, 4), Ci.writeUint32LE(L + s | 0, r, 8), Ci.writeUint32LE(P + o | 0, r, 12), Ci.writeUint32LE(v + a | 0, r, 16), Ci.writeUint32LE(F + c | 0, r, 20), Ci.writeUint32LE(X + u | 0, r, 24), Ci.writeUint32LE(te + f | 0, r, 28), Ci.writeUint32LE(se + d | 0, r, 32), Ci.writeUint32LE(we + m | 0, r, 36), Ci.writeUint32LE(H + y | 0, r, 40), Ci.writeUint32LE(p + b | 0, r, 44), Ci.writeUint32LE(w + I | 0, r, 48), Ci.writeUint32LE(x + k | 0, r, 52), Ci.writeUint32LE(N + R | 0, r, 56), Ci.writeUint32LE(O + T | 0, r, 60);
}
function dD(r, e, t, n, i) {
  if (i === void 0 && (i = 0), r.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (n.length < t.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, o;
  if (i === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), o = s.length - e.length, s.set(e, o);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = e, o = i;
  }
  for (var a = new Uint8Array(64), c = 0; c < t.length; c += 64) {
    Yee(a, s, r);
    for (var u = c; u < c + 64 && u < t.length; u++)
      n[u] = t[u] ^ a[u - c];
    ete(s, 0, o);
  }
  return V6.wipe(a), i === 0 && V6.wipe(s), n;
}
U_.streamXOR = dD;
function Xee(r, e, t, n) {
  return n === void 0 && (n = 0), V6.wipe(t), dD(r, e, t, t, n);
}
U_.stream = Xee;
function ete(r, e, t) {
  for (var n = 1; t--; )
    n = n + (r[e] & 255) | 0, r[e] = n & 255, n >>>= 8, e++;
  if (n > 0)
    throw new Error("ChaCha: counter overflow");
}
var pD = {}, ph = {};
Object.defineProperty(ph, "__esModule", { value: !0 });
function tte(r, e, t) {
  return ~(r - 1) & e | r - 1 & t;
}
ph.select = tte;
function rte(r, e) {
  return (r | 0) - (e | 0) - 1 >>> 31 & 1;
}
ph.lessOrEqual = rte;
function gD(r, e) {
  if (r.length !== e.length)
    return 0;
  for (var t = 0, n = 0; n < r.length; n++)
    t |= r[n] ^ e[n];
  return 1 & t - 1 >>> 8;
}
ph.compare = gD;
function nte(r, e) {
  return r.length === 0 || e.length === 0 ? !1 : gD(r, e) !== 0;
}
ph.equal = nte;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  var e = ph, t = ao;
  r.DIGEST_LENGTH = 16;
  var n = (
    /** @class */
    function() {
      function o(a) {
        this.digestLength = r.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var c = a[0] | a[1] << 8;
        this._r[0] = c & 8191;
        var u = a[2] | a[3] << 8;
        this._r[1] = (c >>> 13 | u << 3) & 8191;
        var f = a[4] | a[5] << 8;
        this._r[2] = (u >>> 10 | f << 6) & 7939;
        var d = a[6] | a[7] << 8;
        this._r[3] = (f >>> 7 | d << 9) & 8191;
        var m = a[8] | a[9] << 8;
        this._r[4] = (d >>> 4 | m << 12) & 255, this._r[5] = m >>> 1 & 8190;
        var y = a[10] | a[11] << 8;
        this._r[6] = (m >>> 14 | y << 2) & 8191;
        var b = a[12] | a[13] << 8;
        this._r[7] = (y >>> 11 | b << 5) & 8065;
        var I = a[14] | a[15] << 8;
        this._r[8] = (b >>> 8 | I << 8) & 8191, this._r[9] = I >>> 5 & 127, this._pad[0] = a[16] | a[17] << 8, this._pad[1] = a[18] | a[19] << 8, this._pad[2] = a[20] | a[21] << 8, this._pad[3] = a[22] | a[23] << 8, this._pad[4] = a[24] | a[25] << 8, this._pad[5] = a[26] | a[27] << 8, this._pad[6] = a[28] | a[29] << 8, this._pad[7] = a[30] | a[31] << 8;
      }
      return o.prototype._blocks = function(a, c, u) {
        for (var f = this._fin ? 0 : 2048, d = this._h[0], m = this._h[1], y = this._h[2], b = this._h[3], I = this._h[4], k = this._h[5], R = this._h[6], T = this._h[7], $ = this._h[8], D = this._h[9], L = this._r[0], P = this._r[1], v = this._r[2], F = this._r[3], X = this._r[4], te = this._r[5], se = this._r[6], we = this._r[7], H = this._r[8], p = this._r[9]; u >= 16; ) {
          var w = a[c + 0] | a[c + 1] << 8;
          d += w & 8191;
          var x = a[c + 2] | a[c + 3] << 8;
          m += (w >>> 13 | x << 3) & 8191;
          var N = a[c + 4] | a[c + 5] << 8;
          y += (x >>> 10 | N << 6) & 8191;
          var O = a[c + 6] | a[c + 7] << 8;
          b += (N >>> 7 | O << 9) & 8191;
          var U = a[c + 8] | a[c + 9] << 8;
          I += (O >>> 4 | U << 12) & 8191, k += U >>> 1 & 8191;
          var q = a[c + 10] | a[c + 11] << 8;
          R += (U >>> 14 | q << 2) & 8191;
          var B = a[c + 12] | a[c + 13] << 8;
          T += (q >>> 11 | B << 5) & 8191;
          var E = a[c + 14] | a[c + 15] << 8;
          $ += (B >>> 8 | E << 8) & 8191, D += E >>> 5 | f;
          var V = 0, be = V;
          be += d * L, be += m * (5 * p), be += y * (5 * H), be += b * (5 * we), be += I * (5 * se), V = be >>> 13, be &= 8191, be += k * (5 * te), be += R * (5 * X), be += T * (5 * F), be += $ * (5 * v), be += D * (5 * P), V += be >>> 13, be &= 8191;
          var ve = V;
          ve += d * P, ve += m * L, ve += y * (5 * p), ve += b * (5 * H), ve += I * (5 * we), V = ve >>> 13, ve &= 8191, ve += k * (5 * se), ve += R * (5 * te), ve += T * (5 * X), ve += $ * (5 * F), ve += D * (5 * v), V += ve >>> 13, ve &= 8191;
          var ne = V;
          ne += d * v, ne += m * P, ne += y * L, ne += b * (5 * p), ne += I * (5 * H), V = ne >>> 13, ne &= 8191, ne += k * (5 * we), ne += R * (5 * se), ne += T * (5 * te), ne += $ * (5 * X), ne += D * (5 * F), V += ne >>> 13, ne &= 8191;
          var K = V;
          K += d * F, K += m * v, K += y * P, K += b * L, K += I * (5 * p), V = K >>> 13, K &= 8191, K += k * (5 * H), K += R * (5 * we), K += T * (5 * se), K += $ * (5 * te), K += D * (5 * X), V += K >>> 13, K &= 8191;
          var Y = V;
          Y += d * X, Y += m * F, Y += y * v, Y += b * P, Y += I * L, V = Y >>> 13, Y &= 8191, Y += k * (5 * p), Y += R * (5 * H), Y += T * (5 * we), Y += $ * (5 * se), Y += D * (5 * te), V += Y >>> 13, Y &= 8191;
          var ee = V;
          ee += d * te, ee += m * X, ee += y * F, ee += b * v, ee += I * P, V = ee >>> 13, ee &= 8191, ee += k * L, ee += R * (5 * p), ee += T * (5 * H), ee += $ * (5 * we), ee += D * (5 * se), V += ee >>> 13, ee &= 8191;
          var S = V;
          S += d * se, S += m * te, S += y * X, S += b * F, S += I * v, V = S >>> 13, S &= 8191, S += k * P, S += R * L, S += T * (5 * p), S += $ * (5 * H), S += D * (5 * we), V += S >>> 13, S &= 8191;
          var M = V;
          M += d * we, M += m * se, M += y * te, M += b * X, M += I * F, V = M >>> 13, M &= 8191, M += k * v, M += R * P, M += T * L, M += $ * (5 * p), M += D * (5 * H), V += M >>> 13, M &= 8191;
          var G = V;
          G += d * H, G += m * we, G += y * se, G += b * te, G += I * X, V = G >>> 13, G &= 8191, G += k * F, G += R * v, G += T * P, G += $ * L, G += D * (5 * p), V += G >>> 13, G &= 8191;
          var ue = V;
          ue += d * p, ue += m * H, ue += y * we, ue += b * se, ue += I * te, V = ue >>> 13, ue &= 8191, ue += k * X, ue += R * F, ue += T * v, ue += $ * P, ue += D * L, V += ue >>> 13, ue &= 8191, V = (V << 2) + V | 0, V = V + be | 0, be = V & 8191, V = V >>> 13, ve += V, d = be, m = ve, y = ne, b = K, I = Y, k = ee, R = S, T = M, $ = G, D = ue, c += 16, u -= 16;
        }
        this._h[0] = d, this._h[1] = m, this._h[2] = y, this._h[3] = b, this._h[4] = I, this._h[5] = k, this._h[6] = R, this._h[7] = T, this._h[8] = $, this._h[9] = D;
      }, o.prototype.finish = function(a, c) {
        c === void 0 && (c = 0);
        var u = new Uint16Array(10), f, d, m, y;
        if (this._leftover) {
          for (y = this._leftover, this._buffer[y++] = 1; y < 16; y++)
            this._buffer[y] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (f = this._h[1] >>> 13, this._h[1] &= 8191, y = 2; y < 10; y++)
          this._h[y] += f, f = this._h[y] >>> 13, this._h[y] &= 8191;
        for (this._h[0] += f * 5, f = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += f, f = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += f, u[0] = this._h[0] + 5, f = u[0] >>> 13, u[0] &= 8191, y = 1; y < 10; y++)
          u[y] = this._h[y] + f, f = u[y] >>> 13, u[y] &= 8191;
        for (u[9] -= 8192, d = (f ^ 1) - 1, y = 0; y < 10; y++)
          u[y] &= d;
        for (d = ~d, y = 0; y < 10; y++)
          this._h[y] = this._h[y] & d | u[y];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, m = this._h[0] + this._pad[0], this._h[0] = m & 65535, y = 1; y < 8; y++)
          m = (this._h[y] + this._pad[y] | 0) + (m >>> 16) | 0, this._h[y] = m & 65535;
        return a[c + 0] = this._h[0] >>> 0, a[c + 1] = this._h[0] >>> 8, a[c + 2] = this._h[1] >>> 0, a[c + 3] = this._h[1] >>> 8, a[c + 4] = this._h[2] >>> 0, a[c + 5] = this._h[2] >>> 8, a[c + 6] = this._h[3] >>> 0, a[c + 7] = this._h[3] >>> 8, a[c + 8] = this._h[4] >>> 0, a[c + 9] = this._h[4] >>> 8, a[c + 10] = this._h[5] >>> 0, a[c + 11] = this._h[5] >>> 8, a[c + 12] = this._h[6] >>> 0, a[c + 13] = this._h[6] >>> 8, a[c + 14] = this._h[7] >>> 0, a[c + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, o.prototype.update = function(a) {
        var c = 0, u = a.length, f;
        if (this._leftover) {
          f = 16 - this._leftover, f > u && (f = u);
          for (var d = 0; d < f; d++)
            this._buffer[this._leftover + d] = a[c + d];
          if (u -= f, c += f, this._leftover += f, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (u >= 16 && (f = u - u % 16, this._blocks(a, c, f), c += f, u -= f), u) {
          for (var d = 0; d < u; d++)
            this._buffer[this._leftover + d] = a[c + d];
          this._leftover += u;
        }
        return this;
      }, o.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var a = new Uint8Array(16);
        return this.finish(a), a;
      }, o.prototype.clean = function() {
        return t.wipe(this._buffer), t.wipe(this._r), t.wipe(this._h), t.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, o;
    }()
  );
  r.Poly1305 = n;
  function i(o, a) {
    var c = new n(o);
    c.update(a);
    var u = c.digest();
    return c.clean(), u;
  }
  r.oneTimeAuth = i;
  function s(o, a) {
    return o.length !== r.DIGEST_LENGTH || a.length !== r.DIGEST_LENGTH ? !1 : e.equal(o, a);
  }
  r.equal = s;
})(pD);
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  var e = U_, t = pD, n = ao, i = Kt, s = ph;
  r.KEY_LENGTH = 32, r.NONCE_LENGTH = 12, r.TAG_LENGTH = 16;
  var o = new Uint8Array(16), a = (
    /** @class */
    function() {
      function c(u) {
        if (this.nonceLength = r.NONCE_LENGTH, this.tagLength = r.TAG_LENGTH, u.length !== r.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(u);
      }
      return c.prototype.seal = function(u, f, d, m) {
        if (u.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var y = new Uint8Array(16);
        y.set(u, y.length - u.length);
        var b = new Uint8Array(32);
        e.stream(this._key, y, b, 4);
        var I = f.length + this.tagLength, k;
        if (m) {
          if (m.length !== I)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          k = m;
        } else
          k = new Uint8Array(I);
        return e.streamXOR(this._key, y, f, k, 4), this._authenticate(k.subarray(k.length - this.tagLength, k.length), b, k.subarray(0, k.length - this.tagLength), d), n.wipe(y), k;
      }, c.prototype.open = function(u, f, d, m) {
        if (u.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (f.length < this.tagLength)
          return null;
        var y = new Uint8Array(16);
        y.set(u, y.length - u.length);
        var b = new Uint8Array(32);
        e.stream(this._key, y, b, 4);
        var I = new Uint8Array(this.tagLength);
        if (this._authenticate(I, b, f.subarray(0, f.length - this.tagLength), d), !s.equal(I, f.subarray(f.length - this.tagLength, f.length)))
          return null;
        var k = f.length - this.tagLength, R;
        if (m) {
          if (m.length !== k)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          R = m;
        } else
          R = new Uint8Array(k);
        return e.streamXOR(this._key, y, f.subarray(0, f.length - this.tagLength), R, 4), n.wipe(y), R;
      }, c.prototype.clean = function() {
        return n.wipe(this._key), this;
      }, c.prototype._authenticate = function(u, f, d, m) {
        var y = new t.Poly1305(f);
        m && (y.update(m), m.length % 16 > 0 && y.update(o.subarray(m.length % 16))), y.update(d), d.length % 16 > 0 && y.update(o.subarray(d.length % 16));
        var b = new Uint8Array(8);
        m && i.writeUint64LE(m.length, b), y.update(b), i.writeUint64LE(d.length, b), y.update(b);
        for (var I = y.digest(), k = 0; k < I.length; k++)
          u[k] = I[k];
        y.clean(), n.wipe(I), n.wipe(b);
      }, c;
    }()
  );
  r.ChaCha20Poly1305 = a;
})(XS);
var mD = {}, iy = {}, eC = {};
Object.defineProperty(eC, "__esModule", { value: !0 });
function ite(r) {
  return typeof r.saveState < "u" && typeof r.restoreState < "u" && typeof r.cleanSavedState < "u";
}
eC.isSerializableHash = ite;
Object.defineProperty(iy, "__esModule", { value: !0 });
var Qa = eC, ste = ph, ote = ao, wD = (
  /** @class */
  function() {
    function r(e, t) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var n = new Uint8Array(this.blockSize);
      t.length > this.blockSize ? this._inner.update(t).finish(n).clean() : n.set(t);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 54;
      this._inner.update(n);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 106;
      this._outer.update(n), Qa.isSerializableHash(this._inner) && Qa.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), ote.wipe(n);
    }
    return r.prototype.reset = function() {
      if (!Qa.isSerializableHash(this._inner) || !Qa.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, r.prototype.clean = function() {
      Qa.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Qa.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, r.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, r.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, r.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, r.prototype.saveState = function() {
      if (!Qa.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, r.prototype.restoreState = function(e) {
      if (!Qa.isSerializableHash(this._inner) || !Qa.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, r.prototype.cleanSavedState = function(e) {
      if (!Qa.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, r;
  }()
);
iy.HMAC = wD;
function ate(r, e, t) {
  var n = new wD(r, e);
  n.update(t);
  var i = n.digest();
  return n.clean(), i;
}
iy.hmac = ate;
iy.equal = ste.equal;
Object.defineProperty(mD, "__esModule", { value: !0 });
var XR = iy, e9 = ao, cte = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i;
      var s = XR.hmac(this._hash, n, t);
      this._hmac = new XR.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return r.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, r.prototype.expand = function(e) {
      for (var t = new Uint8Array(e), n = 0; n < t.length; n++)
        this._bufpos === this._buffer.length && this._fillBuffer(), t[n] = this._buffer[this._bufpos++];
      return t;
    }, r.prototype.clean = function() {
      this._hmac.clean(), e9.wipe(this._buffer), e9.wipe(this._counter), this._bufpos = 0;
    }, r;
  }()
), lte = mD.HKDF = cte, Fg = {}, j_ = {}, W_ = {};
Object.defineProperty(W_, "__esModule", { value: !0 });
W_.BrowserRandomSource = void 0;
const t9 = 65536;
class ute {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const t = new Uint8Array(e);
    for (let n = 0; n < t.length; n += t9)
      this._crypto.getRandomValues(t.subarray(n, n + Math.min(t.length - n, t9)));
    return t;
  }
}
W_.BrowserRandomSource = ute;
function hte(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var H_ = {};
const fte = {}, dte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: fte
}, Symbol.toStringTag, { value: "Module" })), sy = /* @__PURE__ */ La(dte);
Object.defineProperty(H_, "__esModule", { value: !0 });
H_.NodeRandomSource = void 0;
const pte = ao;
class gte {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof hte < "u") {
      const e = sy;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let t = this._crypto.randomBytes(e);
    if (t.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const n = new Uint8Array(e);
    for (let i = 0; i < n.length; i++)
      n[i] = t[i];
    return (0, pte.wipe)(t), n;
  }
}
H_.NodeRandomSource = gte;
Object.defineProperty(j_, "__esModule", { value: !0 });
j_.SystemRandomSource = void 0;
const mte = W_, wte = H_;
class yte {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new mte.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new wte.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
j_.SystemRandomSource = yte;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.randomStringForEntropy = r.randomString = r.randomUint32 = r.randomBytes = r.defaultRandomSource = void 0;
  const e = j_, t = Kt, n = ao;
  r.defaultRandomSource = new e.SystemRandomSource();
  function i(u, f = r.defaultRandomSource) {
    return f.randomBytes(u);
  }
  r.randomBytes = i;
  function s(u = r.defaultRandomSource) {
    const f = i(4, u), d = (0, t.readUint32LE)(f);
    return (0, n.wipe)(f), d;
  }
  r.randomUint32 = s;
  const o = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function a(u, f = o, d = r.defaultRandomSource) {
    if (f.length < 2)
      throw new Error("randomString charset is too short");
    if (f.length > 256)
      throw new Error("randomString charset is too long");
    let m = "";
    const y = f.length, b = 256 - 256 % y;
    for (; u > 0; ) {
      const I = i(Math.ceil(u * 256 / b), d);
      for (let k = 0; k < I.length && u > 0; k++) {
        const R = I[k];
        R < b && (m += f.charAt(R % y), u--);
      }
      (0, n.wipe)(I);
    }
    return m;
  }
  r.randomString = a;
  function c(u, f = o, d = r.defaultRandomSource) {
    const m = Math.ceil(u / (Math.log(f.length) / Math.LN2));
    return a(m, f, d);
  }
  r.randomStringForEntropy = c;
})(Fg);
var z_ = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  var e = Kt, t = ao;
  r.DIGEST_LENGTH = 32, r.BLOCK_SIZE = 64;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = r.DIGEST_LENGTH, this.blockSize = r.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        t.wipe(this._buffer), t.wipe(this._temp), this.reset();
      }, a.prototype.update = function(c, u) {
        if (u === void 0 && (u = c.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var f = 0;
        if (this._bytesHashed += u, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && u > 0; )
            this._buffer[this._bufferLength++] = c[f++], u--;
          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (u >= this.blockSize && (f = s(this._temp, this._state, c, f, u), u %= this.blockSize); u > 0; )
          this._buffer[this._bufferLength++] = c[f++], u--;
        return this;
      }, a.prototype.finish = function(c) {
        if (!this._finished) {
          var u = this._bytesHashed, f = this._bufferLength, d = u / 536870912 | 0, m = u << 3, y = u % 64 < 56 ? 64 : 128;
          this._buffer[f] = 128;
          for (var b = f + 1; b < y - 8; b++)
            this._buffer[b] = 0;
          e.writeUint32BE(d, this._buffer, y - 8), e.writeUint32BE(m, this._buffer, y - 4), s(this._temp, this._state, this._buffer, 0, y), this._finished = !0;
        }
        for (var b = 0; b < this.digestLength / 4; b++)
          e.writeUint32BE(this._state[b], c, b * 4);
        return this;
      }, a.prototype.digest = function() {
        var c = new Uint8Array(this.digestLength);
        return this.finish(c), c;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(c) {
        return this._state.set(c.state), this._bufferLength = c.bufferLength, c.buffer && this._buffer.set(c.buffer), this._bytesHashed = c.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(c) {
        t.wipe(c.state), c.buffer && t.wipe(c.buffer), c.bufferLength = 0, c.bytesHashed = 0;
      }, a;
    }()
  );
  r.SHA256 = n;
  var i = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function s(a, c, u, f, d) {
    for (; d >= 64; ) {
      for (var m = c[0], y = c[1], b = c[2], I = c[3], k = c[4], R = c[5], T = c[6], $ = c[7], D = 0; D < 16; D++) {
        var L = f + D * 4;
        a[D] = e.readUint32BE(u, L);
      }
      for (var D = 16; D < 64; D++) {
        var P = a[D - 2], v = (P >>> 17 | P << 15) ^ (P >>> 19 | P << 13) ^ P >>> 10;
        P = a[D - 15];
        var F = (P >>> 7 | P << 25) ^ (P >>> 18 | P << 14) ^ P >>> 3;
        a[D] = (v + a[D - 7] | 0) + (F + a[D - 16] | 0);
      }
      for (var D = 0; D < 64; D++) {
        var v = (((k >>> 6 | k << 26) ^ (k >>> 11 | k << 21) ^ (k >>> 25 | k << 7)) + (k & R ^ ~k & T) | 0) + ($ + (i[D] + a[D] | 0) | 0) | 0, F = ((m >>> 2 | m << 30) ^ (m >>> 13 | m << 19) ^ (m >>> 22 | m << 10)) + (m & y ^ m & b ^ y & b) | 0;
        $ = T, T = R, R = k, k = I + v | 0, I = b, b = y, y = m, m = v + F | 0;
      }
      c[0] += m, c[1] += y, c[2] += b, c[3] += I, c[4] += k, c[5] += R, c[6] += T, c[7] += $, f += 64, d -= 64;
    }
    return f;
  }
  function o(a) {
    var c = new n();
    c.update(a);
    var u = c.digest();
    return c.clean(), u;
  }
  r.hash = o;
})(z_);
var tC = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.sharedKey = r.generateKeyPair = r.generateKeyPairFromSeed = r.scalarMultBase = r.scalarMult = r.SHARED_KEY_LENGTH = r.SECRET_KEY_LENGTH = r.PUBLIC_KEY_LENGTH = void 0;
  const e = Fg, t = ao;
  r.PUBLIC_KEY_LENGTH = 32, r.SECRET_KEY_LENGTH = 32, r.SHARED_KEY_LENGTH = 32;
  function n(D) {
    const L = new Float64Array(16);
    if (D)
      for (let P = 0; P < D.length; P++)
        L[P] = D[P];
    return L;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = n([56129, 1]);
  function o(D) {
    let L = 1;
    for (let P = 0; P < 16; P++) {
      let v = D[P] + L + 65535;
      L = Math.floor(v / 65536), D[P] = v - L * 65536;
    }
    D[0] += L - 1 + 37 * (L - 1);
  }
  function a(D, L, P) {
    const v = ~(P - 1);
    for (let F = 0; F < 16; F++) {
      const X = v & (D[F] ^ L[F]);
      D[F] ^= X, L[F] ^= X;
    }
  }
  function c(D, L) {
    const P = n(), v = n();
    for (let F = 0; F < 16; F++)
      v[F] = L[F];
    o(v), o(v), o(v);
    for (let F = 0; F < 2; F++) {
      P[0] = v[0] - 65517;
      for (let te = 1; te < 15; te++)
        P[te] = v[te] - 65535 - (P[te - 1] >> 16 & 1), P[te - 1] &= 65535;
      P[15] = v[15] - 32767 - (P[14] >> 16 & 1);
      const X = P[15] >> 16 & 1;
      P[14] &= 65535, a(v, P, 1 - X);
    }
    for (let F = 0; F < 16; F++)
      D[2 * F] = v[F] & 255, D[2 * F + 1] = v[F] >> 8;
  }
  function u(D, L) {
    for (let P = 0; P < 16; P++)
      D[P] = L[2 * P] + (L[2 * P + 1] << 8);
    D[15] &= 32767;
  }
  function f(D, L, P) {
    for (let v = 0; v < 16; v++)
      D[v] = L[v] + P[v];
  }
  function d(D, L, P) {
    for (let v = 0; v < 16; v++)
      D[v] = L[v] - P[v];
  }
  function m(D, L, P) {
    let v, F, X = 0, te = 0, se = 0, we = 0, H = 0, p = 0, w = 0, x = 0, N = 0, O = 0, U = 0, q = 0, B = 0, E = 0, V = 0, be = 0, ve = 0, ne = 0, K = 0, Y = 0, ee = 0, S = 0, M = 0, G = 0, ue = 0, Ee = 0, Le = 0, Fe = 0, De = 0, dt = 0, or = 0, Qe = P[0], We = P[1], lt = P[2], qe = P[3], Ye = P[4], st = P[5], Ge = P[6], W = P[7], _ = P[8], A = P[9], J = P[10], ae = P[11], le = P[12], ge = P[13], je = P[14], Ue = P[15];
    v = L[0], X += v * Qe, te += v * We, se += v * lt, we += v * qe, H += v * Ye, p += v * st, w += v * Ge, x += v * W, N += v * _, O += v * A, U += v * J, q += v * ae, B += v * le, E += v * ge, V += v * je, be += v * Ue, v = L[1], te += v * Qe, se += v * We, we += v * lt, H += v * qe, p += v * Ye, w += v * st, x += v * Ge, N += v * W, O += v * _, U += v * A, q += v * J, B += v * ae, E += v * le, V += v * ge, be += v * je, ve += v * Ue, v = L[2], se += v * Qe, we += v * We, H += v * lt, p += v * qe, w += v * Ye, x += v * st, N += v * Ge, O += v * W, U += v * _, q += v * A, B += v * J, E += v * ae, V += v * le, be += v * ge, ve += v * je, ne += v * Ue, v = L[3], we += v * Qe, H += v * We, p += v * lt, w += v * qe, x += v * Ye, N += v * st, O += v * Ge, U += v * W, q += v * _, B += v * A, E += v * J, V += v * ae, be += v * le, ve += v * ge, ne += v * je, K += v * Ue, v = L[4], H += v * Qe, p += v * We, w += v * lt, x += v * qe, N += v * Ye, O += v * st, U += v * Ge, q += v * W, B += v * _, E += v * A, V += v * J, be += v * ae, ve += v * le, ne += v * ge, K += v * je, Y += v * Ue, v = L[5], p += v * Qe, w += v * We, x += v * lt, N += v * qe, O += v * Ye, U += v * st, q += v * Ge, B += v * W, E += v * _, V += v * A, be += v * J, ve += v * ae, ne += v * le, K += v * ge, Y += v * je, ee += v * Ue, v = L[6], w += v * Qe, x += v * We, N += v * lt, O += v * qe, U += v * Ye, q += v * st, B += v * Ge, E += v * W, V += v * _, be += v * A, ve += v * J, ne += v * ae, K += v * le, Y += v * ge, ee += v * je, S += v * Ue, v = L[7], x += v * Qe, N += v * We, O += v * lt, U += v * qe, q += v * Ye, B += v * st, E += v * Ge, V += v * W, be += v * _, ve += v * A, ne += v * J, K += v * ae, Y += v * le, ee += v * ge, S += v * je, M += v * Ue, v = L[8], N += v * Qe, O += v * We, U += v * lt, q += v * qe, B += v * Ye, E += v * st, V += v * Ge, be += v * W, ve += v * _, ne += v * A, K += v * J, Y += v * ae, ee += v * le, S += v * ge, M += v * je, G += v * Ue, v = L[9], O += v * Qe, U += v * We, q += v * lt, B += v * qe, E += v * Ye, V += v * st, be += v * Ge, ve += v * W, ne += v * _, K += v * A, Y += v * J, ee += v * ae, S += v * le, M += v * ge, G += v * je, ue += v * Ue, v = L[10], U += v * Qe, q += v * We, B += v * lt, E += v * qe, V += v * Ye, be += v * st, ve += v * Ge, ne += v * W, K += v * _, Y += v * A, ee += v * J, S += v * ae, M += v * le, G += v * ge, ue += v * je, Ee += v * Ue, v = L[11], q += v * Qe, B += v * We, E += v * lt, V += v * qe, be += v * Ye, ve += v * st, ne += v * Ge, K += v * W, Y += v * _, ee += v * A, S += v * J, M += v * ae, G += v * le, ue += v * ge, Ee += v * je, Le += v * Ue, v = L[12], B += v * Qe, E += v * We, V += v * lt, be += v * qe, ve += v * Ye, ne += v * st, K += v * Ge, Y += v * W, ee += v * _, S += v * A, M += v * J, G += v * ae, ue += v * le, Ee += v * ge, Le += v * je, Fe += v * Ue, v = L[13], E += v * Qe, V += v * We, be += v * lt, ve += v * qe, ne += v * Ye, K += v * st, Y += v * Ge, ee += v * W, S += v * _, M += v * A, G += v * J, ue += v * ae, Ee += v * le, Le += v * ge, Fe += v * je, De += v * Ue, v = L[14], V += v * Qe, be += v * We, ve += v * lt, ne += v * qe, K += v * Ye, Y += v * st, ee += v * Ge, S += v * W, M += v * _, G += v * A, ue += v * J, Ee += v * ae, Le += v * le, Fe += v * ge, De += v * je, dt += v * Ue, v = L[15], be += v * Qe, ve += v * We, ne += v * lt, K += v * qe, Y += v * Ye, ee += v * st, S += v * Ge, M += v * W, G += v * _, ue += v * A, Ee += v * J, Le += v * ae, Fe += v * le, De += v * ge, dt += v * je, or += v * Ue, X += 38 * ve, te += 38 * ne, se += 38 * K, we += 38 * Y, H += 38 * ee, p += 38 * S, w += 38 * M, x += 38 * G, N += 38 * ue, O += 38 * Ee, U += 38 * Le, q += 38 * Fe, B += 38 * De, E += 38 * dt, V += 38 * or, F = 1, v = X + F + 65535, F = Math.floor(v / 65536), X = v - F * 65536, v = te + F + 65535, F = Math.floor(v / 65536), te = v - F * 65536, v = se + F + 65535, F = Math.floor(v / 65536), se = v - F * 65536, v = we + F + 65535, F = Math.floor(v / 65536), we = v - F * 65536, v = H + F + 65535, F = Math.floor(v / 65536), H = v - F * 65536, v = p + F + 65535, F = Math.floor(v / 65536), p = v - F * 65536, v = w + F + 65535, F = Math.floor(v / 65536), w = v - F * 65536, v = x + F + 65535, F = Math.floor(v / 65536), x = v - F * 65536, v = N + F + 65535, F = Math.floor(v / 65536), N = v - F * 65536, v = O + F + 65535, F = Math.floor(v / 65536), O = v - F * 65536, v = U + F + 65535, F = Math.floor(v / 65536), U = v - F * 65536, v = q + F + 65535, F = Math.floor(v / 65536), q = v - F * 65536, v = B + F + 65535, F = Math.floor(v / 65536), B = v - F * 65536, v = E + F + 65535, F = Math.floor(v / 65536), E = v - F * 65536, v = V + F + 65535, F = Math.floor(v / 65536), V = v - F * 65536, v = be + F + 65535, F = Math.floor(v / 65536), be = v - F * 65536, X += F - 1 + 37 * (F - 1), F = 1, v = X + F + 65535, F = Math.floor(v / 65536), X = v - F * 65536, v = te + F + 65535, F = Math.floor(v / 65536), te = v - F * 65536, v = se + F + 65535, F = Math.floor(v / 65536), se = v - F * 65536, v = we + F + 65535, F = Math.floor(v / 65536), we = v - F * 65536, v = H + F + 65535, F = Math.floor(v / 65536), H = v - F * 65536, v = p + F + 65535, F = Math.floor(v / 65536), p = v - F * 65536, v = w + F + 65535, F = Math.floor(v / 65536), w = v - F * 65536, v = x + F + 65535, F = Math.floor(v / 65536), x = v - F * 65536, v = N + F + 65535, F = Math.floor(v / 65536), N = v - F * 65536, v = O + F + 65535, F = Math.floor(v / 65536), O = v - F * 65536, v = U + F + 65535, F = Math.floor(v / 65536), U = v - F * 65536, v = q + F + 65535, F = Math.floor(v / 65536), q = v - F * 65536, v = B + F + 65535, F = Math.floor(v / 65536), B = v - F * 65536, v = E + F + 65535, F = Math.floor(v / 65536), E = v - F * 65536, v = V + F + 65535, F = Math.floor(v / 65536), V = v - F * 65536, v = be + F + 65535, F = Math.floor(v / 65536), be = v - F * 65536, X += F - 1 + 37 * (F - 1), D[0] = X, D[1] = te, D[2] = se, D[3] = we, D[4] = H, D[5] = p, D[6] = w, D[7] = x, D[8] = N, D[9] = O, D[10] = U, D[11] = q, D[12] = B, D[13] = E, D[14] = V, D[15] = be;
  }
  function y(D, L) {
    m(D, L, L);
  }
  function b(D, L) {
    const P = n();
    for (let v = 0; v < 16; v++)
      P[v] = L[v];
    for (let v = 253; v >= 0; v--)
      y(P, P), v !== 2 && v !== 4 && m(P, P, L);
    for (let v = 0; v < 16; v++)
      D[v] = P[v];
  }
  function I(D, L) {
    const P = new Uint8Array(32), v = new Float64Array(80), F = n(), X = n(), te = n(), se = n(), we = n(), H = n();
    for (let N = 0; N < 31; N++)
      P[N] = D[N];
    P[31] = D[31] & 127 | 64, P[0] &= 248, u(v, L);
    for (let N = 0; N < 16; N++)
      X[N] = v[N];
    F[0] = se[0] = 1;
    for (let N = 254; N >= 0; --N) {
      const O = P[N >>> 3] >>> (N & 7) & 1;
      a(F, X, O), a(te, se, O), f(we, F, te), d(F, F, te), f(te, X, se), d(X, X, se), y(se, we), y(H, F), m(F, te, F), m(te, X, we), f(we, F, te), d(F, F, te), y(X, F), d(te, se, H), m(F, te, s), f(F, F, se), m(te, te, F), m(F, se, H), m(se, X, v), y(X, we), a(F, X, O), a(te, se, O);
    }
    for (let N = 0; N < 16; N++)
      v[N + 16] = F[N], v[N + 32] = te[N], v[N + 48] = X[N], v[N + 64] = se[N];
    const p = v.subarray(32), w = v.subarray(16);
    b(p, p), m(w, w, p);
    const x = new Uint8Array(32);
    return c(x, w), x;
  }
  r.scalarMult = I;
  function k(D) {
    return I(D, i);
  }
  r.scalarMultBase = k;
  function R(D) {
    if (D.length !== r.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${r.SECRET_KEY_LENGTH} bytes`);
    const L = new Uint8Array(D);
    return {
      publicKey: k(L),
      secretKey: L
    };
  }
  r.generateKeyPairFromSeed = R;
  function T(D) {
    const L = (0, e.randomBytes)(32, D), P = R(L);
    return (0, t.wipe)(L), P;
  }
  r.generateKeyPair = T;
  function $(D, L, P = !1) {
    if (D.length !== r.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (L.length !== r.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const v = I(D, L);
    if (P) {
      let F = 0;
      for (let X = 0; X < v.length; X++)
        F |= v[X];
      if (F === 0)
        throw new Error("X25519: invalid shared key");
    }
    return v;
  }
  r.sharedKey = $;
})(tC);
function rC(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function yD(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? rC(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function q6(r, e) {
  e || (e = r.reduce((i, s) => i + s.length, 0));
  const t = yD(e);
  let n = 0;
  for (const i of r)
    t.set(i, n), n += i.length;
  return rC(t);
}
function vte(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++)
    t[n] = 255;
  for (var i = 0; i < r.length; i++) {
    var s = r.charAt(i), o = s.charCodeAt(0);
    if (t[o] !== 255)
      throw new TypeError(s + " is ambiguous");
    t[o] = i;
  }
  var a = r.length, c = r.charAt(0), u = Math.log(a) / Math.log(256), f = Math.log(256) / Math.log(a);
  function d(b) {
    if (b instanceof Uint8Array || (ArrayBuffer.isView(b) ? b = new Uint8Array(b.buffer, b.byteOffset, b.byteLength) : Array.isArray(b) && (b = Uint8Array.from(b))), !(b instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (b.length === 0)
      return "";
    for (var I = 0, k = 0, R = 0, T = b.length; R !== T && b[R] === 0; )
      R++, I++;
    for (var $ = (T - R) * f + 1 >>> 0, D = new Uint8Array($); R !== T; ) {
      for (var L = b[R], P = 0, v = $ - 1; (L !== 0 || P < k) && v !== -1; v--, P++)
        L += 256 * D[v] >>> 0, D[v] = L % a >>> 0, L = L / a >>> 0;
      if (L !== 0)
        throw new Error("Non-zero carry");
      k = P, R++;
    }
    for (var F = $ - k; F !== $ && D[F] === 0; )
      F++;
    for (var X = c.repeat(I); F < $; ++F)
      X += r.charAt(D[F]);
    return X;
  }
  function m(b) {
    if (typeof b != "string")
      throw new TypeError("Expected String");
    if (b.length === 0)
      return new Uint8Array();
    var I = 0;
    if (b[I] !== " ") {
      for (var k = 0, R = 0; b[I] === c; )
        k++, I++;
      for (var T = (b.length - I) * u + 1 >>> 0, $ = new Uint8Array(T); b[I]; ) {
        var D = t[b.charCodeAt(I)];
        if (D === 255)
          return;
        for (var L = 0, P = T - 1; (D !== 0 || L < R) && P !== -1; P--, L++)
          D += a * $[P] >>> 0, $[P] = D % 256 >>> 0, D = D / 256 >>> 0;
        if (D !== 0)
          throw new Error("Non-zero carry");
        R = L, I++;
      }
      if (b[I] !== " ") {
        for (var v = T - R; v !== T && $[v] === 0; )
          v++;
        for (var F = new Uint8Array(k + (T - v)), X = k; v !== T; )
          F[X++] = $[v++];
        return F;
      }
    }
  }
  function y(b) {
    var I = m(b);
    if (I)
      return I;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: d,
    decodeUnsafe: m,
    decode: y
  };
}
var bte = vte, _te = bte;
const Ete = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
}, xte = (r) => new TextEncoder().encode(r), Ste = (r) => new TextDecoder().decode(r);
class Cte {
  constructor(e, t, n) {
    this.name = e, this.prefix = t, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Ate {
  constructor(e, t, n) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return vD(this, e);
  }
}
class Ite {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return vD(this, e);
  }
  decode(e) {
    const t = e[0], n = this.decoders[t];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const vD = (r, e) => new Ite({
  ...r.decoders || { [r.prefix]: r },
  ...e.decoders || { [e.prefix]: e }
});
class Rte {
  constructor(e, t, n, i) {
    this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = i, this.encoder = new Cte(e, t, n), this.decoder = new Ate(e, t, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const V_ = ({ name: r, prefix: e, encode: t, decode: n }) => new Rte(r, e, t, n), oy = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: n, decode: i } = _te(t, e);
  return V_({
    prefix: r,
    name: e,
    encode: n,
    decode: (s) => Ete(i(s))
  });
}, Tte = (r, e, t, n) => {
  const i = {};
  for (let f = 0; f < e.length; ++f)
    i[e[f]] = f;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const o = new Uint8Array(s * t / 8 | 0);
  let a = 0, c = 0, u = 0;
  for (let f = 0; f < s; ++f) {
    const d = i[r[f]];
    if (d === void 0)
      throw new SyntaxError(`Non-${n} character`);
    c = c << t | d, a += t, a >= 8 && (a -= 8, o[u++] = 255 & c >> a);
  }
  if (a >= t || 255 & c << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, Ote = (r, e, t) => {
  const n = e[e.length - 1] === "=", i = (1 << t) - 1;
  let s = "", o = 0, a = 0;
  for (let c = 0; c < r.length; ++c)
    for (a = a << 8 | r[c], o += 8; o > t; )
      o -= t, s += e[i & a >> o];
  if (o && (s += e[i & a << t - o]), n)
    for (; s.length * t & 7; )
      s += "=";
  return s;
}, vi = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => V_({
  prefix: e,
  name: r,
  encode(i) {
    return Ote(i, n, t);
  },
  decode(i) {
    return Tte(i, n, t, r);
  }
}), Nte = V_({
  prefix: "\0",
  name: "identity",
  encode: (r) => Ste(r),
  decode: (r) => xte(r)
}), Pte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: Nte
}, Symbol.toStringTag, { value: "Module" })), Mte = vi({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), Dte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: Mte
}, Symbol.toStringTag, { value: "Module" })), kte = vi({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), $te = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: kte
}, Symbol.toStringTag, { value: "Module" })), Lte = oy({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), Bte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: Lte
}, Symbol.toStringTag, { value: "Module" })), Fte = vi({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), Ute = vi({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), jte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: Fte,
  base16upper: Ute
}, Symbol.toStringTag, { value: "Module" })), Wte = vi({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), Hte = vi({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), zte = vi({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), Vte = vi({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), qte = vi({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), Gte = vi({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), Kte = vi({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), Zte = vi({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), Jte = vi({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), Qte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: Wte,
  base32hex: qte,
  base32hexpad: Kte,
  base32hexpadupper: Zte,
  base32hexupper: Gte,
  base32pad: zte,
  base32padupper: Vte,
  base32upper: Hte,
  base32z: Jte
}, Symbol.toStringTag, { value: "Module" })), Yte = oy({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Xte = oy({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), ere = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: Yte,
  base36upper: Xte
}, Symbol.toStringTag, { value: "Module" })), tre = oy({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), rre = oy({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), nre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: tre,
  base58flickr: rre
}, Symbol.toStringTag, { value: "Module" })), ire = vi({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), sre = vi({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), ore = vi({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), are = vi({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), cre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: ire,
  base64pad: sre,
  base64url: ore,
  base64urlpad: are
}, Symbol.toStringTag, { value: "Module" })), bD = Array.from(""), lre = bD.reduce((r, e, t) => (r[t] = e, r), []), ure = bD.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function hre(r) {
  return r.reduce((e, t) => (e += lre[t], e), "");
}
function fre(r) {
  const e = [];
  for (const t of r) {
    const n = ure[t.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const dre = V_({
  prefix: "",
  name: "base256emoji",
  encode: hre,
  decode: fre
}), pre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: dre
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const r9 = {
  ...Pte,
  ...Dte,
  ...$te,
  ...Bte,
  ...jte,
  ...Qte,
  ...ere,
  ...nre,
  ...cre,
  ...pre
};
function _D(r, e, t, n) {
  return {
    name: r,
    prefix: e,
    encoder: {
      name: r,
      prefix: e,
      encode: t
    },
    decoder: { decode: n }
  };
}
const n9 = _D("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1))), K5 = _D("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = yD(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
}), ED = {
  utf8: n9,
  "utf-8": n9,
  hex: r9.base16,
  latin1: K5,
  ascii: K5,
  binary: K5,
  ...r9
};
function Ms(r, e = "utf8") {
  const t = ED[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? rC(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
function us(r, e = "utf8") {
  const t = ED[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1);
}
var i9 = function(r, e, t) {
  if (t || arguments.length === 2)
    for (var n = 0, i = e.length, s; n < i; n++)
      (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}, gre = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t, n) {
      this.name = e, this.version = t, this.os = n, this.type = "browser";
    }
    return r;
  }()
), mre = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return r;
  }()
), wre = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t, n, i) {
      this.name = e, this.version = t, this.os = n, this.bot = i, this.type = "bot-device";
    }
    return r;
  }()
), yre = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return r;
  }()
), vre = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return r;
  }()
), bre = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, _re = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, s9 = 3, Ere = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", bre]
], o9 = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function xre(r) {
  return r ? a9(r) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new vre() : typeof navigator < "u" ? a9(navigator.userAgent) : Are();
}
function Sre(r) {
  return r !== "" && Ere.reduce(function(e, t) {
    var n = t[0], i = t[1];
    if (e)
      return e;
    var s = i.exec(r);
    return !!s && [n, s];
  }, !1);
}
function a9(r) {
  var e = Sre(r);
  if (!e)
    return null;
  var t = e[0], n = e[1];
  if (t === "searchbot")
    return new yre();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < s9 && (i = i9(i9([], i, !0), Ire(s9 - i.length), !0)) : i = [];
  var s = i.join("."), o = Cre(r), a = _re.exec(r);
  return a && a[1] ? new wre(t, s, o, a[1]) : new gre(t, s, o);
}
function Cre(r) {
  for (var e = 0, t = o9.length; e < t; e++) {
    var n = o9[e], i = n[0], s = n[1], o = s.exec(r);
    if (o)
      return i;
  }
  return null;
}
function Are() {
  var r = typeof process < "u" && process.version;
  return r ? new mre(process.version.slice(1)) : null;
}
function Ire(r) {
  for (var e = [], t = 0; t < r; t++)
    e.push("0");
  return e;
}
var ft = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var G6 = function(r, e) {
  return G6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n)
      n.hasOwnProperty(i) && (t[i] = n[i]);
  }, G6(r, e);
};
function Pe(r, e) {
  G6(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var K6 = function() {
  return K6 = Object.assign || function(e) {
    for (var t, n = 1, i = arguments.length; n < i; n++) {
      t = arguments[n];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, K6.apply(this, arguments);
};
function Rre(r, e) {
  var t = {};
  for (var n in r)
    Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]);
  return t;
}
function Tre(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function Ore(r, e) {
  return function(t, n) {
    e(t, n, r);
  };
}
function Nre(r, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(r, e);
}
function Pre(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function a(f) {
      try {
        u(n.next(f));
      } catch (d) {
        o(d);
      }
    }
    function c(f) {
      try {
        u(n.throw(f));
      } catch (d) {
        o(d);
      }
    }
    function u(f) {
      f.done ? s(f.value) : i(f.value).then(a, c);
    }
    u((n = n.apply(r, e || [])).next());
  });
}
function Mre(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(f) {
      return c([u, f]);
    };
  }
  function c(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done)
          return s;
        switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return t.label++, { value: u[1], done: !1 };
          case 5:
            t.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              t = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              t.label = u[1];
              break;
            }
            if (u[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = u;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(u);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        u = e.call(r, t);
      } catch (f) {
        u = [6, f], i = 0;
      } finally {
        n = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Dre(r, e, t, n) {
  n === void 0 && (n = t), r[n] = e[t];
}
function kre(r, e) {
  for (var t in r)
    t !== "default" && !e.hasOwnProperty(t) && (e[t] = r[t]);
}
function Z6(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t)
    return t.call(r);
  if (r && typeof r.length == "number")
    return {
      next: function() {
        return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function xD(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t)
    return r;
  var n = t.call(r), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function $re() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r = r.concat(xD(arguments[e]));
  return r;
}
function Lre() {
  for (var r = 0, e = 0, t = arguments.length; e < t; e++)
    r += arguments[e].length;
  for (var n = Array(r), i = 0, e = 0; e < t; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      n[i] = s[o];
  return n;
}
function rw(r) {
  return this instanceof rw ? (this.v = r, this) : new rw(r);
}
function Bre(r, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), i, s = [];
  return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function o(m) {
    n[m] && (i[m] = function(y) {
      return new Promise(function(b, I) {
        s.push([m, y, b, I]) > 1 || a(m, y);
      });
    });
  }
  function a(m, y) {
    try {
      c(n[m](y));
    } catch (b) {
      d(s[0][3], b);
    }
  }
  function c(m) {
    m.value instanceof rw ? Promise.resolve(m.value.v).then(u, f) : d(s[0][2], m);
  }
  function u(m) {
    a("next", m);
  }
  function f(m) {
    a("throw", m);
  }
  function d(m, y) {
    m(y), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function Fre(r) {
  var e, t;
  return e = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(i, s) {
    e[i] = r[i] ? function(o) {
      return (t = !t) ? { value: rw(r[i](o)), done: i === "return" } : s ? s(o) : o;
    } : s;
  }
}
function Ure(r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof Z6 == "function" ? Z6(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function n(s) {
    t[s] = r[s] && function(o) {
      return new Promise(function(a, c) {
        o = r[s](o), i(a, c, o.done, o.value);
      });
    };
  }
  function i(s, o, a, c) {
    Promise.resolve(c).then(function(u) {
      s({ value: u, done: a });
    }, o);
  }
}
function jre(r, e) {
  return Object.defineProperty ? Object.defineProperty(r, "raw", { value: e }) : r.raw = e, r;
}
function Wre(r) {
  if (r && r.__esModule)
    return r;
  var e = {};
  if (r != null)
    for (var t in r)
      Object.hasOwnProperty.call(r, t) && (e[t] = r[t]);
  return e.default = r, e;
}
function Hre(r) {
  return r && r.__esModule ? r : { default: r };
}
function zre(r, e) {
  if (!e.has(r))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(r);
}
function Vre(r, e, t) {
  if (!e.has(r))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(r, t), t;
}
const qre = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return K6;
  },
  __asyncDelegator: Fre,
  __asyncGenerator: Bre,
  __asyncValues: Ure,
  __await: rw,
  __awaiter: Pre,
  __classPrivateFieldGet: zre,
  __classPrivateFieldSet: Vre,
  __createBinding: Dre,
  __decorate: Tre,
  __exportStar: kre,
  __extends: Pe,
  __generator: Mre,
  __importDefault: Hre,
  __importStar: Wre,
  __makeTemplateObject: jre,
  __metadata: Nre,
  __param: Ore,
  __read: xD,
  __rest: Rre,
  __spread: $re,
  __spreadArrays: Lre,
  __values: Z6
}, Symbol.toStringTag, { value: "Module" })), $c = /* @__PURE__ */ La(qre);
var Z5 = {}, R1 = {}, c9;
function Gre() {
  if (c9)
    return R1;
  c9 = 1, Object.defineProperty(R1, "__esModule", { value: !0 }), R1.delay = void 0;
  function r(e) {
    return new Promise((t) => {
      setTimeout(() => {
        t(!0);
      }, e);
    });
  }
  return R1.delay = r, R1;
}
var jh = {}, J5 = {}, Wh = {}, l9;
function Kre() {
  return l9 || (l9 = 1, Object.defineProperty(Wh, "__esModule", { value: !0 }), Wh.ONE_THOUSAND = Wh.ONE_HUNDRED = void 0, Wh.ONE_HUNDRED = 100, Wh.ONE_THOUSAND = 1e3), Wh;
}
var Q5 = {}, u9;
function Zre() {
  return u9 || (u9 = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.ONE_YEAR = r.FOUR_WEEKS = r.THREE_WEEKS = r.TWO_WEEKS = r.ONE_WEEK = r.THIRTY_DAYS = r.SEVEN_DAYS = r.FIVE_DAYS = r.THREE_DAYS = r.ONE_DAY = r.TWENTY_FOUR_HOURS = r.TWELVE_HOURS = r.SIX_HOURS = r.THREE_HOURS = r.ONE_HOUR = r.SIXTY_MINUTES = r.THIRTY_MINUTES = r.TEN_MINUTES = r.FIVE_MINUTES = r.ONE_MINUTE = r.SIXTY_SECONDS = r.THIRTY_SECONDS = r.TEN_SECONDS = r.FIVE_SECONDS = r.ONE_SECOND = void 0, r.ONE_SECOND = 1, r.FIVE_SECONDS = 5, r.TEN_SECONDS = 10, r.THIRTY_SECONDS = 30, r.SIXTY_SECONDS = 60, r.ONE_MINUTE = r.SIXTY_SECONDS, r.FIVE_MINUTES = r.ONE_MINUTE * 5, r.TEN_MINUTES = r.ONE_MINUTE * 10, r.THIRTY_MINUTES = r.ONE_MINUTE * 30, r.SIXTY_MINUTES = r.ONE_MINUTE * 60, r.ONE_HOUR = r.SIXTY_MINUTES, r.THREE_HOURS = r.ONE_HOUR * 3, r.SIX_HOURS = r.ONE_HOUR * 6, r.TWELVE_HOURS = r.ONE_HOUR * 12, r.TWENTY_FOUR_HOURS = r.ONE_HOUR * 24, r.ONE_DAY = r.TWENTY_FOUR_HOURS, r.THREE_DAYS = r.ONE_DAY * 3, r.FIVE_DAYS = r.ONE_DAY * 5, r.SEVEN_DAYS = r.ONE_DAY * 7, r.THIRTY_DAYS = r.ONE_DAY * 30, r.ONE_WEEK = r.SEVEN_DAYS, r.TWO_WEEKS = r.ONE_WEEK * 2, r.THREE_WEEKS = r.ONE_WEEK * 3, r.FOUR_WEEKS = r.ONE_WEEK * 4, r.ONE_YEAR = r.ONE_DAY * 365;
  }(Q5)), Q5;
}
var h9;
function SD() {
  return h9 || (h9 = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 });
    const e = $c;
    e.__exportStar(Kre(), r), e.__exportStar(Zre(), r);
  }(J5)), J5;
}
var f9;
function Jre() {
  if (f9)
    return jh;
  f9 = 1, Object.defineProperty(jh, "__esModule", { value: !0 }), jh.fromMiliseconds = jh.toMiliseconds = void 0;
  const r = SD();
  function e(n) {
    return n * r.ONE_THOUSAND;
  }
  jh.toMiliseconds = e;
  function t(n) {
    return Math.floor(n / r.ONE_THOUSAND);
  }
  return jh.fromMiliseconds = t, jh;
}
var d9;
function Qre() {
  return d9 || (d9 = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 });
    const e = $c;
    e.__exportStar(Gre(), r), e.__exportStar(Jre(), r);
  }(Z5)), Z5;
}
var cp = {}, p9;
function Yre() {
  if (p9)
    return cp;
  p9 = 1, Object.defineProperty(cp, "__esModule", { value: !0 }), cp.Watch = void 0;
  class r {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(t) {
      if (this.timestamps.has(t))
        throw new Error(`Watch already started for label: ${t}`);
      this.timestamps.set(t, { started: Date.now() });
    }
    stop(t) {
      const n = this.get(t);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${t}`);
      const i = Date.now() - n.started;
      this.timestamps.set(t, { started: n.started, elapsed: i });
    }
    get(t) {
      const n = this.timestamps.get(t);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${t}`);
      return n;
    }
    elapsed(t) {
      const n = this.get(t);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return cp.Watch = r, cp.default = r, cp;
}
var Y5 = {}, T1 = {}, g9;
function Xre() {
  if (g9)
    return T1;
  g9 = 1, Object.defineProperty(T1, "__esModule", { value: !0 }), T1.IWatch = void 0;
  class r {
  }
  return T1.IWatch = r, T1;
}
var m9;
function ene() {
  return m9 || (m9 = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), $c.__exportStar(Xre(), r);
  }(Y5)), Y5;
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  const e = $c;
  e.__exportStar(Qre(), r), e.__exportStar(Yre(), r), e.__exportStar(ene(), r), e.__exportStar(SD(), r);
})(ft);
var en = {};
Object.defineProperty(en, "__esModule", { value: !0 });
en.getLocalStorage = en.getLocalStorageOrThrow = en.getCrypto = en.getCryptoOrThrow = CD = en.getLocation = en.getLocationOrThrow = iC = en.getNavigator = en.getNavigatorOrThrow = nC = en.getDocument = en.getDocumentOrThrow = en.getFromWindowOrThrow = en.getFromWindow = void 0;
function Td(r) {
  let e;
  return typeof window < "u" && typeof window[r] < "u" && (e = window[r]), e;
}
en.getFromWindow = Td;
function Ug(r) {
  const e = Td(r);
  if (!e)
    throw new Error(`${r} is not defined in Window`);
  return e;
}
en.getFromWindowOrThrow = Ug;
function tne() {
  return Ug("document");
}
en.getDocumentOrThrow = tne;
function rne() {
  return Td("document");
}
var nC = en.getDocument = rne;
function nne() {
  return Ug("navigator");
}
en.getNavigatorOrThrow = nne;
function ine() {
  return Td("navigator");
}
var iC = en.getNavigator = ine;
function sne() {
  return Ug("location");
}
en.getLocationOrThrow = sne;
function one() {
  return Td("location");
}
var CD = en.getLocation = one;
function ane() {
  return Ug("crypto");
}
en.getCryptoOrThrow = ane;
function cne() {
  return Td("crypto");
}
en.getCrypto = cne;
function lne() {
  return Ug("localStorage");
}
en.getLocalStorageOrThrow = lne;
function une() {
  return Td("localStorage");
}
en.getLocalStorage = une;
var sC = {};
Object.defineProperty(sC, "__esModule", { value: !0 });
var AD = sC.getWindowMetadata = void 0;
const w9 = en;
function hne() {
  let r, e;
  try {
    r = w9.getDocumentOrThrow(), e = w9.getLocationOrThrow();
  } catch {
    return null;
  }
  function t() {
    const d = r.getElementsByTagName("link"), m = [];
    for (let y = 0; y < d.length; y++) {
      const b = d[y], I = b.getAttribute("rel");
      if (I && I.toLowerCase().indexOf("icon") > -1) {
        const k = b.getAttribute("href");
        if (k)
          if (k.toLowerCase().indexOf("https:") === -1 && k.toLowerCase().indexOf("http:") === -1 && k.indexOf("//") !== 0) {
            let R = e.protocol + "//" + e.host;
            if (k.indexOf("/") === 0)
              R += k;
            else {
              const T = e.pathname.split("/");
              T.pop();
              const $ = T.join("/");
              R += $ + "/" + k;
            }
            m.push(R);
          } else if (k.indexOf("//") === 0) {
            const R = e.protocol + k;
            m.push(R);
          } else
            m.push(k);
      }
    }
    return m;
  }
  function n(...d) {
    const m = r.getElementsByTagName("meta");
    for (let y = 0; y < m.length; y++) {
      const b = m[y], I = ["itemprop", "property", "name"].map((k) => b.getAttribute(k)).filter((k) => k ? d.includes(k) : !1);
      if (I.length && I) {
        const k = b.getAttribute("content");
        if (k)
          return k;
      }
    }
    return "";
  }
  function i() {
    let d = n("name", "og:site_name", "og:title", "twitter:title");
    return d || (d = r.title), d;
  }
  function s() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const o = i(), a = s(), c = e.origin, u = t();
  return {
    description: a,
    url: c,
    icons: u,
    name: o
  };
}
AD = sC.getWindowMetadata = hne;
var nw = {}, fne = (r) => encodeURIComponent(r).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), ID = "%[a-f0-9]{2}", y9 = new RegExp("(" + ID + ")|([^%]+?)", "gi"), v9 = new RegExp("(" + ID + ")+", "gi");
function J6(r, e) {
  try {
    return [decodeURIComponent(r.join(""))];
  } catch {
  }
  if (r.length === 1)
    return r;
  e = e || 1;
  var t = r.slice(0, e), n = r.slice(e);
  return Array.prototype.concat.call([], J6(t), J6(n));
}
function dne(r) {
  try {
    return decodeURIComponent(r);
  } catch {
    for (var e = r.match(y9) || [], t = 1; t < e.length; t++)
      r = J6(e, t).join(""), e = r.match(y9) || [];
    return r;
  }
}
function pne(r) {
  for (var e = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, t = v9.exec(r); t; ) {
    try {
      e[t[0]] = decodeURIComponent(t[0]);
    } catch {
      var n = dne(t[0]);
      n !== t[0] && (e[t[0]] = n);
    }
    t = v9.exec(r);
  }
  e["%C2"] = "";
  for (var i = Object.keys(e), s = 0; s < i.length; s++) {
    var o = i[s];
    r = r.replace(new RegExp(o, "g"), e[o]);
  }
  return r;
}
var gne = function(r) {
  if (typeof r != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof r + "`");
  try {
    return r = r.replace(/\+/g, " "), decodeURIComponent(r);
  } catch {
    return pne(r);
  }
}, mne = (r, e) => {
  if (!(typeof r == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [r];
  const t = r.indexOf(e);
  return t === -1 ? [r] : [
    r.slice(0, t),
    r.slice(t + e.length)
  ];
}, wne = function(r, e) {
  for (var t = {}, n = Object.keys(r), i = Array.isArray(e), s = 0; s < n.length; s++) {
    var o = n[s], a = r[o];
    (i ? e.indexOf(o) !== -1 : e(o, a, r)) && (t[o] = a);
  }
  return t;
};
(function(r) {
  const e = fne, t = gne, n = mne, i = wne, s = (T) => T == null, o = Symbol("encodeFragmentIdentifier");
  function a(T) {
    switch (T.arrayFormat) {
      case "index":
        return ($) => (D, L) => {
          const P = D.length;
          return L === void 0 || T.skipNull && L === null || T.skipEmptyString && L === "" ? D : L === null ? [...D, [f($, T), "[", P, "]"].join("")] : [
            ...D,
            [f($, T), "[", f(P, T), "]=", f(L, T)].join("")
          ];
        };
      case "bracket":
        return ($) => (D, L) => L === void 0 || T.skipNull && L === null || T.skipEmptyString && L === "" ? D : L === null ? [...D, [f($, T), "[]"].join("")] : [...D, [f($, T), "[]=", f(L, T)].join("")];
      case "colon-list-separator":
        return ($) => (D, L) => L === void 0 || T.skipNull && L === null || T.skipEmptyString && L === "" ? D : L === null ? [...D, [f($, T), ":list="].join("")] : [...D, [f($, T), ":list=", f(L, T)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const $ = T.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (D) => (L, P) => P === void 0 || T.skipNull && P === null || T.skipEmptyString && P === "" ? L : (P = P === null ? "" : P, L.length === 0 ? [[f(D, T), $, f(P, T)].join("")] : [[L, f(P, T)].join(T.arrayFormatSeparator)]);
      }
      default:
        return ($) => (D, L) => L === void 0 || T.skipNull && L === null || T.skipEmptyString && L === "" ? D : L === null ? [...D, f($, T)] : [...D, [f($, T), "=", f(L, T)].join("")];
    }
  }
  function c(T) {
    let $;
    switch (T.arrayFormat) {
      case "index":
        return (D, L, P) => {
          if ($ = /\[(\d*)\]$/.exec(D), D = D.replace(/\[\d*\]$/, ""), !$) {
            P[D] = L;
            return;
          }
          P[D] === void 0 && (P[D] = {}), P[D][$[1]] = L;
        };
      case "bracket":
        return (D, L, P) => {
          if ($ = /(\[\])$/.exec(D), D = D.replace(/\[\]$/, ""), !$) {
            P[D] = L;
            return;
          }
          if (P[D] === void 0) {
            P[D] = [L];
            return;
          }
          P[D] = [].concat(P[D], L);
        };
      case "colon-list-separator":
        return (D, L, P) => {
          if ($ = /(:list)$/.exec(D), D = D.replace(/:list$/, ""), !$) {
            P[D] = L;
            return;
          }
          if (P[D] === void 0) {
            P[D] = [L];
            return;
          }
          P[D] = [].concat(P[D], L);
        };
      case "comma":
      case "separator":
        return (D, L, P) => {
          const v = typeof L == "string" && L.includes(T.arrayFormatSeparator), F = typeof L == "string" && !v && d(L, T).includes(T.arrayFormatSeparator);
          L = F ? d(L, T) : L;
          const X = v || F ? L.split(T.arrayFormatSeparator).map((te) => d(te, T)) : L === null ? L : d(L, T);
          P[D] = X;
        };
      case "bracket-separator":
        return (D, L, P) => {
          const v = /(\[\])$/.test(D);
          if (D = D.replace(/\[\]$/, ""), !v) {
            P[D] = L && d(L, T);
            return;
          }
          const F = L === null ? [] : L.split(T.arrayFormatSeparator).map((X) => d(X, T));
          if (P[D] === void 0) {
            P[D] = F;
            return;
          }
          P[D] = [].concat(P[D], F);
        };
      default:
        return (D, L, P) => {
          if (P[D] === void 0) {
            P[D] = L;
            return;
          }
          P[D] = [].concat(P[D], L);
        };
    }
  }
  function u(T) {
    if (typeof T != "string" || T.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function f(T, $) {
    return $.encode ? $.strict ? e(T) : encodeURIComponent(T) : T;
  }
  function d(T, $) {
    return $.decode ? t(T) : T;
  }
  function m(T) {
    return Array.isArray(T) ? T.sort() : typeof T == "object" ? m(Object.keys(T)).sort(($, D) => Number($) - Number(D)).map(($) => T[$]) : T;
  }
  function y(T) {
    const $ = T.indexOf("#");
    return $ !== -1 && (T = T.slice(0, $)), T;
  }
  function b(T) {
    let $ = "";
    const D = T.indexOf("#");
    return D !== -1 && ($ = T.slice(D)), $;
  }
  function I(T) {
    T = y(T);
    const $ = T.indexOf("?");
    return $ === -1 ? "" : T.slice($ + 1);
  }
  function k(T, $) {
    return $.parseNumbers && !Number.isNaN(Number(T)) && typeof T == "string" && T.trim() !== "" ? T = Number(T) : $.parseBooleans && T !== null && (T.toLowerCase() === "true" || T.toLowerCase() === "false") && (T = T.toLowerCase() === "true"), T;
  }
  function R(T, $) {
    $ = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, $), u($.arrayFormatSeparator);
    const D = c($), L = /* @__PURE__ */ Object.create(null);
    if (typeof T != "string" || (T = T.trim().replace(/^[?#&]/, ""), !T))
      return L;
    for (const P of T.split("&")) {
      if (P === "")
        continue;
      let [v, F] = n($.decode ? P.replace(/\+/g, " ") : P, "=");
      F = F === void 0 ? null : ["comma", "separator", "bracket-separator"].includes($.arrayFormat) ? F : d(F, $), D(d(v, $), F, L);
    }
    for (const P of Object.keys(L)) {
      const v = L[P];
      if (typeof v == "object" && v !== null)
        for (const F of Object.keys(v))
          v[F] = k(v[F], $);
      else
        L[P] = k(v, $);
    }
    return $.sort === !1 ? L : ($.sort === !0 ? Object.keys(L).sort() : Object.keys(L).sort($.sort)).reduce((P, v) => {
      const F = L[v];
      return F && typeof F == "object" && !Array.isArray(F) ? P[v] = m(F) : P[v] = F, P;
    }, /* @__PURE__ */ Object.create(null));
  }
  r.extract = I, r.parse = R, r.stringify = (T, $) => {
    if (!T)
      return "";
    $ = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, $), u($.arrayFormatSeparator);
    const D = (F) => $.skipNull && s(T[F]) || $.skipEmptyString && T[F] === "", L = a($), P = {};
    for (const F of Object.keys(T))
      D(F) || (P[F] = T[F]);
    const v = Object.keys(P);
    return $.sort !== !1 && v.sort($.sort), v.map((F) => {
      const X = T[F];
      return X === void 0 ? "" : X === null ? f(F, $) : Array.isArray(X) ? X.length === 0 && $.arrayFormat === "bracket-separator" ? f(F, $) + "[]" : X.reduce(L(F), []).join("&") : f(F, $) + "=" + f(X, $);
    }).filter((F) => F.length > 0).join("&");
  }, r.parseUrl = (T, $) => {
    $ = Object.assign({
      decode: !0
    }, $);
    const [D, L] = n(T, "#");
    return Object.assign(
      {
        url: D.split("?")[0] || "",
        query: R(I(T), $)
      },
      $ && $.parseFragmentIdentifier && L ? { fragmentIdentifier: d(L, $) } : {}
    );
  }, r.stringifyUrl = (T, $) => {
    $ = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, $);
    const D = y(T.url).split("?")[0] || "", L = r.extract(T.url), P = r.parse(L, { sort: !1 }), v = Object.assign(P, T.query);
    let F = r.stringify(v, $);
    F && (F = `?${F}`);
    let X = b(T.url);
    return T.fragmentIdentifier && (X = `#${$[o] ? f(T.fragmentIdentifier, $) : T.fragmentIdentifier}`), `${D}${F}${X}`;
  }, r.pick = (T, $, D) => {
    D = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, D);
    const { url: L, query: P, fragmentIdentifier: v } = r.parseUrl(T, D);
    return r.stringifyUrl({
      url: L,
      query: i(P, $),
      fragmentIdentifier: v
    }, D);
  }, r.exclude = (T, $, D) => {
    const L = Array.isArray($) ? (P) => !$.includes(P) : (P, v) => !$(P, v);
    return r.pick(T, L, D);
  };
})(nw);
const yne = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
}, vne = ":";
function bne(r) {
  const [e, t] = r.split(vne);
  return { namespace: e, reference: t };
}
function _ne(r, e = []) {
  const t = [];
  return Object.keys(r).forEach((n) => {
    if (e.length && !e.includes(n))
      return;
    const i = r[n];
    t.push(...i.accounts);
  }), t;
}
function RD(r, e) {
  return r.includes(":") ? [r] : e.chains || [];
}
const TD = "base10", as = "base16", Q6 = "base64pad", oC = "utf8", OD = 0, Od = 1, Ene = 0, b9 = 1, Y6 = 12, aC = 32;
function xne() {
  const r = tC.generateKeyPair();
  return { privateKey: us(r.secretKey, as), publicKey: us(r.publicKey, as) };
}
function X6() {
  const r = Fg.randomBytes(aC);
  return us(r, as);
}
function Sne(r, e) {
  const t = tC.sharedKey(Ms(r, as), Ms(e, as), !0), n = new lte(z_.SHA256, t).expand(aC);
  return us(n, as);
}
function Cne(r) {
  const e = z_.hash(Ms(r, as));
  return us(e, as);
}
function qp(r) {
  const e = z_.hash(Ms(r, oC));
  return us(e, as);
}
function Ane(r) {
  return Ms(`${r}`, TD);
}
function ay(r) {
  return Number(us(r, TD));
}
function Ine(r) {
  const e = Ane(typeof r.type < "u" ? r.type : OD);
  if (ay(e) === Od && typeof r.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof r.senderPublicKey < "u" ? Ms(r.senderPublicKey, as) : void 0, n = typeof r.iv < "u" ? Ms(r.iv, as) : Fg.randomBytes(Y6), i = new XS.ChaCha20Poly1305(Ms(r.symKey, as)).seal(n, Ms(r.message, oC));
  return Tne({ type: e, sealed: i, iv: n, senderPublicKey: t });
}
function Rne(r) {
  const e = new XS.ChaCha20Poly1305(Ms(r.symKey, as)), { sealed: t, iv: n } = T2(r.encoded), i = e.open(n, t);
  if (i === null)
    throw new Error("Failed to decrypt");
  return us(i, oC);
}
function Tne(r) {
  if (ay(r.type) === Od) {
    if (typeof r.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return us(q6([r.type, r.senderPublicKey, r.iv, r.sealed]), Q6);
  }
  return us(q6([r.type, r.iv, r.sealed]), Q6);
}
function T2(r) {
  const e = Ms(r, Q6), t = e.slice(Ene, b9), n = b9;
  if (ay(t) === Od) {
    const a = n + aC, c = a + Y6, u = e.slice(n, a), f = e.slice(a, c), d = e.slice(c);
    return { type: t, sealed: d, iv: f, senderPublicKey: u };
  }
  const i = n + Y6, s = e.slice(n, i), o = e.slice(i);
  return { type: t, sealed: o, iv: s };
}
function One(r, e) {
  const t = T2(r);
  return ND({ type: ay(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? us(t.senderPublicKey, as) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function ND(r) {
  const e = (r == null ? void 0 : r.type) || OD;
  if (e === Od) {
    if (typeof (r == null ? void 0 : r.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (r == null ? void 0 : r.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: r == null ? void 0 : r.senderPublicKey, receiverPublicKey: r == null ? void 0 : r.receiverPublicKey };
}
function _9(r) {
  return r.type === Od && typeof r.senderPublicKey == "string" && typeof r.receiverPublicKey == "string";
}
var Nne = Object.defineProperty, E9 = Object.getOwnPropertySymbols, Pne = Object.prototype.hasOwnProperty, Mne = Object.prototype.propertyIsEnumerable, x9 = (r, e, t) => e in r ? Nne(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, S9 = (r, e) => {
  for (var t in e || (e = {}))
    Pne.call(e, t) && x9(r, t, e[t]);
  if (E9)
    for (var t of E9(e))
      Mne.call(e, t) && x9(r, t, e[t]);
  return r;
};
const Dne = "ReactNative", eo = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, kne = "js";
function cC() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function jg() {
  return !nC() && !!iC() && navigator.product === Dne;
}
function Wg() {
  return !cC() && !!iC() && !!nC();
}
function cy() {
  return jg() ? eo.reactNative : cC() ? eo.node : Wg() ? eo.browser : eo.unknown;
}
function $ne() {
  var r;
  try {
    return jg() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (r = global.Application) == null ? void 0 : r.applicationId : void 0;
  } catch {
    return;
  }
}
function Lne(r, e) {
  let t = nw.parse(r);
  return t = S9(S9({}, t), e), r = nw.stringify(t), r;
}
function Bne() {
  return AD() || { name: "", description: "", url: "", icons: [""] };
}
function Fne() {
  if (cy() === eo.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: n } = global.Platform;
    return [t, n].join("-");
  }
  const r = xre();
  if (r === null)
    return "unknown";
  const e = r.os ? r.os.replace(" ", "").toLowerCase() : "unknown";
  return r.type === "browser" ? [e, r.name, r.version].join("-") : [e, r.version].join("-");
}
function Une() {
  var r;
  const e = cy();
  return e === eo.browser ? [e, ((r = CD()) == null ? void 0 : r.host) || "unknown"].join(":") : e;
}
function jne(r, e, t) {
  const n = Fne(), i = Une();
  return [[r, e].join("-"), [kne, t].join("-"), n, i].join("/");
}
function Wne({ protocol: r, version: e, relayUrl: t, sdkVersion: n, auth: i, projectId: s, useOnCloseEvent: o, bundleId: a }) {
  const c = t.split("?"), u = jne(r, e, n), f = { auth: i, ua: u, projectId: s, useOnCloseEvent: o || void 0, origin: a || void 0 }, d = Lne(c[1] || "", f);
  return c[0] + "?" + d;
}
function af(r, e) {
  return r.filter((t) => e.includes(t)).length === r.length;
}
function PD(r) {
  return Object.fromEntries(r.entries());
}
function MD(r) {
  return new Map(Object.entries(r));
}
function Sp(r = ft.FIVE_MINUTES, e) {
  const t = ft.toMiliseconds(r || ft.FIVE_MINUTES);
  let n, i, s;
  return { resolve: (o) => {
    s && n && (clearTimeout(s), n(o));
  }, reject: (o) => {
    s && i && (clearTimeout(s), i(o));
  }, done: () => new Promise((o, a) => {
    s = setTimeout(() => {
      a(new Error(e));
    }, t), n = o, i = a;
  }) };
}
function iw(r, e, t) {
  return new Promise(async (n, i) => {
    const s = setTimeout(() => i(new Error(t)), e);
    try {
      const o = await r;
      n(o);
    } catch (o) {
      i(o);
    }
    clearTimeout(s);
  });
}
function DD(r, e) {
  if (typeof e == "string" && e.startsWith(`${r}:`))
    return e;
  if (r.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (r.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${r}`);
}
function Hne(r) {
  return DD("topic", r);
}
function zne(r) {
  return DD("id", r);
}
function kD(r) {
  const [e, t] = r.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof t == "string")
    n.topic = t;
  else if (e === "id" && Number.isInteger(Number(t)))
    n.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);
  return n;
}
function ba(r, e) {
  return ft.fromMiliseconds((e || Date.now()) + ft.toMiliseconds(r));
}
function hu(r) {
  return Date.now() >= ft.toMiliseconds(r);
}
function zn(r, e) {
  return `${r}${e ? `:${e}` : ""}`;
}
function X5(r = [], e = []) {
  return [.../* @__PURE__ */ new Set([...r, ...e])];
}
async function Vne({ id: r, topic: e, wcDeepLink: t }) {
  try {
    if (!t)
      return;
    const n = typeof t == "string" ? JSON.parse(t) : t;
    let i = n == null ? void 0 : n.href;
    if (typeof i != "string")
      return;
    i.endsWith("/") && (i = i.slice(0, -1));
    const s = `${i}/wc?requestId=${r}&sessionTopic=${e}`, o = cy();
    o === eo.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : o === eo.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (n) {
    console.error(n);
  }
}
async function qne(r, e) {
  try {
    return await r.getItem(e) || (Wg() ? localStorage.getItem(e) : void 0);
  } catch (t) {
    console.error(t);
  }
}
const Gne = "irn";
function ex(r) {
  return (r == null ? void 0 : r.relay) || { protocol: Gne };
}
function Ob(r) {
  const e = yne[r];
  if (typeof e > "u")
    throw new Error(`Relay Protocol not supported: ${r}`);
  return e;
}
var Kne = Object.defineProperty, C9 = Object.getOwnPropertySymbols, Zne = Object.prototype.hasOwnProperty, Jne = Object.prototype.propertyIsEnumerable, A9 = (r, e, t) => e in r ? Kne(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Qne = (r, e) => {
  for (var t in e || (e = {}))
    Zne.call(e, t) && A9(r, t, e[t]);
  if (C9)
    for (var t of C9(e))
      Jne.call(e, t) && A9(r, t, e[t]);
  return r;
};
function Yne(r, e = "-") {
  const t = {}, n = "relay" + e;
  return Object.keys(r).forEach((i) => {
    if (i.startsWith(n)) {
      const s = i.replace(n, ""), o = r[i];
      t[s] = o;
    }
  }), t;
}
function I9(r) {
  r = r.includes("wc://") ? r.replace("wc://", "") : r, r = r.includes("wc:") ? r.replace("wc:", "") : r;
  const e = r.indexOf(":"), t = r.indexOf("?") !== -1 ? r.indexOf("?") : void 0, n = r.substring(0, e), i = r.substring(e + 1, t).split("@"), s = typeof t < "u" ? r.substring(t) : "", o = nw.parse(s);
  return { protocol: n, topic: Xne(i[0]), version: parseInt(i[1], 10), symKey: o.symKey, relay: Yne(o) };
}
function Xne(r) {
  return r.startsWith("//") ? r.substring(2) : r;
}
function eie(r, e = "-") {
  const t = "relay", n = {};
  return Object.keys(r).forEach((i) => {
    const s = t + e + i;
    r[i] && (n[s] = r[i]);
  }), n;
}
function tie(r) {
  return `${r.protocol}:${r.topic}@${r.version}?` + nw.stringify(Qne({ symKey: r.symKey }, eie(r.relay)));
}
function Hg(r) {
  const e = [];
  return r.forEach((t) => {
    const [n, i] = t.split(":");
    e.push(`${n}:${i}`);
  }), e;
}
function rie(r) {
  const e = [];
  return Object.values(r).forEach((t) => {
    e.push(...Hg(t.accounts));
  }), e;
}
function nie(r, e) {
  const t = [];
  return Object.values(r).forEach((n) => {
    Hg(n.accounts).includes(e) && t.push(...n.methods);
  }), t;
}
function iie(r, e) {
  const t = [];
  return Object.values(r).forEach((n) => {
    Hg(n.accounts).includes(e) && t.push(...n.events);
  }), t;
}
function sie(r, e) {
  const t = Nb(r, e);
  if (t)
    throw new Error(t.message);
  const n = {};
  for (const [i, s] of Object.entries(r))
    n[i] = { methods: s.methods, events: s.events, chains: s.accounts.map((o) => `${o.split(":")[0]}:${o.split(":")[1]}`) };
  return n;
}
function lC(r) {
  return r.includes(":");
}
function K1(r) {
  return lC(r) ? r.split(":")[0] : r;
}
const oie = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, aie = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function He(r, e) {
  const { message: t, code: n } = aie[r];
  return { message: e ? `${t} ${e}` : t, code: n };
}
function Cn(r, e) {
  const { message: t, code: n } = oie[r];
  return { message: e ? `${t} ${e}` : t, code: n };
}
function Nc(r, e) {
  return Array.isArray(r) ? typeof e < "u" && r.length ? r.every(e) : !0 : !1;
}
function Gp(r) {
  return Object.getPrototypeOf(r) === Object.prototype && Object.keys(r).length;
}
function ts(r) {
  return typeof r > "u";
}
function ci(r, e) {
  return e && ts(r) ? !0 : typeof r == "string" && !!r.trim().length;
}
function uC(r, e) {
  return e && ts(r) ? !0 : typeof r == "number" && !isNaN(r);
}
function cie(r, e) {
  const { requiredNamespaces: t } = e, n = Object.keys(r.namespaces), i = Object.keys(t);
  let s = !0;
  return af(i, n) ? (n.forEach((o) => {
    const { accounts: a, methods: c, events: u } = r.namespaces[o], f = Hg(a), d = t[o];
    (!af(RD(o, d), f) || !af(d.methods, c) || !af(d.events, u)) && (s = !1);
  }), s) : !1;
}
function O2(r) {
  return ci(r, !1) && r.includes(":") ? r.split(":").length === 2 : !1;
}
function lie(r) {
  if (ci(r, !1) && r.includes(":")) {
    const e = r.split(":");
    if (e.length === 3) {
      const t = e[0] + ":" + e[1];
      return !!e[2] && O2(t);
    }
  }
  return !1;
}
function uie(r) {
  if (ci(r, !1))
    try {
      return typeof new URL(r) < "u";
    } catch {
      return !1;
    }
  return !1;
}
function hie(r) {
  var e;
  return (e = r == null ? void 0 : r.proposer) == null ? void 0 : e.publicKey;
}
function fie(r) {
  return r == null ? void 0 : r.topic;
}
function die(r, e) {
  let t = null;
  return ci(r == null ? void 0 : r.publicKey, !1) || (t = He("MISSING_OR_INVALID", `${e} controller public key should be a string`)), t;
}
function R9(r) {
  let e = !0;
  return Nc(r) ? r.length && (e = r.every((t) => ci(t, !1))) : e = !1, e;
}
function pie(r, e, t) {
  let n = null;
  return Nc(e) && e.length ? e.forEach((i) => {
    n || O2(i) || (n = Cn("UNSUPPORTED_CHAINS", `${t}, chain ${i} should be a string and conform to "namespace:chainId" format`));
  }) : O2(r) || (n = Cn("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function gie(r, e, t) {
  let n = null;
  return Object.entries(r).forEach(([i, s]) => {
    if (n)
      return;
    const o = pie(i, RD(i, s), `${e} ${t}`);
    o && (n = o);
  }), n;
}
function mie(r, e) {
  let t = null;
  return Nc(r) ? r.forEach((n) => {
    t || lie(n) || (t = Cn("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = Cn("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function wie(r, e) {
  let t = null;
  return Object.values(r).forEach((n) => {
    if (t)
      return;
    const i = mie(n == null ? void 0 : n.accounts, `${e} namespace`);
    i && (t = i);
  }), t;
}
function yie(r, e) {
  let t = null;
  return R9(r == null ? void 0 : r.methods) ? R9(r == null ? void 0 : r.events) || (t = Cn("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : t = Cn("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), t;
}
function $D(r, e) {
  let t = null;
  return Object.values(r).forEach((n) => {
    if (t)
      return;
    const i = yie(n, `${e}, namespace`);
    i && (t = i);
  }), t;
}
function vie(r, e, t) {
  let n = null;
  if (r && Gp(r)) {
    const i = $D(r, e);
    i && (n = i);
    const s = gie(r, e, t);
    s && (n = s);
  } else
    n = He("MISSING_OR_INVALID", `${e}, ${t} should be an object with data`);
  return n;
}
function Nb(r, e) {
  let t = null;
  if (r && Gp(r)) {
    const n = $D(r, e);
    n && (t = n);
    const i = wie(r, e);
    i && (t = i);
  } else
    t = He("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return t;
}
function LD(r) {
  return ci(r.protocol, !0);
}
function bie(r, e) {
  let t = !1;
  return e && !r ? t = !0 : r && Nc(r) && r.length && r.forEach((n) => {
    t = LD(n);
  }), t;
}
function _ie(r) {
  return typeof r == "number";
}
function As(r) {
  return typeof r < "u" && typeof r !== null;
}
function Eie(r) {
  return !(!r || typeof r != "object" || !r.code || !uC(r.code, !1) || !r.message || !ci(r.message, !1));
}
function xie(r) {
  return !(ts(r) || !ci(r.method, !1));
}
function Sie(r) {
  return !(ts(r) || ts(r.result) && ts(r.error) || !uC(r.id, !1) || !ci(r.jsonrpc, !1));
}
function Cie(r) {
  return !(ts(r) || !ci(r.name, !1));
}
function T9(r, e) {
  return !(!O2(e) || !rie(r).includes(e));
}
function Aie(r, e, t) {
  return ci(t, !1) ? nie(r, e).includes(t) : !1;
}
function Iie(r, e, t) {
  return ci(t, !1) ? iie(r, e).includes(t) : !1;
}
function O9(r, e, t) {
  let n = null;
  const i = Rie(r), s = Tie(e), o = Object.keys(i), a = Object.keys(s), c = N9(Object.keys(r)), u = N9(Object.keys(e)), f = c.filter((d) => !u.includes(d));
  return f.length && (n = He("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${f.toString()}
      Received: ${Object.keys(e).toString()}`)), af(o, a) || (n = He("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((d) => {
    if (!d.includes(":") || n)
      return;
    const m = Hg(e[d].accounts);
    m.includes(d) || (n = He("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${d}
        Required: ${d}
        Approved: ${m.toString()}`));
  }), o.forEach((d) => {
    n || (af(i[d].methods, s[d].methods) ? af(i[d].events, s[d].events) || (n = He("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${d}`)) : n = He("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${d}`));
  }), n;
}
function Rie(r) {
  const e = {};
  return Object.keys(r).forEach((t) => {
    var n;
    t.includes(":") ? e[t] = r[t] : (n = r[t].chains) == null || n.forEach((i) => {
      e[i] = { methods: r[t].methods, events: r[t].events };
    });
  }), e;
}
function N9(r) {
  return [...new Set(r.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Tie(r) {
  const e = {};
  return Object.keys(r).forEach((t) => {
    if (t.includes(":"))
      e[t] = r[t];
    else {
      const n = Hg(r[t].accounts);
      n == null || n.forEach((i) => {
        e[i] = { accounts: r[t].accounts.filter((s) => s.includes(`${i}:`)), methods: r[t].methods, events: r[t].events };
      });
    }
  }), e;
}
function Oie(r, e) {
  return uC(r, !1) && r <= e.max && r >= e.min;
}
function P9() {
  const r = cy();
  return new Promise((e) => {
    switch (r) {
      case eo.browser:
        e(Nie());
        break;
      case eo.reactNative:
        e(Pie());
        break;
      case eo.node:
        e(Mie());
        break;
      default:
        e(!0);
    }
  });
}
function Nie() {
  return Wg() && (navigator == null ? void 0 : navigator.onLine);
}
async function Pie() {
  if (jg() && typeof global < "u" && global != null && global.NetInfo) {
    const r = await (global == null ? void 0 : global.NetInfo.fetch());
    return r == null ? void 0 : r.isConnected;
  }
  return !0;
}
function Mie() {
  return !0;
}
function Die(r) {
  switch (cy()) {
    case eo.browser:
      kie(r);
      break;
    case eo.reactNative:
      $ie(r);
      break;
  }
}
function kie(r) {
  !jg() && Wg() && (window.addEventListener("online", () => r(!0)), window.addEventListener("offline", () => r(!1)));
}
function $ie(r) {
  jg() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => r(e == null ? void 0 : e.isConnected)));
}
const e4 = {};
let Jv = class {
  static get(e) {
    return e4[e];
  }
  static set(e, t) {
    e4[e] = t;
  }
  static delete(e) {
    delete e4[e];
  }
};
const Lie = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Bie = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, Fie = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function Uie(r, e) {
  if (r === "__proto__" || r === "constructor" && e && typeof e == "object" && "prototype" in e) {
    jie(r);
    return;
  }
  return e;
}
function jie(r) {
  console.warn(`[destr] Dropping "${r}" key to prevent prototype pollution.`);
}
function Qv(r, e = {}) {
  if (typeof r != "string")
    return r;
  const t = r.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    r[0] === '"' && r.at(-1) === '"' && !r.includes("\\")
  )
    return t.slice(1, -1);
  if (t.length <= 9) {
    const n = t.toLowerCase();
    if (n === "true")
      return !0;
    if (n === "false")
      return !1;
    if (n === "undefined")
      return;
    if (n === "null")
      return null;
    if (n === "nan")
      return Number.NaN;
    if (n === "infinity")
      return Number.POSITIVE_INFINITY;
    if (n === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!Fie.test(r)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return r;
  }
  try {
    if (Lie.test(r) || Bie.test(r)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(r, Uie);
    }
    return JSON.parse(r);
  } catch (n) {
    if (e.strict)
      throw n;
    return r;
  }
}
function Wie(r) {
  return !r || typeof r.then != "function" ? Promise.resolve(r) : r;
}
function ti(r, ...e) {
  try {
    return Wie(r(...e));
  } catch (t) {
    return Promise.reject(t);
  }
}
function Hie(r) {
  const e = typeof r;
  return r === null || e !== "object" && e !== "function";
}
function zie(r) {
  const e = Object.getPrototypeOf(r);
  return !e || e.isPrototypeOf(Object);
}
function Pb(r) {
  if (Hie(r))
    return String(r);
  if (zie(r) || Array.isArray(r))
    return JSON.stringify(r);
  if (typeof r.toJSON == "function")
    return Pb(r.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function BD() {
  if (typeof Buffer === void 0)
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const tx = "base64:";
function Vie(r) {
  if (typeof r == "string")
    return r;
  BD();
  const e = Buffer.from(r).toString("base64");
  return tx + e;
}
function qie(r) {
  return typeof r != "string" || !r.startsWith(tx) ? r : (BD(), Buffer.from(r.slice(tx.length), "base64"));
}
function Ss(r) {
  return r ? r.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function Gie(...r) {
  return Ss(r.join(":"));
}
function Yv(r) {
  return r = Ss(r), r ? r + ":" : "";
}
const Kie = "memory", Zie = () => {
  const r = /* @__PURE__ */ new Map();
  return {
    name: Kie,
    options: {},
    hasItem(e) {
      return r.has(e);
    },
    getItem(e) {
      return r.get(e) ?? null;
    },
    getItemRaw(e) {
      return r.get(e) ?? null;
    },
    setItem(e, t) {
      r.set(e, t);
    },
    setItemRaw(e, t) {
      r.set(e, t);
    },
    removeItem(e) {
      r.delete(e);
    },
    getKeys() {
      return Array.from(r.keys());
    },
    clear() {
      r.clear();
    },
    dispose() {
      r.clear();
    }
  };
};
function Jie(r = {}) {
  const e = {
    mounts: { "": r.driver || Zie() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, t = (u) => {
    for (const f of e.mountpoints)
      if (u.startsWith(f))
        return {
          base: f,
          relativeKey: u.slice(f.length),
          driver: e.mounts[f]
        };
    return {
      base: "",
      relativeKey: u,
      driver: e.mounts[""]
    };
  }, n = (u, f) => e.mountpoints.filter(
    (d) => d.startsWith(u) || f && u.startsWith(d)
  ).map((d) => ({
    relativeBase: u.length > d.length ? u.slice(d.length) : void 0,
    mountpoint: d,
    driver: e.mounts[d]
  })), i = (u, f) => {
    if (e.watching) {
      f = Ss(f);
      for (const d of e.watchListeners)
        d(u, f);
    }
  }, s = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const u in e.mounts)
        e.unwatch[u] = await M9(
          e.mounts[u],
          i,
          u
        );
    }
  }, o = async () => {
    if (e.watching) {
      for (const u in e.unwatch)
        await e.unwatch[u]();
      e.unwatch = {}, e.watching = !1;
    }
  }, a = (u, f, d) => {
    const m = /* @__PURE__ */ new Map(), y = (b) => {
      let I = m.get(b.base);
      return I || (I = {
        driver: b.driver,
        base: b.base,
        items: []
      }, m.set(b.base, I)), I;
    };
    for (const b of u) {
      const I = typeof b == "string", k = Ss(I ? b : b.key), R = I ? void 0 : b.value, T = I || !b.options ? f : { ...f, ...b.options }, $ = t(k);
      y($).items.push({
        key: k,
        value: R,
        relativeKey: $.relativeKey,
        options: T
      });
    }
    return Promise.all([...m.values()].map((b) => d(b))).then(
      (b) => b.flat()
    );
  }, c = {
    // Item
    hasItem(u, f = {}) {
      u = Ss(u);
      const { relativeKey: d, driver: m } = t(u);
      return ti(m.hasItem, d, f);
    },
    getItem(u, f = {}) {
      u = Ss(u);
      const { relativeKey: d, driver: m } = t(u);
      return ti(m.getItem, d, f).then(
        (y) => Qv(y)
      );
    },
    getItems(u, f) {
      return a(u, f, (d) => d.driver.getItems ? ti(
        d.driver.getItems,
        d.items.map((m) => ({
          key: m.relativeKey,
          options: m.options
        })),
        f
      ).then(
        (m) => m.map((y) => ({
          key: Gie(d.base, y.key),
          value: Qv(y.value)
        }))
      ) : Promise.all(
        d.items.map((m) => ti(
          d.driver.getItem,
          m.relativeKey,
          m.options
        ).then((y) => ({
          key: m.key,
          value: Qv(y)
        })))
      ));
    },
    getItemRaw(u, f = {}) {
      u = Ss(u);
      const { relativeKey: d, driver: m } = t(u);
      return m.getItemRaw ? ti(m.getItemRaw, d, f) : ti(m.getItem, d, f).then(
        (y) => qie(y)
      );
    },
    async setItem(u, f, d = {}) {
      if (f === void 0)
        return c.removeItem(u);
      u = Ss(u);
      const { relativeKey: m, driver: y } = t(u);
      y.setItem && (await ti(y.setItem, m, Pb(f), d), y.watch || i("update", u));
    },
    async setItems(u, f) {
      await a(u, f, async (d) => {
        d.driver.setItems && await ti(
          d.driver.setItems,
          d.items.map((m) => ({
            key: m.relativeKey,
            value: Pb(m.value),
            options: m.options
          })),
          f
        ), d.driver.setItem && await Promise.all(
          d.items.map((m) => ti(
            d.driver.setItem,
            m.relativeKey,
            Pb(m.value),
            m.options
          ))
        );
      });
    },
    async setItemRaw(u, f, d = {}) {
      if (f === void 0)
        return c.removeItem(u, d);
      u = Ss(u);
      const { relativeKey: m, driver: y } = t(u);
      if (y.setItemRaw)
        await ti(y.setItemRaw, m, f, d);
      else if (y.setItem)
        await ti(y.setItem, m, Vie(f), d);
      else
        return;
      y.watch || i("update", u);
    },
    async removeItem(u, f = {}) {
      typeof f == "boolean" && (f = { removeMeta: f }), u = Ss(u);
      const { relativeKey: d, driver: m } = t(u);
      m.removeItem && (await ti(m.removeItem, d, f), (f.removeMeta || f.removeMata) && await ti(m.removeItem, d + "$", f), m.watch || i("remove", u));
    },
    // Meta
    async getMeta(u, f = {}) {
      typeof f == "boolean" && (f = { nativeOnly: f }), u = Ss(u);
      const { relativeKey: d, driver: m } = t(u), y = /* @__PURE__ */ Object.create(null);
      if (m.getMeta && Object.assign(y, await ti(m.getMeta, d, f)), !f.nativeOnly) {
        const b = await ti(
          m.getItem,
          d + "$",
          f
        ).then((I) => Qv(I));
        b && typeof b == "object" && (typeof b.atime == "string" && (b.atime = new Date(b.atime)), typeof b.mtime == "string" && (b.mtime = new Date(b.mtime)), Object.assign(y, b));
      }
      return y;
    },
    setMeta(u, f, d = {}) {
      return this.setItem(u + "$", f, d);
    },
    removeMeta(u, f = {}) {
      return this.removeItem(u + "$", f);
    },
    // Keys
    async getKeys(u, f = {}) {
      u = Yv(u);
      const d = n(u, !0);
      let m = [];
      const y = [];
      for (const b of d) {
        const k = (await ti(
          b.driver.getKeys,
          b.relativeBase,
          f
        )).map((R) => b.mountpoint + Ss(R)).filter((R) => !m.some((T) => R.startsWith(T)));
        y.push(...k), m = [
          b.mountpoint,
          ...m.filter((R) => !R.startsWith(b.mountpoint))
        ];
      }
      return u ? y.filter((b) => b.startsWith(u) && !b.endsWith("$")) : y.filter((b) => !b.endsWith("$"));
    },
    // Utils
    async clear(u, f = {}) {
      u = Yv(u), await Promise.all(
        n(u, !1).map(async (d) => {
          if (d.driver.clear)
            return ti(d.driver.clear, d.relativeBase, f);
          if (d.driver.removeItem) {
            const m = await d.driver.getKeys(d.relativeBase || "", f);
            return Promise.all(
              m.map((y) => d.driver.removeItem(y, f))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((u) => D9(u))
      );
    },
    async watch(u) {
      return await s(), e.watchListeners.push(u), async () => {
        e.watchListeners = e.watchListeners.filter(
          (f) => f !== u
        ), e.watchListeners.length === 0 && await o();
      };
    },
    async unwatch() {
      e.watchListeners = [], await o();
    },
    // Mount
    mount(u, f) {
      if (u = Yv(u), u && e.mounts[u])
        throw new Error(`already mounted at ${u}`);
      return u && (e.mountpoints.push(u), e.mountpoints.sort((d, m) => m.length - d.length)), e.mounts[u] = f, e.watching && Promise.resolve(M9(f, i, u)).then((d) => {
        e.unwatch[u] = d;
      }).catch(console.error), c;
    },
    async unmount(u, f = !0) {
      u = Yv(u), !(!u || !e.mounts[u]) && (e.watching && u in e.unwatch && (e.unwatch[u](), delete e.unwatch[u]), f && await D9(e.mounts[u]), e.mountpoints = e.mountpoints.filter((d) => d !== u), delete e.mounts[u]);
    },
    getMount(u = "") {
      u = Ss(u) + ":";
      const f = t(u);
      return {
        driver: f.driver,
        base: f.base
      };
    },
    getMounts(u = "", f = {}) {
      return u = Ss(u), n(u, f.parents).map((m) => ({
        driver: m.driver,
        base: m.mountpoint
      }));
    }
  };
  return c;
}
function M9(r, e, t) {
  return r.watch ? r.watch((n, i) => e(n, t + i)) : () => {
  };
}
async function D9(r) {
  typeof r.dispose == "function" && await ti(r.dispose);
}
function Nd(r) {
  return new Promise((e, t) => {
    r.oncomplete = r.onsuccess = () => e(r.result), r.onabort = r.onerror = () => t(r.error);
  });
}
function FD(r, e) {
  const t = indexedDB.open(r);
  t.onupgradeneeded = () => t.result.createObjectStore(e);
  const n = Nd(t);
  return (i, s) => n.then((o) => s(o.transaction(e, i).objectStore(e)));
}
let t4;
function ly() {
  return t4 || (t4 = FD("keyval-store", "keyval")), t4;
}
function k9(r, e = ly()) {
  return e("readonly", (t) => Nd(t.get(r)));
}
function Qie(r, e, t = ly()) {
  return t("readwrite", (n) => (n.put(e, r), Nd(n.transaction)));
}
function Yie(r, e = ly()) {
  return e("readwrite", (t) => (t.delete(r), Nd(t.transaction)));
}
function Xie(r = ly()) {
  return r("readwrite", (e) => (e.clear(), Nd(e.transaction)));
}
function ese(r, e) {
  return r.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, Nd(r.transaction);
}
function tse(r = ly()) {
  return r("readonly", (e) => {
    if (e.getAllKeys)
      return Nd(e.getAllKeys());
    const t = [];
    return ese(e, (n) => t.push(n.key)).then(() => t);
  });
}
const rse = (r) => JSON.stringify(r, (e, t) => typeof t == "bigint" ? t.toString() + "n" : t), nse = (r) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, t = r.replace(e, '$1"$2n"$3');
  return JSON.parse(t, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function uy(r) {
  if (typeof r != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof r}`);
  try {
    return nse(r);
  } catch {
    return r;
  }
}
function hd(r) {
  return typeof r == "string" ? r : rse(r) || "";
}
const ise = "idb-keyval";
var sse = (r = {}) => {
  const e = r.base && r.base.length > 0 ? `${r.base}:` : "", t = (i) => e + i;
  let n;
  return r.dbName && r.storeName && (n = FD(r.dbName, r.storeName)), { name: ise, options: r, async hasItem(i) {
    return !(typeof await k9(t(i), n) > "u");
  }, async getItem(i) {
    return await k9(t(i), n) ?? null;
  }, setItem(i, s) {
    return Qie(t(i), s, n);
  }, removeItem(i) {
    return Yie(t(i), n);
  }, getKeys() {
    return tse(n);
  }, clear() {
    return Xie(n);
  } };
};
const ose = "WALLET_CONNECT_V2_INDEXED_DB", ase = "keyvaluestorage";
let cse = class {
  constructor() {
    this.indexedDb = Jie({ driver: sse({ dbName: ose, storeName: ase }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const t = await this.indexedDb.getItem(e);
    if (t !== null)
      return t;
  }
  async setItem(e, t) {
    await this.indexedDb.setItem(e, hd(t));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var r4 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Mb = { exports: {} };
(function() {
  let r;
  function e() {
  }
  r = e, r.prototype.getItem = function(t) {
    return this.hasOwnProperty(t) ? String(this[t]) : null;
  }, r.prototype.setItem = function(t, n) {
    this[t] = String(n);
  }, r.prototype.removeItem = function(t) {
    delete this[t];
  }, r.prototype.clear = function() {
    const t = this;
    Object.keys(t).forEach(function(n) {
      t[n] = void 0, delete t[n];
    });
  }, r.prototype.key = function(t) {
    return t = t || 0, Object.keys(this)[t];
  }, r.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof r4 < "u" && r4.localStorage ? Mb.exports = r4.localStorage : typeof window < "u" && window.localStorage ? Mb.exports = window.localStorage : Mb.exports = new e();
})();
function lse(r) {
  var e;
  return [r[0], uy((e = r[1]) != null ? e : "")];
}
let use = class {
  constructor() {
    this.localStorage = Mb.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(lse);
  }
  async getItem(e) {
    const t = this.localStorage.getItem(e);
    if (t !== null)
      return uy(t);
  }
  async setItem(e, t) {
    this.localStorage.setItem(e, hd(t));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const hse = "wc_storage_version", $9 = 1, fse = async (r, e, t) => {
  const n = hse, i = await e.getItem(n);
  if (i && i >= $9) {
    t(e);
    return;
  }
  const s = await r.getKeys();
  if (!s.length) {
    t(e);
    return;
  }
  const o = [];
  for (; s.length; ) {
    const a = s.shift();
    if (!a)
      continue;
    const c = a.toLowerCase();
    if (c.includes("wc@") || c.includes("walletconnect") || c.includes("wc_") || c.includes("wallet_connect")) {
      const u = await r.getItem(a);
      await e.setItem(a, u), o.push(a);
    }
  }
  await e.setItem(n, $9), t(e), dse(r, o);
}, dse = async (r, e) => {
  e.length && e.forEach(async (t) => {
    await r.removeItem(t);
  });
};
let pse = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (t) => {
      this.storage = t, this.initialized = !0;
    };
    const e = new use();
    this.storage = e;
    try {
      const t = new cse();
      fse(e, t, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, t) {
    return await this.initialize(), this.storage.setItem(e, t);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const t = setInterval(() => {
        this.initialized && (clearInterval(t), e());
      }, 20);
    });
  }
};
var zg = {}, O1 = {}, n4 = {}, N1 = {};
let Pd = class {
};
const gse = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: Pd
}, Symbol.toStringTag, { value: "Module" })), mse = /* @__PURE__ */ La(gse);
var L9;
function wse() {
  if (L9)
    return N1;
  L9 = 1, Object.defineProperty(N1, "__esModule", { value: !0 }), N1.IHeartBeat = void 0;
  const r = mse;
  class e extends r.IEvents {
    constructor(n) {
      super();
    }
  }
  return N1.IHeartBeat = e, N1;
}
var B9;
function UD() {
  return B9 || (B9 = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), $c.__exportStar(wse(), r);
  }(n4)), n4;
}
var i4 = {}, Hh = {}, F9;
function yse() {
  if (F9)
    return Hh;
  F9 = 1, Object.defineProperty(Hh, "__esModule", { value: !0 }), Hh.HEARTBEAT_EVENTS = Hh.HEARTBEAT_INTERVAL = void 0;
  const r = ft;
  return Hh.HEARTBEAT_INTERVAL = r.FIVE_SECONDS, Hh.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, Hh;
}
var U9;
function jD() {
  return U9 || (U9 = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), $c.__exportStar(yse(), r);
  }(i4)), i4;
}
var j9;
function vse() {
  if (j9)
    return O1;
  j9 = 1, Object.defineProperty(O1, "__esModule", { value: !0 }), O1.HeartBeat = void 0;
  const r = $c, e = Wi, t = ft, n = UD(), i = jD();
  class s extends n.IHeartBeat {
    constructor(a) {
      super(a), this.events = new e.EventEmitter(), this.interval = i.HEARTBEAT_INTERVAL, this.interval = (a == null ? void 0 : a.interval) || i.HEARTBEAT_INTERVAL;
    }
    static init(a) {
      return r.__awaiter(this, void 0, void 0, function* () {
        const c = new s(a);
        return yield c.init(), c;
      });
    }
    init() {
      return r.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(a, c) {
      this.events.on(a, c);
    }
    once(a, c) {
      this.events.once(a, c);
    }
    off(a, c) {
      this.events.off(a, c);
    }
    removeListener(a, c) {
      this.events.removeListener(a, c);
    }
    initialize() {
      return r.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), t.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(i.HEARTBEAT_EVENTS.pulse);
    }
  }
  return O1.HeartBeat = s, O1;
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  const e = $c;
  e.__exportStar(vse(), r), e.__exportStar(UD(), r), e.__exportStar(jD(), r);
})(zg);
var dr = {}, s4, W9;
function bse() {
  if (W9)
    return s4;
  W9 = 1;
  function r(t) {
    try {
      return JSON.stringify(t);
    } catch {
      return '"[Circular]"';
    }
  }
  s4 = e;
  function e(t, n, i) {
    var s = i && i.stringify || r, o = 1;
    if (typeof t == "object" && t !== null) {
      var a = n.length + o;
      if (a === 1)
        return t;
      var c = new Array(a);
      c[0] = s(t);
      for (var u = 1; u < a; u++)
        c[u] = s(n[u]);
      return c.join(" ");
    }
    if (typeof t != "string")
      return t;
    var f = n.length;
    if (f === 0)
      return t;
    for (var d = "", m = 1 - o, y = -1, b = t && t.length || 0, I = 0; I < b; ) {
      if (t.charCodeAt(I) === 37 && I + 1 < b) {
        switch (y = y > -1 ? y : 0, t.charCodeAt(I + 1)) {
          case 100:
          case 102:
            if (m >= f || n[m] == null)
              break;
            y < I && (d += t.slice(y, I)), d += Number(n[m]), y = I + 2, I++;
            break;
          case 105:
            if (m >= f || n[m] == null)
              break;
            y < I && (d += t.slice(y, I)), d += Math.floor(Number(n[m])), y = I + 2, I++;
            break;
          case 79:
          case 111:
          case 106:
            if (m >= f || n[m] === void 0)
              break;
            y < I && (d += t.slice(y, I));
            var k = typeof n[m];
            if (k === "string") {
              d += "'" + n[m] + "'", y = I + 2, I++;
              break;
            }
            if (k === "function") {
              d += n[m].name || "<anonymous>", y = I + 2, I++;
              break;
            }
            d += s(n[m]), y = I + 2, I++;
            break;
          case 115:
            if (m >= f)
              break;
            y < I && (d += t.slice(y, I)), d += String(n[m]), y = I + 2, I++;
            break;
          case 37:
            y < I && (d += t.slice(y, I)), d += "%", y = I + 2, I++, m--;
            break;
        }
        ++m;
      }
      ++I;
    }
    return y === -1 ? t : (y < b && (d += t.slice(y)), d);
  }
  return s4;
}
var o4, H9;
function _se() {
  if (H9)
    return o4;
  H9 = 1;
  const r = bse();
  o4 = i;
  const e = L().console || {}, t = {
    mapHttpRequest: b,
    mapHttpResponse: b,
    wrapRequestSerializer: I,
    wrapResponseSerializer: I,
    wrapErrorSerializer: I,
    req: b,
    res: b,
    err: m
  };
  function n(P, v) {
    return Array.isArray(P) ? P.filter(function(X) {
      return X !== "!stdSerializers.err";
    }) : P === !0 ? Object.keys(v) : !1;
  }
  function i(P) {
    P = P || {}, P.browser = P.browser || {};
    const v = P.browser.transmit;
    if (v && typeof v.send != "function")
      throw Error("pino: transmit option must have a send function");
    const F = P.browser.write || e;
    P.browser.write && (P.browser.asObject = !0);
    const X = P.serializers || {}, te = n(P.browser.serialize, X);
    let se = P.browser.serialize;
    Array.isArray(P.browser.serialize) && P.browser.serialize.indexOf("!stdSerializers.err") > -1 && (se = !1);
    const we = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof F == "function" && (F.error = F.fatal = F.warn = F.info = F.debug = F.trace = F), P.enabled === !1 && (P.level = "silent");
    const H = P.level || "info", p = Object.create(F);
    p.log || (p.log = k), Object.defineProperty(p, "levelVal", {
      get: x
    }), Object.defineProperty(p, "level", {
      get: N,
      set: O
    });
    const w = {
      transmit: v,
      serialize: te,
      asObject: P.browser.asObject,
      levels: we,
      timestamp: y(P)
    };
    p.levels = i.levels, p.level = H, p.setMaxListeners = p.getMaxListeners = p.emit = p.addListener = p.on = p.prependListener = p.once = p.prependOnceListener = p.removeListener = p.removeAllListeners = p.listeners = p.listenerCount = p.eventNames = p.write = p.flush = k, p.serializers = X, p._serialize = te, p._stdErrSerialize = se, p.child = U, v && (p._logEvent = d());
    function x() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function N() {
      return this._level;
    }
    function O(q) {
      if (q !== "silent" && !this.levels.values[q])
        throw Error("unknown level " + q);
      this._level = q, s(w, p, "error", "log"), s(w, p, "fatal", "error"), s(w, p, "warn", "error"), s(w, p, "info", "log"), s(w, p, "debug", "log"), s(w, p, "trace", "log");
    }
    function U(q, B) {
      if (!q)
        throw new Error("missing bindings for child Pino");
      B = B || {}, te && q.serializers && (B.serializers = q.serializers);
      const E = B.serializers;
      if (te && E) {
        var V = Object.assign({}, X, E), be = P.browser.serialize === !0 ? Object.keys(V) : te;
        delete q.serializers, c([q], be, V, this._stdErrSerialize);
      }
      function ve(ne) {
        this._childLevel = (ne._childLevel | 0) + 1, this.error = u(ne, q, "error"), this.fatal = u(ne, q, "fatal"), this.warn = u(ne, q, "warn"), this.info = u(ne, q, "info"), this.debug = u(ne, q, "debug"), this.trace = u(ne, q, "trace"), V && (this.serializers = V, this._serialize = be), v && (this._logEvent = d(
          [].concat(ne._logEvent.bindings, q)
        ));
      }
      return ve.prototype = this, new ve(this);
    }
    return p;
  }
  i.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, i.stdSerializers = t, i.stdTimeFunctions = Object.assign({}, { nullTime: R, epochTime: T, unixTime: $, isoTime: D });
  function s(P, v, F, X) {
    const te = Object.getPrototypeOf(v);
    v[F] = v.levelVal > v.levels.values[F] ? k : te[F] ? te[F] : e[F] || e[X] || k, o(P, v, F);
  }
  function o(P, v, F) {
    !P.transmit && v[F] === k || (v[F] = /* @__PURE__ */ function(X) {
      return function() {
        const se = P.timestamp(), we = new Array(arguments.length), H = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
        for (var p = 0; p < we.length; p++)
          we[p] = arguments[p];
        if (P.serialize && !P.asObject && c(we, this._serialize, this.serializers, this._stdErrSerialize), P.asObject ? X.call(H, a(this, F, we, se)) : X.apply(H, we), P.transmit) {
          const w = P.transmit.level || v.level, x = i.levels.values[w], N = i.levels.values[F];
          if (N < x)
            return;
          f(this, {
            ts: se,
            methodLevel: F,
            methodValue: N,
            transmitLevel: w,
            transmitValue: i.levels.values[P.transmit.level || v.level],
            send: P.transmit.send,
            val: v.levelVal
          }, we);
        }
      };
    }(v[F]));
  }
  function a(P, v, F, X) {
    P._serialize && c(F, P._serialize, P.serializers, P._stdErrSerialize);
    const te = F.slice();
    let se = te[0];
    const we = {};
    X && (we.time = X), we.level = i.levels.values[v];
    let H = (P._childLevel | 0) + 1;
    if (H < 1 && (H = 1), se !== null && typeof se == "object") {
      for (; H-- && typeof te[0] == "object"; )
        Object.assign(we, te.shift());
      se = te.length ? r(te.shift(), te) : void 0;
    } else
      typeof se == "string" && (se = r(te.shift(), te));
    return se !== void 0 && (we.msg = se), we;
  }
  function c(P, v, F, X) {
    for (const te in P)
      if (X && P[te] instanceof Error)
        P[te] = i.stdSerializers.err(P[te]);
      else if (typeof P[te] == "object" && !Array.isArray(P[te]))
        for (const se in P[te])
          v && v.indexOf(se) > -1 && se in F && (P[te][se] = F[se](P[te][se]));
  }
  function u(P, v, F) {
    return function() {
      const X = new Array(1 + arguments.length);
      X[0] = v;
      for (var te = 1; te < X.length; te++)
        X[te] = arguments[te - 1];
      return P[F].apply(this, X);
    };
  }
  function f(P, v, F) {
    const X = v.send, te = v.ts, se = v.methodLevel, we = v.methodValue, H = v.val, p = P._logEvent.bindings;
    c(
      F,
      P._serialize || Object.keys(P.serializers),
      P.serializers,
      P._stdErrSerialize === void 0 ? !0 : P._stdErrSerialize
    ), P._logEvent.ts = te, P._logEvent.messages = F.filter(function(w) {
      return p.indexOf(w) === -1;
    }), P._logEvent.level.label = se, P._logEvent.level.value = we, X(se, P._logEvent, H), P._logEvent = d(p);
  }
  function d(P) {
    return {
      ts: 0,
      messages: [],
      bindings: P || [],
      level: { label: "", value: 0 }
    };
  }
  function m(P) {
    const v = {
      type: P.constructor.name,
      msg: P.message,
      stack: P.stack
    };
    for (const F in P)
      v[F] === void 0 && (v[F] = P[F]);
    return v;
  }
  function y(P) {
    return typeof P.timestamp == "function" ? P.timestamp : P.timestamp === !1 ? R : T;
  }
  function b() {
    return {};
  }
  function I(P) {
    return P;
  }
  function k() {
  }
  function R() {
    return !1;
  }
  function T() {
    return Date.now();
  }
  function $() {
    return Math.round(Date.now() / 1e3);
  }
  function D() {
    return new Date(Date.now()).toISOString();
  }
  function L() {
    function P(v) {
      return typeof v < "u" && v;
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          return delete Object.prototype.globalThis, this.globalThis = this;
        },
        configurable: !0
      }), globalThis;
    } catch {
      return P(self) || P(window) || P(this) || {};
    }
  }
  return o4;
}
var zh = {}, z9;
function WD() {
  return z9 || (z9 = 1, Object.defineProperty(zh, "__esModule", { value: !0 }), zh.PINO_CUSTOM_CONTEXT_KEY = zh.PINO_LOGGER_DEFAULTS = void 0, zh.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, zh.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), zh;
}
var Ki = {}, V9;
function Ese() {
  if (V9)
    return Ki;
  V9 = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.generateChildLogger = Ki.formatChildLoggerContext = Ki.getLoggerContext = Ki.setBrowserLoggerContext = Ki.getBrowserLoggerContext = Ki.getDefaultLoggerOptions = void 0;
  const r = WD();
  function e(a) {
    return Object.assign(Object.assign({}, a), { level: (a == null ? void 0 : a.level) || r.PINO_LOGGER_DEFAULTS.level });
  }
  Ki.getDefaultLoggerOptions = e;
  function t(a, c = r.PINO_CUSTOM_CONTEXT_KEY) {
    return a[c] || "";
  }
  Ki.getBrowserLoggerContext = t;
  function n(a, c, u = r.PINO_CUSTOM_CONTEXT_KEY) {
    return a[u] = c, a;
  }
  Ki.setBrowserLoggerContext = n;
  function i(a, c = r.PINO_CUSTOM_CONTEXT_KEY) {
    let u = "";
    return typeof a.bindings > "u" ? u = t(a, c) : u = a.bindings().context || "", u;
  }
  Ki.getLoggerContext = i;
  function s(a, c, u = r.PINO_CUSTOM_CONTEXT_KEY) {
    const f = i(a, u);
    return f.trim() ? `${f}/${c}` : c;
  }
  Ki.formatChildLoggerContext = s;
  function o(a, c, u = r.PINO_CUSTOM_CONTEXT_KEY) {
    const f = s(a, c, u), d = a.child({ context: f });
    return n(d, f, u);
  }
  return Ki.generateChildLogger = o, Ki;
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.pino = void 0;
  const e = $c, t = e.__importDefault(_se());
  Object.defineProperty(r, "pino", { enumerable: !0, get: function() {
    return t.default;
  } }), e.__exportStar(WD(), r), e.__exportStar(Ese(), r);
})(dr);
let xse = class extends Pd {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, Sse = class extends Pd {
  constructor(e, t) {
    super(), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
}, Cse = class {
  constructor(e, t) {
    this.logger = e, this.core = t;
  }
}, Ase = class extends Pd {
  constructor(e, t) {
    super(), this.relayer = e, this.logger = t;
  }
}, Ise = class extends Pd {
  constructor(e) {
    super();
  }
}, Rse = class {
  constructor(e, t, n, i) {
    this.core = e, this.logger = t, this.name = n;
  }
}, Tse = class extends Pd {
  constructor(e, t) {
    super(), this.relayer = e, this.logger = t;
  }
}, Ose = class extends Pd {
  constructor(e, t) {
    super(), this.core = e, this.logger = t;
  }
}, Nse = class {
  constructor(e, t) {
    this.projectId = e, this.logger = t;
  }
}, Pse = class {
  constructor(e, t) {
    this.projectId = e, this.logger = t;
  }
}, Mse = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, Dse = class {
  constructor(e) {
    this.client = e;
  }
};
var hC = {}, HD = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  var e = Kt, t = ao;
  r.DIGEST_LENGTH = 64, r.BLOCK_SIZE = 128;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = r.DIGEST_LENGTH, this.blockSize = r.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        t.wipe(this._buffer), t.wipe(this._tempHi), t.wipe(this._tempLo), this.reset();
      }, a.prototype.update = function(c, u) {
        if (u === void 0 && (u = c.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var f = 0;
        if (this._bytesHashed += u, this._bufferLength > 0) {
          for (; this._bufferLength < r.BLOCK_SIZE && u > 0; )
            this._buffer[this._bufferLength++] = c[f++], u--;
          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (u >= this.blockSize && (f = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, c, f, u), u %= this.blockSize); u > 0; )
          this._buffer[this._bufferLength++] = c[f++], u--;
        return this;
      }, a.prototype.finish = function(c) {
        if (!this._finished) {
          var u = this._bytesHashed, f = this._bufferLength, d = u / 536870912 | 0, m = u << 3, y = u % 128 < 112 ? 128 : 256;
          this._buffer[f] = 128;
          for (var b = f + 1; b < y - 8; b++)
            this._buffer[b] = 0;
          e.writeUint32BE(d, this._buffer, y - 8), e.writeUint32BE(m, this._buffer, y - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, y), this._finished = !0;
        }
        for (var b = 0; b < this.digestLength / 8; b++)
          e.writeUint32BE(this._stateHi[b], c, b * 8), e.writeUint32BE(this._stateLo[b], c, b * 8 + 4);
        return this;
      }, a.prototype.digest = function() {
        var c = new Uint8Array(this.digestLength);
        return this.finish(c), c;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(c) {
        return this._stateHi.set(c.stateHi), this._stateLo.set(c.stateLo), this._bufferLength = c.bufferLength, c.buffer && this._buffer.set(c.buffer), this._bytesHashed = c.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(c) {
        t.wipe(c.stateHi), t.wipe(c.stateLo), c.buffer && t.wipe(c.buffer), c.bufferLength = 0, c.bytesHashed = 0;
      }, a;
    }()
  );
  r.SHA512 = n;
  var i = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function s(a, c, u, f, d, m, y) {
    for (var b = u[0], I = u[1], k = u[2], R = u[3], T = u[4], $ = u[5], D = u[6], L = u[7], P = f[0], v = f[1], F = f[2], X = f[3], te = f[4], se = f[5], we = f[6], H = f[7], p, w, x, N, O, U, q, B; y >= 128; ) {
      for (var E = 0; E < 16; E++) {
        var V = 8 * E + m;
        a[E] = e.readUint32BE(d, V), c[E] = e.readUint32BE(d, V + 4);
      }
      for (var E = 0; E < 80; E++) {
        var be = b, ve = I, ne = k, K = R, Y = T, ee = $, S = D, M = L, G = P, ue = v, Ee = F, Le = X, Fe = te, De = se, dt = we, or = H;
        if (p = L, w = H, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = (T >>> 14 | te << 18) ^ (T >>> 18 | te << 14) ^ (te >>> 9 | T << 23), w = (te >>> 14 | T << 18) ^ (te >>> 18 | T << 14) ^ (T >>> 9 | te << 23), O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, p = T & $ ^ ~T & D, w = te & se ^ ~te & we, O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, p = i[E * 2], w = i[E * 2 + 1], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, p = a[E % 16], w = c[E % 16], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, x = q & 65535 | B << 16, N = O & 65535 | U << 16, p = x, w = N, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = (b >>> 28 | P << 4) ^ (P >>> 2 | b << 30) ^ (P >>> 7 | b << 25), w = (P >>> 28 | b << 4) ^ (b >>> 2 | P << 30) ^ (b >>> 7 | P << 25), O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, p = b & I ^ b & k ^ I & k, w = P & v ^ P & F ^ v & F, O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, M = q & 65535 | B << 16, or = O & 65535 | U << 16, p = K, w = Le, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = x, w = N, O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, K = q & 65535 | B << 16, Le = O & 65535 | U << 16, I = be, k = ve, R = ne, T = K, $ = Y, D = ee, L = S, b = M, v = G, F = ue, X = Ee, te = Le, se = Fe, we = De, H = dt, P = or, E % 16 === 15)
          for (var V = 0; V < 16; V++)
            p = a[V], w = c[V], O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = a[(V + 9) % 16], w = c[(V + 9) % 16], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, x = a[(V + 1) % 16], N = c[(V + 1) % 16], p = (x >>> 1 | N << 31) ^ (x >>> 8 | N << 24) ^ x >>> 7, w = (N >>> 1 | x << 31) ^ (N >>> 8 | x << 24) ^ (N >>> 7 | x << 25), O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, x = a[(V + 14) % 16], N = c[(V + 14) % 16], p = (x >>> 19 | N << 13) ^ (N >>> 29 | x << 3) ^ x >>> 6, w = (N >>> 19 | x << 13) ^ (x >>> 29 | N << 3) ^ (N >>> 6 | x << 26), O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, a[V] = q & 65535 | B << 16, c[V] = O & 65535 | U << 16;
      }
      p = b, w = P, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = u[0], w = f[0], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, u[0] = b = q & 65535 | B << 16, f[0] = P = O & 65535 | U << 16, p = I, w = v, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = u[1], w = f[1], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, u[1] = I = q & 65535 | B << 16, f[1] = v = O & 65535 | U << 16, p = k, w = F, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = u[2], w = f[2], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, u[2] = k = q & 65535 | B << 16, f[2] = F = O & 65535 | U << 16, p = R, w = X, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = u[3], w = f[3], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, u[3] = R = q & 65535 | B << 16, f[3] = X = O & 65535 | U << 16, p = T, w = te, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = u[4], w = f[4], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, u[4] = T = q & 65535 | B << 16, f[4] = te = O & 65535 | U << 16, p = $, w = se, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = u[5], w = f[5], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, u[5] = $ = q & 65535 | B << 16, f[5] = se = O & 65535 | U << 16, p = D, w = we, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = u[6], w = f[6], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, u[6] = D = q & 65535 | B << 16, f[6] = we = O & 65535 | U << 16, p = L, w = H, O = w & 65535, U = w >>> 16, q = p & 65535, B = p >>> 16, p = u[7], w = f[7], O += w & 65535, U += w >>> 16, q += p & 65535, B += p >>> 16, U += O >>> 16, q += U >>> 16, B += q >>> 16, u[7] = L = q & 65535 | B << 16, f[7] = H = O & 65535 | U << 16, m += 128, y -= 128;
    }
    return m;
  }
  function o(a) {
    var c = new n();
    c.update(a);
    var u = c.digest();
    return c.clean(), u;
  }
  r.hash = o;
})(HD);
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.convertSecretKeyToX25519 = r.convertPublicKeyToX25519 = r.verify = r.sign = r.extractPublicKeyFromSecretKey = r.generateKeyPair = r.generateKeyPairFromSeed = r.SEED_LENGTH = r.SECRET_KEY_LENGTH = r.PUBLIC_KEY_LENGTH = r.SIGNATURE_LENGTH = void 0;
  const e = Fg, t = HD, n = ao;
  r.SIGNATURE_LENGTH = 64, r.PUBLIC_KEY_LENGTH = 32, r.SECRET_KEY_LENGTH = 64, r.SEED_LENGTH = 32;
  function i(K) {
    const Y = new Float64Array(16);
    if (K)
      for (let ee = 0; ee < K.length; ee++)
        Y[ee] = K[ee];
    return Y;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const o = i(), a = i([1]), c = i([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), u = i([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), f = i([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), d = i([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), m = i([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function y(K, Y) {
    for (let ee = 0; ee < 16; ee++)
      K[ee] = Y[ee] | 0;
  }
  function b(K) {
    let Y = 1;
    for (let ee = 0; ee < 16; ee++) {
      let S = K[ee] + Y + 65535;
      Y = Math.floor(S / 65536), K[ee] = S - Y * 65536;
    }
    K[0] += Y - 1 + 37 * (Y - 1);
  }
  function I(K, Y, ee) {
    const S = ~(ee - 1);
    for (let M = 0; M < 16; M++) {
      const G = S & (K[M] ^ Y[M]);
      K[M] ^= G, Y[M] ^= G;
    }
  }
  function k(K, Y) {
    const ee = i(), S = i();
    for (let M = 0; M < 16; M++)
      S[M] = Y[M];
    b(S), b(S), b(S);
    for (let M = 0; M < 2; M++) {
      ee[0] = S[0] - 65517;
      for (let ue = 1; ue < 15; ue++)
        ee[ue] = S[ue] - 65535 - (ee[ue - 1] >> 16 & 1), ee[ue - 1] &= 65535;
      ee[15] = S[15] - 32767 - (ee[14] >> 16 & 1);
      const G = ee[15] >> 16 & 1;
      ee[14] &= 65535, I(S, ee, 1 - G);
    }
    for (let M = 0; M < 16; M++)
      K[2 * M] = S[M] & 255, K[2 * M + 1] = S[M] >> 8;
  }
  function R(K, Y) {
    let ee = 0;
    for (let S = 0; S < 32; S++)
      ee |= K[S] ^ Y[S];
    return (1 & ee - 1 >>> 8) - 1;
  }
  function T(K, Y) {
    const ee = new Uint8Array(32), S = new Uint8Array(32);
    return k(ee, K), k(S, Y), R(ee, S);
  }
  function $(K) {
    const Y = new Uint8Array(32);
    return k(Y, K), Y[0] & 1;
  }
  function D(K, Y) {
    for (let ee = 0; ee < 16; ee++)
      K[ee] = Y[2 * ee] + (Y[2 * ee + 1] << 8);
    K[15] &= 32767;
  }
  function L(K, Y, ee) {
    for (let S = 0; S < 16; S++)
      K[S] = Y[S] + ee[S];
  }
  function P(K, Y, ee) {
    for (let S = 0; S < 16; S++)
      K[S] = Y[S] - ee[S];
  }
  function v(K, Y, ee) {
    let S, M, G = 0, ue = 0, Ee = 0, Le = 0, Fe = 0, De = 0, dt = 0, or = 0, Qe = 0, We = 0, lt = 0, qe = 0, Ye = 0, st = 0, Ge = 0, W = 0, _ = 0, A = 0, J = 0, ae = 0, le = 0, ge = 0, je = 0, Ue = 0, it = 0, jt = 0, at = 0, Jt = 0, _i = 0, yr = 0, _r = 0, Pr = ee[0], It = ee[1], Mt = ee[2], Mr = ee[3], Nt = ee[4], Rt = ee[5], Hr = ee[6], Bt = ee[7], Dt = ee[8], zr = ee[9], kt = ee[10], $t = ee[11], Dr = ee[12], xt = ee[13], Ft = ee[14], Vr = ee[15];
    S = Y[0], G += S * Pr, ue += S * It, Ee += S * Mt, Le += S * Mr, Fe += S * Nt, De += S * Rt, dt += S * Hr, or += S * Bt, Qe += S * Dt, We += S * zr, lt += S * kt, qe += S * $t, Ye += S * Dr, st += S * xt, Ge += S * Ft, W += S * Vr, S = Y[1], ue += S * Pr, Ee += S * It, Le += S * Mt, Fe += S * Mr, De += S * Nt, dt += S * Rt, or += S * Hr, Qe += S * Bt, We += S * Dt, lt += S * zr, qe += S * kt, Ye += S * $t, st += S * Dr, Ge += S * xt, W += S * Ft, _ += S * Vr, S = Y[2], Ee += S * Pr, Le += S * It, Fe += S * Mt, De += S * Mr, dt += S * Nt, or += S * Rt, Qe += S * Hr, We += S * Bt, lt += S * Dt, qe += S * zr, Ye += S * kt, st += S * $t, Ge += S * Dr, W += S * xt, _ += S * Ft, A += S * Vr, S = Y[3], Le += S * Pr, Fe += S * It, De += S * Mt, dt += S * Mr, or += S * Nt, Qe += S * Rt, We += S * Hr, lt += S * Bt, qe += S * Dt, Ye += S * zr, st += S * kt, Ge += S * $t, W += S * Dr, _ += S * xt, A += S * Ft, J += S * Vr, S = Y[4], Fe += S * Pr, De += S * It, dt += S * Mt, or += S * Mr, Qe += S * Nt, We += S * Rt, lt += S * Hr, qe += S * Bt, Ye += S * Dt, st += S * zr, Ge += S * kt, W += S * $t, _ += S * Dr, A += S * xt, J += S * Ft, ae += S * Vr, S = Y[5], De += S * Pr, dt += S * It, or += S * Mt, Qe += S * Mr, We += S * Nt, lt += S * Rt, qe += S * Hr, Ye += S * Bt, st += S * Dt, Ge += S * zr, W += S * kt, _ += S * $t, A += S * Dr, J += S * xt, ae += S * Ft, le += S * Vr, S = Y[6], dt += S * Pr, or += S * It, Qe += S * Mt, We += S * Mr, lt += S * Nt, qe += S * Rt, Ye += S * Hr, st += S * Bt, Ge += S * Dt, W += S * zr, _ += S * kt, A += S * $t, J += S * Dr, ae += S * xt, le += S * Ft, ge += S * Vr, S = Y[7], or += S * Pr, Qe += S * It, We += S * Mt, lt += S * Mr, qe += S * Nt, Ye += S * Rt, st += S * Hr, Ge += S * Bt, W += S * Dt, _ += S * zr, A += S * kt, J += S * $t, ae += S * Dr, le += S * xt, ge += S * Ft, je += S * Vr, S = Y[8], Qe += S * Pr, We += S * It, lt += S * Mt, qe += S * Mr, Ye += S * Nt, st += S * Rt, Ge += S * Hr, W += S * Bt, _ += S * Dt, A += S * zr, J += S * kt, ae += S * $t, le += S * Dr, ge += S * xt, je += S * Ft, Ue += S * Vr, S = Y[9], We += S * Pr, lt += S * It, qe += S * Mt, Ye += S * Mr, st += S * Nt, Ge += S * Rt, W += S * Hr, _ += S * Bt, A += S * Dt, J += S * zr, ae += S * kt, le += S * $t, ge += S * Dr, je += S * xt, Ue += S * Ft, it += S * Vr, S = Y[10], lt += S * Pr, qe += S * It, Ye += S * Mt, st += S * Mr, Ge += S * Nt, W += S * Rt, _ += S * Hr, A += S * Bt, J += S * Dt, ae += S * zr, le += S * kt, ge += S * $t, je += S * Dr, Ue += S * xt, it += S * Ft, jt += S * Vr, S = Y[11], qe += S * Pr, Ye += S * It, st += S * Mt, Ge += S * Mr, W += S * Nt, _ += S * Rt, A += S * Hr, J += S * Bt, ae += S * Dt, le += S * zr, ge += S * kt, je += S * $t, Ue += S * Dr, it += S * xt, jt += S * Ft, at += S * Vr, S = Y[12], Ye += S * Pr, st += S * It, Ge += S * Mt, W += S * Mr, _ += S * Nt, A += S * Rt, J += S * Hr, ae += S * Bt, le += S * Dt, ge += S * zr, je += S * kt, Ue += S * $t, it += S * Dr, jt += S * xt, at += S * Ft, Jt += S * Vr, S = Y[13], st += S * Pr, Ge += S * It, W += S * Mt, _ += S * Mr, A += S * Nt, J += S * Rt, ae += S * Hr, le += S * Bt, ge += S * Dt, je += S * zr, Ue += S * kt, it += S * $t, jt += S * Dr, at += S * xt, Jt += S * Ft, _i += S * Vr, S = Y[14], Ge += S * Pr, W += S * It, _ += S * Mt, A += S * Mr, J += S * Nt, ae += S * Rt, le += S * Hr, ge += S * Bt, je += S * Dt, Ue += S * zr, it += S * kt, jt += S * $t, at += S * Dr, Jt += S * xt, _i += S * Ft, yr += S * Vr, S = Y[15], W += S * Pr, _ += S * It, A += S * Mt, J += S * Mr, ae += S * Nt, le += S * Rt, ge += S * Hr, je += S * Bt, Ue += S * Dt, it += S * zr, jt += S * kt, at += S * $t, Jt += S * Dr, _i += S * xt, yr += S * Ft, _r += S * Vr, G += 38 * _, ue += 38 * A, Ee += 38 * J, Le += 38 * ae, Fe += 38 * le, De += 38 * ge, dt += 38 * je, or += 38 * Ue, Qe += 38 * it, We += 38 * jt, lt += 38 * at, qe += 38 * Jt, Ye += 38 * _i, st += 38 * yr, Ge += 38 * _r, M = 1, S = G + M + 65535, M = Math.floor(S / 65536), G = S - M * 65536, S = ue + M + 65535, M = Math.floor(S / 65536), ue = S - M * 65536, S = Ee + M + 65535, M = Math.floor(S / 65536), Ee = S - M * 65536, S = Le + M + 65535, M = Math.floor(S / 65536), Le = S - M * 65536, S = Fe + M + 65535, M = Math.floor(S / 65536), Fe = S - M * 65536, S = De + M + 65535, M = Math.floor(S / 65536), De = S - M * 65536, S = dt + M + 65535, M = Math.floor(S / 65536), dt = S - M * 65536, S = or + M + 65535, M = Math.floor(S / 65536), or = S - M * 65536, S = Qe + M + 65535, M = Math.floor(S / 65536), Qe = S - M * 65536, S = We + M + 65535, M = Math.floor(S / 65536), We = S - M * 65536, S = lt + M + 65535, M = Math.floor(S / 65536), lt = S - M * 65536, S = qe + M + 65535, M = Math.floor(S / 65536), qe = S - M * 65536, S = Ye + M + 65535, M = Math.floor(S / 65536), Ye = S - M * 65536, S = st + M + 65535, M = Math.floor(S / 65536), st = S - M * 65536, S = Ge + M + 65535, M = Math.floor(S / 65536), Ge = S - M * 65536, S = W + M + 65535, M = Math.floor(S / 65536), W = S - M * 65536, G += M - 1 + 37 * (M - 1), M = 1, S = G + M + 65535, M = Math.floor(S / 65536), G = S - M * 65536, S = ue + M + 65535, M = Math.floor(S / 65536), ue = S - M * 65536, S = Ee + M + 65535, M = Math.floor(S / 65536), Ee = S - M * 65536, S = Le + M + 65535, M = Math.floor(S / 65536), Le = S - M * 65536, S = Fe + M + 65535, M = Math.floor(S / 65536), Fe = S - M * 65536, S = De + M + 65535, M = Math.floor(S / 65536), De = S - M * 65536, S = dt + M + 65535, M = Math.floor(S / 65536), dt = S - M * 65536, S = or + M + 65535, M = Math.floor(S / 65536), or = S - M * 65536, S = Qe + M + 65535, M = Math.floor(S / 65536), Qe = S - M * 65536, S = We + M + 65535, M = Math.floor(S / 65536), We = S - M * 65536, S = lt + M + 65535, M = Math.floor(S / 65536), lt = S - M * 65536, S = qe + M + 65535, M = Math.floor(S / 65536), qe = S - M * 65536, S = Ye + M + 65535, M = Math.floor(S / 65536), Ye = S - M * 65536, S = st + M + 65535, M = Math.floor(S / 65536), st = S - M * 65536, S = Ge + M + 65535, M = Math.floor(S / 65536), Ge = S - M * 65536, S = W + M + 65535, M = Math.floor(S / 65536), W = S - M * 65536, G += M - 1 + 37 * (M - 1), K[0] = G, K[1] = ue, K[2] = Ee, K[3] = Le, K[4] = Fe, K[5] = De, K[6] = dt, K[7] = or, K[8] = Qe, K[9] = We, K[10] = lt, K[11] = qe, K[12] = Ye, K[13] = st, K[14] = Ge, K[15] = W;
  }
  function F(K, Y) {
    v(K, Y, Y);
  }
  function X(K, Y) {
    const ee = i();
    let S;
    for (S = 0; S < 16; S++)
      ee[S] = Y[S];
    for (S = 253; S >= 0; S--)
      F(ee, ee), S !== 2 && S !== 4 && v(ee, ee, Y);
    for (S = 0; S < 16; S++)
      K[S] = ee[S];
  }
  function te(K, Y) {
    const ee = i();
    let S;
    for (S = 0; S < 16; S++)
      ee[S] = Y[S];
    for (S = 250; S >= 0; S--)
      F(ee, ee), S !== 1 && v(ee, ee, Y);
    for (S = 0; S < 16; S++)
      K[S] = ee[S];
  }
  function se(K, Y) {
    const ee = i(), S = i(), M = i(), G = i(), ue = i(), Ee = i(), Le = i(), Fe = i(), De = i();
    P(ee, K[1], K[0]), P(De, Y[1], Y[0]), v(ee, ee, De), L(S, K[0], K[1]), L(De, Y[0], Y[1]), v(S, S, De), v(M, K[3], Y[3]), v(M, M, u), v(G, K[2], Y[2]), L(G, G, G), P(ue, S, ee), P(Ee, G, M), L(Le, G, M), L(Fe, S, ee), v(K[0], ue, Ee), v(K[1], Fe, Le), v(K[2], Le, Ee), v(K[3], ue, Fe);
  }
  function we(K, Y, ee) {
    for (let S = 0; S < 4; S++)
      I(K[S], Y[S], ee);
  }
  function H(K, Y) {
    const ee = i(), S = i(), M = i();
    X(M, Y[2]), v(ee, Y[0], M), v(S, Y[1], M), k(K, S), K[31] ^= $(ee) << 7;
  }
  function p(K, Y, ee) {
    y(K[0], o), y(K[1], a), y(K[2], a), y(K[3], o);
    for (let S = 255; S >= 0; --S) {
      const M = ee[S / 8 | 0] >> (S & 7) & 1;
      we(K, Y, M), se(Y, K), se(K, K), we(K, Y, M);
    }
  }
  function w(K, Y) {
    const ee = [i(), i(), i(), i()];
    y(ee[0], f), y(ee[1], d), y(ee[2], a), v(ee[3], f, d), p(K, ee, Y);
  }
  function x(K) {
    if (K.length !== r.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${r.SEED_LENGTH} bytes`);
    const Y = (0, t.hash)(K);
    Y[0] &= 248, Y[31] &= 127, Y[31] |= 64;
    const ee = new Uint8Array(32), S = [i(), i(), i(), i()];
    w(S, Y), H(ee, S);
    const M = new Uint8Array(64);
    return M.set(K), M.set(ee, 32), {
      publicKey: ee,
      secretKey: M
    };
  }
  r.generateKeyPairFromSeed = x;
  function N(K) {
    const Y = (0, e.randomBytes)(32, K), ee = x(Y);
    return (0, n.wipe)(Y), ee;
  }
  r.generateKeyPair = N;
  function O(K) {
    if (K.length !== r.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${r.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(K.subarray(32));
  }
  r.extractPublicKeyFromSecretKey = O;
  const U = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function q(K, Y) {
    let ee, S, M, G;
    for (S = 63; S >= 32; --S) {
      for (ee = 0, M = S - 32, G = S - 12; M < G; ++M)
        Y[M] += ee - 16 * Y[S] * U[M - (S - 32)], ee = Math.floor((Y[M] + 128) / 256), Y[M] -= ee * 256;
      Y[M] += ee, Y[S] = 0;
    }
    for (ee = 0, M = 0; M < 32; M++)
      Y[M] += ee - (Y[31] >> 4) * U[M], ee = Y[M] >> 8, Y[M] &= 255;
    for (M = 0; M < 32; M++)
      Y[M] -= ee * U[M];
    for (S = 0; S < 32; S++)
      Y[S + 1] += Y[S] >> 8, K[S] = Y[S] & 255;
  }
  function B(K) {
    const Y = new Float64Array(64);
    for (let ee = 0; ee < 64; ee++)
      Y[ee] = K[ee];
    for (let ee = 0; ee < 64; ee++)
      K[ee] = 0;
    q(K, Y);
  }
  function E(K, Y) {
    const ee = new Float64Array(64), S = [i(), i(), i(), i()], M = (0, t.hash)(K.subarray(0, 32));
    M[0] &= 248, M[31] &= 127, M[31] |= 64;
    const G = new Uint8Array(64);
    G.set(M.subarray(32), 32);
    const ue = new t.SHA512();
    ue.update(G.subarray(32)), ue.update(Y);
    const Ee = ue.digest();
    ue.clean(), B(Ee), w(S, Ee), H(G, S), ue.reset(), ue.update(G.subarray(0, 32)), ue.update(K.subarray(32)), ue.update(Y);
    const Le = ue.digest();
    B(Le);
    for (let Fe = 0; Fe < 32; Fe++)
      ee[Fe] = Ee[Fe];
    for (let Fe = 0; Fe < 32; Fe++)
      for (let De = 0; De < 32; De++)
        ee[Fe + De] += Le[Fe] * M[De];
    return q(G.subarray(32), ee), G;
  }
  r.sign = E;
  function V(K, Y) {
    const ee = i(), S = i(), M = i(), G = i(), ue = i(), Ee = i(), Le = i();
    return y(K[2], a), D(K[1], Y), F(M, K[1]), v(G, M, c), P(M, M, K[2]), L(G, K[2], G), F(ue, G), F(Ee, ue), v(Le, Ee, ue), v(ee, Le, M), v(ee, ee, G), te(ee, ee), v(ee, ee, M), v(ee, ee, G), v(ee, ee, G), v(K[0], ee, G), F(S, K[0]), v(S, S, G), T(S, M) && v(K[0], K[0], m), F(S, K[0]), v(S, S, G), T(S, M) ? -1 : ($(K[0]) === Y[31] >> 7 && P(K[0], o, K[0]), v(K[3], K[0], K[1]), 0);
  }
  function be(K, Y, ee) {
    const S = new Uint8Array(32), M = [i(), i(), i(), i()], G = [i(), i(), i(), i()];
    if (ee.length !== r.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${r.SIGNATURE_LENGTH} bytes`);
    if (V(G, K))
      return !1;
    const ue = new t.SHA512();
    ue.update(ee.subarray(0, 32)), ue.update(K), ue.update(Y);
    const Ee = ue.digest();
    return B(Ee), p(M, G, Ee), w(G, ee.subarray(32)), se(M, G), H(S, M), !R(ee, S);
  }
  r.verify = be;
  function ve(K) {
    let Y = [i(), i(), i(), i()];
    if (V(Y, K))
      throw new Error("Ed25519: invalid public key");
    let ee = i(), S = i(), M = Y[1];
    L(ee, a, M), P(S, a, M), X(S, S), v(ee, ee, S);
    let G = new Uint8Array(32);
    return k(G, ee), G;
  }
  r.convertPublicKeyToX25519 = ve;
  function ne(K) {
    const Y = (0, t.hash)(K.subarray(0, 32));
    Y[0] &= 248, Y[31] &= 127, Y[31] |= 64;
    const ee = new Uint8Array(Y.subarray(0, 32));
    return (0, n.wipe)(Y), ee;
  }
  r.convertSecretKeyToX25519 = ne;
})(hC);
const kse = "EdDSA", $se = "JWT", zD = ".", VD = "base64url", Lse = "utf8", Bse = "utf8", Fse = ":", Use = "did", jse = "key", q9 = "base58btc", Wse = "z", Hse = "K36", zse = 32;
function N2(r) {
  return us(Ms(hd(r), Lse), VD);
}
function qD(r) {
  const e = Ms(Hse, q9), t = Wse + us(q6([e, r]), q9);
  return [Use, jse, t].join(Fse);
}
function Vse(r) {
  return us(r, VD);
}
function qse(r) {
  return Ms([N2(r.header), N2(r.payload)].join(zD), Bse);
}
function Gse(r) {
  return [
    N2(r.header),
    N2(r.payload),
    Vse(r.signature)
  ].join(zD);
}
function G9(r = Fg.randomBytes(zse)) {
  return hC.generateKeyPairFromSeed(r);
}
async function Kse(r, e, t, n, i = ft.fromMiliseconds(Date.now())) {
  const s = { alg: kse, typ: $se }, o = qD(n.publicKey), a = i + t, c = { iss: o, sub: r, aud: e, iat: i, exp: a }, u = qse({ header: s, payload: c }), f = hC.sign(n.secretKey, u);
  return Gse({ header: s, payload: c, signature: f });
}
const Zse = "PARSE_ERROR", Jse = "INVALID_REQUEST", Qse = "METHOD_NOT_FOUND", Yse = "INVALID_PARAMS", GD = "INTERNAL_ERROR", fC = "SERVER_ERROR", Xse = [-32700, -32600, -32601, -32602, -32603], hm = {
  [Zse]: { code: -32700, message: "Parse error" },
  [Jse]: { code: -32600, message: "Invalid Request" },
  [Qse]: { code: -32601, message: "Method not found" },
  [Yse]: { code: -32602, message: "Invalid params" },
  [GD]: { code: -32603, message: "Internal error" },
  [fC]: { code: -32e3, message: "Server error" }
}, KD = fC;
function eoe(r) {
  return Xse.includes(r);
}
function K9(r) {
  return Object.keys(hm).includes(r) ? hm[r] : hm[KD];
}
function toe(r) {
  const e = Object.values(hm).find((t) => t.code === r);
  return e || hm[KD];
}
function ZD(r, e, t) {
  return r.message.includes("getaddrinfo ENOTFOUND") || r.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${t} RPC url at ${e}`) : r;
}
var JD = {}, Jc = {}, Z9;
function roe() {
  if (Z9)
    return Jc;
  Z9 = 1, Object.defineProperty(Jc, "__esModule", { value: !0 }), Jc.isBrowserCryptoAvailable = Jc.getSubtleCrypto = Jc.getBrowerCrypto = void 0;
  function r() {
    return (ze == null ? void 0 : ze.crypto) || (ze == null ? void 0 : ze.msCrypto) || {};
  }
  Jc.getBrowerCrypto = r;
  function e() {
    const n = r();
    return n.subtle || n.webkitSubtle;
  }
  Jc.getSubtleCrypto = e;
  function t() {
    return !!r() && !!e();
  }
  return Jc.isBrowserCryptoAvailable = t, Jc;
}
var Qc = {}, J9;
function noe() {
  if (J9)
    return Qc;
  J9 = 1, Object.defineProperty(Qc, "__esModule", { value: !0 }), Qc.isBrowser = Qc.isNode = Qc.isReactNative = void 0;
  function r() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  Qc.isReactNative = r;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  Qc.isNode = e;
  function t() {
    return !r() && !e();
  }
  return Qc.isBrowser = t, Qc;
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 });
  const e = $c;
  e.__exportStar(roe(), r), e.__exportStar(noe(), r);
})(JD);
function dC(r = 3) {
  const e = Date.now() * Math.pow(10, r), t = Math.floor(Math.random() * Math.pow(10, r));
  return e + t;
}
function QD(r = 6) {
  return BigInt(dC(r));
}
function Kp(r, e, t) {
  return {
    id: t || dC(),
    jsonrpc: "2.0",
    method: r,
    params: e
  };
}
function q_(r, e) {
  return {
    id: r,
    jsonrpc: "2.0",
    result: e
  };
}
function G_(r, e, t) {
  return {
    id: r,
    jsonrpc: "2.0",
    error: ioe(e, t)
  };
}
function ioe(r, e) {
  return typeof r > "u" ? K9(GD) : (typeof r == "string" && (r = Object.assign(Object.assign({}, K9(fC)), { message: r })), typeof e < "u" && (r.data = e), eoe(r.code) && (r = toe(r.code)), r);
}
class soe {
}
class ooe extends soe {
  constructor() {
    super();
  }
}
class aoe extends ooe {
  constructor(e) {
    super();
  }
}
const coe = "^https?:", loe = "^wss?:";
function uoe(r) {
  const e = r.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function YD(r, e) {
  const t = uoe(r);
  return typeof t > "u" ? !1 : new RegExp(e).test(t);
}
function Q9(r) {
  return YD(r, coe);
}
function Y9(r) {
  return YD(r, loe);
}
function hoe(r) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(r);
}
function XD(r) {
  return typeof r == "object" && "id" in r && "jsonrpc" in r && r.jsonrpc === "2.0";
}
function pC(r) {
  return XD(r) && "method" in r;
}
function K_(r) {
  return XD(r) && (tl(r) || _a(r));
}
function tl(r) {
  return "result" in r;
}
function _a(r) {
  return "error" in r;
}
let Wl = class extends aoe {
  constructor(e) {
    super(e), this.events = new Wi.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async request(e, t) {
    return this.requestStrict(Kp(e.method, e.params || [], e.id || QD().toString()), t);
  }
  async requestStrict(e, t) {
    return new Promise(async (n, i) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (s) {
          i(s);
        }
      this.events.on(`${e.id}`, (s) => {
        _a(s) ? i(s.error) : n(s.result);
      });
      try {
        await this.connection.send(e, t);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), K_(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
      type: e.method,
      data: e.params
    });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const foe = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), doe = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", X9 = (r) => r.split("?")[0], eT = 10, poe = foe();
let goe = class {
  constructor(e) {
    if (this.url = e, this.events = new Wi.EventEmitter(), this.registering = !1, !Y9(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(hd(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!Y9(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return i(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((t, n) => {
      const i = new URLSearchParams(e).get("origin"), s = JD.isReactNative() ? { headers: { origin: i } } : { rejectUnauthorized: !hoe(e) }, o = new poe(e, [], s);
      doe() ? o.onerror = (a) => {
        const c = a;
        n(this.emitError(c.error));
      } : o.on("error", (a) => {
        n(this.emitError(a));
      }), o.onopen = () => {
        this.onOpen(o), t(o);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const t = typeof e.data == "string" ? uy(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n = this.parseError(t), i = n.message || n.toString(), s = G_(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, t = this.url) {
    return ZD(e, X9(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > eT && this.events.setMaxListeners(eT);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${X9(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};
var P2 = { exports: {} };
P2.exports;
(function(r, e) {
  var t = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, o = 9007199254740991, a = "[object Arguments]", c = "[object Array]", u = "[object AsyncFunction]", f = "[object Boolean]", d = "[object Date]", m = "[object Error]", y = "[object Function]", b = "[object GeneratorFunction]", I = "[object Map]", k = "[object Number]", R = "[object Null]", T = "[object Object]", $ = "[object Promise]", D = "[object Proxy]", L = "[object RegExp]", P = "[object Set]", v = "[object String]", F = "[object Symbol]", X = "[object Undefined]", te = "[object WeakMap]", se = "[object ArrayBuffer]", we = "[object DataView]", H = "[object Float32Array]", p = "[object Float64Array]", w = "[object Int8Array]", x = "[object Int16Array]", N = "[object Int32Array]", O = "[object Uint8Array]", U = "[object Uint8ClampedArray]", q = "[object Uint16Array]", B = "[object Uint32Array]", E = /[\\^$.*+?()[\]{}|]/g, V = /^\[object .+?Constructor\]$/, be = /^(?:0|[1-9]\d*)$/, ve = {};
  ve[H] = ve[p] = ve[w] = ve[x] = ve[N] = ve[O] = ve[U] = ve[q] = ve[B] = !0, ve[a] = ve[c] = ve[se] = ve[f] = ve[we] = ve[d] = ve[m] = ve[y] = ve[I] = ve[k] = ve[T] = ve[L] = ve[P] = ve[v] = ve[te] = !1;
  var ne = typeof ze == "object" && ze && ze.Object === Object && ze, K = typeof self == "object" && self && self.Object === Object && self, Y = ne || K || Function("return this")(), ee = e && !e.nodeType && e, S = ee && !0 && r && !r.nodeType && r, M = S && S.exports === ee, G = M && ne.process, ue = function() {
    try {
      return G && G.binding && G.binding("util");
    } catch {
    }
  }(), Ee = ue && ue.isTypedArray;
  function Le(re, fe) {
    for (var Oe = -1, et = re == null ? 0 : re.length, Gr = 0, Vt = []; ++Oe < et; ) {
      var rn = re[Oe];
      fe(rn, Oe, re) && (Vt[Gr++] = rn);
    }
    return Vt;
  }
  function Fe(re, fe) {
    for (var Oe = -1, et = fe.length, Gr = re.length; ++Oe < et; )
      re[Gr + Oe] = fe[Oe];
    return re;
  }
  function De(re, fe) {
    for (var Oe = -1, et = re == null ? 0 : re.length; ++Oe < et; )
      if (fe(re[Oe], Oe, re))
        return !0;
    return !1;
  }
  function dt(re, fe) {
    for (var Oe = -1, et = Array(re); ++Oe < re; )
      et[Oe] = fe(Oe);
    return et;
  }
  function or(re) {
    return function(fe) {
      return re(fe);
    };
  }
  function Qe(re, fe) {
    return re.has(fe);
  }
  function We(re, fe) {
    return re == null ? void 0 : re[fe];
  }
  function lt(re) {
    var fe = -1, Oe = Array(re.size);
    return re.forEach(function(et, Gr) {
      Oe[++fe] = [Gr, et];
    }), Oe;
  }
  function qe(re, fe) {
    return function(Oe) {
      return re(fe(Oe));
    };
  }
  function Ye(re) {
    var fe = -1, Oe = Array(re.size);
    return re.forEach(function(et) {
      Oe[++fe] = et;
    }), Oe;
  }
  var st = Array.prototype, Ge = Function.prototype, W = Object.prototype, _ = Y["__core-js_shared__"], A = Ge.toString, J = W.hasOwnProperty, ae = function() {
    var re = /[^.]+$/.exec(_ && _.keys && _.keys.IE_PROTO || "");
    return re ? "Symbol(src)_1." + re : "";
  }(), le = W.toString, ge = RegExp(
    "^" + A.call(J).replace(E, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), je = M ? Y.Buffer : void 0, Ue = Y.Symbol, it = Y.Uint8Array, jt = W.propertyIsEnumerable, at = st.splice, Jt = Ue ? Ue.toStringTag : void 0, _i = Object.getOwnPropertySymbols, yr = je ? je.isBuffer : void 0, _r = qe(Object.keys, Object), Pr = Bs(Y, "DataView"), It = Bs(Y, "Map"), Mt = Bs(Y, "Promise"), Mr = Bs(Y, "Set"), Nt = Bs(Y, "WeakMap"), Rt = Bs(Object, "create"), Hr = Bc(Pr), Bt = Bc(It), Dt = Bc(Mt), zr = Bc(Mr), kt = Bc(Nt), $t = Ue ? Ue.prototype : void 0, Dr = $t ? $t.valueOf : void 0;
  function xt(re) {
    var fe = -1, Oe = re == null ? 0 : re.length;
    for (this.clear(); ++fe < Oe; ) {
      var et = re[fe];
      this.set(et[0], et[1]);
    }
  }
  function Ft() {
    this.__data__ = Rt ? Rt(null) : {}, this.size = 0;
  }
  function Vr(re) {
    var fe = this.has(re) && delete this.__data__[re];
    return this.size -= fe ? 1 : 0, fe;
  }
  function $r(re) {
    var fe = this.__data__;
    if (Rt) {
      var Oe = fe[re];
      return Oe === n ? void 0 : Oe;
    }
    return J.call(fe, re) ? fe[re] : void 0;
  }
  function Lr(re) {
    var fe = this.__data__;
    return Rt ? fe[re] !== void 0 : J.call(fe, re);
  }
  function za(re, fe) {
    var Oe = this.__data__;
    return this.size += this.has(re) ? 0 : 1, Oe[re] = Rt && fe === void 0 ? n : fe, this;
  }
  xt.prototype.clear = Ft, xt.prototype.delete = Vr, xt.prototype.get = $r, xt.prototype.has = Lr, xt.prototype.set = za;
  function ar(re) {
    var fe = -1, Oe = re == null ? 0 : re.length;
    for (this.clear(); ++fe < Oe; ) {
      var et = re[fe];
      this.set(et[0], et[1]);
    }
  }
  function Br() {
    this.__data__ = [], this.size = 0;
  }
  function qo(re) {
    var fe = this.__data__, Oe = xh(fe, re);
    if (Oe < 0)
      return !1;
    var et = fe.length - 1;
    return Oe == et ? fe.pop() : at.call(fe, Oe, 1), --this.size, !0;
  }
  function Go(re) {
    var fe = this.__data__, Oe = xh(fe, re);
    return Oe < 0 ? void 0 : fe[Oe][1];
  }
  function Ko(re) {
    return xh(this.__data__, re) > -1;
  }
  function Zo(re, fe) {
    var Oe = this.__data__, et = xh(Oe, re);
    return et < 0 ? (++this.size, Oe.push([re, fe])) : Oe[et][1] = fe, this;
  }
  ar.prototype.clear = Br, ar.prototype.delete = qo, ar.prototype.get = Go, ar.prototype.has = Ko, ar.prototype.set = Zo;
  function hi(re) {
    var fe = -1, Oe = re == null ? 0 : re.length;
    for (this.clear(); ++fe < Oe; ) {
      var et = re[fe];
      this.set(et[0], et[1]);
    }
  }
  function ps() {
    this.size = 0, this.__data__ = {
      hash: new xt(),
      map: new (It || ar)(),
      string: new xt()
    };
  }
  function Jo(re) {
    var fe = Gl(this, re).delete(re);
    return this.size -= fe ? 1 : 0, fe;
  }
  function gs(re) {
    return Gl(this, re).get(re);
  }
  function Qo(re) {
    return Gl(this, re).has(re);
  }
  function Yo(re, fe) {
    var Oe = Gl(this, re), et = Oe.size;
    return Oe.set(re, fe), this.size += Oe.size == et ? 0 : 1, this;
  }
  hi.prototype.clear = ps, hi.prototype.delete = Jo, hi.prototype.get = gs, hi.prototype.has = Qo, hi.prototype.set = Yo;
  function ms(re) {
    var fe = -1, Oe = re == null ? 0 : re.length;
    for (this.__data__ = new hi(); ++fe < Oe; )
      this.add(re[fe]);
  }
  function lo(re) {
    return this.__data__.set(re, n), this;
  }
  function uo(re) {
    return this.__data__.has(re);
  }
  ms.prototype.add = ms.prototype.push = lo, ms.prototype.has = uo;
  function Vn(re) {
    var fe = this.__data__ = new ar(re);
    this.size = fe.size;
  }
  function vh() {
    this.__data__ = new ar(), this.size = 0;
  }
  function bh(re) {
    var fe = this.__data__, Oe = fe.delete(re);
    return this.size = fe.size, Oe;
  }
  function _h(re) {
    return this.__data__.get(re);
  }
  function Eh(re) {
    return this.__data__.has(re);
  }
  function ql(re, fe) {
    var Oe = this.__data__;
    if (Oe instanceof ar) {
      var et = Oe.__data__;
      if (!It || et.length < t - 1)
        return et.push([re, fe]), this.size = ++Oe.size, this;
      Oe = this.__data__ = new hi(et);
    }
    return Oe.set(re, fe), this.size = Oe.size, this;
  }
  Vn.prototype.clear = vh, Vn.prototype.delete = bh, Vn.prototype.get = _h, Vn.prototype.has = Eh, Vn.prototype.set = ql;
  function Hy(re, fe) {
    var Oe = qd(re), et = !Oe && tv(re), Gr = !Oe && !et && a1(re), Vt = !Oe && !et && !Gr && iv(re), rn = Oe || et || Gr || Vt, Fn = rn ? dt(re.length, String) : [], pr = Fn.length;
    for (var Kr in re)
      (fe || J.call(re, Kr)) && !(rn && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Kr == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Gr && (Kr == "offset" || Kr == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Vt && (Kr == "buffer" || Kr == "byteLength" || Kr == "byteOffset") || // Skip index properties.
      Jy(Kr, pr))) && Fn.push(Kr);
    return Fn;
  }
  function xh(re, fe) {
    for (var Oe = re.length; Oe--; )
      if (ev(re[Oe][0], fe))
        return Oe;
    return -1;
  }
  function s1(re, fe, Oe) {
    var et = fe(re);
    return qd(re) ? et : Fe(et, Oe(re));
  }
  function Sh(re) {
    return re == null ? re === void 0 ? X : R : Jt && Jt in Object(re) ? Ky(re) : yE(re);
  }
  function o1(re) {
    return Ah(re) && Sh(re) == a;
  }
  function Ch(re, fe, Oe, et, Gr) {
    return re === fe ? !0 : re == null || fe == null || !Ah(re) && !Ah(fe) ? re !== re && fe !== fe : zy(re, fe, Oe, et, Ch, Gr);
  }
  function zy(re, fe, Oe, et, Gr, Vt) {
    var rn = qd(re), Fn = qd(fe), pr = rn ? c : Va(re), Kr = Fn ? c : Va(fe);
    pr = pr == a ? T : pr, Kr = Kr == a ? T : Kr;
    var Nn = pr == T, ws = Kr == T, Un = pr == Kr;
    if (Un && a1(re)) {
      if (!a1(fe))
        return !1;
      rn = !0, Nn = !1;
    }
    if (Un && !Nn)
      return Vt || (Vt = new Vn()), rn || iv(re) ? zd(re, fe, Oe, et, Gr, Vt) : wE(re, fe, pr, Oe, et, Gr, Vt);
    if (!(Oe & i)) {
      var nn = Nn && J.call(re, "__wrapped__"), Hi = ws && J.call(fe, "__wrapped__");
      if (nn || Hi) {
        var Xo = nn ? re.value() : re, ho = Hi ? fe.value() : fe;
        return Vt || (Vt = new Vn()), Gr(Xo, ho, Oe, et, Vt);
      }
    }
    return Un ? (Vt || (Vt = new Vn()), Gy(re, fe, Oe, et, Gr, Vt)) : !1;
  }
  function mE(re) {
    if (!nv(re) || Yy(re))
      return !1;
    var fe = Gd(re) ? ge : V;
    return fe.test(Bc(re));
  }
  function Vy(re) {
    return Ah(re) && rv(re.length) && !!ve[Sh(re)];
  }
  function qy(re) {
    if (!Xy(re))
      return _r(re);
    var fe = [];
    for (var Oe in Object(re))
      J.call(re, Oe) && Oe != "constructor" && fe.push(Oe);
    return fe;
  }
  function zd(re, fe, Oe, et, Gr, Vt) {
    var rn = Oe & i, Fn = re.length, pr = fe.length;
    if (Fn != pr && !(rn && pr > Fn))
      return !1;
    var Kr = Vt.get(re);
    if (Kr && Vt.get(fe))
      return Kr == fe;
    var Nn = -1, ws = !0, Un = Oe & s ? new ms() : void 0;
    for (Vt.set(re, fe), Vt.set(fe, re); ++Nn < Fn; ) {
      var nn = re[Nn], Hi = fe[Nn];
      if (et)
        var Xo = rn ? et(Hi, nn, Nn, fe, re, Vt) : et(nn, Hi, Nn, re, fe, Vt);
      if (Xo !== void 0) {
        if (Xo)
          continue;
        ws = !1;
        break;
      }
      if (Un) {
        if (!De(fe, function(ho, qa) {
          if (!Qe(Un, qa) && (nn === ho || Gr(nn, ho, Oe, et, Vt)))
            return Un.push(qa);
        })) {
          ws = !1;
          break;
        }
      } else if (!(nn === Hi || Gr(nn, Hi, Oe, et, Vt))) {
        ws = !1;
        break;
      }
    }
    return Vt.delete(re), Vt.delete(fe), ws;
  }
  function wE(re, fe, Oe, et, Gr, Vt, rn) {
    switch (Oe) {
      case we:
        if (re.byteLength != fe.byteLength || re.byteOffset != fe.byteOffset)
          return !1;
        re = re.buffer, fe = fe.buffer;
      case se:
        return !(re.byteLength != fe.byteLength || !Vt(new it(re), new it(fe)));
      case f:
      case d:
      case k:
        return ev(+re, +fe);
      case m:
        return re.name == fe.name && re.message == fe.message;
      case L:
      case v:
        return re == fe + "";
      case I:
        var Fn = lt;
      case P:
        var pr = et & i;
        if (Fn || (Fn = Ye), re.size != fe.size && !pr)
          return !1;
        var Kr = rn.get(re);
        if (Kr)
          return Kr == fe;
        et |= s, rn.set(re, fe);
        var Nn = zd(Fn(re), Fn(fe), et, Gr, Vt, rn);
        return rn.delete(re), Nn;
      case F:
        if (Dr)
          return Dr.call(re) == Dr.call(fe);
    }
    return !1;
  }
  function Gy(re, fe, Oe, et, Gr, Vt) {
    var rn = Oe & i, Fn = Vd(re), pr = Fn.length, Kr = Vd(fe), Nn = Kr.length;
    if (pr != Nn && !rn)
      return !1;
    for (var ws = pr; ws--; ) {
      var Un = Fn[ws];
      if (!(rn ? Un in fe : J.call(fe, Un)))
        return !1;
    }
    var nn = Vt.get(re);
    if (nn && Vt.get(fe))
      return nn == fe;
    var Hi = !0;
    Vt.set(re, fe), Vt.set(fe, re);
    for (var Xo = rn; ++ws < pr; ) {
      Un = Fn[ws];
      var ho = re[Un], qa = fe[Un];
      if (et)
        var c1 = rn ? et(qa, ho, Un, fe, re, Vt) : et(ho, qa, Un, re, fe, Vt);
      if (!(c1 === void 0 ? ho === qa || Gr(ho, qa, Oe, et, Vt) : c1)) {
        Hi = !1;
        break;
      }
      Xo || (Xo = Un == "constructor");
    }
    if (Hi && !Xo) {
      var Ih = re.constructor, Qn = fe.constructor;
      Ih != Qn && "constructor" in re && "constructor" in fe && !(typeof Ih == "function" && Ih instanceof Ih && typeof Qn == "function" && Qn instanceof Qn) && (Hi = !1);
    }
    return Vt.delete(re), Vt.delete(fe), Hi;
  }
  function Vd(re) {
    return s1(re, _E, Zy);
  }
  function Gl(re, fe) {
    var Oe = re.__data__;
    return Qy(fe) ? Oe[typeof fe == "string" ? "string" : "hash"] : Oe.map;
  }
  function Bs(re, fe) {
    var Oe = We(re, fe);
    return mE(Oe) ? Oe : void 0;
  }
  function Ky(re) {
    var fe = J.call(re, Jt), Oe = re[Jt];
    try {
      re[Jt] = void 0;
      var et = !0;
    } catch {
    }
    var Gr = le.call(re);
    return et && (fe ? re[Jt] = Oe : delete re[Jt]), Gr;
  }
  var Zy = _i ? function(re) {
    return re == null ? [] : (re = Object(re), Le(_i(re), function(fe) {
      return jt.call(re, fe);
    }));
  } : qr, Va = Sh;
  (Pr && Va(new Pr(new ArrayBuffer(1))) != we || It && Va(new It()) != I || Mt && Va(Mt.resolve()) != $ || Mr && Va(new Mr()) != P || Nt && Va(new Nt()) != te) && (Va = function(re) {
    var fe = Sh(re), Oe = fe == T ? re.constructor : void 0, et = Oe ? Bc(Oe) : "";
    if (et)
      switch (et) {
        case Hr:
          return we;
        case Bt:
          return I;
        case Dt:
          return $;
        case zr:
          return P;
        case kt:
          return te;
      }
    return fe;
  });
  function Jy(re, fe) {
    return fe = fe ?? o, !!fe && (typeof re == "number" || be.test(re)) && re > -1 && re % 1 == 0 && re < fe;
  }
  function Qy(re) {
    var fe = typeof re;
    return fe == "string" || fe == "number" || fe == "symbol" || fe == "boolean" ? re !== "__proto__" : re === null;
  }
  function Yy(re) {
    return !!ae && ae in re;
  }
  function Xy(re) {
    var fe = re && re.constructor, Oe = typeof fe == "function" && fe.prototype || W;
    return re === Oe;
  }
  function yE(re) {
    return le.call(re);
  }
  function Bc(re) {
    if (re != null) {
      try {
        return A.call(re);
      } catch {
      }
      try {
        return re + "";
      } catch {
      }
    }
    return "";
  }
  function ev(re, fe) {
    return re === fe || re !== re && fe !== fe;
  }
  var tv = o1(/* @__PURE__ */ function() {
    return arguments;
  }()) ? o1 : function(re) {
    return Ah(re) && J.call(re, "callee") && !jt.call(re, "callee");
  }, qd = Array.isArray;
  function vE(re) {
    return re != null && rv(re.length) && !Gd(re);
  }
  var a1 = yr || Fr;
  function bE(re, fe) {
    return Ch(re, fe);
  }
  function Gd(re) {
    if (!nv(re))
      return !1;
    var fe = Sh(re);
    return fe == y || fe == b || fe == u || fe == D;
  }
  function rv(re) {
    return typeof re == "number" && re > -1 && re % 1 == 0 && re <= o;
  }
  function nv(re) {
    var fe = typeof re;
    return re != null && (fe == "object" || fe == "function");
  }
  function Ah(re) {
    return re != null && typeof re == "object";
  }
  var iv = Ee ? or(Ee) : Vy;
  function _E(re) {
    return vE(re) ? Hy(re) : qy(re);
  }
  function qr() {
    return [];
  }
  function Fr() {
    return !1;
  }
  r.exports = bE;
})(P2, P2.exports);
var moe = P2.exports;
const woe = /* @__PURE__ */ Ed(moe);
function yoe(r, e) {
  return e = e || {}, new Promise(function(t, n) {
    var i = new XMLHttpRequest(), s = [], o = [], a = {}, c = function() {
      return { ok: (i.status / 100 | 0) == 2, statusText: i.statusText, status: i.status, url: i.responseURL, text: function() {
        return Promise.resolve(i.responseText);
      }, json: function() {
        return Promise.resolve(i.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([i.response]));
      }, clone: c, headers: { keys: function() {
        return s;
      }, entries: function() {
        return o;
      }, get: function(f) {
        return a[f.toLowerCase()];
      }, has: function(f) {
        return f.toLowerCase() in a;
      } } };
    };
    for (var u in i.open(e.method || "get", r, !0), i.onload = function() {
      i.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(f, d, m) {
        s.push(d = d.toLowerCase()), o.push([d, m]), a[d] = a[d] ? a[d] + "," + m : m;
      }), t(c());
    }, i.onerror = n, i.withCredentials = e.credentials == "include", e.headers)
      i.setRequestHeader(u, e.headers[u]);
    i.send(e.body || null);
  });
}
const voe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: yoe
}, Symbol.toStringTag, { value: "Module" })), tT = /* @__PURE__ */ La(voe);
var boe = self.fetch || (self.fetch = tT.default || tT);
const _oe = /* @__PURE__ */ Ed(boe);
function Eoe(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++)
    t[n] = 255;
  for (var i = 0; i < r.length; i++) {
    var s = r.charAt(i), o = s.charCodeAt(0);
    if (t[o] !== 255)
      throw new TypeError(s + " is ambiguous");
    t[o] = i;
  }
  var a = r.length, c = r.charAt(0), u = Math.log(a) / Math.log(256), f = Math.log(256) / Math.log(a);
  function d(b) {
    if (b instanceof Uint8Array || (ArrayBuffer.isView(b) ? b = new Uint8Array(b.buffer, b.byteOffset, b.byteLength) : Array.isArray(b) && (b = Uint8Array.from(b))), !(b instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (b.length === 0)
      return "";
    for (var I = 0, k = 0, R = 0, T = b.length; R !== T && b[R] === 0; )
      R++, I++;
    for (var $ = (T - R) * f + 1 >>> 0, D = new Uint8Array($); R !== T; ) {
      for (var L = b[R], P = 0, v = $ - 1; (L !== 0 || P < k) && v !== -1; v--, P++)
        L += 256 * D[v] >>> 0, D[v] = L % a >>> 0, L = L / a >>> 0;
      if (L !== 0)
        throw new Error("Non-zero carry");
      k = P, R++;
    }
    for (var F = $ - k; F !== $ && D[F] === 0; )
      F++;
    for (var X = c.repeat(I); F < $; ++F)
      X += r.charAt(D[F]);
    return X;
  }
  function m(b) {
    if (typeof b != "string")
      throw new TypeError("Expected String");
    if (b.length === 0)
      return new Uint8Array();
    var I = 0;
    if (b[I] !== " ") {
      for (var k = 0, R = 0; b[I] === c; )
        k++, I++;
      for (var T = (b.length - I) * u + 1 >>> 0, $ = new Uint8Array(T); b[I]; ) {
        var D = t[b.charCodeAt(I)];
        if (D === 255)
          return;
        for (var L = 0, P = T - 1; (D !== 0 || L < R) && P !== -1; P--, L++)
          D += a * $[P] >>> 0, $[P] = D % 256 >>> 0, D = D / 256 >>> 0;
        if (D !== 0)
          throw new Error("Non-zero carry");
        R = L, I++;
      }
      if (b[I] !== " ") {
        for (var v = T - R; v !== T && $[v] === 0; )
          v++;
        for (var F = new Uint8Array(k + (T - v)), X = k; v !== T; )
          F[X++] = $[v++];
        return F;
      }
    }
  }
  function y(b) {
    var I = m(b);
    if (I)
      return I;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d, decodeUnsafe: m, decode: y };
}
var xoe = Eoe, Soe = xoe;
const ek = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Coe = (r) => new TextEncoder().encode(r), Aoe = (r) => new TextDecoder().decode(r);
class Ioe {
  constructor(e, t, n) {
    this.name = e, this.prefix = t, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Roe {
  constructor(e, t, n) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return tk(this, e);
  }
}
class Toe {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return tk(this, e);
  }
  decode(e) {
    const t = e[0], n = this.decoders[t];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const tk = (r, e) => new Toe({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
let Ooe = class {
  constructor(e, t, n, i) {
    this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = i, this.encoder = new Ioe(e, t, n), this.decoder = new Roe(e, t, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
const Z_ = ({ name: r, prefix: e, encode: t, decode: n }) => new Ooe(r, e, t, n), hy = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: n, decode: i } = Soe(t, e);
  return Z_({ prefix: r, name: e, encode: n, decode: (s) => ek(i(s)) });
}, Noe = (r, e, t, n) => {
  const i = {};
  for (let f = 0; f < e.length; ++f)
    i[e[f]] = f;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const o = new Uint8Array(s * t / 8 | 0);
  let a = 0, c = 0, u = 0;
  for (let f = 0; f < s; ++f) {
    const d = i[r[f]];
    if (d === void 0)
      throw new SyntaxError(`Non-${n} character`);
    c = c << t | d, a += t, a >= 8 && (a -= 8, o[u++] = 255 & c >> a);
  }
  if (a >= t || 255 & c << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, Poe = (r, e, t) => {
  const n = e[e.length - 1] === "=", i = (1 << t) - 1;
  let s = "", o = 0, a = 0;
  for (let c = 0; c < r.length; ++c)
    for (a = a << 8 | r[c], o += 8; o > t; )
      o -= t, s += e[i & a >> o];
  if (o && (s += e[i & a << t - o]), n)
    for (; s.length * t & 7; )
      s += "=";
  return s;
}, bi = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => Z_({ prefix: e, name: r, encode(i) {
  return Poe(i, n, t);
}, decode(i) {
  return Noe(i, n, t, r);
} }), Moe = Z_({ prefix: "\0", name: "identity", encode: (r) => Aoe(r), decode: (r) => Coe(r) });
var Doe = Object.freeze({ __proto__: null, identity: Moe });
const koe = bi({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var $oe = Object.freeze({ __proto__: null, base2: koe });
const Loe = bi({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Boe = Object.freeze({ __proto__: null, base8: Loe });
const Foe = hy({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Uoe = Object.freeze({ __proto__: null, base10: Foe });
const joe = bi({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Woe = bi({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Hoe = Object.freeze({ __proto__: null, base16: joe, base16upper: Woe });
const zoe = bi({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Voe = bi({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), qoe = bi({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Goe = bi({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Koe = bi({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), Zoe = bi({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Joe = bi({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Qoe = bi({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Yoe = bi({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Xoe = Object.freeze({ __proto__: null, base32: zoe, base32upper: Voe, base32pad: qoe, base32padupper: Goe, base32hex: Koe, base32hexupper: Zoe, base32hexpad: Joe, base32hexpadupper: Qoe, base32z: Yoe });
const eae = hy({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), tae = hy({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var rae = Object.freeze({ __proto__: null, base36: eae, base36upper: tae });
const nae = hy({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), iae = hy({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var sae = Object.freeze({ __proto__: null, base58btc: nae, base58flickr: iae });
const oae = bi({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), aae = bi({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), cae = bi({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), lae = bi({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var uae = Object.freeze({ __proto__: null, base64: oae, base64pad: aae, base64url: cae, base64urlpad: lae });
const rk = Array.from(""), hae = rk.reduce((r, e, t) => (r[t] = e, r), []), fae = rk.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function dae(r) {
  return r.reduce((e, t) => (e += hae[t], e), "");
}
function pae(r) {
  const e = [];
  for (const t of r) {
    const n = fae[t.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const gae = Z_({ prefix: "", name: "base256emoji", encode: dae, decode: pae });
var mae = Object.freeze({ __proto__: null, base256emoji: gae }), wae = nk, rT = 128, yae = 127, vae = ~yae, bae = Math.pow(2, 31);
function nk(r, e, t) {
  e = e || [], t = t || 0;
  for (var n = t; r >= bae; )
    e[t++] = r & 255 | rT, r /= 128;
  for (; r & vae; )
    e[t++] = r & 255 | rT, r >>>= 7;
  return e[t] = r | 0, nk.bytes = t - n + 1, e;
}
var _ae = rx, Eae = 128, nT = 127;
function rx(r, n) {
  var t = 0, n = n || 0, i = 0, s = n, o, a = r.length;
  do {
    if (s >= a)
      throw rx.bytes = 0, new RangeError("Could not decode varint");
    o = r[s++], t += i < 28 ? (o & nT) << i : (o & nT) * Math.pow(2, i), i += 7;
  } while (o >= Eae);
  return rx.bytes = s - n, t;
}
var xae = Math.pow(2, 7), Sae = Math.pow(2, 14), Cae = Math.pow(2, 21), Aae = Math.pow(2, 28), Iae = Math.pow(2, 35), Rae = Math.pow(2, 42), Tae = Math.pow(2, 49), Oae = Math.pow(2, 56), Nae = Math.pow(2, 63), Pae = function(r) {
  return r < xae ? 1 : r < Sae ? 2 : r < Cae ? 3 : r < Aae ? 4 : r < Iae ? 5 : r < Rae ? 6 : r < Tae ? 7 : r < Oae ? 8 : r < Nae ? 9 : 10;
}, Mae = { encode: wae, decode: _ae, encodingLength: Pae }, ik = Mae;
const iT = (r, e, t = 0) => (ik.encode(r, e, t), e), sT = (r) => ik.encodingLength(r), nx = (r, e) => {
  const t = e.byteLength, n = sT(r), i = n + sT(t), s = new Uint8Array(i + t);
  return iT(r, s, 0), iT(t, s, n), s.set(e, i), new Dae(r, t, e, s);
};
class Dae {
  constructor(e, t, n, i) {
    this.code = e, this.size = t, this.digest = n, this.bytes = i;
  }
}
const sk = ({ name: r, code: e, encode: t }) => new kae(r, e, t);
class kae {
  constructor(e, t, n) {
    this.name = e, this.code = t, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? nx(this.code, t) : t.then((n) => nx(this.code, n));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const ok = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e)), $ae = sk({ name: "sha2-256", code: 18, encode: ok("SHA-256") }), Lae = sk({ name: "sha2-512", code: 19, encode: ok("SHA-512") });
var Bae = Object.freeze({ __proto__: null, sha256: $ae, sha512: Lae });
const ak = 0, Fae = "identity", ck = ek, Uae = (r) => nx(ak, ck(r)), jae = { code: ak, name: Fae, encode: ck, digest: Uae };
var Wae = Object.freeze({ __proto__: null, identity: jae });
new TextEncoder(), new TextDecoder();
const oT = { ...Doe, ...$oe, ...Boe, ...Uoe, ...Hoe, ...Xoe, ...rae, ...sae, ...uae, ...mae };
({ ...Bae, ...Wae });
function lk(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function Hae(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? lk(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function uk(r, e, t, n) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: n } };
}
const aT = uk("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1))), a4 = uk("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = Hae(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
}), zae = { utf8: aT, "utf-8": aT, hex: oT.base16, latin1: a4, ascii: a4, binary: a4, ...oT };
function Vae(r, e = "utf8") {
  const t = zae[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? lk(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
const hk = "wc", qae = 2, gC = "core", eh = `${hk}@2:${gC}:`, Gae = { name: gC, logger: "error" }, Kae = { database: ":memory:" }, Zae = "crypto", cT = "client_ed25519_seed", Jae = ft.ONE_DAY, Qae = "keychain", Yae = "0.3", Xae = "messages", ece = "0.3", tce = ft.SIX_HOURS, rce = "publisher", fk = "irn", nce = "error", dk = "wss://relay.walletconnect.com", lT = "wss://relay.walletconnect.org", ice = "relayer", Di = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, sce = "_subscription", Yc = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, oce = ft.ONE_SECOND, ace = "2.11.0", cce = 1e4, lce = "0.3", uce = "WALLETCONNECT_CLIENT_ID", ha = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, hce = "subscription", fce = "0.3", dce = ft.FIVE_SECONDS * 1e3, pce = "pairing", gce = "0.3", P1 = { wc_pairingDelete: { req: { ttl: ft.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: ft.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: ft.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: ft.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: ft.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: ft.ONE_DAY, prompt: !1, tag: 0 } } }, Z1 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, Ya = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, mce = "history", wce = "0.3", yce = "expirer", So = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, vce = "0.3", c4 = "verify-api", Op = "https://verify.walletconnect.com", ix = "https://verify.walletconnect.org", bce = [Op, ix], _ce = "echo", Ece = "https://echo.walletconnect.com";
class xce {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = Qae, this.version = Yae, this.initialized = !1, this.storagePrefix = eh, this.init = async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }, this.has = (n) => (this.isInitialized(), this.keychain.has(n)), this.set = async (n, i) => {
      this.isInitialized(), this.keychain.set(n, i), await this.persist();
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.keychain.get(n);
      if (typeof i > "u") {
        const { message: s } = He("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(s);
      }
      return i;
    }, this.del = async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }, this.core = e, this.logger = dr.generateChildLogger(t, this.name);
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, PD(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? MD(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class Sce {
  constructor(e, t, n) {
    this.core = e, this.logger = t, this.name = Zae, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (i) => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
      this.isInitialized();
      const i = await this.getClientSeed(), s = G9(i);
      return qD(s.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i = xne();
      return this.setPrivateKey(i.publicKey, i.privateKey);
    }, this.signJWT = async (i) => {
      this.isInitialized();
      const s = await this.getClientSeed(), o = G9(s), a = X6();
      return await Kse(a, i, Jae, o);
    }, this.generateSharedKey = (i, s, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(i), c = Sne(a, s);
      return this.setSymKey(c, o);
    }, this.setSymKey = async (i, s) => {
      this.isInitialized();
      const o = s || Cne(i);
      return await this.keychain.set(o, i), o;
    }, this.deleteKeyPair = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.deleteSymKey = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.encode = async (i, s, o) => {
      this.isInitialized();
      const a = ND(o), c = hd(s);
      if (_9(a)) {
        const m = a.senderPublicKey, y = a.receiverPublicKey;
        i = await this.generateSharedKey(m, y);
      }
      const u = this.getSymKey(i), { type: f, senderPublicKey: d } = a;
      return Ine({ type: f, symKey: u, message: c, senderPublicKey: d });
    }, this.decode = async (i, s, o) => {
      this.isInitialized();
      const a = One(s, o);
      if (_9(a)) {
        const c = a.receiverPublicKey, u = a.senderPublicKey;
        i = await this.generateSharedKey(c, u);
      }
      try {
        const c = this.getSymKey(i), u = Rne({ symKey: c, encoded: s });
        return uy(u);
      } catch (c) {
        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(c);
      }
    }, this.getPayloadType = (i) => {
      const s = T2(i);
      return ay(s.type);
    }, this.getPayloadSenderPublicKey = (i) => {
      const s = T2(i);
      return s.senderPublicKey ? us(s.senderPublicKey, as) : void 0;
    }, this.core = e, this.logger = dr.generateChildLogger(t, this.name), this.keychain = n || new xce(this.core, this.logger);
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(cT);
    } catch {
      e = X6(), await this.keychain.set(cT, e);
    }
    return Vae(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class Cce extends Cse {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = Xae, this.version = ece, this.initialized = !1, this.storagePrefix = eh, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (n, i) => {
      this.isInitialized();
      const s = qp(i);
      let o = this.messages.get(n);
      return typeof o > "u" && (o = {}), typeof o[s] < "u" || (o[s] = i, this.messages.set(n, o), await this.persist()), s;
    }, this.get = (n) => {
      this.isInitialized();
      let i = this.messages.get(n);
      return typeof i > "u" && (i = {}), i;
    }, this.has = (n, i) => {
      this.isInitialized();
      const s = this.get(n), o = qp(i);
      return typeof s[o] < "u";
    }, this.del = async (n) => {
      this.isInitialized(), this.messages.delete(n), await this.persist();
    }, this.logger = dr.generateChildLogger(e, this.name), this.core = t;
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, PD(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? MD(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class Ace extends Ase {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new Wi.EventEmitter(), this.name = rce, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = ft.toMiliseconds(ft.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (n, i, s) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      try {
        const a = (s == null ? void 0 : s.ttl) || tce, c = ex(s), u = (s == null ? void 0 : s.prompt) || !1, f = (s == null ? void 0 : s.tag) || 0, d = (s == null ? void 0 : s.id) || QD().toString(), m = { topic: n, message: i, opts: { ttl: a, relay: c, prompt: u, tag: f, id: d } }, y = setTimeout(() => this.queue.set(d, m), this.publishTimeout);
        try {
          await await iw(this.rpcPublish(n, i, a, c, u, f, d), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(d), this.relayer.events.emit(Di.publish, m);
        } catch (b) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, (o = s == null ? void 0 : s.internal) != null && o.throwOnFailedPublish)
            throw this.removeRequestFromQueue(d), b;
          return;
        } finally {
          clearTimeout(y);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      } catch (a) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a), a;
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.relayer = e, this.logger = dr.generateChildLogger(t, this.name), this.registerEventListeners();
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  rpcPublish(e, t, n, i, s, o, a) {
    var c, u, f, d;
    const m = { method: Ob(i.protocol).publish, params: { topic: e, message: t, ttl: n, prompt: s, tag: o }, id: a };
    return ts((c = m.params) == null ? void 0 : c.prompt) && ((u = m.params) == null || delete u.prompt), ts((f = m.params) == null ? void 0 : f.tag) && ((d = m.params) == null || delete d.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: m }), this.relayer.request(m);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: n, opts: i } = e;
      await this.publish(t, n, i);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(zg.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(Di.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(Di.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class Ice {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const n = this.get(e);
      this.exists(e, t) || this.map.set(e, [...n, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const n = this.get(e);
      if (!this.exists(e, t))
        return;
      const i = n.filter((s) => s !== t);
      if (!i.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var Rce = Object.defineProperty, Tce = Object.defineProperties, Oce = Object.getOwnPropertyDescriptors, uT = Object.getOwnPropertySymbols, Nce = Object.prototype.hasOwnProperty, Pce = Object.prototype.propertyIsEnumerable, hT = (r, e, t) => e in r ? Rce(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, M1 = (r, e) => {
  for (var t in e || (e = {}))
    Nce.call(e, t) && hT(r, t, e[t]);
  if (uT)
    for (var t of uT(e))
      Pce.call(e, t) && hT(r, t, e[t]);
  return r;
}, l4 = (r, e) => Tce(r, Oce(e));
class Mce extends Tse {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Ice(), this.events = new Wi.EventEmitter(), this.name = hce, this.version = fce, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = eh, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } });
      try {
        const s = ex(i), o = { topic: n, relay: s };
        this.pending.set(n, o);
        const a = await this.rpcSubscribe(n, s);
        return this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } }), a;
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s;
      }
    }, this.unsubscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(n, i.id, i) : await this.unsubscribeByTopic(n, i);
    }, this.isSubscribed = async (n) => this.topics.includes(n) ? !0 : await new Promise((i, s) => {
      const o = new ft.Watch();
      o.start(this.pendingSubscriptionWatchLabel);
      const a = setInterval(() => {
        !this.pending.has(n) && this.topics.includes(n) && (clearInterval(a), o.stop(this.pendingSubscriptionWatchLabel), i(!0)), o.elapsed(this.pendingSubscriptionWatchLabel) >= dce && (clearInterval(a), o.stop(this.pendingSubscriptionWatchLabel), s(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => !1), this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = dr.generateChildLogger(t, this.name), this.clientId = "";
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === t;
    } catch {
    }
    return n;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (i) => await this.unsubscribeById(e, i, t)));
  }
  async unsubscribeById(e, t, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: n } });
    try {
      const i = ex(n);
      await this.rpcUnsubscribe(e, t, i);
      const s = Cn("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: n } });
    } catch (i) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i;
    }
  }
  async rpcSubscribe(e, t) {
    const n = { method: Ob(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      await await iw(this.relayer.request(n), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(Di.connection_stalled);
    }
    return qp(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, n = { method: Ob(t.protocol).batchSubscribe, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      return await await iw(this.relayer.request(n), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(Di.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, n) {
    const i = { method: Ob(n.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i }), this.relayer.request(i);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, l4(M1({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, M1({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, n) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, M1({}, t)), this.topicMap.set(t.topic, e), this.events.emit(ha.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: n } = He("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(ha.deleted, l4(M1({}, n), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(ha.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const n = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(n);
      }
    }
    this.events.emit(ha.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = He("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    Nc(t) && this.onBatchSubscribe(t.map((n, i) => l4(M1({}, e[i]), { id: n })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(zg.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(Di.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(Di.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(ha.created, async (e) => {
      const t = ha.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(ha.deleted, async (e) => {
      const t = ha.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
}
var Dce = Object.defineProperty, fT = Object.getOwnPropertySymbols, kce = Object.prototype.hasOwnProperty, $ce = Object.prototype.propertyIsEnumerable, dT = (r, e, t) => e in r ? Dce(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Lce = (r, e) => {
  for (var t in e || (e = {}))
    kce.call(e, t) && dT(r, t, e[t]);
  if (fT)
    for (var t of fT(e))
      $ce.call(e, t) && dT(r, t, e[t]);
  return r;
};
class Bce extends Ise {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new Wi.EventEmitter(), this.name = ice, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (n) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(n), n;
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t);
    }, this.onConnectHandler = () => {
      this.events.emit(Di.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(Di.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(Yc.payload, this.onPayloadHandler), this.provider.on(Yc.connect, this.onConnectHandler), this.provider.on(Yc.disconnect, this.onDisconnectHandler), this.provider.on(Yc.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? dr.generateChildLogger(e.logger, this.name) : dr.pino(dr.getDefaultLoggerOptions({ level: e.logger || nce })), this.messages = new Cce(this.logger, e.core), this.subscriber = new Mce(this, this.logger), this.publisher = new Ace(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || dk, this.projectId = e.projectId, this.bundleId = $ne(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${lT}...`), await this.restartTransport(lT);
    }
    this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, cce);
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, n) {
    this.isInitialized(), await this.publisher.publish(e, t, n), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var n;
    this.isInitialized();
    let i = ((n = this.subscriber.topicMap.get(e)) == null ? void 0 : n[0]) || "";
    if (i)
      return i;
    let s;
    const o = (a) => {
      a.topic === e && (this.subscriber.off(ha.created, o), s());
    };
    return await Promise.all([new Promise((a) => {
      s = a, this.subscriber.on(ha.created, o);
    }), new Promise(async (a) => {
      i = await this.subscriber.subscribe(e, t), a();
    })]), i;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await iw(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
      try {
        await Promise.all([new Promise((t) => {
          if (!this.initialized)
            return t();
          this.subscriber.once(ha.resubscribed, () => {
            t();
          });
        }), new Promise(async (t, n) => {
          try {
            await iw(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (i) {
            n(i);
            return;
          }
          t();
        })]);
      } catch (t) {
        this.logger.error(t);
        const n = t;
        if (!this.isConnectionStalled(n.message))
          throw t;
        this.provider.events.emit(Yc.disconnect);
      } finally {
        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await P9())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new Wl(new goe(Wne({ sdkVersion: ace, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: n } = e;
    await this.messages.set(t, n);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: n } = e;
    if (!n || n.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${n}`), !0;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), !0;
    const i = this.messages.has(t, n);
    return i && this.logger.debug(`Ignoring duplicate message: ${n}`), i;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), pC(e)) {
      if (!e.method.endsWith(sce))
        return;
      const t = e.params, { topic: n, message: i, publishedAt: s } = t.data, o = { topic: n, message: i, publishedAt: s };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Lce({ type: "event", event: t.id }, o)), this.events.emit(t.id, o), await this.acknowledgePayload(e), await this.onMessageEvent(o);
    } else
      K_(e) && this.events.emit(Di.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(Di.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = q_(e.id, !0);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(Yc.payload, this.onPayloadHandler), this.provider.off(Yc.connect, this.onConnectHandler), this.provider.off(Yc.disconnect, this.onDisconnectHandler), this.provider.off(Yc.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(Di.connection_stalled, () => {
      this.restartTransport().catch((t) => this.logger.error(t));
    });
    let e = await P9();
    Die(async (t) => {
      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((n) => this.logger.error(n)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((n) => this.logger.error(n))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(Di.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, ft.toMiliseconds(oce)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
}
var Fce = Object.defineProperty, pT = Object.getOwnPropertySymbols, Uce = Object.prototype.hasOwnProperty, jce = Object.prototype.propertyIsEnumerable, gT = (r, e, t) => e in r ? Fce(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, mT = (r, e) => {
  for (var t in e || (e = {}))
    Uce.call(e, t) && gT(r, t, e[t]);
  if (pT)
    for (var t of pT(e))
      jce.call(e, t) && gT(r, t, e[t]);
  return r;
};
class J_ extends Rse {
  constructor(e, t, n, i = eh, s = void 0) {
    super(e, t, n, i), this.core = e, this.logger = t, this.name = n, this.map = /* @__PURE__ */ new Map(), this.version = lce, this.cached = [], this.initialized = !1, this.storagePrefix = eh, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !ts(o) ? this.map.set(this.getKey(o), o) : hie(o) ? this.map.set(o.id, o) : fie(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a }), this.map.set(o, a), await this.persist());
    }, this.get = (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((a) => Object.keys(o).every((c) => woe(a[c], o[c]))) : this.values), this.update = async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a });
      const c = mT(mT({}, this.getData(o)), a);
      this.map.set(o, c), await this.persist();
    }, this.delete = async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a }), this.map.delete(o), await this.persist());
    }, this.logger = dr.generateChildLogger(t, this.name), this.storagePrefix = i, this.getKey = s;
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: n } = He("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = He("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class Wce {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = pce, this.version = gce, this.events = new YS(), this.initialized = !1, this.storagePrefix = eh, this.ignoredPayloadTypes = [Od], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }, this.create = async () => {
      this.isInitialized();
      const n = X6(), i = await this.core.crypto.setSymKey(n), s = ba(ft.FIVE_MINUTES), o = { protocol: fk }, a = { topic: i, expiry: s, relay: o, active: !1 }, c = tie({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: n, relay: o });
      return await this.pairings.set(i, a), await this.core.relayer.subscribe(i), this.core.expirer.set(i, s), { topic: i, uri: c };
    }, this.pair = async (n) => {
      this.isInitialized(), this.isValidPair(n);
      const { topic: i, symKey: s, relay: o } = I9(n.uri);
      let a;
      if (this.pairings.keys.includes(i) && (a = this.pairings.get(i), a.active))
        throw new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
      const c = ba(ft.FIVE_MINUTES), u = { topic: i, relay: o, expiry: c, active: !1 };
      return await this.pairings.set(i, u), this.core.expirer.set(i, c), n.activatePairing && await this.activate({ topic: i }), this.events.emit(Z1.create, u), this.core.crypto.keychain.has(i) || (await this.core.crypto.setSymKey(s, i), await this.core.relayer.subscribe(i, { relay: o })), u;
    }, this.activate = async ({ topic: n }) => {
      this.isInitialized();
      const i = ba(ft.THIRTY_DAYS);
      await this.pairings.update(n, { active: !0, expiry: i }), this.core.expirer.set(n, i);
    }, this.ping = async (n) => {
      this.isInitialized(), await this.isValidPing(n);
      const { topic: i } = n;
      if (this.pairings.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_pairingPing", {}), { done: o, resolve: a, reject: c } = Sp();
        this.events.once(zn("pairing_ping", s), ({ error: u }) => {
          u ? c(u) : a();
        }), await o();
      }
    }, this.updateExpiry = async ({ topic: n, expiry: i }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: i });
    }, this.updateMetadata = async ({ topic: n, metadata: i }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: i });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: i } = n;
      this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", Cn("USER_DISCONNECTED")), await this.deletePairing(i));
    }, this.sendRequest = async (n, i, s) => {
      const o = Kp(i, s), a = await this.core.crypto.encode(n, o), c = P1[i].req;
      return this.core.history.set(n, o), this.core.relayer.publish(n, a, c), o.id;
    }, this.sendResult = async (n, i, s) => {
      const o = q_(n, s), a = await this.core.crypto.encode(i, o), c = await this.core.history.get(i, n), u = P1[c.request.method].res;
      await this.core.relayer.publish(i, a, u), await this.core.history.resolve(o);
    }, this.sendError = async (n, i, s) => {
      const o = G_(n, s), a = await this.core.crypto.encode(i, o), c = await this.core.history.get(i, n), u = P1[c.request.method] ? P1[c.request.method].res : P1.unregistered_method.res;
      await this.core.relayer.publish(i, a, u), await this.core.history.resolve(o);
    }, this.deletePairing = async (n, i) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, Cn("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), i ? Promise.resolve() : this.core.expirer.del(n)]);
    }, this.cleanup = async () => {
      const n = this.pairings.getAll().filter((i) => hu(i.expiry));
      await Promise.all(n.map((i) => this.deletePairing(i.topic)));
    }, this.onRelayEventRequest = (n) => {
      const { topic: i, payload: s } = n;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i, s);
        default:
          return this.onUnknownRpcMethodRequest(i, s);
      }
    }, this.onRelayEventResponse = async (n) => {
      const { topic: i, payload: s } = n, o = (await this.core.history.get(i, s.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i, s);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }, this.onPairingPingRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(s, n, !0), this.events.emit(Z1.ping, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onPairingPingResponse = (n, i) => {
      const { id: s } = i;
      setTimeout(() => {
        tl(i) ? this.events.emit(zn("pairing_ping", s), {}) : _a(i) && this.events.emit(zn("pairing_ping", s), { error: i.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(Z1.delete, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodRequest = async (n, i) => {
      const { id: s, method: o } = i;
      try {
        if (this.registeredMethods.includes(o))
          return;
        const a = Cn("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(s, n, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onUnknownRpcMethodResponse = (n) => {
      this.registeredMethods.includes(n) || this.logger.error(Cn("WC_METHOD_UNSUPPORTED", n));
    }, this.isValidPair = (n) => {
      var i;
      if (!As(n)) {
        const { message: o } = He("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw new Error(o);
      }
      if (!uie(n.uri)) {
        const { message: o } = He("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw new Error(o);
      }
      const s = I9(n.uri);
      if (!((i = s == null ? void 0 : s.relay) != null && i.protocol)) {
        const { message: o } = He("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(o);
      }
      if (!(s != null && s.symKey)) {
        const { message: o } = He("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(o);
      }
    }, this.isValidPing = async (n) => {
      if (!As(n)) {
        const { message: s } = He("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidDisconnect = async (n) => {
      if (!As(n)) {
        const { message: s } = He("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidPairingTopic = async (n) => {
      if (!ci(n, !1)) {
        const { message: i } = He("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(i);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: i } = He("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(i);
      }
      if (hu(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: i } = He("EXPIRED", `pairing topic: ${n}`);
        throw new Error(i);
      }
    }, this.core = e, this.logger = dr.generateChildLogger(t, this.name), this.pairings = new J_(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(Di.message, async (e) => {
      const { topic: t, message: n } = e;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n)))
        return;
      const i = await this.core.crypto.decode(t, n);
      try {
        pC(i) ? (this.core.history.set(t, i), this.onRelayEventRequest({ topic: t, payload: i })) : K_(i) && (await this.core.history.resolve(i), await this.onRelayEventResponse({ topic: t, payload: i }), this.core.history.delete(t, i.id));
      } catch (s) {
        this.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(So.expired, async (e) => {
      const { topic: t } = kD(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(Z1.expire, { topic: t }));
    });
  }
}
class Hce extends Sse {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new Wi.EventEmitter(), this.name = mce, this.version = wce, this.cached = [], this.initialized = !1, this.storagePrefix = eh, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (n, i, s) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: i, chainId: s }), this.records.has(i.id))
        return;
      const o = { id: i.id, topic: n, request: { method: i.method, params: i.params || null }, chainId: s, expiry: ba(ft.THIRTY_DAYS) };
      this.records.set(o.id, o), this.events.emit(Ya.created, o);
    }, this.resolve = async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id))
        return;
      const i = await this.getRecord(n.id);
      typeof i.response > "u" && (i.response = _a(n) ? { error: n.error } : { result: n.result }, this.records.set(i.id, i), this.events.emit(Ya.updated, i));
    }, this.get = async (n, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: i }), await this.getRecord(i)), this.delete = (n, i) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i }), this.values.forEach((s) => {
        if (s.topic === n) {
          if (typeof i < "u" && s.id !== i)
            return;
          this.records.delete(s.id), this.events.emit(Ya.deleted, s);
        }
      });
    }, this.exists = async (n, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === n : !1), this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = dr.generateChildLogger(t, this.name);
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const n = { topic: t.topic, request: Kp(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: n } = He("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(Ya.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = He("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(Ya.created, (e) => {
      const t = Ya.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(Ya.updated, (e) => {
      const t = Ya.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(Ya.deleted, (e) => {
      const t = Ya.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.core.heartbeat.on(zg.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        ft.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class zce extends Ose {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new Wi.EventEmitter(), this.name = yce, this.version = vce, this.cached = [], this.initialized = !1, this.storagePrefix = eh, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (n) => {
      try {
        const i = this.formatTarget(n);
        return typeof this.getExpiration(i) < "u";
      } catch {
        return !1;
      }
    }, this.set = (n, i) => {
      this.isInitialized();
      const s = this.formatTarget(n), o = { target: s, expiry: i };
      this.expirations.set(s, o), this.checkExpiry(s, o), this.events.emit(So.created, { target: s, expiration: o });
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.formatTarget(n);
      return this.getExpiration(i);
    }, this.del = (n) => {
      if (this.isInitialized(), this.has(n)) {
        const i = this.formatTarget(n), s = this.getExpiration(i);
        this.expirations.delete(i), this.events.emit(So.deleted, { target: i, expiration: s });
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = dr.generateChildLogger(t, this.name);
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return Hne(e);
    if (typeof e == "number")
      return zne(e);
    const { message: t } = He("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(So.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = He("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: n } = He("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: n } = t;
    ft.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(So.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(zg.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(So.created, (e) => {
      const t = So.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(So.expired, (e) => {
      const t = So.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(So.deleted, (e) => {
      const t = So.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class Vce extends Nse {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = c4, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (n) => {
      if (this.verifyDisabled || jg() || !Wg())
        return;
      const i = this.getVerifyUrl(n == null ? void 0 : n.verifyUrl);
      this.verifyUrl !== i && this.removeIframe(), this.verifyUrl = i;
      try {
        await this.createIframe();
      } catch (s) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ix;
        try {
          await this.createIframe();
        } catch (s) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s), this.verifyDisabled = !0;
        }
      }
    }, this.register = async (n) => {
      this.initialized ? this.sendPost(n.attestationId) : (this.addToQueue(n.attestationId), await this.init());
    }, this.resolve = async (n) => {
      if (this.isDevEnv)
        return "";
      const i = this.getVerifyUrl(n == null ? void 0 : n.verifyUrl);
      let s;
      try {
        s = await this.fetchAttestation(n.attestationId, i);
      } catch (o) {
        this.logger.info(`failed to resolve attestation: ${n.attestationId} from url: ${i}`), this.logger.info(o), s = await this.fetchAttestation(n.attestationId, ix);
      }
      return s;
    }, this.fetchAttestation = async (n, i) => {
      this.logger.info(`resolving attestation: ${n} from url: ${i}`);
      const s = this.startAbortTimer(ft.ONE_SECOND * 2), o = await fetch(`${i}/attestation/${n}`, { signal: this.abortController.signal });
      return clearTimeout(s), o.status === 200 ? await o.json() : void 0;
    }, this.addToQueue = (n) => {
      this.queue.push(n);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((n) => this.sendPost(n)), this.queue = []);
    }, this.sendPost = (n) => {
      var i;
      try {
        if (!this.iframe)
          return;
        (i = this.iframe.contentWindow) == null || i.postMessage(n, "*"), this.logger.info(`postMessage sent: ${n} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let n;
      const i = (s) => {
        s.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", i), n());
      };
      await Promise.race([new Promise((s) => {
        if (document.getElementById(c4))
          return s();
        window.addEventListener("message", i);
        const o = document.createElement("iframe");
        o.id = c4, o.src = `${this.verifyUrl}/${this.projectId}`, o.style.display = "none", document.body.append(o), this.iframe = o, n = s;
      }), new Promise((s, o) => setTimeout(() => {
        window.removeEventListener("message", i), o("verify iframe load timeout");
      }, ft.toMiliseconds(ft.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);
    }, this.getVerifyUrl = (n) => {
      let i = n || Op;
      return bce.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${Op}`), i = Op), i;
    }, this.logger = dr.generateChildLogger(t, this.name), this.verifyUrl = Op, this.abortController = new AbortController(), this.isDevEnv = cC() && process.env.IS_VITEST;
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), ft.toMiliseconds(e));
  }
}
class qce extends Pse {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = _ce, this.registerDeviceToken = async (n) => {
      const { clientId: i, token: s, notificationType: o, enableEncrypted: a = !1 } = n, c = `${Ece}/${this.projectId}/clients`;
      await _oe(c, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i, type: o, token: s, always_raw: a }) });
    }, this.logger = dr.generateChildLogger(t, this.context);
  }
}
var Gce = Object.defineProperty, wT = Object.getOwnPropertySymbols, Kce = Object.prototype.hasOwnProperty, Zce = Object.prototype.propertyIsEnumerable, yT = (r, e, t) => e in r ? Gce(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, vT = (r, e) => {
  for (var t in e || (e = {}))
    Kce.call(e, t) && yT(r, t, e[t]);
  if (wT)
    for (var t of wT(e))
      Zce.call(e, t) && yT(r, t, e[t]);
  return r;
};
class mC extends xse {
  constructor(e) {
    super(e), this.protocol = hk, this.version = qae, this.name = gC, this.events = new Wi.EventEmitter(), this.initialized = !1, this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || dk, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : dr.pino(dr.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || Gae.logger }));
    this.logger = dr.generateChildLogger(t, this.name), this.heartbeat = new zg.HeartBeat(), this.crypto = new Sce(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Hce(this, this.logger), this.expirer = new zce(this, this.logger), this.storage = e != null && e.storage ? e.storage : new pse(vT(vT({}, Kae), e == null ? void 0 : e.storageOptions)), this.relayer = new Bce({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Wce(this, this.logger), this.verify = new Vce(this.projectId || "", this.logger), this.echoClient = new qce(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new mC(e);
    await t.initialize();
    const n = await t.crypto.getClientId();
    return await t.storage.setItem(uce, n), t;
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const Jce = mC, pk = "wc", gk = 2, mk = "client", wC = `${pk}@${gk}:${mk}:`, u4 = { name: mk, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.com" }, bT = "WALLETCONNECT_DEEPLINK_CHOICE", Qce = "proposal", wk = "Proposal expired", Yce = "session", Xv = ft.SEVEN_DAYS, Xce = "engine", D1 = { wc_sessionPropose: { req: { ttl: ft.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: ft.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: ft.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: ft.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: ft.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: ft.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: ft.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: ft.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: ft.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: ft.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: ft.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: ft.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: ft.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: ft.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: ft.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: ft.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, h4 = { min: ft.FIVE_MINUTES, max: ft.SEVEN_DAYS }, Xc = { idle: "IDLE", active: "ACTIVE" }, ele = "request", tle = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var rle = Object.defineProperty, nle = Object.defineProperties, ile = Object.getOwnPropertyDescriptors, _T = Object.getOwnPropertySymbols, sle = Object.prototype.hasOwnProperty, ole = Object.prototype.propertyIsEnumerable, ET = (r, e, t) => e in r ? rle(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Es = (r, e) => {
  for (var t in e || (e = {}))
    sle.call(e, t) && ET(r, t, e[t]);
  if (_T)
    for (var t of _T(e))
      ole.call(e, t) && ET(r, t, e[t]);
  return r;
}, k1 = (r, e) => nle(r, ile(e));
class ale extends Dse {
  constructor(e) {
    super(e), this.name = Xce, this.events = new YS(), this.initialized = !1, this.ignoredPayloadTypes = [Od], this.requestQueue = { state: Xc.idle, queue: [] }, this.sessionRequestQueue = { state: Xc.idle, queue: [] }, this.requestQueueDelay = ft.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(D1) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, ft.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (t) => {
      await this.isInitialized();
      const n = k1(Es({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });
      await this.isValidConnect(n);
      const { pairingTopic: i, requiredNamespaces: s, optionalNamespaces: o, sessionProperties: a, relays: c } = n;
      let u = i, f, d = !1;
      if (u && (d = this.client.core.pairing.pairings.get(u).active), !u || !d) {
        const { topic: $, uri: D } = await this.client.core.pairing.create();
        u = $, f = D;
      }
      const m = await this.client.core.crypto.generateKeyPair(), y = Es({ requiredNamespaces: s, optionalNamespaces: o, relays: c ?? [{ protocol: fk }], proposer: { publicKey: m, metadata: this.client.metadata } }, a && { sessionProperties: a }), { reject: b, resolve: I, done: k } = Sp(ft.FIVE_MINUTES, wk);
      if (this.events.once(zn("session_connect"), async ({ error: $, session: D }) => {
        if ($)
          b($);
        else if (D) {
          D.self.publicKey = m;
          const L = k1(Es({}, D), { requiredNamespaces: D.requiredNamespaces, optionalNamespaces: D.optionalNamespaces });
          await this.client.session.set(D.topic, L), await this.setExpiry(D.topic, D.expiry), u && await this.client.core.pairing.updateMetadata({ topic: u, metadata: D.peer.metadata }), I(L);
        }
      }), !u) {
        const { message: $ } = He("NO_MATCHING_KEY", `connect() pairing topic: ${u}`);
        throw new Error($);
      }
      const R = await this.sendRequest({ topic: u, method: "wc_sessionPropose", params: y }), T = ba(ft.FIVE_MINUTES);
      return await this.setProposal(R, Es({ id: R, expiry: T }, y)), { uri: f, approval: k };
    }, this.pair = async (t) => (await this.isInitialized(), await this.client.core.pairing.pair(t)), this.approve = async (t) => {
      await this.isInitialized(), await this.isValidApprove(t);
      const { id: n, relayProtocol: i, namespaces: s, sessionProperties: o } = t, a = this.client.proposal.get(n);
      let { pairingTopic: c, proposer: u, requiredNamespaces: f, optionalNamespaces: d } = a;
      c = c || "", Gp(f) || (f = sie(s, "approve()"));
      const m = await this.client.core.crypto.generateKeyPair(), y = u.publicKey, b = await this.client.core.crypto.generateSharedKey(m, y);
      c && n && (await this.client.core.pairing.updateMetadata({ topic: c, metadata: u.metadata }), await this.sendResult({ id: n, topic: c, result: { relay: { protocol: i ?? "irn" }, responderPublicKey: m } }), await this.client.proposal.delete(n, Cn("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: c }));
      const I = Es({ relay: { protocol: i ?? "irn" }, namespaces: s, requiredNamespaces: f, optionalNamespaces: d, pairingTopic: c, controller: { publicKey: m, metadata: this.client.metadata }, expiry: ba(Xv) }, o && { sessionProperties: o });
      await this.client.core.relayer.subscribe(b), await this.sendRequest({ topic: b, method: "wc_sessionSettle", params: I, throwOnFailedPublish: !0 });
      const k = k1(Es({}, I), { topic: b, pairingTopic: c, acknowledged: !1, self: I.controller, peer: { publicKey: u.publicKey, metadata: u.metadata }, controller: m });
      return await this.client.session.set(b, k), await this.setExpiry(b, ba(Xv)), { topic: b, acknowledged: () => new Promise((R) => setTimeout(() => R(this.client.session.get(b)), 500)) };
    }, this.reject = async (t) => {
      await this.isInitialized(), await this.isValidReject(t);
      const { id: n, reason: i } = t, { pairingTopic: s } = this.client.proposal.get(n);
      s && (await this.sendError(n, s, i), await this.client.proposal.delete(n, Cn("USER_DISCONNECTED")));
    }, this.update = async (t) => {
      await this.isInitialized(), await this.isValidUpdate(t);
      const { topic: n, namespaces: i } = t, s = await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: i } }), { done: o, resolve: a, reject: c } = Sp();
      return this.events.once(zn("session_update", s), ({ error: u }) => {
        u ? c(u) : a();
      }), await this.client.session.update(n, { namespaces: i }), { acknowledged: o };
    }, this.extend = async (t) => {
      await this.isInitialized(), await this.isValidExtend(t);
      const { topic: n } = t, i = await this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {} }), { done: s, resolve: o, reject: a } = Sp();
      return this.events.once(zn("session_extend", i), ({ error: c }) => {
        c ? a(c) : o();
      }), await this.setExpiry(n, ba(Xv)), { acknowledged: s };
    }, this.request = async (t) => {
      await this.isInitialized(), await this.isValidRequest(t);
      const { chainId: n, request: i, topic: s, expiry: o } = t, a = dC(), { done: c, resolve: u, reject: f } = Sp(o, "Request expired. Please try again.");
      return this.events.once(zn("session_request", a), ({ error: d, result: m }) => {
        d ? f(d) : u(m);
      }), await Promise.all([new Promise(async (d) => {
        await this.sendRequest({ clientRpcId: a, topic: s, method: "wc_sessionRequest", params: { request: i, chainId: n }, expiry: o, throwOnFailedPublish: !0 }).catch((m) => f(m)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: a }), d();
      }), new Promise(async (d) => {
        const m = await qne(this.client.core.storage, bT);
        Vne({ id: a, topic: s, wcDeepLink: m }), d();
      }), c()]).then((d) => d[2]);
    }, this.respond = async (t) => {
      await this.isInitialized(), await this.isValidRespond(t);
      const { topic: n, response: i } = t, { id: s } = i;
      tl(i) ? await this.sendResult({ id: s, topic: n, result: i.result, throwOnFailedPublish: !0 }) : _a(i) && await this.sendError(s, n, i.error), this.cleanupAfterResponse(t);
    }, this.ping = async (t) => {
      await this.isInitialized(), await this.isValidPing(t);
      const { topic: n } = t;
      if (this.client.session.keys.includes(n)) {
        const i = await this.sendRequest({ topic: n, method: "wc_sessionPing", params: {} }), { done: s, resolve: o, reject: a } = Sp();
        this.events.once(zn("session_ping", i), ({ error: c }) => {
          c ? a(c) : o();
        }), await s();
      } else
        this.client.core.pairing.pairings.keys.includes(n) && await this.client.core.pairing.ping({ topic: n });
    }, this.emit = async (t) => {
      await this.isInitialized(), await this.isValidEmit(t);
      const { topic: n, event: i, chainId: s } = t;
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: i, chainId: s } });
    }, this.disconnect = async (t) => {
      await this.isInitialized(), await this.isValidDisconnect(t);
      const { topic: n } = t;
      this.client.session.keys.includes(n) ? (await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: Cn("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession(n)) : await this.client.core.pairing.disconnect({ topic: n });
    }, this.find = (t) => (this.isInitialized(), this.client.session.getAll().filter((n) => cie(n, t))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (t) => {
      if (t.pairingTopic)
        try {
          const n = this.client.core.pairing.pairings.get(t.pairingTopic), i = this.client.core.pairing.pairings.getAll().filter((s) => {
            var o, a;
            return ((o = s.peerMetadata) == null ? void 0 : o.url) && ((a = s.peerMetadata) == null ? void 0 : a.url) === t.peer.metadata.url && s.topic && s.topic !== n.topic;
          });
          if (i.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (n) {
          this.client.logger.error(n);
        }
    }, this.deleteSession = async (t, n) => {
      const { self: i } = this.client.session.get(t);
      await this.client.core.relayer.unsubscribe(t), this.client.session.delete(t, Cn("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(i.publicKey) && await this.client.core.crypto.deleteKeyPair(i.publicKey), this.client.core.crypto.keychain.has(t) && await this.client.core.crypto.deleteSymKey(t), n || this.client.core.expirer.del(t), this.client.core.storage.removeItem(bT).catch((s) => this.client.logger.warn(s)), this.getPendingSessionRequests().forEach((s) => {
        s.topic === t && this.deletePendingSessionRequest(s.id, Cn("USER_DISCONNECTED"));
      });
    }, this.deleteProposal = async (t, n) => {
      await Promise.all([this.client.proposal.delete(t, Cn("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(t)]);
    }, this.deletePendingSessionRequest = async (t, n, i = !1) => {
      await Promise.all([this.client.pendingRequest.delete(t, n), i ? Promise.resolve() : this.client.core.expirer.del(t)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== t), i && (this.sessionRequestQueue.state = Xc.idle);
    }, this.setExpiry = async (t, n) => {
      this.client.session.keys.includes(t) && await this.client.session.update(t, { expiry: n }), this.client.core.expirer.set(t, n);
    }, this.setProposal = async (t, n) => {
      await this.client.proposal.set(t, n), this.client.core.expirer.set(t, n.expiry);
    }, this.setPendingSessionRequest = async (t) => {
      const n = D1.wc_sessionRequest.req.ttl, { id: i, topic: s, params: o, verifyContext: a } = t;
      await this.client.pendingRequest.set(i, { id: i, topic: s, params: o, verifyContext: a }), n && this.client.core.expirer.set(i, ba(n));
    }, this.sendRequest = async (t) => {
      const { topic: n, method: i, params: s, expiry: o, relayRpcId: a, clientRpcId: c, throwOnFailedPublish: u } = t, f = Kp(i, s, c);
      if (Wg() && tle.includes(i)) {
        const y = qp(JSON.stringify(f));
        this.client.core.verify.register({ attestationId: y });
      }
      const d = await this.client.core.crypto.encode(n, f), m = D1[i].req;
      return o && (m.ttl = o), a && (m.id = a), this.client.core.history.set(n, f), u ? (m.internal = k1(Es({}, m.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, d, m)) : this.client.core.relayer.publish(n, d, m).catch((y) => this.client.logger.error(y)), f.id;
    }, this.sendResult = async (t) => {
      const { id: n, topic: i, result: s, throwOnFailedPublish: o } = t, a = q_(n, s), c = await this.client.core.crypto.encode(i, a), u = await this.client.core.history.get(i, n), f = D1[u.request.method].res;
      o ? (f.internal = k1(Es({}, f.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, c, f)) : this.client.core.relayer.publish(i, c, f).catch((d) => this.client.logger.error(d)), await this.client.core.history.resolve(a);
    }, this.sendError = async (t, n, i) => {
      const s = G_(t, i), o = await this.client.core.crypto.encode(n, s), a = await this.client.core.history.get(n, t), c = D1[a.request.method].res;
      this.client.core.relayer.publish(n, o, c), await this.client.core.history.resolve(s);
    }, this.cleanup = async () => {
      const t = [], n = [];
      this.client.session.getAll().forEach((i) => {
        hu(i.expiry) && t.push(i.topic);
      }), this.client.proposal.getAll().forEach((i) => {
        hu(i.expiry) && n.push(i.id);
      }), await Promise.all([...t.map((i) => this.deleteSession(i)), ...n.map((i) => this.deleteProposal(i))]);
    }, this.onRelayEventRequest = async (t) => {
      this.requestQueue.queue.push(t), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === Xc.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = Xc.active;
        const t = this.requestQueue.queue.shift();
        if (t)
          try {
            this.processRequest(t), await new Promise((n) => setTimeout(n, 300));
          } catch (n) {
            this.client.logger.warn(n);
          }
      }
      this.requestQueue.state = Xc.idle;
    }, this.processRequest = (t) => {
      const { topic: n, payload: i } = t, s = i.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(n, i);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(n, i);
        case "wc_sessionPing":
          return this.onSessionPingRequest(n, i);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequest(n, i);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(n, i);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (t) => {
      const { topic: n, payload: i } = t, s = (await this.client.core.history.get(n, i.id)).request.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, i);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, i);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, i);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onRelayEventUnknownPayload = (t) => {
      const { topic: n } = t, { message: i } = He("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(i);
    }, this.onSessionProposeRequest = async (t, n) => {
      const { params: i, id: s } = n;
      try {
        this.isValidConnect(Es({}, n.params));
        const o = ba(ft.FIVE_MINUTES), a = Es({ id: s, pairingTopic: t, expiry: o }, i);
        await this.setProposal(s, a);
        const c = qp(JSON.stringify(n)), u = await this.getVerifyContext(c, a.proposer.metadata);
        this.client.events.emit("session_proposal", { id: s, params: a, verifyContext: u });
      } catch (o) {
        await this.sendError(s, t, o), this.client.logger.error(o);
      }
    }, this.onSessionProposeResponse = async (t, n) => {
      const { id: i } = n;
      if (tl(n)) {
        const { result: s } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: s });
        const o = this.client.proposal.get(i);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o });
        const a = o.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a });
        const c = s.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c });
        const u = await this.client.core.crypto.generateSharedKey(a, c);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: u });
        const f = await this.client.core.relayer.subscribe(u);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: f }), await this.client.core.pairing.activate({ topic: t });
      } else
        _a(n) && (await this.client.proposal.delete(i, Cn("USER_DISCONNECTED")), this.events.emit(zn("session_connect"), { error: n.error }));
    }, this.onSessionSettleRequest = async (t, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidSessionSettleRequest(s);
        const { relay: o, controller: a, expiry: c, namespaces: u, requiredNamespaces: f, optionalNamespaces: d, sessionProperties: m, pairingTopic: y } = n.params, b = Es({ topic: t, relay: o, expiry: c, namespaces: u, acknowledged: !0, pairingTopic: y, requiredNamespaces: f, optionalNamespaces: d, controller: a.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, m && { sessionProperties: m });
        await this.sendResult({ id: n.id, topic: t, result: !0 }), this.events.emit(zn("session_connect"), { session: b }), this.cleanupDuplicatePairings(b);
      } catch (o) {
        await this.sendError(i, t, o), this.client.logger.error(o);
      }
    }, this.onSessionSettleResponse = async (t, n) => {
      const { id: i } = n;
      tl(n) ? (await this.client.session.update(t, { acknowledged: !0 }), this.events.emit(zn("session_approve", i), {})) : _a(n) && (await this.client.session.delete(t, Cn("USER_DISCONNECTED")), this.events.emit(zn("session_approve", i), { error: n.error }));
    }, this.onSessionUpdateRequest = async (t, n) => {
      const { params: i, id: s } = n;
      try {
        const o = `${t}_session_update`, a = Jv.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidUpdate(Es({ topic: t }, i)), await this.client.session.update(t, { namespaces: i.namespaces }), await this.sendResult({ id: s, topic: t, result: !0 }), this.client.events.emit("session_update", { id: s, topic: t, params: i }), Jv.set(o, s);
      } catch (o) {
        await this.sendError(s, t, o), this.client.logger.error(o);
      }
    }, this.isRequestOutOfSync = (t, n) => parseInt(n.toString().slice(0, -3)) <= parseInt(t.toString().slice(0, -3)), this.onSessionUpdateResponse = (t, n) => {
      const { id: i } = n;
      tl(n) ? this.events.emit(zn("session_update", i), {}) : _a(n) && this.events.emit(zn("session_update", i), { error: n.error });
    }, this.onSessionExtendRequest = async (t, n) => {
      const { id: i } = n;
      try {
        this.isValidExtend({ topic: t }), await this.setExpiry(t, ba(Xv)), await this.sendResult({ id: i, topic: t, result: !0 }), this.client.events.emit("session_extend", { id: i, topic: t });
      } catch (s) {
        await this.sendError(i, t, s), this.client.logger.error(s);
      }
    }, this.onSessionExtendResponse = (t, n) => {
      const { id: i } = n;
      tl(n) ? this.events.emit(zn("session_extend", i), {}) : _a(n) && this.events.emit(zn("session_extend", i), { error: n.error });
    }, this.onSessionPingRequest = async (t, n) => {
      const { id: i } = n;
      try {
        this.isValidPing({ topic: t }), await this.sendResult({ id: i, topic: t, result: !0 }), this.client.events.emit("session_ping", { id: i, topic: t });
      } catch (s) {
        await this.sendError(i, t, s), this.client.logger.error(s);
      }
    }, this.onSessionPingResponse = (t, n) => {
      const { id: i } = n;
      setTimeout(() => {
        tl(n) ? this.events.emit(zn("session_ping", i), {}) : _a(n) && this.events.emit(zn("session_ping", i), { error: n.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (t, n) => {
      const { id: i } = n;
      try {
        this.isValidDisconnect({ topic: t, reason: n.params }), await Promise.all([new Promise((s) => {
          this.client.core.relayer.once(Di.publish, async () => {
            s(await this.deleteSession(t));
          });
        }), this.sendResult({ id: i, topic: t, result: !0 })]), this.client.events.emit("session_delete", { id: i, topic: t });
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onSessionRequest = async (t, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidRequest(Es({ topic: t }, s));
        const o = qp(JSON.stringify(Kp("wc_sessionRequest", s, i))), a = this.client.session.get(t), c = await this.getVerifyContext(o, a.peer.metadata), u = { id: i, topic: t, params: s, verifyContext: c };
        await this.setPendingSessionRequest(u), this.addSessionRequestToSessionRequestQueue(u), this.processSessionRequestQueue();
      } catch (o) {
        await this.sendError(i, t, o), this.client.logger.error(o);
      }
    }, this.onSessionRequestResponse = (t, n) => {
      const { id: i } = n;
      tl(n) ? this.events.emit(zn("session_request", i), { result: n.result }) : _a(n) && this.events.emit(zn("session_request", i), { error: n.error });
    }, this.onSessionEventRequest = async (t, n) => {
      const { id: i, params: s } = n;
      try {
        const o = `${t}_session_event_${s.event.name}`, a = Jv.get(o);
        if (a && this.isRequestOutOfSync(a, i)) {
          this.client.logger.info(`Discarding out of sync request - ${i}`);
          return;
        }
        this.isValidEmit(Es({ topic: t }, s)), this.client.events.emit("session_event", { id: i, topic: t, params: s }), Jv.set(o, i);
      } catch (o) {
        await this.sendError(i, t, o), this.client.logger.error(o);
      }
    }, this.addSessionRequestToSessionRequestQueue = (t) => {
      this.sessionRequestQueue.queue.push(t);
    }, this.cleanupAfterResponse = (t) => {
      this.deletePendingSessionRequest(t.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = Xc.idle, this.processSessionRequestQueue();
      }, ft.toMiliseconds(this.requestQueueDelay));
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === Xc.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t = this.sessionRequestQueue.queue[0];
      if (!t) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = Xc.active, this.client.events.emit("session_request", t);
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.onPairingCreated = (t) => {
      if (t.active)
        return;
      const n = this.client.proposal.getAll().find((i) => i.pairingTopic === t.topic);
      n && this.onSessionProposeRequest(t.topic, Kp("wc_sessionPropose", { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties }, n.id));
    }, this.isValidConnect = async (t) => {
      if (!As(t)) {
        const { message: c } = He("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
        throw new Error(c);
      }
      const { pairingTopic: n, requiredNamespaces: i, optionalNamespaces: s, sessionProperties: o, relays: a } = t;
      if (ts(n) || await this.isValidPairingTopic(n), !bie(a, !0)) {
        const { message: c } = He("MISSING_OR_INVALID", `connect() relays: ${a}`);
        throw new Error(c);
      }
      !ts(i) && Gp(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !ts(s) && Gp(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), ts(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.validateNamespaces = (t, n) => {
      const i = vie(t, "connect()", n);
      if (i)
        throw new Error(i.message);
    }, this.isValidApprove = async (t) => {
      if (!As(t))
        throw new Error(He("MISSING_OR_INVALID", `approve() params: ${t}`).message);
      const { id: n, namespaces: i, relayProtocol: s, sessionProperties: o } = t;
      await this.isValidProposalId(n);
      const a = this.client.proposal.get(n), c = Nb(i, "approve()");
      if (c)
        throw new Error(c.message);
      const u = O9(a.requiredNamespaces, i, "approve()");
      if (u)
        throw new Error(u.message);
      if (!ci(s, !0)) {
        const { message: f } = He("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(f);
      }
      ts(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.isValidReject = async (t) => {
      if (!As(t)) {
        const { message: s } = He("MISSING_OR_INVALID", `reject() params: ${t}`);
        throw new Error(s);
      }
      const { id: n, reason: i } = t;
      if (await this.isValidProposalId(n), !Eie(i)) {
        const { message: s } = He("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
        throw new Error(s);
      }
    }, this.isValidSessionSettleRequest = (t) => {
      if (!As(t)) {
        const { message: u } = He("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
        throw new Error(u);
      }
      const { relay: n, controller: i, namespaces: s, expiry: o } = t;
      if (!LD(n)) {
        const { message: u } = He("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(u);
      }
      const a = die(i, "onSessionSettleRequest()");
      if (a)
        throw new Error(a.message);
      const c = Nb(s, "onSessionSettleRequest()");
      if (c)
        throw new Error(c.message);
      if (hu(o)) {
        const { message: u } = He("EXPIRED", "onSessionSettleRequest()");
        throw new Error(u);
      }
    }, this.isValidUpdate = async (t) => {
      if (!As(t)) {
        const { message: c } = He("MISSING_OR_INVALID", `update() params: ${t}`);
        throw new Error(c);
      }
      const { topic: n, namespaces: i } = t;
      await this.isValidSessionTopic(n);
      const s = this.client.session.get(n), o = Nb(i, "update()");
      if (o)
        throw new Error(o.message);
      const a = O9(s.requiredNamespaces, i, "update()");
      if (a)
        throw new Error(a.message);
    }, this.isValidExtend = async (t) => {
      if (!As(t)) {
        const { message: i } = He("MISSING_OR_INVALID", `extend() params: ${t}`);
        throw new Error(i);
      }
      const { topic: n } = t;
      await this.isValidSessionTopic(n);
    }, this.isValidRequest = async (t) => {
      if (!As(t)) {
        const { message: c } = He("MISSING_OR_INVALID", `request() params: ${t}`);
        throw new Error(c);
      }
      const { topic: n, request: i, chainId: s, expiry: o } = t;
      await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!T9(a, s)) {
        const { message: c } = He("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(c);
      }
      if (!xie(i)) {
        const { message: c } = He("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
        throw new Error(c);
      }
      if (!Aie(a, s, i.method)) {
        const { message: c } = He("MISSING_OR_INVALID", `request() method: ${i.method}`);
        throw new Error(c);
      }
      if (o && !Oie(o, h4)) {
        const { message: c } = He("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${h4.min} and ${h4.max}`);
        throw new Error(c);
      }
    }, this.isValidRespond = async (t) => {
      var n;
      if (!As(t)) {
        const { message: o } = He("MISSING_OR_INVALID", `respond() params: ${t}`);
        throw new Error(o);
      }
      const { topic: i, response: s } = t;
      try {
        await this.isValidSessionTopic(i);
      } catch (o) {
        throw (n = t == null ? void 0 : t.response) != null && n.id && this.cleanupAfterResponse(t), o;
      }
      if (!Sie(s)) {
        const { message: o } = He("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(o);
      }
    }, this.isValidPing = async (t) => {
      if (!As(t)) {
        const { message: i } = He("MISSING_OR_INVALID", `ping() params: ${t}`);
        throw new Error(i);
      }
      const { topic: n } = t;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidEmit = async (t) => {
      if (!As(t)) {
        const { message: a } = He("MISSING_OR_INVALID", `emit() params: ${t}`);
        throw new Error(a);
      }
      const { topic: n, event: i, chainId: s } = t;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!T9(o, s)) {
        const { message: a } = He("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(a);
      }
      if (!Cie(i)) {
        const { message: a } = He("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
      if (!Iie(o, s, i.name)) {
        const { message: a } = He("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
    }, this.isValidDisconnect = async (t) => {
      if (!As(t)) {
        const { message: i } = He("MISSING_OR_INVALID", `disconnect() params: ${t}`);
        throw new Error(i);
      }
      const { topic: n } = t;
      await this.isValidSessionOrPairingTopic(n);
    }, this.getVerifyContext = async (t, n) => {
      const i = { verified: { verifyUrl: n.verifyUrl || Op, validation: "UNKNOWN", origin: n.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: t, verifyUrl: n.verifyUrl });
        s && (i.verified.origin = s.origin, i.verified.isScam = s.isScam, i.verified.validation = s.origin === new URL(n.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.info(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(i)}`), i;
    }, this.validateSessionProps = (t, n) => {
      Object.values(t).forEach((i) => {
        if (!ci(i, !1)) {
          const { message: s } = He("MISSING_OR_INVALID", `${n} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
          throw new Error(s);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: e } = He("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(Di.message, async (e) => {
      const { topic: t, message: n } = e;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(n)))
        return;
      const i = await this.client.core.crypto.decode(t, n);
      try {
        pC(i) ? (this.client.core.history.set(t, i), this.onRelayEventRequest({ topic: t, payload: i })) : K_(i) ? (await this.client.core.history.resolve(i), await this.onRelayEventResponse({ topic: t, payload: i }), this.client.core.history.delete(t, i.id)) : this.onRelayEventUnknownPayload({ topic: t, payload: i });
      } catch (s) {
        this.client.logger.error(s);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(So.expired, async (e) => {
      const { topic: t, id: n } = kD(e.target);
      if (n && this.client.pendingRequest.keys.includes(n))
        return await this.deletePendingSessionRequest(n, He("EXPIRED"), !0);
      t ? this.client.session.keys.includes(t) && (await this.deleteSession(t, !0), this.client.events.emit("session_expire", { topic: t })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Z1.create, (e) => this.onPairingCreated(e));
  }
  isValidPairingTopic(e) {
    if (!ci(e, !1)) {
      const { message: t } = He("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(t);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: t } = He("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (hu(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: t } = He("EXPIRED", `pairing topic: ${e}`);
      throw new Error(t);
    }
  }
  async isValidSessionTopic(e) {
    if (!ci(e, !1)) {
      const { message: t } = He("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(t);
    }
    if (!this.client.session.keys.includes(e)) {
      const { message: t } = He("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (hu(this.client.session.get(e).expiry)) {
      await this.deleteSession(e);
      const { message: t } = He("EXPIRED", `session topic: ${e}`);
      throw new Error(t);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.client.session.keys.includes(e))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (ci(e, !1)) {
      const { message: t } = He("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(t);
    } else {
      const { message: t } = He("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(t);
    }
  }
  async isValidProposalId(e) {
    if (!_ie(e)) {
      const { message: t } = He("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(t);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: t } = He("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (hu(this.client.proposal.get(e).expiry)) {
      await this.deleteProposal(e);
      const { message: t } = He("EXPIRED", `proposal id: ${e}`);
      throw new Error(t);
    }
  }
}
class cle extends J_ {
  constructor(e, t) {
    super(e, t, Qce, wC), this.core = e, this.logger = t;
  }
}
class lle extends J_ {
  constructor(e, t) {
    super(e, t, Yce, wC), this.core = e, this.logger = t;
  }
}
class ule extends J_ {
  constructor(e, t) {
    super(e, t, ele, wC, (n) => n.id), this.core = e, this.logger = t;
  }
}
let hle = class yk extends Mse {
  constructor(e) {
    super(e), this.protocol = pk, this.version = gk, this.name = u4.name, this.events = new Wi.EventEmitter(), this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.removeAllListeners = (n) => this.events.removeAllListeners(n), this.connect = async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.pair = async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approve = async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.reject = async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.update = async (n) => {
      try {
        return await this.engine.update(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.extend = async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.request = async (n) => {
      try {
        return await this.engine.request(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.respond = async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.ping = async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.emit = async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.disconnect = async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.find = (n) => {
      try {
        return this.engine.find(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.name = (e == null ? void 0 : e.name) || u4.name, this.metadata = (e == null ? void 0 : e.metadata) || Bne();
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : dr.pino(dr.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || u4.logger }));
    this.core = (e == null ? void 0 : e.core) || new Jce(e), this.logger = dr.generateChildLogger(t, this.name), this.session = new lle(this.core, this.logger), this.proposal = new cle(this.core, this.logger), this.pendingRequest = new ule(this.core, this.logger), this.engine = new ale(this);
  }
  static async init(e) {
    const t = new yk(e);
    return await t.initialize(), t;
  }
  get context() {
    return dr.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
};
var sx = { exports: {} };
(function(r, e) {
  var t = typeof self < "u" ? self : ze, n = function() {
    function s() {
      this.fetch = !1, this.DOMException = t.DOMException;
    }
    return s.prototype = t, new s();
  }();
  (function(s) {
    (function(o) {
      var a = {
        searchParams: "URLSearchParams" in s,
        iterable: "Symbol" in s && "iterator" in Symbol,
        blob: "FileReader" in s && "Blob" in s && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in s,
        arrayBuffer: "ArrayBuffer" in s
      };
      function c(p) {
        return p && DataView.prototype.isPrototypeOf(p);
      }
      if (a.arrayBuffer)
        var u = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], f = ArrayBuffer.isView || function(p) {
          return p && u.indexOf(Object.prototype.toString.call(p)) > -1;
        };
      function d(p) {
        if (typeof p != "string" && (p = String(p)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(p))
          throw new TypeError("Invalid character in header field name");
        return p.toLowerCase();
      }
      function m(p) {
        return typeof p != "string" && (p = String(p)), p;
      }
      function y(p) {
        var w = {
          next: function() {
            var x = p.shift();
            return { done: x === void 0, value: x };
          }
        };
        return a.iterable && (w[Symbol.iterator] = function() {
          return w;
        }), w;
      }
      function b(p) {
        this.map = {}, p instanceof b ? p.forEach(function(w, x) {
          this.append(x, w);
        }, this) : Array.isArray(p) ? p.forEach(function(w) {
          this.append(w[0], w[1]);
        }, this) : p && Object.getOwnPropertyNames(p).forEach(function(w) {
          this.append(w, p[w]);
        }, this);
      }
      b.prototype.append = function(p, w) {
        p = d(p), w = m(w);
        var x = this.map[p];
        this.map[p] = x ? x + ", " + w : w;
      }, b.prototype.delete = function(p) {
        delete this.map[d(p)];
      }, b.prototype.get = function(p) {
        return p = d(p), this.has(p) ? this.map[p] : null;
      }, b.prototype.has = function(p) {
        return this.map.hasOwnProperty(d(p));
      }, b.prototype.set = function(p, w) {
        this.map[d(p)] = m(w);
      }, b.prototype.forEach = function(p, w) {
        for (var x in this.map)
          this.map.hasOwnProperty(x) && p.call(w, this.map[x], x, this);
      }, b.prototype.keys = function() {
        var p = [];
        return this.forEach(function(w, x) {
          p.push(x);
        }), y(p);
      }, b.prototype.values = function() {
        var p = [];
        return this.forEach(function(w) {
          p.push(w);
        }), y(p);
      }, b.prototype.entries = function() {
        var p = [];
        return this.forEach(function(w, x) {
          p.push([x, w]);
        }), y(p);
      }, a.iterable && (b.prototype[Symbol.iterator] = b.prototype.entries);
      function I(p) {
        if (p.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        p.bodyUsed = !0;
      }
      function k(p) {
        return new Promise(function(w, x) {
          p.onload = function() {
            w(p.result);
          }, p.onerror = function() {
            x(p.error);
          };
        });
      }
      function R(p) {
        var w = new FileReader(), x = k(w);
        return w.readAsArrayBuffer(p), x;
      }
      function T(p) {
        var w = new FileReader(), x = k(w);
        return w.readAsText(p), x;
      }
      function $(p) {
        for (var w = new Uint8Array(p), x = new Array(w.length), N = 0; N < w.length; N++)
          x[N] = String.fromCharCode(w[N]);
        return x.join("");
      }
      function D(p) {
        if (p.slice)
          return p.slice(0);
        var w = new Uint8Array(p.byteLength);
        return w.set(new Uint8Array(p)), w.buffer;
      }
      function L() {
        return this.bodyUsed = !1, this._initBody = function(p) {
          this._bodyInit = p, p ? typeof p == "string" ? this._bodyText = p : a.blob && Blob.prototype.isPrototypeOf(p) ? this._bodyBlob = p : a.formData && FormData.prototype.isPrototypeOf(p) ? this._bodyFormData = p : a.searchParams && URLSearchParams.prototype.isPrototypeOf(p) ? this._bodyText = p.toString() : a.arrayBuffer && a.blob && c(p) ? (this._bodyArrayBuffer = D(p.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(p) || f(p)) ? this._bodyArrayBuffer = D(p) : this._bodyText = p = Object.prototype.toString.call(p) : this._bodyText = "", this.headers.get("content-type") || (typeof p == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(p) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, a.blob && (this.blob = function() {
          var p = I(this);
          if (p)
            return p;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? I(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(R);
        }), this.text = function() {
          var p = I(this);
          if (p)
            return p;
          if (this._bodyBlob)
            return T(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve($(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, a.formData && (this.formData = function() {
          return this.text().then(X);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var P = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function v(p) {
        var w = p.toUpperCase();
        return P.indexOf(w) > -1 ? w : p;
      }
      function F(p, w) {
        w = w || {};
        var x = w.body;
        if (p instanceof F) {
          if (p.bodyUsed)
            throw new TypeError("Already read");
          this.url = p.url, this.credentials = p.credentials, w.headers || (this.headers = new b(p.headers)), this.method = p.method, this.mode = p.mode, this.signal = p.signal, !x && p._bodyInit != null && (x = p._bodyInit, p.bodyUsed = !0);
        } else
          this.url = String(p);
        if (this.credentials = w.credentials || this.credentials || "same-origin", (w.headers || !this.headers) && (this.headers = new b(w.headers)), this.method = v(w.method || this.method || "GET"), this.mode = w.mode || this.mode || null, this.signal = w.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && x)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(x);
      }
      F.prototype.clone = function() {
        return new F(this, { body: this._bodyInit });
      };
      function X(p) {
        var w = new FormData();
        return p.trim().split("&").forEach(function(x) {
          if (x) {
            var N = x.split("="), O = N.shift().replace(/\+/g, " "), U = N.join("=").replace(/\+/g, " ");
            w.append(decodeURIComponent(O), decodeURIComponent(U));
          }
        }), w;
      }
      function te(p) {
        var w = new b(), x = p.replace(/\r?\n[\t ]+/g, " ");
        return x.split(/\r?\n/).forEach(function(N) {
          var O = N.split(":"), U = O.shift().trim();
          if (U) {
            var q = O.join(":").trim();
            w.append(U, q);
          }
        }), w;
      }
      L.call(F.prototype);
      function se(p, w) {
        w || (w = {}), this.type = "default", this.status = w.status === void 0 ? 200 : w.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in w ? w.statusText : "OK", this.headers = new b(w.headers), this.url = w.url || "", this._initBody(p);
      }
      L.call(se.prototype), se.prototype.clone = function() {
        return new se(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new b(this.headers),
          url: this.url
        });
      }, se.error = function() {
        var p = new se(null, { status: 0, statusText: "" });
        return p.type = "error", p;
      };
      var we = [301, 302, 303, 307, 308];
      se.redirect = function(p, w) {
        if (we.indexOf(w) === -1)
          throw new RangeError("Invalid status code");
        return new se(null, { status: w, headers: { location: p } });
      }, o.DOMException = s.DOMException;
      try {
        new o.DOMException();
      } catch {
        o.DOMException = function(w, x) {
          this.message = w, this.name = x;
          var N = Error(w);
          this.stack = N.stack;
        }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
      }
      function H(p, w) {
        return new Promise(function(x, N) {
          var O = new F(p, w);
          if (O.signal && O.signal.aborted)
            return N(new o.DOMException("Aborted", "AbortError"));
          var U = new XMLHttpRequest();
          function q() {
            U.abort();
          }
          U.onload = function() {
            var B = {
              status: U.status,
              statusText: U.statusText,
              headers: te(U.getAllResponseHeaders() || "")
            };
            B.url = "responseURL" in U ? U.responseURL : B.headers.get("X-Request-URL");
            var E = "response" in U ? U.response : U.responseText;
            x(new se(E, B));
          }, U.onerror = function() {
            N(new TypeError("Network request failed"));
          }, U.ontimeout = function() {
            N(new TypeError("Network request failed"));
          }, U.onabort = function() {
            N(new o.DOMException("Aborted", "AbortError"));
          }, U.open(O.method, O.url, !0), O.credentials === "include" ? U.withCredentials = !0 : O.credentials === "omit" && (U.withCredentials = !1), "responseType" in U && a.blob && (U.responseType = "blob"), O.headers.forEach(function(B, E) {
            U.setRequestHeader(E, B);
          }), O.signal && (O.signal.addEventListener("abort", q), U.onreadystatechange = function() {
            U.readyState === 4 && O.signal.removeEventListener("abort", q);
          }), U.send(typeof O._bodyInit > "u" ? null : O._bodyInit);
        });
      }
      return H.polyfill = !0, s.fetch || (s.fetch = H, s.Headers = b, s.Request = F, s.Response = se), o.Headers = b, o.Request = F, o.Response = se, o.fetch = H, Object.defineProperty(o, "__esModule", { value: !0 }), o;
    })({});
  })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
  var i = n;
  e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, r.exports = e;
})(sx, sx.exports);
var fle = sx.exports;
const xT = /* @__PURE__ */ Ed(fle), dle = {
  Accept: "application/json",
  "Content-Type": "application/json"
}, ple = "POST", ST = {
  headers: dle,
  method: ple
}, CT = 10;
class gh {
  constructor(e, t = !1) {
    if (this.url = e, this.disableProviderPing = t, this.events = new Wi.EventEmitter(), this.isAvailable = !1, this.registering = !1, !Q9(e))
      throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    this.url = e, this.disableProviderPing = t;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable)
      throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e, t) {
    this.isAvailable || await this.register();
    try {
      const n = hd(e), s = await (await xT(this.url, Object.assign(Object.assign({}, ST), { body: n }))).json();
      this.onPayload({ data: s });
    } catch (n) {
      this.onError(e.id, n);
    }
  }
  async register(e = this.url) {
    if (!Q9(e))
      throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u")
            return i(new Error("HTTP connection is missing or invalid"));
          n();
        });
      });
    }
    this.url = e, this.registering = !0;
    try {
      if (!this.disableProviderPing) {
        const t = hd({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await xT(e, Object.assign(Object.assign({}, ST), { body: t }));
      }
      this.onOpen();
    } catch (t) {
      const n = this.parseError(t);
      throw this.events.emit("register_error", n), this.onClose(), n;
    }
  }
  onOpen() {
    this.isAvailable = !0, this.registering = !1, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = !1, this.registering = !1, this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const t = typeof e.data == "string" ? uy(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n = this.parseError(t), i = n.message || n.toString(), s = G_(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, t = this.url) {
    return ZD(e, t, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > CT && this.events.setMaxListeners(CT);
  }
}
const AT = "error", gle = "wss://relay.walletconnect.com", mle = "wc", wle = "universal_provider", IT = `${mle}@2:${wle}:`, yle = "https://rpc.walletconnect.com/v1/", Hl = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var $1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, ox = { exports: {} };
/**
* @license
* Lodash <https://lodash.com/>
* Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
* Released under MIT license <https://lodash.com/license>
* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
*/
(function(r, e) {
  (function() {
    var t, n = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", a = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", u = 500, f = "__lodash_placeholder__", d = 1, m = 2, y = 4, b = 1, I = 2, k = 1, R = 2, T = 4, $ = 8, D = 16, L = 32, P = 64, v = 128, F = 256, X = 512, te = 30, se = "...", we = 800, H = 16, p = 1, w = 2, x = 3, N = 1 / 0, O = 9007199254740991, U = 17976931348623157e292, q = NaN, B = 4294967295, E = B - 1, V = B >>> 1, be = [["ary", v], ["bind", k], ["bindKey", R], ["curry", $], ["curryRight", D], ["flip", X], ["partial", L], ["partialRight", P], ["rearg", F]], ve = "[object Arguments]", ne = "[object Array]", K = "[object AsyncFunction]", Y = "[object Boolean]", ee = "[object Date]", S = "[object DOMException]", M = "[object Error]", G = "[object Function]", ue = "[object GeneratorFunction]", Ee = "[object Map]", Le = "[object Number]", Fe = "[object Null]", De = "[object Object]", dt = "[object Promise]", or = "[object Proxy]", Qe = "[object RegExp]", We = "[object Set]", lt = "[object String]", qe = "[object Symbol]", Ye = "[object Undefined]", st = "[object WeakMap]", Ge = "[object WeakSet]", W = "[object ArrayBuffer]", _ = "[object DataView]", A = "[object Float32Array]", J = "[object Float64Array]", ae = "[object Int8Array]", le = "[object Int16Array]", ge = "[object Int32Array]", je = "[object Uint8Array]", Ue = "[object Uint8ClampedArray]", it = "[object Uint16Array]", jt = "[object Uint32Array]", at = /\b__p \+= '';/g, Jt = /\b(__p \+=) '' \+/g, _i = /(__e\(.*?\)|\b__t\)) \+\n'';/g, yr = /&(?:amp|lt|gt|quot|#39);/g, _r = /[&<>"']/g, Pr = RegExp(yr.source), It = RegExp(_r.source), Mt = /<%-([\s\S]+?)%>/g, Mr = /<%([\s\S]+?)%>/g, Nt = /<%=([\s\S]+?)%>/g, Rt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Hr = /^\w*$/, Bt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Dt = /[\\^$.*+?()[\]{}|]/g, zr = RegExp(Dt.source), kt = /^\s+/, $t = /\s/, Dr = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, xt = /\{\n\/\* \[wrapped with (.+)\] \*/, Ft = /,? & /, Vr = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, $r = /[()=,{}\[\]\/\s]/, Lr = /\\(\\)?/g, za = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, ar = /\w*$/, Br = /^[-+]0x[0-9a-f]+$/i, qo = /^0b[01]+$/i, Go = /^\[object .+?Constructor\]$/, Ko = /^0o[0-7]+$/i, Zo = /^(?:0|[1-9]\d*)$/, hi = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, ps = /($^)/, Jo = /['\n\r\u2028\u2029\\]/g, gs = "\\ud800-\\udfff", Qo = "\\u0300-\\u036f", Yo = "\\ufe20-\\ufe2f", ms = "\\u20d0-\\u20ff", lo = Qo + Yo + ms, uo = "\\u2700-\\u27bf", Vn = "a-z\\xdf-\\xf6\\xf8-\\xff", vh = "\\xac\\xb1\\xd7\\xf7", bh = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", _h = "\\u2000-\\u206f", Eh = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ql = "A-Z\\xc0-\\xd6\\xd8-\\xde", Hy = "\\ufe0e\\ufe0f", xh = vh + bh + _h + Eh, s1 = "[']", Sh = "[" + gs + "]", o1 = "[" + xh + "]", Ch = "[" + lo + "]", zy = "\\d+", mE = "[" + uo + "]", Vy = "[" + Vn + "]", qy = "[^" + gs + xh + zy + uo + Vn + ql + "]", zd = "\\ud83c[\\udffb-\\udfff]", wE = "(?:" + Ch + "|" + zd + ")", Gy = "[^" + gs + "]", Vd = "(?:\\ud83c[\\udde6-\\uddff]){2}", Gl = "[\\ud800-\\udbff][\\udc00-\\udfff]", Bs = "[" + ql + "]", Ky = "\\u200d", Zy = "(?:" + Vy + "|" + qy + ")", Va = "(?:" + Bs + "|" + qy + ")", Jy = "(?:" + s1 + "(?:d|ll|m|re|s|t|ve))?", Qy = "(?:" + s1 + "(?:D|LL|M|RE|S|T|VE))?", Yy = wE + "?", Xy = "[" + Hy + "]?", yE = "(?:" + Ky + "(?:" + [Gy, Vd, Gl].join("|") + ")" + Xy + Yy + ")*", Bc = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", ev = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", tv = Xy + Yy + yE, qd = "(?:" + [mE, Vd, Gl].join("|") + ")" + tv, vE = "(?:" + [Gy + Ch + "?", Ch, Vd, Gl, Sh].join("|") + ")", a1 = RegExp(s1, "g"), bE = RegExp(Ch, "g"), Gd = RegExp(zd + "(?=" + zd + ")|" + vE + tv, "g"), rv = RegExp([Bs + "?" + Vy + "+" + Jy + "(?=" + [o1, Bs, "$"].join("|") + ")", Va + "+" + Qy + "(?=" + [o1, Bs + Zy, "$"].join("|") + ")", Bs + "?" + Zy + "+" + Jy, Bs + "+" + Qy, ev, Bc, zy, qd].join("|"), "g"), nv = RegExp("[" + Ky + gs + lo + Hy + "]"), Ah = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, iv = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], _E = -1, qr = {};
    qr[A] = qr[J] = qr[ae] = qr[le] = qr[ge] = qr[je] = qr[Ue] = qr[it] = qr[jt] = !0, qr[ve] = qr[ne] = qr[W] = qr[Y] = qr[_] = qr[ee] = qr[M] = qr[G] = qr[Ee] = qr[Le] = qr[De] = qr[Qe] = qr[We] = qr[lt] = qr[st] = !1;
    var Fr = {};
    Fr[ve] = Fr[ne] = Fr[W] = Fr[_] = Fr[Y] = Fr[ee] = Fr[A] = Fr[J] = Fr[ae] = Fr[le] = Fr[ge] = Fr[Ee] = Fr[Le] = Fr[De] = Fr[Qe] = Fr[We] = Fr[lt] = Fr[qe] = Fr[je] = Fr[Ue] = Fr[it] = Fr[jt] = !0, Fr[M] = Fr[G] = Fr[st] = !1;
    var re = { : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "Ae", : "ae", : "Th", : "th", : "ss", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "IJ", : "ij", : "Oe", : "oe", : "'n", : "s" }, fe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Oe = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, et = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Gr = parseFloat, Vt = parseInt, rn = typeof $1 == "object" && $1 && $1.Object === Object && $1, Fn = typeof self == "object" && self && self.Object === Object && self, pr = rn || Fn || Function("return this")(), Kr = e && !e.nodeType && e, Nn = Kr && !0 && r && !r.nodeType && r, ws = Nn && Nn.exports === Kr, Un = ws && rn.process, nn = function() {
      try {
        var de = Nn && Nn.require && Nn.require("util").types;
        return de || Un && Un.binding && Un.binding("util");
      } catch {
      }
    }(), Hi = nn && nn.isArrayBuffer, Xo = nn && nn.isDate, ho = nn && nn.isMap, qa = nn && nn.isRegExp, c1 = nn && nn.isSet, Ih = nn && nn.isTypedArray;
    function Qn(de, Ce, Se) {
      switch (Se.length) {
        case 0:
          return de.call(Ce);
        case 1:
          return de.call(Ce, Se[0]);
        case 2:
          return de.call(Ce, Se[0], Se[1]);
        case 3:
          return de.call(Ce, Se[0], Se[1], Se[2]);
      }
      return de.apply(Ce, Se);
    }
    function KU(de, Ce, Se, tt) {
      for (var Wt = -1, Ir = de == null ? 0 : de.length; ++Wt < Ir; ) {
        var qn = de[Wt];
        Ce(tt, qn, Se(qn), de);
      }
      return tt;
    }
    function fo(de, Ce) {
      for (var Se = -1, tt = de == null ? 0 : de.length; ++Se < tt && Ce(de[Se], Se, de) !== !1; )
        ;
      return de;
    }
    function ZU(de, Ce) {
      for (var Se = de == null ? 0 : de.length; Se-- && Ce(de[Se], Se, de) !== !1; )
        ;
      return de;
    }
    function n8(de, Ce) {
      for (var Se = -1, tt = de == null ? 0 : de.length; ++Se < tt; )
        if (!Ce(de[Se], Se, de))
          return !1;
      return !0;
    }
    function Kl(de, Ce) {
      for (var Se = -1, tt = de == null ? 0 : de.length, Wt = 0, Ir = []; ++Se < tt; ) {
        var qn = de[Se];
        Ce(qn, Se, de) && (Ir[Wt++] = qn);
      }
      return Ir;
    }
    function sv(de, Ce) {
      var Se = de == null ? 0 : de.length;
      return !!Se && Kd(de, Ce, 0) > -1;
    }
    function EE(de, Ce, Se) {
      for (var tt = -1, Wt = de == null ? 0 : de.length; ++tt < Wt; )
        if (Se(Ce, de[tt]))
          return !0;
      return !1;
    }
    function sn(de, Ce) {
      for (var Se = -1, tt = de == null ? 0 : de.length, Wt = Array(tt); ++Se < tt; )
        Wt[Se] = Ce(de[Se], Se, de);
      return Wt;
    }
    function Zl(de, Ce) {
      for (var Se = -1, tt = Ce.length, Wt = de.length; ++Se < tt; )
        de[Wt + Se] = Ce[Se];
      return de;
    }
    function xE(de, Ce, Se, tt) {
      var Wt = -1, Ir = de == null ? 0 : de.length;
      for (tt && Ir && (Se = de[++Wt]); ++Wt < Ir; )
        Se = Ce(Se, de[Wt], Wt, de);
      return Se;
    }
    function JU(de, Ce, Se, tt) {
      var Wt = de == null ? 0 : de.length;
      for (tt && Wt && (Se = de[--Wt]); Wt--; )
        Se = Ce(Se, de[Wt], Wt, de);
      return Se;
    }
    function SE(de, Ce) {
      for (var Se = -1, tt = de == null ? 0 : de.length; ++Se < tt; )
        if (Ce(de[Se], Se, de))
          return !0;
      return !1;
    }
    var QU = CE("length");
    function YU(de) {
      return de.split("");
    }
    function XU(de) {
      return de.match(Vr) || [];
    }
    function i8(de, Ce, Se) {
      var tt;
      return Se(de, function(Wt, Ir, qn) {
        if (Ce(Wt, Ir, qn))
          return tt = Ir, !1;
      }), tt;
    }
    function ov(de, Ce, Se, tt) {
      for (var Wt = de.length, Ir = Se + (tt ? 1 : -1); tt ? Ir-- : ++Ir < Wt; )
        if (Ce(de[Ir], Ir, de))
          return Ir;
      return -1;
    }
    function Kd(de, Ce, Se) {
      return Ce === Ce ? hj(de, Ce, Se) : ov(de, s8, Se);
    }
    function ej(de, Ce, Se, tt) {
      for (var Wt = Se - 1, Ir = de.length; ++Wt < Ir; )
        if (tt(de[Wt], Ce))
          return Wt;
      return -1;
    }
    function s8(de) {
      return de !== de;
    }
    function o8(de, Ce) {
      var Se = de == null ? 0 : de.length;
      return Se ? IE(de, Ce) / Se : q;
    }
    function CE(de) {
      return function(Ce) {
        return Ce == null ? t : Ce[de];
      };
    }
    function AE(de) {
      return function(Ce) {
        return de == null ? t : de[Ce];
      };
    }
    function a8(de, Ce, Se, tt, Wt) {
      return Wt(de, function(Ir, qn, Zr) {
        Se = tt ? (tt = !1, Ir) : Ce(Se, Ir, qn, Zr);
      }), Se;
    }
    function tj(de, Ce) {
      var Se = de.length;
      for (de.sort(Ce); Se--; )
        de[Se] = de[Se].value;
      return de;
    }
    function IE(de, Ce) {
      for (var Se, tt = -1, Wt = de.length; ++tt < Wt; ) {
        var Ir = Ce(de[tt]);
        Ir !== t && (Se = Se === t ? Ir : Se + Ir);
      }
      return Se;
    }
    function RE(de, Ce) {
      for (var Se = -1, tt = Array(de); ++Se < de; )
        tt[Se] = Ce(Se);
      return tt;
    }
    function rj(de, Ce) {
      return sn(Ce, function(Se) {
        return [Se, de[Se]];
      });
    }
    function c8(de) {
      return de && de.slice(0, f8(de) + 1).replace(kt, "");
    }
    function Fs(de) {
      return function(Ce) {
        return de(Ce);
      };
    }
    function TE(de, Ce) {
      return sn(Ce, function(Se) {
        return de[Se];
      });
    }
    function l1(de, Ce) {
      return de.has(Ce);
    }
    function l8(de, Ce) {
      for (var Se = -1, tt = de.length; ++Se < tt && Kd(Ce, de[Se], 0) > -1; )
        ;
      return Se;
    }
    function u8(de, Ce) {
      for (var Se = de.length; Se-- && Kd(Ce, de[Se], 0) > -1; )
        ;
      return Se;
    }
    function nj(de, Ce) {
      for (var Se = de.length, tt = 0; Se--; )
        de[Se] === Ce && ++tt;
      return tt;
    }
    var ij = AE(re), sj = AE(fe);
    function oj(de) {
      return "\\" + et[de];
    }
    function aj(de, Ce) {
      return de == null ? t : de[Ce];
    }
    function Zd(de) {
      return nv.test(de);
    }
    function cj(de) {
      return Ah.test(de);
    }
    function lj(de) {
      for (var Ce, Se = []; !(Ce = de.next()).done; )
        Se.push(Ce.value);
      return Se;
    }
    function OE(de) {
      var Ce = -1, Se = Array(de.size);
      return de.forEach(function(tt, Wt) {
        Se[++Ce] = [Wt, tt];
      }), Se;
    }
    function h8(de, Ce) {
      return function(Se) {
        return de(Ce(Se));
      };
    }
    function Jl(de, Ce) {
      for (var Se = -1, tt = de.length, Wt = 0, Ir = []; ++Se < tt; ) {
        var qn = de[Se];
        (qn === Ce || qn === f) && (de[Se] = f, Ir[Wt++] = Se);
      }
      return Ir;
    }
    function av(de) {
      var Ce = -1, Se = Array(de.size);
      return de.forEach(function(tt) {
        Se[++Ce] = tt;
      }), Se;
    }
    function uj(de) {
      var Ce = -1, Se = Array(de.size);
      return de.forEach(function(tt) {
        Se[++Ce] = [tt, tt];
      }), Se;
    }
    function hj(de, Ce, Se) {
      for (var tt = Se - 1, Wt = de.length; ++tt < Wt; )
        if (de[tt] === Ce)
          return tt;
      return -1;
    }
    function fj(de, Ce, Se) {
      for (var tt = Se + 1; tt--; )
        if (de[tt] === Ce)
          return tt;
      return tt;
    }
    function Jd(de) {
      return Zd(de) ? pj(de) : QU(de);
    }
    function ea(de) {
      return Zd(de) ? gj(de) : YU(de);
    }
    function f8(de) {
      for (var Ce = de.length; Ce-- && $t.test(de.charAt(Ce)); )
        ;
      return Ce;
    }
    var dj = AE(Oe);
    function pj(de) {
      for (var Ce = Gd.lastIndex = 0; Gd.test(de); )
        ++Ce;
      return Ce;
    }
    function gj(de) {
      return de.match(Gd) || [];
    }
    function mj(de) {
      return de.match(rv) || [];
    }
    var wj = function de(Ce) {
      Ce = Ce == null ? pr : Qd.defaults(pr.Object(), Ce, Qd.pick(pr, iv));
      var Se = Ce.Array, tt = Ce.Date, Wt = Ce.Error, Ir = Ce.Function, qn = Ce.Math, Zr = Ce.Object, NE = Ce.RegExp, yj = Ce.String, po = Ce.TypeError, cv = Se.prototype, vj = Ir.prototype, Yd = Zr.prototype, lv = Ce["__core-js_shared__"], uv = vj.toString, kr = Yd.hasOwnProperty, bj = 0, d8 = function() {
        var l = /[^.]+$/.exec(lv && lv.keys && lv.keys.IE_PROTO || "");
        return l ? "Symbol(src)_1." + l : "";
      }(), hv = Yd.toString, _j = uv.call(Zr), Ej = pr._, xj = NE("^" + uv.call(kr).replace(Dt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), fv = ws ? Ce.Buffer : t, Ql = Ce.Symbol, dv = Ce.Uint8Array, p8 = fv ? fv.allocUnsafe : t, pv = h8(Zr.getPrototypeOf, Zr), g8 = Zr.create, m8 = Yd.propertyIsEnumerable, gv = cv.splice, w8 = Ql ? Ql.isConcatSpreadable : t, u1 = Ql ? Ql.iterator : t, Rh = Ql ? Ql.toStringTag : t, mv = function() {
        try {
          var l = Mh(Zr, "defineProperty");
          return l({}, "", {}), l;
        } catch {
        }
      }(), Sj = Ce.clearTimeout !== pr.clearTimeout && Ce.clearTimeout, Cj = tt && tt.now !== pr.Date.now && tt.now, Aj = Ce.setTimeout !== pr.setTimeout && Ce.setTimeout, wv = qn.ceil, yv = qn.floor, PE = Zr.getOwnPropertySymbols, Ij = fv ? fv.isBuffer : t, y8 = Ce.isFinite, Rj = cv.join, Tj = h8(Zr.keys, Zr), Gn = qn.max, Ei = qn.min, Oj = tt.now, Nj = Ce.parseInt, v8 = qn.random, Pj = cv.reverse, ME = Mh(Ce, "DataView"), h1 = Mh(Ce, "Map"), DE = Mh(Ce, "Promise"), Xd = Mh(Ce, "Set"), f1 = Mh(Ce, "WeakMap"), d1 = Mh(Zr, "create"), vv = f1 && new f1(), ep = {}, Mj = Dh(ME), Dj = Dh(h1), kj = Dh(DE), $j = Dh(Xd), Lj = Dh(f1), bv = Ql ? Ql.prototype : t, p1 = bv ? bv.valueOf : t, b8 = bv ? bv.toString : t;
      function Z(l) {
        if (_n(l) && !qt(l) && !(l instanceof ur)) {
          if (l instanceof go)
            return l;
          if (kr.call(l, "__wrapped__"))
            return _I(l);
        }
        return new go(l);
      }
      var tp = /* @__PURE__ */ function() {
        function l() {
        }
        return function(h) {
          if (!ln(h))
            return {};
          if (g8)
            return g8(h);
          l.prototype = h;
          var g = new l();
          return l.prototype = t, g;
        };
      }();
      function _v() {
      }
      function go(l, h) {
        this.__wrapped__ = l, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = t;
      }
      Z.templateSettings = { escape: Mt, evaluate: Mr, interpolate: Nt, variable: "", imports: { _: Z } }, Z.prototype = _v.prototype, Z.prototype.constructor = Z, go.prototype = tp(_v.prototype), go.prototype.constructor = go;
      function ur(l) {
        this.__wrapped__ = l, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = B, this.__views__ = [];
      }
      function Bj() {
        var l = new ur(this.__wrapped__);
        return l.__actions__ = ys(this.__actions__), l.__dir__ = this.__dir__, l.__filtered__ = this.__filtered__, l.__iteratees__ = ys(this.__iteratees__), l.__takeCount__ = this.__takeCount__, l.__views__ = ys(this.__views__), l;
      }
      function Fj() {
        if (this.__filtered__) {
          var l = new ur(this);
          l.__dir__ = -1, l.__filtered__ = !0;
        } else
          l = this.clone(), l.__dir__ *= -1;
        return l;
      }
      function Uj() {
        var l = this.__wrapped__.value(), h = this.__dir__, g = qt(l), C = h < 0, z = g ? l.length : 0, Q = YW(0, z, this.__views__), oe = Q.start, ce = Q.end, pe = ce - oe, Ie = C ? ce : oe - 1, Re = this.__iteratees__, Me = Re.length, Ve = 0, ht = Ei(pe, this.__takeCount__);
        if (!g || !C && z == pe && ht == pe)
          return z8(l, this.__actions__);
        var Ct = [];
        e:
          for (; pe-- && Ve < ht; ) {
            Ie += h;
            for (var Qt = -1, At = l[Ie]; ++Qt < Me; ) {
              var cr = Re[Qt], gr = cr.iteratee, Ws = cr.type, qi = gr(At);
              if (Ws == w)
                At = qi;
              else if (!qi) {
                if (Ws == p)
                  continue e;
                break e;
              }
            }
            Ct[Ve++] = At;
          }
        return Ct;
      }
      ur.prototype = tp(_v.prototype), ur.prototype.constructor = ur;
      function Th(l) {
        var h = -1, g = l == null ? 0 : l.length;
        for (this.clear(); ++h < g; ) {
          var C = l[h];
          this.set(C[0], C[1]);
        }
      }
      function jj() {
        this.__data__ = d1 ? d1(null) : {}, this.size = 0;
      }
      function Wj(l) {
        var h = this.has(l) && delete this.__data__[l];
        return this.size -= h ? 1 : 0, h;
      }
      function Hj(l) {
        var h = this.__data__;
        if (d1) {
          var g = h[l];
          return g === c ? t : g;
        }
        return kr.call(h, l) ? h[l] : t;
      }
      function zj(l) {
        var h = this.__data__;
        return d1 ? h[l] !== t : kr.call(h, l);
      }
      function Vj(l, h) {
        var g = this.__data__;
        return this.size += this.has(l) ? 0 : 1, g[l] = d1 && h === t ? c : h, this;
      }
      Th.prototype.clear = jj, Th.prototype.delete = Wj, Th.prototype.get = Hj, Th.prototype.has = zj, Th.prototype.set = Vj;
      function Fc(l) {
        var h = -1, g = l == null ? 0 : l.length;
        for (this.clear(); ++h < g; ) {
          var C = l[h];
          this.set(C[0], C[1]);
        }
      }
      function qj() {
        this.__data__ = [], this.size = 0;
      }
      function Gj(l) {
        var h = this.__data__, g = Ev(h, l);
        if (g < 0)
          return !1;
        var C = h.length - 1;
        return g == C ? h.pop() : gv.call(h, g, 1), --this.size, !0;
      }
      function Kj(l) {
        var h = this.__data__, g = Ev(h, l);
        return g < 0 ? t : h[g][1];
      }
      function Zj(l) {
        return Ev(this.__data__, l) > -1;
      }
      function Jj(l, h) {
        var g = this.__data__, C = Ev(g, l);
        return C < 0 ? (++this.size, g.push([l, h])) : g[C][1] = h, this;
      }
      Fc.prototype.clear = qj, Fc.prototype.delete = Gj, Fc.prototype.get = Kj, Fc.prototype.has = Zj, Fc.prototype.set = Jj;
      function Uc(l) {
        var h = -1, g = l == null ? 0 : l.length;
        for (this.clear(); ++h < g; ) {
          var C = l[h];
          this.set(C[0], C[1]);
        }
      }
      function Qj() {
        this.size = 0, this.__data__ = { hash: new Th(), map: new (h1 || Fc)(), string: new Th() };
      }
      function Yj(l) {
        var h = Dv(this, l).delete(l);
        return this.size -= h ? 1 : 0, h;
      }
      function Xj(l) {
        return Dv(this, l).get(l);
      }
      function eW(l) {
        return Dv(this, l).has(l);
      }
      function tW(l, h) {
        var g = Dv(this, l), C = g.size;
        return g.set(l, h), this.size += g.size == C ? 0 : 1, this;
      }
      Uc.prototype.clear = Qj, Uc.prototype.delete = Yj, Uc.prototype.get = Xj, Uc.prototype.has = eW, Uc.prototype.set = tW;
      function Oh(l) {
        var h = -1, g = l == null ? 0 : l.length;
        for (this.__data__ = new Uc(); ++h < g; )
          this.add(l[h]);
      }
      function rW(l) {
        return this.__data__.set(l, c), this;
      }
      function nW(l) {
        return this.__data__.has(l);
      }
      Oh.prototype.add = Oh.prototype.push = rW, Oh.prototype.has = nW;
      function ta(l) {
        var h = this.__data__ = new Fc(l);
        this.size = h.size;
      }
      function iW() {
        this.__data__ = new Fc(), this.size = 0;
      }
      function sW(l) {
        var h = this.__data__, g = h.delete(l);
        return this.size = h.size, g;
      }
      function oW(l) {
        return this.__data__.get(l);
      }
      function aW(l) {
        return this.__data__.has(l);
      }
      function cW(l, h) {
        var g = this.__data__;
        if (g instanceof Fc) {
          var C = g.__data__;
          if (!h1 || C.length < i - 1)
            return C.push([l, h]), this.size = ++g.size, this;
          g = this.__data__ = new Uc(C);
        }
        return g.set(l, h), this.size = g.size, this;
      }
      ta.prototype.clear = iW, ta.prototype.delete = sW, ta.prototype.get = oW, ta.prototype.has = aW, ta.prototype.set = cW;
      function _8(l, h) {
        var g = qt(l), C = !g && kh(l), z = !g && !C && ru(l), Q = !g && !C && !z && sp(l), oe = g || C || z || Q, ce = oe ? RE(l.length, yj) : [], pe = ce.length;
        for (var Ie in l)
          (h || kr.call(l, Ie)) && !(oe && (Ie == "length" || z && (Ie == "offset" || Ie == "parent") || Q && (Ie == "buffer" || Ie == "byteLength" || Ie == "byteOffset") || zc(Ie, pe))) && ce.push(Ie);
        return ce;
      }
      function E8(l) {
        var h = l.length;
        return h ? l[VE(0, h - 1)] : t;
      }
      function lW(l, h) {
        return kv(ys(l), Nh(h, 0, l.length));
      }
      function uW(l) {
        return kv(ys(l));
      }
      function kE(l, h, g) {
        (g !== t && !ra(l[h], g) || g === t && !(h in l)) && jc(l, h, g);
      }
      function g1(l, h, g) {
        var C = l[h];
        (!(kr.call(l, h) && ra(C, g)) || g === t && !(h in l)) && jc(l, h, g);
      }
      function Ev(l, h) {
        for (var g = l.length; g--; )
          if (ra(l[g][0], h))
            return g;
        return -1;
      }
      function hW(l, h, g, C) {
        return Yl(l, function(z, Q, oe) {
          h(C, z, g(z), oe);
        }), C;
      }
      function x8(l, h) {
        return l && Ka(h, Yn(h), l);
      }
      function fW(l, h) {
        return l && Ka(h, bs(h), l);
      }
      function jc(l, h, g) {
        h == "__proto__" && mv ? mv(l, h, { configurable: !0, enumerable: !0, value: g, writable: !0 }) : l[h] = g;
      }
      function $E(l, h) {
        for (var g = -1, C = h.length, z = Se(C), Q = l == null; ++g < C; )
          z[g] = Q ? t : m5(l, h[g]);
        return z;
      }
      function Nh(l, h, g) {
        return l === l && (g !== t && (l = l <= g ? l : g), h !== t && (l = l >= h ? l : h)), l;
      }
      function mo(l, h, g, C, z, Q) {
        var oe, ce = h & d, pe = h & m, Ie = h & y;
        if (g && (oe = z ? g(l, C, z, Q) : g(l)), oe !== t)
          return oe;
        if (!ln(l))
          return l;
        var Re = qt(l);
        if (Re) {
          if (oe = eH(l), !ce)
            return ys(l, oe);
        } else {
          var Me = xi(l), Ve = Me == G || Me == ue;
          if (ru(l))
            return G8(l, ce);
          if (Me == De || Me == ve || Ve && !z) {
            if (oe = pe || Ve ? {} : fI(l), !ce)
              return pe ? HW(l, fW(oe, l)) : WW(l, x8(oe, l));
          } else {
            if (!Fr[Me])
              return z ? l : {};
            oe = tH(l, Me, ce);
          }
        }
        Q || (Q = new ta());
        var ht = Q.get(l);
        if (ht)
          return ht;
        Q.set(l, oe), jI(l) ? l.forEach(function(At) {
          oe.add(mo(At, h, g, At, l, Q));
        }) : FI(l) && l.forEach(function(At, cr) {
          oe.set(cr, mo(At, h, g, cr, l, Q));
        });
        var Ct = Ie ? pe ? r5 : t5 : pe ? bs : Yn, Qt = Re ? t : Ct(l);
        return fo(Qt || l, function(At, cr) {
          Qt && (cr = At, At = l[cr]), g1(oe, cr, mo(At, h, g, cr, l, Q));
        }), oe;
      }
      function dW(l) {
        var h = Yn(l);
        return function(g) {
          return S8(g, l, h);
        };
      }
      function S8(l, h, g) {
        var C = g.length;
        if (l == null)
          return !C;
        for (l = Zr(l); C--; ) {
          var z = g[C], Q = h[z], oe = l[z];
          if (oe === t && !(z in l) || !Q(oe))
            return !1;
        }
        return !0;
      }
      function C8(l, h, g) {
        if (typeof l != "function")
          throw new po(o);
        return E1(function() {
          l.apply(t, g);
        }, h);
      }
      function m1(l, h, g, C) {
        var z = -1, Q = sv, oe = !0, ce = l.length, pe = [], Ie = h.length;
        if (!ce)
          return pe;
        g && (h = sn(h, Fs(g))), C ? (Q = EE, oe = !1) : h.length >= i && (Q = l1, oe = !1, h = new Oh(h));
        e:
          for (; ++z < ce; ) {
            var Re = l[z], Me = g == null ? Re : g(Re);
            if (Re = C || Re !== 0 ? Re : 0, oe && Me === Me) {
              for (var Ve = Ie; Ve--; )
                if (h[Ve] === Me)
                  continue e;
              pe.push(Re);
            } else
              Q(h, Me, C) || pe.push(Re);
          }
        return pe;
      }
      var Yl = Y8(Ga), A8 = Y8(BE, !0);
      function pW(l, h) {
        var g = !0;
        return Yl(l, function(C, z, Q) {
          return g = !!h(C, z, Q), g;
        }), g;
      }
      function xv(l, h, g) {
        for (var C = -1, z = l.length; ++C < z; ) {
          var Q = l[C], oe = h(Q);
          if (oe != null && (ce === t ? oe === oe && !js(oe) : g(oe, ce)))
            var ce = oe, pe = Q;
        }
        return pe;
      }
      function gW(l, h, g, C) {
        var z = l.length;
        for (g = Zt(g), g < 0 && (g = -g > z ? 0 : z + g), C = C === t || C > z ? z : Zt(C), C < 0 && (C += z), C = g > C ? 0 : HI(C); g < C; )
          l[g++] = h;
        return l;
      }
      function I8(l, h) {
        var g = [];
        return Yl(l, function(C, z, Q) {
          h(C, z, Q) && g.push(C);
        }), g;
      }
      function fi(l, h, g, C, z) {
        var Q = -1, oe = l.length;
        for (g || (g = nH), z || (z = []); ++Q < oe; ) {
          var ce = l[Q];
          h > 0 && g(ce) ? h > 1 ? fi(ce, h - 1, g, C, z) : Zl(z, ce) : C || (z[z.length] = ce);
        }
        return z;
      }
      var LE = X8(), R8 = X8(!0);
      function Ga(l, h) {
        return l && LE(l, h, Yn);
      }
      function BE(l, h) {
        return l && R8(l, h, Yn);
      }
      function Sv(l, h) {
        return Kl(h, function(g) {
          return Vc(l[g]);
        });
      }
      function Ph(l, h) {
        h = eu(h, l);
        for (var g = 0, C = h.length; l != null && g < C; )
          l = l[Za(h[g++])];
        return g && g == C ? l : t;
      }
      function T8(l, h, g) {
        var C = h(l);
        return qt(l) ? C : Zl(C, g(l));
      }
      function zi(l) {
        return l == null ? l === t ? Ye : Fe : Rh && Rh in Zr(l) ? QW(l) : uH(l);
      }
      function FE(l, h) {
        return l > h;
      }
      function mW(l, h) {
        return l != null && kr.call(l, h);
      }
      function wW(l, h) {
        return l != null && h in Zr(l);
      }
      function yW(l, h, g) {
        return l >= Ei(h, g) && l < Gn(h, g);
      }
      function UE(l, h, g) {
        for (var C = g ? EE : sv, z = l[0].length, Q = l.length, oe = Q, ce = Se(Q), pe = 1 / 0, Ie = []; oe--; ) {
          var Re = l[oe];
          oe && h && (Re = sn(Re, Fs(h))), pe = Ei(Re.length, pe), ce[oe] = !g && (h || z >= 120 && Re.length >= 120) ? new Oh(oe && Re) : t;
        }
        Re = l[0];
        var Me = -1, Ve = ce[0];
        e:
          for (; ++Me < z && Ie.length < pe; ) {
            var ht = Re[Me], Ct = h ? h(ht) : ht;
            if (ht = g || ht !== 0 ? ht : 0, !(Ve ? l1(Ve, Ct) : C(Ie, Ct, g))) {
              for (oe = Q; --oe; ) {
                var Qt = ce[oe];
                if (!(Qt ? l1(Qt, Ct) : C(l[oe], Ct, g)))
                  continue e;
              }
              Ve && Ve.push(Ct), Ie.push(ht);
            }
          }
        return Ie;
      }
      function vW(l, h, g, C) {
        return Ga(l, function(z, Q, oe) {
          h(C, g(z), Q, oe);
        }), C;
      }
      function w1(l, h, g) {
        h = eu(h, l), l = mI(l, h);
        var C = l == null ? l : l[Za(yo(h))];
        return C == null ? t : Qn(C, l, g);
      }
      function O8(l) {
        return _n(l) && zi(l) == ve;
      }
      function bW(l) {
        return _n(l) && zi(l) == W;
      }
      function _W(l) {
        return _n(l) && zi(l) == ee;
      }
      function y1(l, h, g, C, z) {
        return l === h ? !0 : l == null || h == null || !_n(l) && !_n(h) ? l !== l && h !== h : EW(l, h, g, C, y1, z);
      }
      function EW(l, h, g, C, z, Q) {
        var oe = qt(l), ce = qt(h), pe = oe ? ne : xi(l), Ie = ce ? ne : xi(h);
        pe = pe == ve ? De : pe, Ie = Ie == ve ? De : Ie;
        var Re = pe == De, Me = Ie == De, Ve = pe == Ie;
        if (Ve && ru(l)) {
          if (!ru(h))
            return !1;
          oe = !0, Re = !1;
        }
        if (Ve && !Re)
          return Q || (Q = new ta()), oe || sp(l) ? lI(l, h, g, C, z, Q) : ZW(l, h, pe, g, C, z, Q);
        if (!(g & b)) {
          var ht = Re && kr.call(l, "__wrapped__"), Ct = Me && kr.call(h, "__wrapped__");
          if (ht || Ct) {
            var Qt = ht ? l.value() : l, At = Ct ? h.value() : h;
            return Q || (Q = new ta()), z(Qt, At, g, C, Q);
          }
        }
        return Ve ? (Q || (Q = new ta()), JW(l, h, g, C, z, Q)) : !1;
      }
      function xW(l) {
        return _n(l) && xi(l) == Ee;
      }
      function jE(l, h, g, C) {
        var z = g.length, Q = z, oe = !C;
        if (l == null)
          return !Q;
        for (l = Zr(l); z--; ) {
          var ce = g[z];
          if (oe && ce[2] ? ce[1] !== l[ce[0]] : !(ce[0] in l))
            return !1;
        }
        for (; ++z < Q; ) {
          ce = g[z];
          var pe = ce[0], Ie = l[pe], Re = ce[1];
          if (oe && ce[2]) {
            if (Ie === t && !(pe in l))
              return !1;
          } else {
            var Me = new ta();
            if (C)
              var Ve = C(Ie, Re, pe, l, h, Me);
            if (!(Ve === t ? y1(Re, Ie, b | I, C, Me) : Ve))
              return !1;
          }
        }
        return !0;
      }
      function N8(l) {
        if (!ln(l) || sH(l))
          return !1;
        var h = Vc(l) ? xj : Go;
        return h.test(Dh(l));
      }
      function SW(l) {
        return _n(l) && zi(l) == Qe;
      }
      function CW(l) {
        return _n(l) && xi(l) == We;
      }
      function AW(l) {
        return _n(l) && jv(l.length) && !!qr[zi(l)];
      }
      function P8(l) {
        return typeof l == "function" ? l : l == null ? _s : typeof l == "object" ? qt(l) ? k8(l[0], l[1]) : D8(l) : eR(l);
      }
      function WE(l) {
        if (!_1(l))
          return Tj(l);
        var h = [];
        for (var g in Zr(l))
          kr.call(l, g) && g != "constructor" && h.push(g);
        return h;
      }
      function IW(l) {
        if (!ln(l))
          return lH(l);
        var h = _1(l), g = [];
        for (var C in l)
          C == "constructor" && (h || !kr.call(l, C)) || g.push(C);
        return g;
      }
      function HE(l, h) {
        return l < h;
      }
      function M8(l, h) {
        var g = -1, C = vs(l) ? Se(l.length) : [];
        return Yl(l, function(z, Q, oe) {
          C[++g] = h(z, Q, oe);
        }), C;
      }
      function D8(l) {
        var h = i5(l);
        return h.length == 1 && h[0][2] ? pI(h[0][0], h[0][1]) : function(g) {
          return g === l || jE(g, l, h);
        };
      }
      function k8(l, h) {
        return o5(l) && dI(h) ? pI(Za(l), h) : function(g) {
          var C = m5(g, l);
          return C === t && C === h ? w5(g, l) : y1(h, C, b | I);
        };
      }
      function Cv(l, h, g, C, z) {
        l !== h && LE(h, function(Q, oe) {
          if (z || (z = new ta()), ln(Q))
            RW(l, h, oe, g, Cv, C, z);
          else {
            var ce = C ? C(c5(l, oe), Q, oe + "", l, h, z) : t;
            ce === t && (ce = Q), kE(l, oe, ce);
          }
        }, bs);
      }
      function RW(l, h, g, C, z, Q, oe) {
        var ce = c5(l, g), pe = c5(h, g), Ie = oe.get(pe);
        if (Ie) {
          kE(l, g, Ie);
          return;
        }
        var Re = Q ? Q(ce, pe, g + "", l, h, oe) : t, Me = Re === t;
        if (Me) {
          var Ve = qt(pe), ht = !Ve && ru(pe), Ct = !Ve && !ht && sp(pe);
          Re = pe, Ve || ht || Ct ? qt(ce) ? Re = ce : Pn(ce) ? Re = ys(ce) : ht ? (Me = !1, Re = G8(pe, !0)) : Ct ? (Me = !1, Re = K8(pe, !0)) : Re = [] : x1(pe) || kh(pe) ? (Re = ce, kh(ce) ? Re = zI(ce) : (!ln(ce) || Vc(ce)) && (Re = fI(pe))) : Me = !1;
        }
        Me && (oe.set(pe, Re), z(Re, pe, C, Q, oe), oe.delete(pe)), kE(l, g, Re);
      }
      function $8(l, h) {
        var g = l.length;
        if (g)
          return h += h < 0 ? g : 0, zc(h, g) ? l[h] : t;
      }
      function L8(l, h, g) {
        h.length ? h = sn(h, function(Q) {
          return qt(Q) ? function(oe) {
            return Ph(oe, Q.length === 1 ? Q[0] : Q);
          } : Q;
        }) : h = [_s];
        var C = -1;
        h = sn(h, Fs(St()));
        var z = M8(l, function(Q, oe, ce) {
          var pe = sn(h, function(Ie) {
            return Ie(Q);
          });
          return { criteria: pe, index: ++C, value: Q };
        });
        return tj(z, function(Q, oe) {
          return jW(Q, oe, g);
        });
      }
      function TW(l, h) {
        return B8(l, h, function(g, C) {
          return w5(l, C);
        });
      }
      function B8(l, h, g) {
        for (var C = -1, z = h.length, Q = {}; ++C < z; ) {
          var oe = h[C], ce = Ph(l, oe);
          g(ce, oe) && v1(Q, eu(oe, l), ce);
        }
        return Q;
      }
      function OW(l) {
        return function(h) {
          return Ph(h, l);
        };
      }
      function zE(l, h, g, C) {
        var z = C ? ej : Kd, Q = -1, oe = h.length, ce = l;
        for (l === h && (h = ys(h)), g && (ce = sn(l, Fs(g))); ++Q < oe; )
          for (var pe = 0, Ie = h[Q], Re = g ? g(Ie) : Ie; (pe = z(ce, Re, pe, C)) > -1; )
            ce !== l && gv.call(ce, pe, 1), gv.call(l, pe, 1);
        return l;
      }
      function F8(l, h) {
        for (var g = l ? h.length : 0, C = g - 1; g--; ) {
          var z = h[g];
          if (g == C || z !== Q) {
            var Q = z;
            zc(z) ? gv.call(l, z, 1) : KE(l, z);
          }
        }
        return l;
      }
      function VE(l, h) {
        return l + yv(v8() * (h - l + 1));
      }
      function NW(l, h, g, C) {
        for (var z = -1, Q = Gn(wv((h - l) / (g || 1)), 0), oe = Se(Q); Q--; )
          oe[C ? Q : ++z] = l, l += g;
        return oe;
      }
      function qE(l, h) {
        var g = "";
        if (!l || h < 1 || h > O)
          return g;
        do
          h % 2 && (g += l), h = yv(h / 2), h && (l += l);
        while (h);
        return g;
      }
      function tr(l, h) {
        return l5(gI(l, h, _s), l + "");
      }
      function PW(l) {
        return E8(op(l));
      }
      function MW(l, h) {
        var g = op(l);
        return kv(g, Nh(h, 0, g.length));
      }
      function v1(l, h, g, C) {
        if (!ln(l))
          return l;
        h = eu(h, l);
        for (var z = -1, Q = h.length, oe = Q - 1, ce = l; ce != null && ++z < Q; ) {
          var pe = Za(h[z]), Ie = g;
          if (pe === "__proto__" || pe === "constructor" || pe === "prototype")
            return l;
          if (z != oe) {
            var Re = ce[pe];
            Ie = C ? C(Re, pe, ce) : t, Ie === t && (Ie = ln(Re) ? Re : zc(h[z + 1]) ? [] : {});
          }
          g1(ce, pe, Ie), ce = ce[pe];
        }
        return l;
      }
      var U8 = vv ? function(l, h) {
        return vv.set(l, h), l;
      } : _s, DW = mv ? function(l, h) {
        return mv(l, "toString", { configurable: !0, enumerable: !1, value: v5(h), writable: !0 });
      } : _s;
      function kW(l) {
        return kv(op(l));
      }
      function wo(l, h, g) {
        var C = -1, z = l.length;
        h < 0 && (h = -h > z ? 0 : z + h), g = g > z ? z : g, g < 0 && (g += z), z = h > g ? 0 : g - h >>> 0, h >>>= 0;
        for (var Q = Se(z); ++C < z; )
          Q[C] = l[C + h];
        return Q;
      }
      function $W(l, h) {
        var g;
        return Yl(l, function(C, z, Q) {
          return g = h(C, z, Q), !g;
        }), !!g;
      }
      function Av(l, h, g) {
        var C = 0, z = l == null ? C : l.length;
        if (typeof h == "number" && h === h && z <= V) {
          for (; C < z; ) {
            var Q = C + z >>> 1, oe = l[Q];
            oe !== null && !js(oe) && (g ? oe <= h : oe < h) ? C = Q + 1 : z = Q;
          }
          return z;
        }
        return GE(l, h, _s, g);
      }
      function GE(l, h, g, C) {
        var z = 0, Q = l == null ? 0 : l.length;
        if (Q === 0)
          return 0;
        h = g(h);
        for (var oe = h !== h, ce = h === null, pe = js(h), Ie = h === t; z < Q; ) {
          var Re = yv((z + Q) / 2), Me = g(l[Re]), Ve = Me !== t, ht = Me === null, Ct = Me === Me, Qt = js(Me);
          if (oe)
            var At = C || Ct;
          else
            Ie ? At = Ct && (C || Ve) : ce ? At = Ct && Ve && (C || !ht) : pe ? At = Ct && Ve && !ht && (C || !Qt) : ht || Qt ? At = !1 : At = C ? Me <= h : Me < h;
          At ? z = Re + 1 : Q = Re;
        }
        return Ei(Q, E);
      }
      function j8(l, h) {
        for (var g = -1, C = l.length, z = 0, Q = []; ++g < C; ) {
          var oe = l[g], ce = h ? h(oe) : oe;
          if (!g || !ra(ce, pe)) {
            var pe = ce;
            Q[z++] = oe === 0 ? 0 : oe;
          }
        }
        return Q;
      }
      function W8(l) {
        return typeof l == "number" ? l : js(l) ? q : +l;
      }
      function Us(l) {
        if (typeof l == "string")
          return l;
        if (qt(l))
          return sn(l, Us) + "";
        if (js(l))
          return b8 ? b8.call(l) : "";
        var h = l + "";
        return h == "0" && 1 / l == -N ? "-0" : h;
      }
      function Xl(l, h, g) {
        var C = -1, z = sv, Q = l.length, oe = !0, ce = [], pe = ce;
        if (g)
          oe = !1, z = EE;
        else if (Q >= i) {
          var Ie = h ? null : GW(l);
          if (Ie)
            return av(Ie);
          oe = !1, z = l1, pe = new Oh();
        } else
          pe = h ? [] : ce;
        e:
          for (; ++C < Q; ) {
            var Re = l[C], Me = h ? h(Re) : Re;
            if (Re = g || Re !== 0 ? Re : 0, oe && Me === Me) {
              for (var Ve = pe.length; Ve--; )
                if (pe[Ve] === Me)
                  continue e;
              h && pe.push(Me), ce.push(Re);
            } else
              z(pe, Me, g) || (pe !== ce && pe.push(Me), ce.push(Re));
          }
        return ce;
      }
      function KE(l, h) {
        return h = eu(h, l), l = mI(l, h), l == null || delete l[Za(yo(h))];
      }
      function H8(l, h, g, C) {
        return v1(l, h, g(Ph(l, h)), C);
      }
      function Iv(l, h, g, C) {
        for (var z = l.length, Q = C ? z : -1; (C ? Q-- : ++Q < z) && h(l[Q], Q, l); )
          ;
        return g ? wo(l, C ? 0 : Q, C ? Q + 1 : z) : wo(l, C ? Q + 1 : 0, C ? z : Q);
      }
      function z8(l, h) {
        var g = l;
        return g instanceof ur && (g = g.value()), xE(h, function(C, z) {
          return z.func.apply(z.thisArg, Zl([C], z.args));
        }, g);
      }
      function ZE(l, h, g) {
        var C = l.length;
        if (C < 2)
          return C ? Xl(l[0]) : [];
        for (var z = -1, Q = Se(C); ++z < C; )
          for (var oe = l[z], ce = -1; ++ce < C; )
            ce != z && (Q[z] = m1(Q[z] || oe, l[ce], h, g));
        return Xl(fi(Q, 1), h, g);
      }
      function V8(l, h, g) {
        for (var C = -1, z = l.length, Q = h.length, oe = {}; ++C < z; ) {
          var ce = C < Q ? h[C] : t;
          g(oe, l[C], ce);
        }
        return oe;
      }
      function JE(l) {
        return Pn(l) ? l : [];
      }
      function QE(l) {
        return typeof l == "function" ? l : _s;
      }
      function eu(l, h) {
        return qt(l) ? l : o5(l, h) ? [l] : bI(Or(l));
      }
      var LW = tr;
      function tu(l, h, g) {
        var C = l.length;
        return g = g === t ? C : g, !h && g >= C ? l : wo(l, h, g);
      }
      var q8 = Sj || function(l) {
        return pr.clearTimeout(l);
      };
      function G8(l, h) {
        if (h)
          return l.slice();
        var g = l.length, C = p8 ? p8(g) : new l.constructor(g);
        return l.copy(C), C;
      }
      function YE(l) {
        var h = new l.constructor(l.byteLength);
        return new dv(h).set(new dv(l)), h;
      }
      function BW(l, h) {
        var g = h ? YE(l.buffer) : l.buffer;
        return new l.constructor(g, l.byteOffset, l.byteLength);
      }
      function FW(l) {
        var h = new l.constructor(l.source, ar.exec(l));
        return h.lastIndex = l.lastIndex, h;
      }
      function UW(l) {
        return p1 ? Zr(p1.call(l)) : {};
      }
      function K8(l, h) {
        var g = h ? YE(l.buffer) : l.buffer;
        return new l.constructor(g, l.byteOffset, l.length);
      }
      function Z8(l, h) {
        if (l !== h) {
          var g = l !== t, C = l === null, z = l === l, Q = js(l), oe = h !== t, ce = h === null, pe = h === h, Ie = js(h);
          if (!ce && !Ie && !Q && l > h || Q && oe && pe && !ce && !Ie || C && oe && pe || !g && pe || !z)
            return 1;
          if (!C && !Q && !Ie && l < h || Ie && g && z && !C && !Q || ce && g && z || !oe && z || !pe)
            return -1;
        }
        return 0;
      }
      function jW(l, h, g) {
        for (var C = -1, z = l.criteria, Q = h.criteria, oe = z.length, ce = g.length; ++C < oe; ) {
          var pe = Z8(z[C], Q[C]);
          if (pe) {
            if (C >= ce)
              return pe;
            var Ie = g[C];
            return pe * (Ie == "desc" ? -1 : 1);
          }
        }
        return l.index - h.index;
      }
      function J8(l, h, g, C) {
        for (var z = -1, Q = l.length, oe = g.length, ce = -1, pe = h.length, Ie = Gn(Q - oe, 0), Re = Se(pe + Ie), Me = !C; ++ce < pe; )
          Re[ce] = h[ce];
        for (; ++z < oe; )
          (Me || z < Q) && (Re[g[z]] = l[z]);
        for (; Ie--; )
          Re[ce++] = l[z++];
        return Re;
      }
      function Q8(l, h, g, C) {
        for (var z = -1, Q = l.length, oe = -1, ce = g.length, pe = -1, Ie = h.length, Re = Gn(Q - ce, 0), Me = Se(Re + Ie), Ve = !C; ++z < Re; )
          Me[z] = l[z];
        for (var ht = z; ++pe < Ie; )
          Me[ht + pe] = h[pe];
        for (; ++oe < ce; )
          (Ve || z < Q) && (Me[ht + g[oe]] = l[z++]);
        return Me;
      }
      function ys(l, h) {
        var g = -1, C = l.length;
        for (h || (h = Se(C)); ++g < C; )
          h[g] = l[g];
        return h;
      }
      function Ka(l, h, g, C) {
        var z = !g;
        g || (g = {});
        for (var Q = -1, oe = h.length; ++Q < oe; ) {
          var ce = h[Q], pe = C ? C(g[ce], l[ce], ce, g, l) : t;
          pe === t && (pe = l[ce]), z ? jc(g, ce, pe) : g1(g, ce, pe);
        }
        return g;
      }
      function WW(l, h) {
        return Ka(l, s5(l), h);
      }
      function HW(l, h) {
        return Ka(l, uI(l), h);
      }
      function Rv(l, h) {
        return function(g, C) {
          var z = qt(g) ? KU : hW, Q = h ? h() : {};
          return z(g, l, St(C, 2), Q);
        };
      }
      function rp(l) {
        return tr(function(h, g) {
          var C = -1, z = g.length, Q = z > 1 ? g[z - 1] : t, oe = z > 2 ? g[2] : t;
          for (Q = l.length > 3 && typeof Q == "function" ? (z--, Q) : t, oe && Vi(g[0], g[1], oe) && (Q = z < 3 ? t : Q, z = 1), h = Zr(h); ++C < z; ) {
            var ce = g[C];
            ce && l(h, ce, C, Q);
          }
          return h;
        });
      }
      function Y8(l, h) {
        return function(g, C) {
          if (g == null)
            return g;
          if (!vs(g))
            return l(g, C);
          for (var z = g.length, Q = h ? z : -1, oe = Zr(g); (h ? Q-- : ++Q < z) && C(oe[Q], Q, oe) !== !1; )
            ;
          return g;
        };
      }
      function X8(l) {
        return function(h, g, C) {
          for (var z = -1, Q = Zr(h), oe = C(h), ce = oe.length; ce--; ) {
            var pe = oe[l ? ce : ++z];
            if (g(Q[pe], pe, Q) === !1)
              break;
          }
          return h;
        };
      }
      function zW(l, h, g) {
        var C = h & k, z = b1(l);
        function Q() {
          var oe = this && this !== pr && this instanceof Q ? z : l;
          return oe.apply(C ? g : this, arguments);
        }
        return Q;
      }
      function eI(l) {
        return function(h) {
          h = Or(h);
          var g = Zd(h) ? ea(h) : t, C = g ? g[0] : h.charAt(0), z = g ? tu(g, 1).join("") : h.slice(1);
          return C[l]() + z;
        };
      }
      function np(l) {
        return function(h) {
          return xE(YI(QI(h).replace(a1, "")), l, "");
        };
      }
      function b1(l) {
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return new l();
            case 1:
              return new l(h[0]);
            case 2:
              return new l(h[0], h[1]);
            case 3:
              return new l(h[0], h[1], h[2]);
            case 4:
              return new l(h[0], h[1], h[2], h[3]);
            case 5:
              return new l(h[0], h[1], h[2], h[3], h[4]);
            case 6:
              return new l(h[0], h[1], h[2], h[3], h[4], h[5]);
            case 7:
              return new l(h[0], h[1], h[2], h[3], h[4], h[5], h[6]);
          }
          var g = tp(l.prototype), C = l.apply(g, h);
          return ln(C) ? C : g;
        };
      }
      function VW(l, h, g) {
        var C = b1(l);
        function z() {
          for (var Q = arguments.length, oe = Se(Q), ce = Q, pe = ip(z); ce--; )
            oe[ce] = arguments[ce];
          var Ie = Q < 3 && oe[0] !== pe && oe[Q - 1] !== pe ? [] : Jl(oe, pe);
          if (Q -= Ie.length, Q < g)
            return sI(l, h, Tv, z.placeholder, t, oe, Ie, t, t, g - Q);
          var Re = this && this !== pr && this instanceof z ? C : l;
          return Qn(Re, this, oe);
        }
        return z;
      }
      function tI(l) {
        return function(h, g, C) {
          var z = Zr(h);
          if (!vs(h)) {
            var Q = St(g, 3);
            h = Yn(h), g = function(ce) {
              return Q(z[ce], ce, z);
            };
          }
          var oe = l(h, g, C);
          return oe > -1 ? z[Q ? h[oe] : oe] : t;
        };
      }
      function rI(l) {
        return Hc(function(h) {
          var g = h.length, C = g, z = go.prototype.thru;
          for (l && h.reverse(); C--; ) {
            var Q = h[C];
            if (typeof Q != "function")
              throw new po(o);
            if (z && !oe && Mv(Q) == "wrapper")
              var oe = new go([], !0);
          }
          for (C = oe ? C : g; ++C < g; ) {
            Q = h[C];
            var ce = Mv(Q), pe = ce == "wrapper" ? n5(Q) : t;
            pe && a5(pe[0]) && pe[1] == (v | $ | L | F) && !pe[4].length && pe[9] == 1 ? oe = oe[Mv(pe[0])].apply(oe, pe[3]) : oe = Q.length == 1 && a5(Q) ? oe[ce]() : oe.thru(Q);
          }
          return function() {
            var Ie = arguments, Re = Ie[0];
            if (oe && Ie.length == 1 && qt(Re))
              return oe.plant(Re).value();
            for (var Me = 0, Ve = g ? h[Me].apply(this, Ie) : Re; ++Me < g; )
              Ve = h[Me].call(this, Ve);
            return Ve;
          };
        });
      }
      function Tv(l, h, g, C, z, Q, oe, ce, pe, Ie) {
        var Re = h & v, Me = h & k, Ve = h & R, ht = h & ($ | D), Ct = h & X, Qt = Ve ? t : b1(l);
        function At() {
          for (var cr = arguments.length, gr = Se(cr), Ws = cr; Ws--; )
            gr[Ws] = arguments[Ws];
          if (ht)
            var qi = ip(At), Hs = nj(gr, qi);
          if (C && (gr = J8(gr, C, z, ht)), Q && (gr = Q8(gr, Q, oe, ht)), cr -= Hs, ht && cr < Ie) {
            var Mn = Jl(gr, qi);
            return sI(l, h, Tv, At.placeholder, g, gr, Mn, ce, pe, Ie - cr);
          }
          var na = Me ? g : this, Gc = Ve ? na[l] : l;
          return cr = gr.length, ce ? gr = hH(gr, ce) : Ct && cr > 1 && gr.reverse(), Re && pe < cr && (gr.length = pe), this && this !== pr && this instanceof At && (Gc = Qt || b1(Gc)), Gc.apply(na, gr);
        }
        return At;
      }
      function nI(l, h) {
        return function(g, C) {
          return vW(g, l, h(C), {});
        };
      }
      function Ov(l, h) {
        return function(g, C) {
          var z;
          if (g === t && C === t)
            return h;
          if (g !== t && (z = g), C !== t) {
            if (z === t)
              return C;
            typeof g == "string" || typeof C == "string" ? (g = Us(g), C = Us(C)) : (g = W8(g), C = W8(C)), z = l(g, C);
          }
          return z;
        };
      }
      function XE(l) {
        return Hc(function(h) {
          return h = sn(h, Fs(St())), tr(function(g) {
            var C = this;
            return l(h, function(z) {
              return Qn(z, C, g);
            });
          });
        });
      }
      function Nv(l, h) {
        h = h === t ? " " : Us(h);
        var g = h.length;
        if (g < 2)
          return g ? qE(h, l) : h;
        var C = qE(h, wv(l / Jd(h)));
        return Zd(h) ? tu(ea(C), 0, l).join("") : C.slice(0, l);
      }
      function qW(l, h, g, C) {
        var z = h & k, Q = b1(l);
        function oe() {
          for (var ce = -1, pe = arguments.length, Ie = -1, Re = C.length, Me = Se(Re + pe), Ve = this && this !== pr && this instanceof oe ? Q : l; ++Ie < Re; )
            Me[Ie] = C[Ie];
          for (; pe--; )
            Me[Ie++] = arguments[++ce];
          return Qn(Ve, z ? g : this, Me);
        }
        return oe;
      }
      function iI(l) {
        return function(h, g, C) {
          return C && typeof C != "number" && Vi(h, g, C) && (g = C = t), h = qc(h), g === t ? (g = h, h = 0) : g = qc(g), C = C === t ? h < g ? 1 : -1 : qc(C), NW(h, g, C, l);
        };
      }
      function Pv(l) {
        return function(h, g) {
          return typeof h == "string" && typeof g == "string" || (h = vo(h), g = vo(g)), l(h, g);
        };
      }
      function sI(l, h, g, C, z, Q, oe, ce, pe, Ie) {
        var Re = h & $, Me = Re ? oe : t, Ve = Re ? t : oe, ht = Re ? Q : t, Ct = Re ? t : Q;
        h |= Re ? L : P, h &= ~(Re ? P : L), h & T || (h &= ~(k | R));
        var Qt = [l, h, z, ht, Me, Ct, Ve, ce, pe, Ie], At = g.apply(t, Qt);
        return a5(l) && wI(At, Qt), At.placeholder = C, yI(At, l, h);
      }
      function e5(l) {
        var h = qn[l];
        return function(g, C) {
          if (g = vo(g), C = C == null ? 0 : Ei(Zt(C), 292), C && y8(g)) {
            var z = (Or(g) + "e").split("e"), Q = h(z[0] + "e" + (+z[1] + C));
            return z = (Or(Q) + "e").split("e"), +(z[0] + "e" + (+z[1] - C));
          }
          return h(g);
        };
      }
      var GW = Xd && 1 / av(new Xd([, -0]))[1] == N ? function(l) {
        return new Xd(l);
      } : E5;
      function oI(l) {
        return function(h) {
          var g = xi(h);
          return g == Ee ? OE(h) : g == We ? uj(h) : rj(h, l(h));
        };
      }
      function Wc(l, h, g, C, z, Q, oe, ce) {
        var pe = h & R;
        if (!pe && typeof l != "function")
          throw new po(o);
        var Ie = C ? C.length : 0;
        if (Ie || (h &= ~(L | P), C = z = t), oe = oe === t ? oe : Gn(Zt(oe), 0), ce = ce === t ? ce : Zt(ce), Ie -= z ? z.length : 0, h & P) {
          var Re = C, Me = z;
          C = z = t;
        }
        var Ve = pe ? t : n5(l), ht = [l, h, g, C, z, Re, Me, Q, oe, ce];
        if (Ve && cH(ht, Ve), l = ht[0], h = ht[1], g = ht[2], C = ht[3], z = ht[4], ce = ht[9] = ht[9] === t ? pe ? 0 : l.length : Gn(ht[9] - Ie, 0), !ce && h & ($ | D) && (h &= ~($ | D)), !h || h == k)
          var Ct = zW(l, h, g);
        else
          h == $ || h == D ? Ct = VW(l, h, ce) : (h == L || h == (k | L)) && !z.length ? Ct = qW(l, h, g, C) : Ct = Tv.apply(t, ht);
        var Qt = Ve ? U8 : wI;
        return yI(Qt(Ct, ht), l, h);
      }
      function aI(l, h, g, C) {
        return l === t || ra(l, Yd[g]) && !kr.call(C, g) ? h : l;
      }
      function cI(l, h, g, C, z, Q) {
        return ln(l) && ln(h) && (Q.set(h, l), Cv(l, h, t, cI, Q), Q.delete(h)), l;
      }
      function KW(l) {
        return x1(l) ? t : l;
      }
      function lI(l, h, g, C, z, Q) {
        var oe = g & b, ce = l.length, pe = h.length;
        if (ce != pe && !(oe && pe > ce))
          return !1;
        var Ie = Q.get(l), Re = Q.get(h);
        if (Ie && Re)
          return Ie == h && Re == l;
        var Me = -1, Ve = !0, ht = g & I ? new Oh() : t;
        for (Q.set(l, h), Q.set(h, l); ++Me < ce; ) {
          var Ct = l[Me], Qt = h[Me];
          if (C)
            var At = oe ? C(Qt, Ct, Me, h, l, Q) : C(Ct, Qt, Me, l, h, Q);
          if (At !== t) {
            if (At)
              continue;
            Ve = !1;
            break;
          }
          if (ht) {
            if (!SE(h, function(cr, gr) {
              if (!l1(ht, gr) && (Ct === cr || z(Ct, cr, g, C, Q)))
                return ht.push(gr);
            })) {
              Ve = !1;
              break;
            }
          } else if (!(Ct === Qt || z(Ct, Qt, g, C, Q))) {
            Ve = !1;
            break;
          }
        }
        return Q.delete(l), Q.delete(h), Ve;
      }
      function ZW(l, h, g, C, z, Q, oe) {
        switch (g) {
          case _:
            if (l.byteLength != h.byteLength || l.byteOffset != h.byteOffset)
              return !1;
            l = l.buffer, h = h.buffer;
          case W:
            return !(l.byteLength != h.byteLength || !Q(new dv(l), new dv(h)));
          case Y:
          case ee:
          case Le:
            return ra(+l, +h);
          case M:
            return l.name == h.name && l.message == h.message;
          case Qe:
          case lt:
            return l == h + "";
          case Ee:
            var ce = OE;
          case We:
            var pe = C & b;
            if (ce || (ce = av), l.size != h.size && !pe)
              return !1;
            var Ie = oe.get(l);
            if (Ie)
              return Ie == h;
            C |= I, oe.set(l, h);
            var Re = lI(ce(l), ce(h), C, z, Q, oe);
            return oe.delete(l), Re;
          case qe:
            if (p1)
              return p1.call(l) == p1.call(h);
        }
        return !1;
      }
      function JW(l, h, g, C, z, Q) {
        var oe = g & b, ce = t5(l), pe = ce.length, Ie = t5(h), Re = Ie.length;
        if (pe != Re && !oe)
          return !1;
        for (var Me = pe; Me--; ) {
          var Ve = ce[Me];
          if (!(oe ? Ve in h : kr.call(h, Ve)))
            return !1;
        }
        var ht = Q.get(l), Ct = Q.get(h);
        if (ht && Ct)
          return ht == h && Ct == l;
        var Qt = !0;
        Q.set(l, h), Q.set(h, l);
        for (var At = oe; ++Me < pe; ) {
          Ve = ce[Me];
          var cr = l[Ve], gr = h[Ve];
          if (C)
            var Ws = oe ? C(gr, cr, Ve, h, l, Q) : C(cr, gr, Ve, l, h, Q);
          if (!(Ws === t ? cr === gr || z(cr, gr, g, C, Q) : Ws)) {
            Qt = !1;
            break;
          }
          At || (At = Ve == "constructor");
        }
        if (Qt && !At) {
          var qi = l.constructor, Hs = h.constructor;
          qi != Hs && "constructor" in l && "constructor" in h && !(typeof qi == "function" && qi instanceof qi && typeof Hs == "function" && Hs instanceof Hs) && (Qt = !1);
        }
        return Q.delete(l), Q.delete(h), Qt;
      }
      function Hc(l) {
        return l5(gI(l, t, SI), l + "");
      }
      function t5(l) {
        return T8(l, Yn, s5);
      }
      function r5(l) {
        return T8(l, bs, uI);
      }
      var n5 = vv ? function(l) {
        return vv.get(l);
      } : E5;
      function Mv(l) {
        for (var h = l.name + "", g = ep[h], C = kr.call(ep, h) ? g.length : 0; C--; ) {
          var z = g[C], Q = z.func;
          if (Q == null || Q == l)
            return z.name;
        }
        return h;
      }
      function ip(l) {
        var h = kr.call(Z, "placeholder") ? Z : l;
        return h.placeholder;
      }
      function St() {
        var l = Z.iteratee || b5;
        return l = l === b5 ? P8 : l, arguments.length ? l(arguments[0], arguments[1]) : l;
      }
      function Dv(l, h) {
        var g = l.__data__;
        return iH(h) ? g[typeof h == "string" ? "string" : "hash"] : g.map;
      }
      function i5(l) {
        for (var h = Yn(l), g = h.length; g--; ) {
          var C = h[g], z = l[C];
          h[g] = [C, z, dI(z)];
        }
        return h;
      }
      function Mh(l, h) {
        var g = aj(l, h);
        return N8(g) ? g : t;
      }
      function QW(l) {
        var h = kr.call(l, Rh), g = l[Rh];
        try {
          l[Rh] = t;
          var C = !0;
        } catch {
        }
        var z = hv.call(l);
        return C && (h ? l[Rh] = g : delete l[Rh]), z;
      }
      var s5 = PE ? function(l) {
        return l == null ? [] : (l = Zr(l), Kl(PE(l), function(h) {
          return m8.call(l, h);
        }));
      } : x5, uI = PE ? function(l) {
        for (var h = []; l; )
          Zl(h, s5(l)), l = pv(l);
        return h;
      } : x5, xi = zi;
      (ME && xi(new ME(new ArrayBuffer(1))) != _ || h1 && xi(new h1()) != Ee || DE && xi(DE.resolve()) != dt || Xd && xi(new Xd()) != We || f1 && xi(new f1()) != st) && (xi = function(l) {
        var h = zi(l), g = h == De ? l.constructor : t, C = g ? Dh(g) : "";
        if (C)
          switch (C) {
            case Mj:
              return _;
            case Dj:
              return Ee;
            case kj:
              return dt;
            case $j:
              return We;
            case Lj:
              return st;
          }
        return h;
      });
      function YW(l, h, g) {
        for (var C = -1, z = g.length; ++C < z; ) {
          var Q = g[C], oe = Q.size;
          switch (Q.type) {
            case "drop":
              l += oe;
              break;
            case "dropRight":
              h -= oe;
              break;
            case "take":
              h = Ei(h, l + oe);
              break;
            case "takeRight":
              l = Gn(l, h - oe);
              break;
          }
        }
        return { start: l, end: h };
      }
      function XW(l) {
        var h = l.match(xt);
        return h ? h[1].split(Ft) : [];
      }
      function hI(l, h, g) {
        h = eu(h, l);
        for (var C = -1, z = h.length, Q = !1; ++C < z; ) {
          var oe = Za(h[C]);
          if (!(Q = l != null && g(l, oe)))
            break;
          l = l[oe];
        }
        return Q || ++C != z ? Q : (z = l == null ? 0 : l.length, !!z && jv(z) && zc(oe, z) && (qt(l) || kh(l)));
      }
      function eH(l) {
        var h = l.length, g = new l.constructor(h);
        return h && typeof l[0] == "string" && kr.call(l, "index") && (g.index = l.index, g.input = l.input), g;
      }
      function fI(l) {
        return typeof l.constructor == "function" && !_1(l) ? tp(pv(l)) : {};
      }
      function tH(l, h, g) {
        var C = l.constructor;
        switch (h) {
          case W:
            return YE(l);
          case Y:
          case ee:
            return new C(+l);
          case _:
            return BW(l, g);
          case A:
          case J:
          case ae:
          case le:
          case ge:
          case je:
          case Ue:
          case it:
          case jt:
            return K8(l, g);
          case Ee:
            return new C();
          case Le:
          case lt:
            return new C(l);
          case Qe:
            return FW(l);
          case We:
            return new C();
          case qe:
            return UW(l);
        }
      }
      function rH(l, h) {
        var g = h.length;
        if (!g)
          return l;
        var C = g - 1;
        return h[C] = (g > 1 ? "& " : "") + h[C], h = h.join(g > 2 ? ", " : " "), l.replace(Dr, `{
/* [wrapped with ` + h + `] */
`);
      }
      function nH(l) {
        return qt(l) || kh(l) || !!(w8 && l && l[w8]);
      }
      function zc(l, h) {
        var g = typeof l;
        return h = h ?? O, !!h && (g == "number" || g != "symbol" && Zo.test(l)) && l > -1 && l % 1 == 0 && l < h;
      }
      function Vi(l, h, g) {
        if (!ln(g))
          return !1;
        var C = typeof h;
        return (C == "number" ? vs(g) && zc(h, g.length) : C == "string" && h in g) ? ra(g[h], l) : !1;
      }
      function o5(l, h) {
        if (qt(l))
          return !1;
        var g = typeof l;
        return g == "number" || g == "symbol" || g == "boolean" || l == null || js(l) ? !0 : Hr.test(l) || !Rt.test(l) || h != null && l in Zr(h);
      }
      function iH(l) {
        var h = typeof l;
        return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? l !== "__proto__" : l === null;
      }
      function a5(l) {
        var h = Mv(l), g = Z[h];
        if (typeof g != "function" || !(h in ur.prototype))
          return !1;
        if (l === g)
          return !0;
        var C = n5(g);
        return !!C && l === C[0];
      }
      function sH(l) {
        return !!d8 && d8 in l;
      }
      var oH = lv ? Vc : S5;
      function _1(l) {
        var h = l && l.constructor, g = typeof h == "function" && h.prototype || Yd;
        return l === g;
      }
      function dI(l) {
        return l === l && !ln(l);
      }
      function pI(l, h) {
        return function(g) {
          return g == null ? !1 : g[l] === h && (h !== t || l in Zr(g));
        };
      }
      function aH(l) {
        var h = Fv(l, function(C) {
          return g.size === u && g.clear(), C;
        }), g = h.cache;
        return h;
      }
      function cH(l, h) {
        var g = l[1], C = h[1], z = g | C, Q = z < (k | R | v), oe = C == v && g == $ || C == v && g == F && l[7].length <= h[8] || C == (v | F) && h[7].length <= h[8] && g == $;
        if (!(Q || oe))
          return l;
        C & k && (l[2] = h[2], z |= g & k ? 0 : T);
        var ce = h[3];
        if (ce) {
          var pe = l[3];
          l[3] = pe ? J8(pe, ce, h[4]) : ce, l[4] = pe ? Jl(l[3], f) : h[4];
        }
        return ce = h[5], ce && (pe = l[5], l[5] = pe ? Q8(pe, ce, h[6]) : ce, l[6] = pe ? Jl(l[5], f) : h[6]), ce = h[7], ce && (l[7] = ce), C & v && (l[8] = l[8] == null ? h[8] : Ei(l[8], h[8])), l[9] == null && (l[9] = h[9]), l[0] = h[0], l[1] = z, l;
      }
      function lH(l) {
        var h = [];
        if (l != null)
          for (var g in Zr(l))
            h.push(g);
        return h;
      }
      function uH(l) {
        return hv.call(l);
      }
      function gI(l, h, g) {
        return h = Gn(h === t ? l.length - 1 : h, 0), function() {
          for (var C = arguments, z = -1, Q = Gn(C.length - h, 0), oe = Se(Q); ++z < Q; )
            oe[z] = C[h + z];
          z = -1;
          for (var ce = Se(h + 1); ++z < h; )
            ce[z] = C[z];
          return ce[h] = g(oe), Qn(l, this, ce);
        };
      }
      function mI(l, h) {
        return h.length < 2 ? l : Ph(l, wo(h, 0, -1));
      }
      function hH(l, h) {
        for (var g = l.length, C = Ei(h.length, g), z = ys(l); C--; ) {
          var Q = h[C];
          l[C] = zc(Q, g) ? z[Q] : t;
        }
        return l;
      }
      function c5(l, h) {
        if (!(h === "constructor" && typeof l[h] == "function") && h != "__proto__")
          return l[h];
      }
      var wI = vI(U8), E1 = Aj || function(l, h) {
        return pr.setTimeout(l, h);
      }, l5 = vI(DW);
      function yI(l, h, g) {
        var C = h + "";
        return l5(l, rH(C, fH(XW(C), g)));
      }
      function vI(l) {
        var h = 0, g = 0;
        return function() {
          var C = Oj(), z = H - (C - g);
          if (g = C, z > 0) {
            if (++h >= we)
              return arguments[0];
          } else
            h = 0;
          return l.apply(t, arguments);
        };
      }
      function kv(l, h) {
        var g = -1, C = l.length, z = C - 1;
        for (h = h === t ? C : h; ++g < h; ) {
          var Q = VE(g, z), oe = l[Q];
          l[Q] = l[g], l[g] = oe;
        }
        return l.length = h, l;
      }
      var bI = aH(function(l) {
        var h = [];
        return l.charCodeAt(0) === 46 && h.push(""), l.replace(Bt, function(g, C, z, Q) {
          h.push(z ? Q.replace(Lr, "$1") : C || g);
        }), h;
      });
      function Za(l) {
        if (typeof l == "string" || js(l))
          return l;
        var h = l + "";
        return h == "0" && 1 / l == -N ? "-0" : h;
      }
      function Dh(l) {
        if (l != null) {
          try {
            return uv.call(l);
          } catch {
          }
          try {
            return l + "";
          } catch {
          }
        }
        return "";
      }
      function fH(l, h) {
        return fo(be, function(g) {
          var C = "_." + g[0];
          h & g[1] && !sv(l, C) && l.push(C);
        }), l.sort();
      }
      function _I(l) {
        if (l instanceof ur)
          return l.clone();
        var h = new go(l.__wrapped__, l.__chain__);
        return h.__actions__ = ys(l.__actions__), h.__index__ = l.__index__, h.__values__ = l.__values__, h;
      }
      function dH(l, h, g) {
        (g ? Vi(l, h, g) : h === t) ? h = 1 : h = Gn(Zt(h), 0);
        var C = l == null ? 0 : l.length;
        if (!C || h < 1)
          return [];
        for (var z = 0, Q = 0, oe = Se(wv(C / h)); z < C; )
          oe[Q++] = wo(l, z, z += h);
        return oe;
      }
      function pH(l) {
        for (var h = -1, g = l == null ? 0 : l.length, C = 0, z = []; ++h < g; ) {
          var Q = l[h];
          Q && (z[C++] = Q);
        }
        return z;
      }
      function gH() {
        var l = arguments.length;
        if (!l)
          return [];
        for (var h = Se(l - 1), g = arguments[0], C = l; C--; )
          h[C - 1] = arguments[C];
        return Zl(qt(g) ? ys(g) : [g], fi(h, 1));
      }
      var mH = tr(function(l, h) {
        return Pn(l) ? m1(l, fi(h, 1, Pn, !0)) : [];
      }), wH = tr(function(l, h) {
        var g = yo(h);
        return Pn(g) && (g = t), Pn(l) ? m1(l, fi(h, 1, Pn, !0), St(g, 2)) : [];
      }), yH = tr(function(l, h) {
        var g = yo(h);
        return Pn(g) && (g = t), Pn(l) ? m1(l, fi(h, 1, Pn, !0), t, g) : [];
      });
      function vH(l, h, g) {
        var C = l == null ? 0 : l.length;
        return C ? (h = g || h === t ? 1 : Zt(h), wo(l, h < 0 ? 0 : h, C)) : [];
      }
      function bH(l, h, g) {
        var C = l == null ? 0 : l.length;
        return C ? (h = g || h === t ? 1 : Zt(h), h = C - h, wo(l, 0, h < 0 ? 0 : h)) : [];
      }
      function _H(l, h) {
        return l && l.length ? Iv(l, St(h, 3), !0, !0) : [];
      }
      function EH(l, h) {
        return l && l.length ? Iv(l, St(h, 3), !0) : [];
      }
      function xH(l, h, g, C) {
        var z = l == null ? 0 : l.length;
        return z ? (g && typeof g != "number" && Vi(l, h, g) && (g = 0, C = z), gW(l, h, g, C)) : [];
      }
      function EI(l, h, g) {
        var C = l == null ? 0 : l.length;
        if (!C)
          return -1;
        var z = g == null ? 0 : Zt(g);
        return z < 0 && (z = Gn(C + z, 0)), ov(l, St(h, 3), z);
      }
      function xI(l, h, g) {
        var C = l == null ? 0 : l.length;
        if (!C)
          return -1;
        var z = C - 1;
        return g !== t && (z = Zt(g), z = g < 0 ? Gn(C + z, 0) : Ei(z, C - 1)), ov(l, St(h, 3), z, !0);
      }
      function SI(l) {
        var h = l == null ? 0 : l.length;
        return h ? fi(l, 1) : [];
      }
      function SH(l) {
        var h = l == null ? 0 : l.length;
        return h ? fi(l, N) : [];
      }
      function CH(l, h) {
        var g = l == null ? 0 : l.length;
        return g ? (h = h === t ? 1 : Zt(h), fi(l, h)) : [];
      }
      function AH(l) {
        for (var h = -1, g = l == null ? 0 : l.length, C = {}; ++h < g; ) {
          var z = l[h];
          C[z[0]] = z[1];
        }
        return C;
      }
      function CI(l) {
        return l && l.length ? l[0] : t;
      }
      function IH(l, h, g) {
        var C = l == null ? 0 : l.length;
        if (!C)
          return -1;
        var z = g == null ? 0 : Zt(g);
        return z < 0 && (z = Gn(C + z, 0)), Kd(l, h, z);
      }
      function RH(l) {
        var h = l == null ? 0 : l.length;
        return h ? wo(l, 0, -1) : [];
      }
      var TH = tr(function(l) {
        var h = sn(l, JE);
        return h.length && h[0] === l[0] ? UE(h) : [];
      }), OH = tr(function(l) {
        var h = yo(l), g = sn(l, JE);
        return h === yo(g) ? h = t : g.pop(), g.length && g[0] === l[0] ? UE(g, St(h, 2)) : [];
      }), NH = tr(function(l) {
        var h = yo(l), g = sn(l, JE);
        return h = typeof h == "function" ? h : t, h && g.pop(), g.length && g[0] === l[0] ? UE(g, t, h) : [];
      });
      function PH(l, h) {
        return l == null ? "" : Rj.call(l, h);
      }
      function yo(l) {
        var h = l == null ? 0 : l.length;
        return h ? l[h - 1] : t;
      }
      function MH(l, h, g) {
        var C = l == null ? 0 : l.length;
        if (!C)
          return -1;
        var z = C;
        return g !== t && (z = Zt(g), z = z < 0 ? Gn(C + z, 0) : Ei(z, C - 1)), h === h ? fj(l, h, z) : ov(l, s8, z, !0);
      }
      function DH(l, h) {
        return l && l.length ? $8(l, Zt(h)) : t;
      }
      var kH = tr(AI);
      function AI(l, h) {
        return l && l.length && h && h.length ? zE(l, h) : l;
      }
      function $H(l, h, g) {
        return l && l.length && h && h.length ? zE(l, h, St(g, 2)) : l;
      }
      function LH(l, h, g) {
        return l && l.length && h && h.length ? zE(l, h, t, g) : l;
      }
      var BH = Hc(function(l, h) {
        var g = l == null ? 0 : l.length, C = $E(l, h);
        return F8(l, sn(h, function(z) {
          return zc(z, g) ? +z : z;
        }).sort(Z8)), C;
      });
      function FH(l, h) {
        var g = [];
        if (!(l && l.length))
          return g;
        var C = -1, z = [], Q = l.length;
        for (h = St(h, 3); ++C < Q; ) {
          var oe = l[C];
          h(oe, C, l) && (g.push(oe), z.push(C));
        }
        return F8(l, z), g;
      }
      function u5(l) {
        return l == null ? l : Pj.call(l);
      }
      function UH(l, h, g) {
        var C = l == null ? 0 : l.length;
        return C ? (g && typeof g != "number" && Vi(l, h, g) ? (h = 0, g = C) : (h = h == null ? 0 : Zt(h), g = g === t ? C : Zt(g)), wo(l, h, g)) : [];
      }
      function jH(l, h) {
        return Av(l, h);
      }
      function WH(l, h, g) {
        return GE(l, h, St(g, 2));
      }
      function HH(l, h) {
        var g = l == null ? 0 : l.length;
        if (g) {
          var C = Av(l, h);
          if (C < g && ra(l[C], h))
            return C;
        }
        return -1;
      }
      function zH(l, h) {
        return Av(l, h, !0);
      }
      function VH(l, h, g) {
        return GE(l, h, St(g, 2), !0);
      }
      function qH(l, h) {
        var g = l == null ? 0 : l.length;
        if (g) {
          var C = Av(l, h, !0) - 1;
          if (ra(l[C], h))
            return C;
        }
        return -1;
      }
      function GH(l) {
        return l && l.length ? j8(l) : [];
      }
      function KH(l, h) {
        return l && l.length ? j8(l, St(h, 2)) : [];
      }
      function ZH(l) {
        var h = l == null ? 0 : l.length;
        return h ? wo(l, 1, h) : [];
      }
      function JH(l, h, g) {
        return l && l.length ? (h = g || h === t ? 1 : Zt(h), wo(l, 0, h < 0 ? 0 : h)) : [];
      }
      function QH(l, h, g) {
        var C = l == null ? 0 : l.length;
        return C ? (h = g || h === t ? 1 : Zt(h), h = C - h, wo(l, h < 0 ? 0 : h, C)) : [];
      }
      function YH(l, h) {
        return l && l.length ? Iv(l, St(h, 3), !1, !0) : [];
      }
      function XH(l, h) {
        return l && l.length ? Iv(l, St(h, 3)) : [];
      }
      var ez = tr(function(l) {
        return Xl(fi(l, 1, Pn, !0));
      }), tz = tr(function(l) {
        var h = yo(l);
        return Pn(h) && (h = t), Xl(fi(l, 1, Pn, !0), St(h, 2));
      }), rz = tr(function(l) {
        var h = yo(l);
        return h = typeof h == "function" ? h : t, Xl(fi(l, 1, Pn, !0), t, h);
      });
      function nz(l) {
        return l && l.length ? Xl(l) : [];
      }
      function iz(l, h) {
        return l && l.length ? Xl(l, St(h, 2)) : [];
      }
      function sz(l, h) {
        return h = typeof h == "function" ? h : t, l && l.length ? Xl(l, t, h) : [];
      }
      function h5(l) {
        if (!(l && l.length))
          return [];
        var h = 0;
        return l = Kl(l, function(g) {
          if (Pn(g))
            return h = Gn(g.length, h), !0;
        }), RE(h, function(g) {
          return sn(l, CE(g));
        });
      }
      function II(l, h) {
        if (!(l && l.length))
          return [];
        var g = h5(l);
        return h == null ? g : sn(g, function(C) {
          return Qn(h, t, C);
        });
      }
      var oz = tr(function(l, h) {
        return Pn(l) ? m1(l, h) : [];
      }), az = tr(function(l) {
        return ZE(Kl(l, Pn));
      }), cz = tr(function(l) {
        var h = yo(l);
        return Pn(h) && (h = t), ZE(Kl(l, Pn), St(h, 2));
      }), lz = tr(function(l) {
        var h = yo(l);
        return h = typeof h == "function" ? h : t, ZE(Kl(l, Pn), t, h);
      }), uz = tr(h5);
      function hz(l, h) {
        return V8(l || [], h || [], g1);
      }
      function fz(l, h) {
        return V8(l || [], h || [], v1);
      }
      var dz = tr(function(l) {
        var h = l.length, g = h > 1 ? l[h - 1] : t;
        return g = typeof g == "function" ? (l.pop(), g) : t, II(l, g);
      });
      function RI(l) {
        var h = Z(l);
        return h.__chain__ = !0, h;
      }
      function pz(l, h) {
        return h(l), l;
      }
      function $v(l, h) {
        return h(l);
      }
      var gz = Hc(function(l) {
        var h = l.length, g = h ? l[0] : 0, C = this.__wrapped__, z = function(Q) {
          return $E(Q, l);
        };
        return h > 1 || this.__actions__.length || !(C instanceof ur) || !zc(g) ? this.thru(z) : (C = C.slice(g, +g + (h ? 1 : 0)), C.__actions__.push({ func: $v, args: [z], thisArg: t }), new go(C, this.__chain__).thru(function(Q) {
          return h && !Q.length && Q.push(t), Q;
        }));
      });
      function mz() {
        return RI(this);
      }
      function wz() {
        return new go(this.value(), this.__chain__);
      }
      function yz() {
        this.__values__ === t && (this.__values__ = WI(this.value()));
        var l = this.__index__ >= this.__values__.length, h = l ? t : this.__values__[this.__index__++];
        return { done: l, value: h };
      }
      function vz() {
        return this;
      }
      function bz(l) {
        for (var h, g = this; g instanceof _v; ) {
          var C = _I(g);
          C.__index__ = 0, C.__values__ = t, h ? z.__wrapped__ = C : h = C;
          var z = C;
          g = g.__wrapped__;
        }
        return z.__wrapped__ = l, h;
      }
      function _z() {
        var l = this.__wrapped__;
        if (l instanceof ur) {
          var h = l;
          return this.__actions__.length && (h = new ur(this)), h = h.reverse(), h.__actions__.push({ func: $v, args: [u5], thisArg: t }), new go(h, this.__chain__);
        }
        return this.thru(u5);
      }
      function Ez() {
        return z8(this.__wrapped__, this.__actions__);
      }
      var xz = Rv(function(l, h, g) {
        kr.call(l, g) ? ++l[g] : jc(l, g, 1);
      });
      function Sz(l, h, g) {
        var C = qt(l) ? n8 : pW;
        return g && Vi(l, h, g) && (h = t), C(l, St(h, 3));
      }
      function Cz(l, h) {
        var g = qt(l) ? Kl : I8;
        return g(l, St(h, 3));
      }
      var Az = tI(EI), Iz = tI(xI);
      function Rz(l, h) {
        return fi(Lv(l, h), 1);
      }
      function Tz(l, h) {
        return fi(Lv(l, h), N);
      }
      function Oz(l, h, g) {
        return g = g === t ? 1 : Zt(g), fi(Lv(l, h), g);
      }
      function TI(l, h) {
        var g = qt(l) ? fo : Yl;
        return g(l, St(h, 3));
      }
      function OI(l, h) {
        var g = qt(l) ? ZU : A8;
        return g(l, St(h, 3));
      }
      var Nz = Rv(function(l, h, g) {
        kr.call(l, g) ? l[g].push(h) : jc(l, g, [h]);
      });
      function Pz(l, h, g, C) {
        l = vs(l) ? l : op(l), g = g && !C ? Zt(g) : 0;
        var z = l.length;
        return g < 0 && (g = Gn(z + g, 0)), Wv(l) ? g <= z && l.indexOf(h, g) > -1 : !!z && Kd(l, h, g) > -1;
      }
      var Mz = tr(function(l, h, g) {
        var C = -1, z = typeof h == "function", Q = vs(l) ? Se(l.length) : [];
        return Yl(l, function(oe) {
          Q[++C] = z ? Qn(h, oe, g) : w1(oe, h, g);
        }), Q;
      }), Dz = Rv(function(l, h, g) {
        jc(l, g, h);
      });
      function Lv(l, h) {
        var g = qt(l) ? sn : M8;
        return g(l, St(h, 3));
      }
      function kz(l, h, g, C) {
        return l == null ? [] : (qt(h) || (h = h == null ? [] : [h]), g = C ? t : g, qt(g) || (g = g == null ? [] : [g]), L8(l, h, g));
      }
      var $z = Rv(function(l, h, g) {
        l[g ? 0 : 1].push(h);
      }, function() {
        return [[], []];
      });
      function Lz(l, h, g) {
        var C = qt(l) ? xE : a8, z = arguments.length < 3;
        return C(l, St(h, 4), g, z, Yl);
      }
      function Bz(l, h, g) {
        var C = qt(l) ? JU : a8, z = arguments.length < 3;
        return C(l, St(h, 4), g, z, A8);
      }
      function Fz(l, h) {
        var g = qt(l) ? Kl : I8;
        return g(l, Uv(St(h, 3)));
      }
      function Uz(l) {
        var h = qt(l) ? E8 : PW;
        return h(l);
      }
      function jz(l, h, g) {
        (g ? Vi(l, h, g) : h === t) ? h = 1 : h = Zt(h);
        var C = qt(l) ? lW : MW;
        return C(l, h);
      }
      function Wz(l) {
        var h = qt(l) ? uW : kW;
        return h(l);
      }
      function Hz(l) {
        if (l == null)
          return 0;
        if (vs(l))
          return Wv(l) ? Jd(l) : l.length;
        var h = xi(l);
        return h == Ee || h == We ? l.size : WE(l).length;
      }
      function zz(l, h, g) {
        var C = qt(l) ? SE : $W;
        return g && Vi(l, h, g) && (h = t), C(l, St(h, 3));
      }
      var Vz = tr(function(l, h) {
        if (l == null)
          return [];
        var g = h.length;
        return g > 1 && Vi(l, h[0], h[1]) ? h = [] : g > 2 && Vi(h[0], h[1], h[2]) && (h = [h[0]]), L8(l, fi(h, 1), []);
      }), Bv = Cj || function() {
        return pr.Date.now();
      };
      function qz(l, h) {
        if (typeof h != "function")
          throw new po(o);
        return l = Zt(l), function() {
          if (--l < 1)
            return h.apply(this, arguments);
        };
      }
      function NI(l, h, g) {
        return h = g ? t : h, h = l && h == null ? l.length : h, Wc(l, v, t, t, t, t, h);
      }
      function PI(l, h) {
        var g;
        if (typeof h != "function")
          throw new po(o);
        return l = Zt(l), function() {
          return --l > 0 && (g = h.apply(this, arguments)), l <= 1 && (h = t), g;
        };
      }
      var f5 = tr(function(l, h, g) {
        var C = k;
        if (g.length) {
          var z = Jl(g, ip(f5));
          C |= L;
        }
        return Wc(l, C, h, g, z);
      }), MI = tr(function(l, h, g) {
        var C = k | R;
        if (g.length) {
          var z = Jl(g, ip(MI));
          C |= L;
        }
        return Wc(h, C, l, g, z);
      });
      function DI(l, h, g) {
        h = g ? t : h;
        var C = Wc(l, $, t, t, t, t, t, h);
        return C.placeholder = DI.placeholder, C;
      }
      function kI(l, h, g) {
        h = g ? t : h;
        var C = Wc(l, D, t, t, t, t, t, h);
        return C.placeholder = kI.placeholder, C;
      }
      function $I(l, h, g) {
        var C, z, Q, oe, ce, pe, Ie = 0, Re = !1, Me = !1, Ve = !0;
        if (typeof l != "function")
          throw new po(o);
        h = vo(h) || 0, ln(g) && (Re = !!g.leading, Me = "maxWait" in g, Q = Me ? Gn(vo(g.maxWait) || 0, h) : Q, Ve = "trailing" in g ? !!g.trailing : Ve);
        function ht(Mn) {
          var na = C, Gc = z;
          return C = z = t, Ie = Mn, oe = l.apply(Gc, na), oe;
        }
        function Ct(Mn) {
          return Ie = Mn, ce = E1(cr, h), Re ? ht(Mn) : oe;
        }
        function Qt(Mn) {
          var na = Mn - pe, Gc = Mn - Ie, tR = h - na;
          return Me ? Ei(tR, Q - Gc) : tR;
        }
        function At(Mn) {
          var na = Mn - pe, Gc = Mn - Ie;
          return pe === t || na >= h || na < 0 || Me && Gc >= Q;
        }
        function cr() {
          var Mn = Bv();
          if (At(Mn))
            return gr(Mn);
          ce = E1(cr, Qt(Mn));
        }
        function gr(Mn) {
          return ce = t, Ve && C ? ht(Mn) : (C = z = t, oe);
        }
        function Ws() {
          ce !== t && q8(ce), Ie = 0, C = pe = z = ce = t;
        }
        function qi() {
          return ce === t ? oe : gr(Bv());
        }
        function Hs() {
          var Mn = Bv(), na = At(Mn);
          if (C = arguments, z = this, pe = Mn, na) {
            if (ce === t)
              return Ct(pe);
            if (Me)
              return q8(ce), ce = E1(cr, h), ht(pe);
          }
          return ce === t && (ce = E1(cr, h)), oe;
        }
        return Hs.cancel = Ws, Hs.flush = qi, Hs;
      }
      var Gz = tr(function(l, h) {
        return C8(l, 1, h);
      }), Kz = tr(function(l, h, g) {
        return C8(l, vo(h) || 0, g);
      });
      function Zz(l) {
        return Wc(l, X);
      }
      function Fv(l, h) {
        if (typeof l != "function" || h != null && typeof h != "function")
          throw new po(o);
        var g = function() {
          var C = arguments, z = h ? h.apply(this, C) : C[0], Q = g.cache;
          if (Q.has(z))
            return Q.get(z);
          var oe = l.apply(this, C);
          return g.cache = Q.set(z, oe) || Q, oe;
        };
        return g.cache = new (Fv.Cache || Uc)(), g;
      }
      Fv.Cache = Uc;
      function Uv(l) {
        if (typeof l != "function")
          throw new po(o);
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return !l.call(this);
            case 1:
              return !l.call(this, h[0]);
            case 2:
              return !l.call(this, h[0], h[1]);
            case 3:
              return !l.call(this, h[0], h[1], h[2]);
          }
          return !l.apply(this, h);
        };
      }
      function Jz(l) {
        return PI(2, l);
      }
      var Qz = LW(function(l, h) {
        h = h.length == 1 && qt(h[0]) ? sn(h[0], Fs(St())) : sn(fi(h, 1), Fs(St()));
        var g = h.length;
        return tr(function(C) {
          for (var z = -1, Q = Ei(C.length, g); ++z < Q; )
            C[z] = h[z].call(this, C[z]);
          return Qn(l, this, C);
        });
      }), d5 = tr(function(l, h) {
        var g = Jl(h, ip(d5));
        return Wc(l, L, t, h, g);
      }), LI = tr(function(l, h) {
        var g = Jl(h, ip(LI));
        return Wc(l, P, t, h, g);
      }), Yz = Hc(function(l, h) {
        return Wc(l, F, t, t, t, h);
      });
      function Xz(l, h) {
        if (typeof l != "function")
          throw new po(o);
        return h = h === t ? h : Zt(h), tr(l, h);
      }
      function eV(l, h) {
        if (typeof l != "function")
          throw new po(o);
        return h = h == null ? 0 : Gn(Zt(h), 0), tr(function(g) {
          var C = g[h], z = tu(g, 0, h);
          return C && Zl(z, C), Qn(l, this, z);
        });
      }
      function tV(l, h, g) {
        var C = !0, z = !0;
        if (typeof l != "function")
          throw new po(o);
        return ln(g) && (C = "leading" in g ? !!g.leading : C, z = "trailing" in g ? !!g.trailing : z), $I(l, h, { leading: C, maxWait: h, trailing: z });
      }
      function rV(l) {
        return NI(l, 1);
      }
      function nV(l, h) {
        return d5(QE(h), l);
      }
      function iV() {
        if (!arguments.length)
          return [];
        var l = arguments[0];
        return qt(l) ? l : [l];
      }
      function sV(l) {
        return mo(l, y);
      }
      function oV(l, h) {
        return h = typeof h == "function" ? h : t, mo(l, y, h);
      }
      function aV(l) {
        return mo(l, d | y);
      }
      function cV(l, h) {
        return h = typeof h == "function" ? h : t, mo(l, d | y, h);
      }
      function lV(l, h) {
        return h == null || S8(l, h, Yn(h));
      }
      function ra(l, h) {
        return l === h || l !== l && h !== h;
      }
      var uV = Pv(FE), hV = Pv(function(l, h) {
        return l >= h;
      }), kh = O8(/* @__PURE__ */ function() {
        return arguments;
      }()) ? O8 : function(l) {
        return _n(l) && kr.call(l, "callee") && !m8.call(l, "callee");
      }, qt = Se.isArray, fV = Hi ? Fs(Hi) : bW;
      function vs(l) {
        return l != null && jv(l.length) && !Vc(l);
      }
      function Pn(l) {
        return _n(l) && vs(l);
      }
      function dV(l) {
        return l === !0 || l === !1 || _n(l) && zi(l) == Y;
      }
      var ru = Ij || S5, pV = Xo ? Fs(Xo) : _W;
      function gV(l) {
        return _n(l) && l.nodeType === 1 && !x1(l);
      }
      function mV(l) {
        if (l == null)
          return !0;
        if (vs(l) && (qt(l) || typeof l == "string" || typeof l.splice == "function" || ru(l) || sp(l) || kh(l)))
          return !l.length;
        var h = xi(l);
        if (h == Ee || h == We)
          return !l.size;
        if (_1(l))
          return !WE(l).length;
        for (var g in l)
          if (kr.call(l, g))
            return !1;
        return !0;
      }
      function wV(l, h) {
        return y1(l, h);
      }
      function yV(l, h, g) {
        g = typeof g == "function" ? g : t;
        var C = g ? g(l, h) : t;
        return C === t ? y1(l, h, t, g) : !!C;
      }
      function p5(l) {
        if (!_n(l))
          return !1;
        var h = zi(l);
        return h == M || h == S || typeof l.message == "string" && typeof l.name == "string" && !x1(l);
      }
      function vV(l) {
        return typeof l == "number" && y8(l);
      }
      function Vc(l) {
        if (!ln(l))
          return !1;
        var h = zi(l);
        return h == G || h == ue || h == K || h == or;
      }
      function BI(l) {
        return typeof l == "number" && l == Zt(l);
      }
      function jv(l) {
        return typeof l == "number" && l > -1 && l % 1 == 0 && l <= O;
      }
      function ln(l) {
        var h = typeof l;
        return l != null && (h == "object" || h == "function");
      }
      function _n(l) {
        return l != null && typeof l == "object";
      }
      var FI = ho ? Fs(ho) : xW;
      function bV(l, h) {
        return l === h || jE(l, h, i5(h));
      }
      function _V(l, h, g) {
        return g = typeof g == "function" ? g : t, jE(l, h, i5(h), g);
      }
      function EV(l) {
        return UI(l) && l != +l;
      }
      function xV(l) {
        if (oH(l))
          throw new Wt(s);
        return N8(l);
      }
      function SV(l) {
        return l === null;
      }
      function CV(l) {
        return l == null;
      }
      function UI(l) {
        return typeof l == "number" || _n(l) && zi(l) == Le;
      }
      function x1(l) {
        if (!_n(l) || zi(l) != De)
          return !1;
        var h = pv(l);
        if (h === null)
          return !0;
        var g = kr.call(h, "constructor") && h.constructor;
        return typeof g == "function" && g instanceof g && uv.call(g) == _j;
      }
      var g5 = qa ? Fs(qa) : SW;
      function AV(l) {
        return BI(l) && l >= -O && l <= O;
      }
      var jI = c1 ? Fs(c1) : CW;
      function Wv(l) {
        return typeof l == "string" || !qt(l) && _n(l) && zi(l) == lt;
      }
      function js(l) {
        return typeof l == "symbol" || _n(l) && zi(l) == qe;
      }
      var sp = Ih ? Fs(Ih) : AW;
      function IV(l) {
        return l === t;
      }
      function RV(l) {
        return _n(l) && xi(l) == st;
      }
      function TV(l) {
        return _n(l) && zi(l) == Ge;
      }
      var OV = Pv(HE), NV = Pv(function(l, h) {
        return l <= h;
      });
      function WI(l) {
        if (!l)
          return [];
        if (vs(l))
          return Wv(l) ? ea(l) : ys(l);
        if (u1 && l[u1])
          return lj(l[u1]());
        var h = xi(l), g = h == Ee ? OE : h == We ? av : op;
        return g(l);
      }
      function qc(l) {
        if (!l)
          return l === 0 ? l : 0;
        if (l = vo(l), l === N || l === -N) {
          var h = l < 0 ? -1 : 1;
          return h * U;
        }
        return l === l ? l : 0;
      }
      function Zt(l) {
        var h = qc(l), g = h % 1;
        return h === h ? g ? h - g : h : 0;
      }
      function HI(l) {
        return l ? Nh(Zt(l), 0, B) : 0;
      }
      function vo(l) {
        if (typeof l == "number")
          return l;
        if (js(l))
          return q;
        if (ln(l)) {
          var h = typeof l.valueOf == "function" ? l.valueOf() : l;
          l = ln(h) ? h + "" : h;
        }
        if (typeof l != "string")
          return l === 0 ? l : +l;
        l = c8(l);
        var g = qo.test(l);
        return g || Ko.test(l) ? Vt(l.slice(2), g ? 2 : 8) : Br.test(l) ? q : +l;
      }
      function zI(l) {
        return Ka(l, bs(l));
      }
      function PV(l) {
        return l ? Nh(Zt(l), -O, O) : l === 0 ? l : 0;
      }
      function Or(l) {
        return l == null ? "" : Us(l);
      }
      var MV = rp(function(l, h) {
        if (_1(h) || vs(h)) {
          Ka(h, Yn(h), l);
          return;
        }
        for (var g in h)
          kr.call(h, g) && g1(l, g, h[g]);
      }), VI = rp(function(l, h) {
        Ka(h, bs(h), l);
      }), Hv = rp(function(l, h, g, C) {
        Ka(h, bs(h), l, C);
      }), DV = rp(function(l, h, g, C) {
        Ka(h, Yn(h), l, C);
      }), kV = Hc($E);
      function $V(l, h) {
        var g = tp(l);
        return h == null ? g : x8(g, h);
      }
      var LV = tr(function(l, h) {
        l = Zr(l);
        var g = -1, C = h.length, z = C > 2 ? h[2] : t;
        for (z && Vi(h[0], h[1], z) && (C = 1); ++g < C; )
          for (var Q = h[g], oe = bs(Q), ce = -1, pe = oe.length; ++ce < pe; ) {
            var Ie = oe[ce], Re = l[Ie];
            (Re === t || ra(Re, Yd[Ie]) && !kr.call(l, Ie)) && (l[Ie] = Q[Ie]);
          }
        return l;
      }), BV = tr(function(l) {
        return l.push(t, cI), Qn(qI, t, l);
      });
      function FV(l, h) {
        return i8(l, St(h, 3), Ga);
      }
      function UV(l, h) {
        return i8(l, St(h, 3), BE);
      }
      function jV(l, h) {
        return l == null ? l : LE(l, St(h, 3), bs);
      }
      function WV(l, h) {
        return l == null ? l : R8(l, St(h, 3), bs);
      }
      function HV(l, h) {
        return l && Ga(l, St(h, 3));
      }
      function zV(l, h) {
        return l && BE(l, St(h, 3));
      }
      function VV(l) {
        return l == null ? [] : Sv(l, Yn(l));
      }
      function qV(l) {
        return l == null ? [] : Sv(l, bs(l));
      }
      function m5(l, h, g) {
        var C = l == null ? t : Ph(l, h);
        return C === t ? g : C;
      }
      function GV(l, h) {
        return l != null && hI(l, h, mW);
      }
      function w5(l, h) {
        return l != null && hI(l, h, wW);
      }
      var KV = nI(function(l, h, g) {
        h != null && typeof h.toString != "function" && (h = hv.call(h)), l[h] = g;
      }, v5(_s)), ZV = nI(function(l, h, g) {
        h != null && typeof h.toString != "function" && (h = hv.call(h)), kr.call(l, h) ? l[h].push(g) : l[h] = [g];
      }, St), JV = tr(w1);
      function Yn(l) {
        return vs(l) ? _8(l) : WE(l);
      }
      function bs(l) {
        return vs(l) ? _8(l, !0) : IW(l);
      }
      function QV(l, h) {
        var g = {};
        return h = St(h, 3), Ga(l, function(C, z, Q) {
          jc(g, h(C, z, Q), C);
        }), g;
      }
      function YV(l, h) {
        var g = {};
        return h = St(h, 3), Ga(l, function(C, z, Q) {
          jc(g, z, h(C, z, Q));
        }), g;
      }
      var XV = rp(function(l, h, g) {
        Cv(l, h, g);
      }), qI = rp(function(l, h, g, C) {
        Cv(l, h, g, C);
      }), eq = Hc(function(l, h) {
        var g = {};
        if (l == null)
          return g;
        var C = !1;
        h = sn(h, function(Q) {
          return Q = eu(Q, l), C || (C = Q.length > 1), Q;
        }), Ka(l, r5(l), g), C && (g = mo(g, d | m | y, KW));
        for (var z = h.length; z--; )
          KE(g, h[z]);
        return g;
      });
      function tq(l, h) {
        return GI(l, Uv(St(h)));
      }
      var rq = Hc(function(l, h) {
        return l == null ? {} : TW(l, h);
      });
      function GI(l, h) {
        if (l == null)
          return {};
        var g = sn(r5(l), function(C) {
          return [C];
        });
        return h = St(h), B8(l, g, function(C, z) {
          return h(C, z[0]);
        });
      }
      function nq(l, h, g) {
        h = eu(h, l);
        var C = -1, z = h.length;
        for (z || (z = 1, l = t); ++C < z; ) {
          var Q = l == null ? t : l[Za(h[C])];
          Q === t && (C = z, Q = g), l = Vc(Q) ? Q.call(l) : Q;
        }
        return l;
      }
      function iq(l, h, g) {
        return l == null ? l : v1(l, h, g);
      }
      function sq(l, h, g, C) {
        return C = typeof C == "function" ? C : t, l == null ? l : v1(l, h, g, C);
      }
      var KI = oI(Yn), ZI = oI(bs);
      function oq(l, h, g) {
        var C = qt(l), z = C || ru(l) || sp(l);
        if (h = St(h, 4), g == null) {
          var Q = l && l.constructor;
          z ? g = C ? new Q() : [] : ln(l) ? g = Vc(Q) ? tp(pv(l)) : {} : g = {};
        }
        return (z ? fo : Ga)(l, function(oe, ce, pe) {
          return h(g, oe, ce, pe);
        }), g;
      }
      function aq(l, h) {
        return l == null ? !0 : KE(l, h);
      }
      function cq(l, h, g) {
        return l == null ? l : H8(l, h, QE(g));
      }
      function lq(l, h, g, C) {
        return C = typeof C == "function" ? C : t, l == null ? l : H8(l, h, QE(g), C);
      }
      function op(l) {
        return l == null ? [] : TE(l, Yn(l));
      }
      function uq(l) {
        return l == null ? [] : TE(l, bs(l));
      }
      function hq(l, h, g) {
        return g === t && (g = h, h = t), g !== t && (g = vo(g), g = g === g ? g : 0), h !== t && (h = vo(h), h = h === h ? h : 0), Nh(vo(l), h, g);
      }
      function fq(l, h, g) {
        return h = qc(h), g === t ? (g = h, h = 0) : g = qc(g), l = vo(l), yW(l, h, g);
      }
      function dq(l, h, g) {
        if (g && typeof g != "boolean" && Vi(l, h, g) && (h = g = t), g === t && (typeof h == "boolean" ? (g = h, h = t) : typeof l == "boolean" && (g = l, l = t)), l === t && h === t ? (l = 0, h = 1) : (l = qc(l), h === t ? (h = l, l = 0) : h = qc(h)), l > h) {
          var C = l;
          l = h, h = C;
        }
        if (g || l % 1 || h % 1) {
          var z = v8();
          return Ei(l + z * (h - l + Gr("1e-" + ((z + "").length - 1))), h);
        }
        return VE(l, h);
      }
      var pq = np(function(l, h, g) {
        return h = h.toLowerCase(), l + (g ? JI(h) : h);
      });
      function JI(l) {
        return y5(Or(l).toLowerCase());
      }
      function QI(l) {
        return l = Or(l), l && l.replace(hi, ij).replace(bE, "");
      }
      function gq(l, h, g) {
        l = Or(l), h = Us(h);
        var C = l.length;
        g = g === t ? C : Nh(Zt(g), 0, C);
        var z = g;
        return g -= h.length, g >= 0 && l.slice(g, z) == h;
      }
      function mq(l) {
        return l = Or(l), l && It.test(l) ? l.replace(_r, sj) : l;
      }
      function wq(l) {
        return l = Or(l), l && zr.test(l) ? l.replace(Dt, "\\$&") : l;
      }
      var yq = np(function(l, h, g) {
        return l + (g ? "-" : "") + h.toLowerCase();
      }), vq = np(function(l, h, g) {
        return l + (g ? " " : "") + h.toLowerCase();
      }), bq = eI("toLowerCase");
      function _q(l, h, g) {
        l = Or(l), h = Zt(h);
        var C = h ? Jd(l) : 0;
        if (!h || C >= h)
          return l;
        var z = (h - C) / 2;
        return Nv(yv(z), g) + l + Nv(wv(z), g);
      }
      function Eq(l, h, g) {
        l = Or(l), h = Zt(h);
        var C = h ? Jd(l) : 0;
        return h && C < h ? l + Nv(h - C, g) : l;
      }
      function xq(l, h, g) {
        l = Or(l), h = Zt(h);
        var C = h ? Jd(l) : 0;
        return h && C < h ? Nv(h - C, g) + l : l;
      }
      function Sq(l, h, g) {
        return g || h == null ? h = 0 : h && (h = +h), Nj(Or(l).replace(kt, ""), h || 0);
      }
      function Cq(l, h, g) {
        return (g ? Vi(l, h, g) : h === t) ? h = 1 : h = Zt(h), qE(Or(l), h);
      }
      function Aq() {
        var l = arguments, h = Or(l[0]);
        return l.length < 3 ? h : h.replace(l[1], l[2]);
      }
      var Iq = np(function(l, h, g) {
        return l + (g ? "_" : "") + h.toLowerCase();
      });
      function Rq(l, h, g) {
        return g && typeof g != "number" && Vi(l, h, g) && (h = g = t), g = g === t ? B : g >>> 0, g ? (l = Or(l), l && (typeof h == "string" || h != null && !g5(h)) && (h = Us(h), !h && Zd(l)) ? tu(ea(l), 0, g) : l.split(h, g)) : [];
      }
      var Tq = np(function(l, h, g) {
        return l + (g ? " " : "") + y5(h);
      });
      function Oq(l, h, g) {
        return l = Or(l), g = g == null ? 0 : Nh(Zt(g), 0, l.length), h = Us(h), l.slice(g, g + h.length) == h;
      }
      function Nq(l, h, g) {
        var C = Z.templateSettings;
        g && Vi(l, h, g) && (h = t), l = Or(l), h = Hv({}, h, C, aI);
        var z = Hv({}, h.imports, C.imports, aI), Q = Yn(z), oe = TE(z, Q), ce, pe, Ie = 0, Re = h.interpolate || ps, Me = "__p += '", Ve = NE((h.escape || ps).source + "|" + Re.source + "|" + (Re === Nt ? za : ps).source + "|" + (h.evaluate || ps).source + "|$", "g"), ht = "//# sourceURL=" + (kr.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++_E + "]") + `
`;
        l.replace(Ve, function(At, cr, gr, Ws, qi, Hs) {
          return gr || (gr = Ws), Me += l.slice(Ie, Hs).replace(Jo, oj), cr && (ce = !0, Me += `' +
__e(` + cr + `) +
'`), qi && (pe = !0, Me += `';
` + qi + `;
__p += '`), gr && (Me += `' +
((__t = (` + gr + `)) == null ? '' : __t) +
'`), Ie = Hs + At.length, At;
        }), Me += `';
`;
        var Ct = kr.call(h, "variable") && h.variable;
        if (!Ct)
          Me = `with (obj) {
` + Me + `
}
`;
        else if ($r.test(Ct))
          throw new Wt(a);
        Me = (pe ? Me.replace(at, "") : Me).replace(Jt, "$1").replace(_i, "$1;"), Me = "function(" + (Ct || "obj") + `) {
` + (Ct ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (ce ? ", __e = _.escape" : "") + (pe ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Me + `return __p
}`;
        var Qt = XI(function() {
          return Ir(Q, ht + "return " + Me).apply(t, oe);
        });
        if (Qt.source = Me, p5(Qt))
          throw Qt;
        return Qt;
      }
      function Pq(l) {
        return Or(l).toLowerCase();
      }
      function Mq(l) {
        return Or(l).toUpperCase();
      }
      function Dq(l, h, g) {
        if (l = Or(l), l && (g || h === t))
          return c8(l);
        if (!l || !(h = Us(h)))
          return l;
        var C = ea(l), z = ea(h), Q = l8(C, z), oe = u8(C, z) + 1;
        return tu(C, Q, oe).join("");
      }
      function kq(l, h, g) {
        if (l = Or(l), l && (g || h === t))
          return l.slice(0, f8(l) + 1);
        if (!l || !(h = Us(h)))
          return l;
        var C = ea(l), z = u8(C, ea(h)) + 1;
        return tu(C, 0, z).join("");
      }
      function $q(l, h, g) {
        if (l = Or(l), l && (g || h === t))
          return l.replace(kt, "");
        if (!l || !(h = Us(h)))
          return l;
        var C = ea(l), z = l8(C, ea(h));
        return tu(C, z).join("");
      }
      function Lq(l, h) {
        var g = te, C = se;
        if (ln(h)) {
          var z = "separator" in h ? h.separator : z;
          g = "length" in h ? Zt(h.length) : g, C = "omission" in h ? Us(h.omission) : C;
        }
        l = Or(l);
        var Q = l.length;
        if (Zd(l)) {
          var oe = ea(l);
          Q = oe.length;
        }
        if (g >= Q)
          return l;
        var ce = g - Jd(C);
        if (ce < 1)
          return C;
        var pe = oe ? tu(oe, 0, ce).join("") : l.slice(0, ce);
        if (z === t)
          return pe + C;
        if (oe && (ce += pe.length - ce), g5(z)) {
          if (l.slice(ce).search(z)) {
            var Ie, Re = pe;
            for (z.global || (z = NE(z.source, Or(ar.exec(z)) + "g")), z.lastIndex = 0; Ie = z.exec(Re); )
              var Me = Ie.index;
            pe = pe.slice(0, Me === t ? ce : Me);
          }
        } else if (l.indexOf(Us(z), ce) != ce) {
          var Ve = pe.lastIndexOf(z);
          Ve > -1 && (pe = pe.slice(0, Ve));
        }
        return pe + C;
      }
      function Bq(l) {
        return l = Or(l), l && Pr.test(l) ? l.replace(yr, dj) : l;
      }
      var Fq = np(function(l, h, g) {
        return l + (g ? " " : "") + h.toUpperCase();
      }), y5 = eI("toUpperCase");
      function YI(l, h, g) {
        return l = Or(l), h = g ? t : h, h === t ? cj(l) ? mj(l) : XU(l) : l.match(h) || [];
      }
      var XI = tr(function(l, h) {
        try {
          return Qn(l, t, h);
        } catch (g) {
          return p5(g) ? g : new Wt(g);
        }
      }), Uq = Hc(function(l, h) {
        return fo(h, function(g) {
          g = Za(g), jc(l, g, f5(l[g], l));
        }), l;
      });
      function jq(l) {
        var h = l == null ? 0 : l.length, g = St();
        return l = h ? sn(l, function(C) {
          if (typeof C[1] != "function")
            throw new po(o);
          return [g(C[0]), C[1]];
        }) : [], tr(function(C) {
          for (var z = -1; ++z < h; ) {
            var Q = l[z];
            if (Qn(Q[0], this, C))
              return Qn(Q[1], this, C);
          }
        });
      }
      function Wq(l) {
        return dW(mo(l, d));
      }
      function v5(l) {
        return function() {
          return l;
        };
      }
      function Hq(l, h) {
        return l == null || l !== l ? h : l;
      }
      var zq = rI(), Vq = rI(!0);
      function _s(l) {
        return l;
      }
      function b5(l) {
        return P8(typeof l == "function" ? l : mo(l, d));
      }
      function qq(l) {
        return D8(mo(l, d));
      }
      function Gq(l, h) {
        return k8(l, mo(h, d));
      }
      var Kq = tr(function(l, h) {
        return function(g) {
          return w1(g, l, h);
        };
      }), Zq = tr(function(l, h) {
        return function(g) {
          return w1(l, g, h);
        };
      });
      function _5(l, h, g) {
        var C = Yn(h), z = Sv(h, C);
        g == null && !(ln(h) && (z.length || !C.length)) && (g = h, h = l, l = this, z = Sv(h, Yn(h)));
        var Q = !(ln(g) && "chain" in g) || !!g.chain, oe = Vc(l);
        return fo(z, function(ce) {
          var pe = h[ce];
          l[ce] = pe, oe && (l.prototype[ce] = function() {
            var Ie = this.__chain__;
            if (Q || Ie) {
              var Re = l(this.__wrapped__), Me = Re.__actions__ = ys(this.__actions__);
              return Me.push({ func: pe, args: arguments, thisArg: l }), Re.__chain__ = Ie, Re;
            }
            return pe.apply(l, Zl([this.value()], arguments));
          });
        }), l;
      }
      function Jq() {
        return pr._ === this && (pr._ = Ej), this;
      }
      function E5() {
      }
      function Qq(l) {
        return l = Zt(l), tr(function(h) {
          return $8(h, l);
        });
      }
      var Yq = XE(sn), Xq = XE(n8), eG = XE(SE);
      function eR(l) {
        return o5(l) ? CE(Za(l)) : OW(l);
      }
      function tG(l) {
        return function(h) {
          return l == null ? t : Ph(l, h);
        };
      }
      var rG = iI(), nG = iI(!0);
      function x5() {
        return [];
      }
      function S5() {
        return !1;
      }
      function iG() {
        return {};
      }
      function sG() {
        return "";
      }
      function oG() {
        return !0;
      }
      function aG(l, h) {
        if (l = Zt(l), l < 1 || l > O)
          return [];
        var g = B, C = Ei(l, B);
        h = St(h), l -= B;
        for (var z = RE(C, h); ++g < l; )
          h(g);
        return z;
      }
      function cG(l) {
        return qt(l) ? sn(l, Za) : js(l) ? [l] : ys(bI(Or(l)));
      }
      function lG(l) {
        var h = ++bj;
        return Or(l) + h;
      }
      var uG = Ov(function(l, h) {
        return l + h;
      }, 0), hG = e5("ceil"), fG = Ov(function(l, h) {
        return l / h;
      }, 1), dG = e5("floor");
      function pG(l) {
        return l && l.length ? xv(l, _s, FE) : t;
      }
      function gG(l, h) {
        return l && l.length ? xv(l, St(h, 2), FE) : t;
      }
      function mG(l) {
        return o8(l, _s);
      }
      function wG(l, h) {
        return o8(l, St(h, 2));
      }
      function yG(l) {
        return l && l.length ? xv(l, _s, HE) : t;
      }
      function vG(l, h) {
        return l && l.length ? xv(l, St(h, 2), HE) : t;
      }
      var bG = Ov(function(l, h) {
        return l * h;
      }, 1), _G = e5("round"), EG = Ov(function(l, h) {
        return l - h;
      }, 0);
      function xG(l) {
        return l && l.length ? IE(l, _s) : 0;
      }
      function SG(l, h) {
        return l && l.length ? IE(l, St(h, 2)) : 0;
      }
      return Z.after = qz, Z.ary = NI, Z.assign = MV, Z.assignIn = VI, Z.assignInWith = Hv, Z.assignWith = DV, Z.at = kV, Z.before = PI, Z.bind = f5, Z.bindAll = Uq, Z.bindKey = MI, Z.castArray = iV, Z.chain = RI, Z.chunk = dH, Z.compact = pH, Z.concat = gH, Z.cond = jq, Z.conforms = Wq, Z.constant = v5, Z.countBy = xz, Z.create = $V, Z.curry = DI, Z.curryRight = kI, Z.debounce = $I, Z.defaults = LV, Z.defaultsDeep = BV, Z.defer = Gz, Z.delay = Kz, Z.difference = mH, Z.differenceBy = wH, Z.differenceWith = yH, Z.drop = vH, Z.dropRight = bH, Z.dropRightWhile = _H, Z.dropWhile = EH, Z.fill = xH, Z.filter = Cz, Z.flatMap = Rz, Z.flatMapDeep = Tz, Z.flatMapDepth = Oz, Z.flatten = SI, Z.flattenDeep = SH, Z.flattenDepth = CH, Z.flip = Zz, Z.flow = zq, Z.flowRight = Vq, Z.fromPairs = AH, Z.functions = VV, Z.functionsIn = qV, Z.groupBy = Nz, Z.initial = RH, Z.intersection = TH, Z.intersectionBy = OH, Z.intersectionWith = NH, Z.invert = KV, Z.invertBy = ZV, Z.invokeMap = Mz, Z.iteratee = b5, Z.keyBy = Dz, Z.keys = Yn, Z.keysIn = bs, Z.map = Lv, Z.mapKeys = QV, Z.mapValues = YV, Z.matches = qq, Z.matchesProperty = Gq, Z.memoize = Fv, Z.merge = XV, Z.mergeWith = qI, Z.method = Kq, Z.methodOf = Zq, Z.mixin = _5, Z.negate = Uv, Z.nthArg = Qq, Z.omit = eq, Z.omitBy = tq, Z.once = Jz, Z.orderBy = kz, Z.over = Yq, Z.overArgs = Qz, Z.overEvery = Xq, Z.overSome = eG, Z.partial = d5, Z.partialRight = LI, Z.partition = $z, Z.pick = rq, Z.pickBy = GI, Z.property = eR, Z.propertyOf = tG, Z.pull = kH, Z.pullAll = AI, Z.pullAllBy = $H, Z.pullAllWith = LH, Z.pullAt = BH, Z.range = rG, Z.rangeRight = nG, Z.rearg = Yz, Z.reject = Fz, Z.remove = FH, Z.rest = Xz, Z.reverse = u5, Z.sampleSize = jz, Z.set = iq, Z.setWith = sq, Z.shuffle = Wz, Z.slice = UH, Z.sortBy = Vz, Z.sortedUniq = GH, Z.sortedUniqBy = KH, Z.split = Rq, Z.spread = eV, Z.tail = ZH, Z.take = JH, Z.takeRight = QH, Z.takeRightWhile = YH, Z.takeWhile = XH, Z.tap = pz, Z.throttle = tV, Z.thru = $v, Z.toArray = WI, Z.toPairs = KI, Z.toPairsIn = ZI, Z.toPath = cG, Z.toPlainObject = zI, Z.transform = oq, Z.unary = rV, Z.union = ez, Z.unionBy = tz, Z.unionWith = rz, Z.uniq = nz, Z.uniqBy = iz, Z.uniqWith = sz, Z.unset = aq, Z.unzip = h5, Z.unzipWith = II, Z.update = cq, Z.updateWith = lq, Z.values = op, Z.valuesIn = uq, Z.without = oz, Z.words = YI, Z.wrap = nV, Z.xor = az, Z.xorBy = cz, Z.xorWith = lz, Z.zip = uz, Z.zipObject = hz, Z.zipObjectDeep = fz, Z.zipWith = dz, Z.entries = KI, Z.entriesIn = ZI, Z.extend = VI, Z.extendWith = Hv, _5(Z, Z), Z.add = uG, Z.attempt = XI, Z.camelCase = pq, Z.capitalize = JI, Z.ceil = hG, Z.clamp = hq, Z.clone = sV, Z.cloneDeep = aV, Z.cloneDeepWith = cV, Z.cloneWith = oV, Z.conformsTo = lV, Z.deburr = QI, Z.defaultTo = Hq, Z.divide = fG, Z.endsWith = gq, Z.eq = ra, Z.escape = mq, Z.escapeRegExp = wq, Z.every = Sz, Z.find = Az, Z.findIndex = EI, Z.findKey = FV, Z.findLast = Iz, Z.findLastIndex = xI, Z.findLastKey = UV, Z.floor = dG, Z.forEach = TI, Z.forEachRight = OI, Z.forIn = jV, Z.forInRight = WV, Z.forOwn = HV, Z.forOwnRight = zV, Z.get = m5, Z.gt = uV, Z.gte = hV, Z.has = GV, Z.hasIn = w5, Z.head = CI, Z.identity = _s, Z.includes = Pz, Z.indexOf = IH, Z.inRange = fq, Z.invoke = JV, Z.isArguments = kh, Z.isArray = qt, Z.isArrayBuffer = fV, Z.isArrayLike = vs, Z.isArrayLikeObject = Pn, Z.isBoolean = dV, Z.isBuffer = ru, Z.isDate = pV, Z.isElement = gV, Z.isEmpty = mV, Z.isEqual = wV, Z.isEqualWith = yV, Z.isError = p5, Z.isFinite = vV, Z.isFunction = Vc, Z.isInteger = BI, Z.isLength = jv, Z.isMap = FI, Z.isMatch = bV, Z.isMatchWith = _V, Z.isNaN = EV, Z.isNative = xV, Z.isNil = CV, Z.isNull = SV, Z.isNumber = UI, Z.isObject = ln, Z.isObjectLike = _n, Z.isPlainObject = x1, Z.isRegExp = g5, Z.isSafeInteger = AV, Z.isSet = jI, Z.isString = Wv, Z.isSymbol = js, Z.isTypedArray = sp, Z.isUndefined = IV, Z.isWeakMap = RV, Z.isWeakSet = TV, Z.join = PH, Z.kebabCase = yq, Z.last = yo, Z.lastIndexOf = MH, Z.lowerCase = vq, Z.lowerFirst = bq, Z.lt = OV, Z.lte = NV, Z.max = pG, Z.maxBy = gG, Z.mean = mG, Z.meanBy = wG, Z.min = yG, Z.minBy = vG, Z.stubArray = x5, Z.stubFalse = S5, Z.stubObject = iG, Z.stubString = sG, Z.stubTrue = oG, Z.multiply = bG, Z.nth = DH, Z.noConflict = Jq, Z.noop = E5, Z.now = Bv, Z.pad = _q, Z.padEnd = Eq, Z.padStart = xq, Z.parseInt = Sq, Z.random = dq, Z.reduce = Lz, Z.reduceRight = Bz, Z.repeat = Cq, Z.replace = Aq, Z.result = nq, Z.round = _G, Z.runInContext = de, Z.sample = Uz, Z.size = Hz, Z.snakeCase = Iq, Z.some = zz, Z.sortedIndex = jH, Z.sortedIndexBy = WH, Z.sortedIndexOf = HH, Z.sortedLastIndex = zH, Z.sortedLastIndexBy = VH, Z.sortedLastIndexOf = qH, Z.startCase = Tq, Z.startsWith = Oq, Z.subtract = EG, Z.sum = xG, Z.sumBy = SG, Z.template = Nq, Z.times = aG, Z.toFinite = qc, Z.toInteger = Zt, Z.toLength = HI, Z.toLower = Pq, Z.toNumber = vo, Z.toSafeInteger = PV, Z.toString = Or, Z.toUpper = Mq, Z.trim = Dq, Z.trimEnd = kq, Z.trimStart = $q, Z.truncate = Lq, Z.unescape = Bq, Z.uniqueId = lG, Z.upperCase = Fq, Z.upperFirst = y5, Z.each = TI, Z.eachRight = OI, Z.first = CI, _5(Z, function() {
        var l = {};
        return Ga(Z, function(h, g) {
          kr.call(Z.prototype, g) || (l[g] = h);
        }), l;
      }(), { chain: !1 }), Z.VERSION = n, fo(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(l) {
        Z[l].placeholder = Z;
      }), fo(["drop", "take"], function(l, h) {
        ur.prototype[l] = function(g) {
          g = g === t ? 1 : Gn(Zt(g), 0);
          var C = this.__filtered__ && !h ? new ur(this) : this.clone();
          return C.__filtered__ ? C.__takeCount__ = Ei(g, C.__takeCount__) : C.__views__.push({ size: Ei(g, B), type: l + (C.__dir__ < 0 ? "Right" : "") }), C;
        }, ur.prototype[l + "Right"] = function(g) {
          return this.reverse()[l](g).reverse();
        };
      }), fo(["filter", "map", "takeWhile"], function(l, h) {
        var g = h + 1, C = g == p || g == x;
        ur.prototype[l] = function(z) {
          var Q = this.clone();
          return Q.__iteratees__.push({ iteratee: St(z, 3), type: g }), Q.__filtered__ = Q.__filtered__ || C, Q;
        };
      }), fo(["head", "last"], function(l, h) {
        var g = "take" + (h ? "Right" : "");
        ur.prototype[l] = function() {
          return this[g](1).value()[0];
        };
      }), fo(["initial", "tail"], function(l, h) {
        var g = "drop" + (h ? "" : "Right");
        ur.prototype[l] = function() {
          return this.__filtered__ ? new ur(this) : this[g](1);
        };
      }), ur.prototype.compact = function() {
        return this.filter(_s);
      }, ur.prototype.find = function(l) {
        return this.filter(l).head();
      }, ur.prototype.findLast = function(l) {
        return this.reverse().find(l);
      }, ur.prototype.invokeMap = tr(function(l, h) {
        return typeof l == "function" ? new ur(this) : this.map(function(g) {
          return w1(g, l, h);
        });
      }), ur.prototype.reject = function(l) {
        return this.filter(Uv(St(l)));
      }, ur.prototype.slice = function(l, h) {
        l = Zt(l);
        var g = this;
        return g.__filtered__ && (l > 0 || h < 0) ? new ur(g) : (l < 0 ? g = g.takeRight(-l) : l && (g = g.drop(l)), h !== t && (h = Zt(h), g = h < 0 ? g.dropRight(-h) : g.take(h - l)), g);
      }, ur.prototype.takeRightWhile = function(l) {
        return this.reverse().takeWhile(l).reverse();
      }, ur.prototype.toArray = function() {
        return this.take(B);
      }, Ga(ur.prototype, function(l, h) {
        var g = /^(?:filter|find|map|reject)|While$/.test(h), C = /^(?:head|last)$/.test(h), z = Z[C ? "take" + (h == "last" ? "Right" : "") : h], Q = C || /^find/.test(h);
        z && (Z.prototype[h] = function() {
          var oe = this.__wrapped__, ce = C ? [1] : arguments, pe = oe instanceof ur, Ie = ce[0], Re = pe || qt(oe), Me = function(cr) {
            var gr = z.apply(Z, Zl([cr], ce));
            return C && Ve ? gr[0] : gr;
          };
          Re && g && typeof Ie == "function" && Ie.length != 1 && (pe = Re = !1);
          var Ve = this.__chain__, ht = !!this.__actions__.length, Ct = Q && !Ve, Qt = pe && !ht;
          if (!Q && Re) {
            oe = Qt ? oe : new ur(this);
            var At = l.apply(oe, ce);
            return At.__actions__.push({ func: $v, args: [Me], thisArg: t }), new go(At, Ve);
          }
          return Ct && Qt ? l.apply(this, ce) : (At = this.thru(Me), Ct ? C ? At.value()[0] : At.value() : At);
        });
      }), fo(["pop", "push", "shift", "sort", "splice", "unshift"], function(l) {
        var h = cv[l], g = /^(?:push|sort|unshift)$/.test(l) ? "tap" : "thru", C = /^(?:pop|shift)$/.test(l);
        Z.prototype[l] = function() {
          var z = arguments;
          if (C && !this.__chain__) {
            var Q = this.value();
            return h.apply(qt(Q) ? Q : [], z);
          }
          return this[g](function(oe) {
            return h.apply(qt(oe) ? oe : [], z);
          });
        };
      }), Ga(ur.prototype, function(l, h) {
        var g = Z[h];
        if (g) {
          var C = g.name + "";
          kr.call(ep, C) || (ep[C] = []), ep[C].push({ name: h, func: g });
        }
      }), ep[Tv(t, R).name] = [{ name: "wrapper", func: t }], ur.prototype.clone = Bj, ur.prototype.reverse = Fj, ur.prototype.value = Uj, Z.prototype.at = gz, Z.prototype.chain = mz, Z.prototype.commit = wz, Z.prototype.next = yz, Z.prototype.plant = bz, Z.prototype.reverse = _z, Z.prototype.toJSON = Z.prototype.valueOf = Z.prototype.value = Ez, Z.prototype.first = Z.prototype.head, u1 && (Z.prototype[u1] = vz), Z;
    }, Qd = wj();
    Nn ? ((Nn.exports = Qd)._ = Qd, Kr._ = Qd) : pr._ = Qd;
  }).call($1);
})(ox, ox.exports);
var vle = Object.defineProperty, ble = Object.defineProperties, _le = Object.getOwnPropertyDescriptors, RT = Object.getOwnPropertySymbols, Ele = Object.prototype.hasOwnProperty, xle = Object.prototype.propertyIsEnumerable, TT = (r, e, t) => e in r ? vle(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, eb = (r, e) => {
  for (var t in e || (e = {}))
    Ele.call(e, t) && TT(r, t, e[t]);
  if (RT)
    for (var t of RT(e))
      xle.call(e, t) && TT(r, t, e[t]);
  return r;
}, Sle = (r, e) => ble(r, _le(e));
function th(r, e, t) {
  var n;
  const i = bne(r);
  return ((n = e.rpcMap) == null ? void 0 : n[i.reference]) || `${yle}?chainId=${i.namespace}:${i.reference}&projectId=${t}`;
}
function Md(r) {
  return r.includes(":") ? r.split(":")[1] : r;
}
function vk(r) {
  return r.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function Cle(r, e) {
  const t = Object.keys(e.namespaces).filter((i) => i.includes(r));
  if (!t.length)
    return [];
  const n = [];
  return t.forEach((i) => {
    const s = e.namespaces[i].accounts;
    n.push(...s);
  }), n;
}
function Ale(r = {}, e = {}) {
  const t = OT(r), n = OT(e);
  return ox.exports.merge(t, n);
}
function OT(r) {
  var e, t, n, i;
  const s = {};
  if (!Gp(r))
    return s;
  for (const [o, a] of Object.entries(r)) {
    const c = lC(o) ? [o] : a.chains, u = a.methods || [], f = a.events || [], d = a.rpcMap || {}, m = K1(o);
    s[m] = Sle(eb(eb({}, s[m]), a), { chains: X5(c, (e = s[m]) == null ? void 0 : e.chains), methods: X5(u, (t = s[m]) == null ? void 0 : t.methods), events: X5(f, (n = s[m]) == null ? void 0 : n.events), rpcMap: eb(eb({}, d), (i = s[m]) == null ? void 0 : i.rpcMap) });
  }
  return s;
}
function Ile(r) {
  return r.includes(":") ? r.split(":")[2] : r;
}
function Rle(r) {
  const e = {};
  for (const [t, n] of Object.entries(r)) {
    const i = n.methods || [], s = n.events || [], o = n.accounts || [], a = lC(t) ? [t] : n.chains ? n.chains : vk(n.accounts);
    e[t] = { chains: a, methods: i, events: s, accounts: o };
  }
  return e;
}
function f4(r) {
  return typeof r == "number" ? r : r.includes("0x") ? parseInt(r, 16) : r.includes(":") ? Number(r.split(":")[1]) : Number(r);
}
const bk = {}, an = (r) => bk[r], d4 = (r, e) => {
  bk[r] = e;
};
class Tle {
  constructor(e) {
    this.name = "polkadot", this.namespace = e.namespace, this.events = an("events"), this.client = an("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Hl.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const i = Md(t);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || th(e, this.namespace, this.client.core.projectId);
    if (!n)
      throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Wl(new gh(n, an("disableProviderPing")));
  }
}
class Ole {
  constructor(e) {
    this.name = "eip155", this.namespace = e.namespace, this.events = an("events"), this.client = an("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
    }
    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(Hl.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId.toString();
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, t) {
    const n = t || th(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!n)
      throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Wl(new gh(n, an("disableProviderPing")));
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const i = parseInt(Md(t));
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e = this.chainId, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  async handleSwitchChain(e) {
    var t, n;
    let i = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : "0x0";
    i = i.startsWith("0x") ? i : `0x${i}`;
    const s = parseInt(i, 16);
    if (this.isChainApproved(s))
      this.setDefaultChain(`${s}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
      await this.client.request({ topic: e.topic, request: { method: e.request.method, params: [{ chainId: i }] }, chainId: (n = this.namespace.chains) == null ? void 0 : n[0] }), this.setDefaultChain(`${s}`);
    else
      throw new Error(`Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
}
class Nle {
  constructor(e) {
    this.name = "solana", this.namespace = e.namespace, this.events = an("events"), this.client = an("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Hl.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const i = Md(t);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || th(e, this.namespace, this.client.core.projectId);
    if (!n)
      throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Wl(new gh(n, an("disableProviderPing")));
  }
}
class Ple {
  constructor(e) {
    this.name = "cosmos", this.namespace = e.namespace, this.events = an("events"), this.client = an("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Hl.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const i = Md(t);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || th(e, this.namespace, this.client.core.projectId);
    if (!n)
      throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Wl(new gh(n, an("disableProviderPing")));
  }
}
class Mle {
  constructor(e) {
    this.name = "cip34", this.namespace = e.namespace, this.events = an("events"), this.client = an("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Hl.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      const n = this.getCardanoRPCUrl(t), i = Md(t);
      e[i] = this.createHttpProvider(i, n);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  getCardanoRPCUrl(e) {
    const t = this.namespace.rpcMap;
    if (t)
      return t[e];
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || this.getCardanoRPCUrl(e);
    if (!n)
      throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Wl(new gh(n, an("disableProviderPing")));
  }
}
class Dle {
  constructor(e) {
    this.name = "elrond", this.namespace = e.namespace, this.events = an("events"), this.client = an("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Hl.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const i = Md(t);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || th(e, this.namespace, this.client.core.projectId);
    if (!n)
      throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Wl(new gh(n, an("disableProviderPing")));
  }
}
class kle {
  constructor(e) {
    this.name = "multiversx", this.namespace = e.namespace, this.events = an("events"), this.client = an("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(Hl.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      const i = Md(t);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || th(e, this.namespace, this.client.core.projectId);
    if (!n)
      throw new Error(`No RPC url provided for chainId: ${e}`);
    return new Wl(new gh(n, an("disableProviderPing")));
  }
}
class $le {
  constructor(e) {
    this.name = "near", this.namespace = e.namespace, this.events = an("events"), this.client = an("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e)
      throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, t) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = t || th(`${this.name}:${e}`, this.namespace);
      if (!n)
        throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(Hl.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((t) => t.split(":")[1] === this.chainId.toString()).map((t) => t.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((t) => {
      var n;
      e[t] = this.createHttpProvider(t, (n = this.namespace.rpcMap) == null ? void 0 : n[t]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, t = this.httpProviders[e];
    if (typeof t > "u")
      throw new Error(`JSON-RPC provider for ${e} not found`);
    return t;
  }
  setHttpProvider(e, t) {
    const n = this.createHttpProvider(e, t);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, t) {
    const n = t || th(e, this.namespace);
    return typeof n > "u" ? void 0 : new Wl(new gh(n, an("disableProviderPing")));
  }
}
var Lle = Object.defineProperty, Ble = Object.defineProperties, Fle = Object.getOwnPropertyDescriptors, NT = Object.getOwnPropertySymbols, Ule = Object.prototype.hasOwnProperty, jle = Object.prototype.propertyIsEnumerable, PT = (r, e, t) => e in r ? Lle(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, tb = (r, e) => {
  for (var t in e || (e = {}))
    Ule.call(e, t) && PT(r, t, e[t]);
  if (NT)
    for (var t of NT(e))
      jle.call(e, t) && PT(r, t, e[t]);
  return r;
}, p4 = (r, e) => Ble(r, Fle(e));
class yC {
  constructor(e) {
    this.events = new YS(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : dr.pino(dr.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || AT })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1;
  }
  static async init(e) {
    const t = new yC(e);
    return await t.initialize(), t;
  }
  async request(e, t) {
    const [n, i] = this.validateChain(t);
    if (!this.session)
      throw new Error("Please call connect() before request()");
    return await this.getProvider(n).request({ request: tb({}, e), chainId: `${n}:${i}`, topic: this.session.topic });
  }
  sendAsync(e, t, n) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    this.request(e, n).then((s) => t(null, q_(i, s))).catch((s) => t(s, void 0));
  }
  async enable() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session)
      throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: Cn("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing)
      return await this.pair(e.pairingTopic);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(e) {
    this.shouldAbortPairingAttempt = !1;
    let t = 0;
    do {
      if (this.shouldAbortPairingAttempt)
        throw new Error("Pairing aborted");
      if (t >= this.maxPairingAttempts)
        throw new Error("Max auto pairing attempts reached");
      const { uri: n, approval: i } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      n && (this.uri = n, this.events.emit("display_uri", n)), await i().then((s) => {
        this.session = s, this.namespaces || (this.namespaces = Rle(s.namespaces), this.persist("namespaces", this.namespaces));
      }).catch((s) => {
        if (s.message !== wk)
          throw s;
        t++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(e, t) {
    try {
      if (!this.session)
        return;
      const [n, i] = this.validateChain(e);
      this.getProvider(n).setDefaultChain(i, t);
    } catch (n) {
      if (!/Please call connect/.test(n.message))
        throw n;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const t = this.client.pairing.getAll();
    if (Nc(t)) {
      for (const n of t)
        e.deletePairings ? this.client.core.expirer.set(n.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
      this.logger.info(`Inactive pairings cleared: ${t.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = !0;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await hle.init({ logger: this.providerOpts.logger || AT, relayUrl: this.providerOpts.relayUrl || gle, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (!this.session)
      throw new Error("Session not initialized. Please call connect() before enable()");
    const e = [...new Set(Object.keys(this.session.namespaces).map((t) => K1(t)))];
    d4("client", this.client), d4("events", this.events), d4("disableProviderPing", this.disableProviderPing), e.forEach((t) => {
      if (!this.session)
        return;
      const n = Cle(t, this.session), i = vk(n), s = Ale(this.namespaces, this.optionalNamespaces), o = p4(tb({}, s[t]), { accounts: n, chains: i });
      switch (t) {
        case "eip155":
          this.rpcProviders[t] = new Ole({ namespace: o });
          break;
        case "solana":
          this.rpcProviders[t] = new Nle({ namespace: o });
          break;
        case "cosmos":
          this.rpcProviders[t] = new Ple({ namespace: o });
          break;
        case "polkadot":
          this.rpcProviders[t] = new Tle({ namespace: o });
          break;
        case "cip34":
          this.rpcProviders[t] = new Mle({ namespace: o });
          break;
        case "elrond":
          this.rpcProviders[t] = new Dle({ namespace: o });
          break;
        case "multiversx":
          this.rpcProviders[t] = new kle({ namespace: o });
          break;
        case "near":
          this.rpcProviders[t] = new $le({ namespace: o });
          break;
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u")
      throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      const { params: t } = e, { event: n } = t;
      if (n.name === "accountsChanged") {
        const i = n.data;
        i && Nc(i) && this.events.emit("accountsChanged", i.map(Ile));
      } else if (n.name === "chainChanged") {
        const i = t.chainId, s = t.event.data, o = K1(i), a = f4(i) !== f4(s) ? `${o}:${f4(s)}` : i;
        this.onChainChanged(a);
      } else
        this.events.emit(n.name, n.data);
      this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: t }) => {
      var n;
      const { namespaces: i } = t, s = (n = this.client) == null ? void 0 : n.session.get(e);
      this.session = p4(tb({}, s), { namespaces: i }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: t });
    }), this.client.on("session_delete", async (e) => {
      await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", p4(tb({}, Cn("USER_DISCONNECTED")), { data: e.topic }));
    }), this.on(Hl.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(e, !0);
    });
  }
  getProvider(e) {
    if (!this.rpcProviders[e])
      throw new Error(`Provider not found: ${e}`);
    return this.rpcProviders[e];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var t;
      this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: t, optionalNamespaces: n, sessionProperties: i } = e;
    t && Object.keys(t).length && (this.namespaces = t), n && Object.keys(n).length && (this.optionalNamespaces = n), this.sessionProperties = i, this.persist("namespaces", t), this.persist("optionalNamespaces", n);
  }
  validateChain(e) {
    const [t, n] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length)
      return [t, n];
    if (t && !Object.keys(this.namespaces || {}).map((o) => K1(o)).includes(t))
      throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);
    if (t && n)
      return [t, n];
    const i = K1(Object.keys(this.namespaces)[0]), s = this.rpcProviders[i].getDefaultChain();
    return [i, s];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  onChainChanged(e, t = !1) {
    var n;
    if (!this.namespaces)
      return;
    const [i, s] = this.validateChain(e);
    t || this.getProvider(i).setDefaultChain(s), ((n = this.namespaces[i]) != null ? n : this.namespaces[`${i}:${s}`]).defaultChain = s, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", s);
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: !0 });
  }
  persist(e, t) {
    this.client.core.storage.setItem(`${IT}/${e}`, t);
  }
  async getFromStore(e) {
    return await this.client.core.storage.getItem(`${IT}/${e}`);
  }
}
const Wle = yC, Hle = "wc", zle = "ethereum_provider", Vle = `${Hle}@2:${zle}:`, qle = "https://rpc.walletconnect.com/v1/", ax = ["eth_sendTransaction", "personal_sign"], Gle = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"], cx = ["chainChanged", "accountsChanged"], Kle = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var Zle = Object.defineProperty, Jle = Object.defineProperties, Qle = Object.getOwnPropertyDescriptors, MT = Object.getOwnPropertySymbols, Yle = Object.prototype.hasOwnProperty, Xle = Object.prototype.propertyIsEnumerable, DT = (r, e, t) => e in r ? Zle(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, J1 = (r, e) => {
  for (var t in e || (e = {}))
    Yle.call(e, t) && DT(r, t, e[t]);
  if (MT)
    for (var t of MT(e))
      Xle.call(e, t) && DT(r, t, e[t]);
  return r;
}, kT = (r, e) => Jle(r, Qle(e));
function M2(r) {
  return Number(r[0].split(":")[1]);
}
function g4(r) {
  return `0x${r.toString(16)}`;
}
function eue(r) {
  const { chains: e, optionalChains: t, methods: n, optionalMethods: i, events: s, optionalEvents: o, rpcMap: a } = r;
  if (!Nc(e))
    throw new Error("Invalid chains");
  const c = { chains: e, methods: n || ax, events: s || cx, rpcMap: J1({}, e.length ? { [M2(e)]: a[M2(e)] } : {}) }, u = s == null ? void 0 : s.filter((y) => !cx.includes(y)), f = n == null ? void 0 : n.filter((y) => !ax.includes(y));
  if (!t && !o && !i && !(u != null && u.length) && !(f != null && f.length))
    return { required: e.length ? c : void 0 };
  const d = (u == null ? void 0 : u.length) && (f == null ? void 0 : f.length) || !t, m = { chains: [...new Set(d ? c.chains.concat(t || []) : t)], methods: [...new Set(c.methods.concat(i != null && i.length ? i : Gle))], events: [...new Set(c.events.concat(o != null && o.length ? o : Kle))], rpcMap: a };
  return { required: e.length ? c : void 0, optional: t.length ? m : void 0 };
}
let tue = class _k {
  constructor() {
    this.events = new Wi.EventEmitter(), this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = Vle, this.on = (e, t) => (this.events.on(e, t), this), this.once = (e, t) => (this.events.once(e, t), this), this.removeListener = (e, t) => (this.events.removeListener(e, t), this), this.off = (e, t) => (this.events.off(e, t), this), this.parseAccount = (e) => this.isCompatibleChainId(e) ? this.parseAccountId(e).address : e, this.signer = {}, this.rpc = {};
  }
  static async init(e) {
    const t = new _k();
    return await t.initialize(e), t;
  }
  async request(e) {
    return await this.signer.request(e, this.formatChainId(this.chainId));
  }
  sendAsync(e, t) {
    this.signer.sendAsync(e, t, this.formatChainId(this.chainId));
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : !1;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : !1;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(e) {
    if (!this.signer.client)
      throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(e);
    const { required: t, optional: n } = eue(this.rpc);
    try {
      const i = await new Promise(async (o, a) => {
        var c;
        this.rpc.showQrModal && ((c = this.modal) == null || c.subscribeModal((u) => {
          !u.open && !this.signer.session && (this.signer.abortPairingAttempt(), a(new Error("Connection request reset. Please try again.")));
        })), await this.signer.connect(kT(J1({ namespaces: J1({}, t && { [this.namespace]: t }) }, n && { optionalNamespaces: { [this.namespace]: n } }), { pairingTopic: e == null ? void 0 : e.pairingTopic })).then((u) => {
          o(u);
        }).catch((u) => {
          a(new Error(u.message));
        });
      });
      if (!i)
        return;
      const s = _ne(i.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : s), this.setAccounts(s), this.events.emit("connect", { chainId: g4(this.chainId) });
    } catch (i) {
      throw this.signer.logger.error(i), i;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return !0;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (e) => {
      const { params: t } = e, { event: n } = t;
      n.name === "accountsChanged" ? (this.accounts = this.parseAccounts(n.data), this.events.emit("accountsChanged", this.accounts)) : n.name === "chainChanged" ? this.setChainId(this.formatChainId(n.data)) : this.events.emit(n.name, n.data), this.events.emit("session_event", e);
    }), this.signer.on("chainChanged", (e) => {
      const t = parseInt(e);
      this.chainId = t, this.events.emit("chainChanged", g4(this.chainId)), this.persist();
    }), this.signer.on("session_update", (e) => {
      this.events.emit("session_update", e);
    }), this.signer.on("session_delete", (e) => {
      this.reset(), this.events.emit("session_delete", e), this.events.emit("disconnect", kT(J1({}, Cn("USER_DISCONNECTED")), { data: e.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (e) => {
      var t, n;
      this.rpc.showQrModal && ((t = this.modal) == null || t.closeModal(), (n = this.modal) == null || n.openModal({ uri: e })), this.events.emit("display_uri", e);
    });
  }
  switchEthereumChain(e) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: e.toString(16) }] });
  }
  isCompatibleChainId(e) {
    return typeof e == "string" ? e.startsWith(`${this.namespace}:`) : !1;
  }
  formatChainId(e) {
    return `${this.namespace}:${e}`;
  }
  parseChainId(e) {
    return Number(e.split(":")[1]);
  }
  setChainIds(e) {
    const t = e.filter((n) => this.isCompatibleChainId(n)).map((n) => this.parseChainId(n));
    t.length && (this.chainId = t[0], this.events.emit("chainChanged", g4(this.chainId)), this.persist());
  }
  setChainId(e) {
    if (this.isCompatibleChainId(e)) {
      const t = this.parseChainId(e);
      this.chainId = t, this.switchEthereumChain(t);
    }
  }
  parseAccountId(e) {
    const [t, n, i] = e.split(":");
    return { chainId: `${t}:${n}`, address: i };
  }
  setAccounts(e) {
    this.accounts = e.filter((t) => this.parseChainId(this.parseAccountId(t).chainId) === this.chainId).map((t) => this.parseAccountId(t).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(e) {
    var t, n;
    const i = (t = e == null ? void 0 : e.chains) != null ? t : [], s = (n = e == null ? void 0 : e.optionalChains) != null ? n : [], o = i.concat(s);
    if (!o.length)
      throw new Error("No chains specified in either `chains` or `optionalChains`");
    const a = i.length ? (e == null ? void 0 : e.methods) || ax : [], c = i.length ? (e == null ? void 0 : e.events) || cx : [], u = (e == null ? void 0 : e.optionalMethods) || [], f = (e == null ? void 0 : e.optionalEvents) || [], d = (e == null ? void 0 : e.rpcMap) || this.buildRpcMap(o, e.projectId), m = (e == null ? void 0 : e.qrModalOptions) || void 0;
    return { chains: i == null ? void 0 : i.map((y) => this.formatChainId(y)), optionalChains: s.map((y) => this.formatChainId(y)), methods: a, events: c, optionalMethods: u, optionalEvents: f, rpcMap: d, showQrModal: !!(e != null && e.showQrModal), qrModalOptions: m, projectId: e.projectId, metadata: e.metadata };
  }
  buildRpcMap(e, t) {
    const n = {};
    return e.forEach((i) => {
      n[i] = this.getRpcUrl(i, t);
    }), n;
  }
  async initialize(e) {
    if (this.rpc = this.getRpcConfig(e), this.chainId = this.rpc.chains.length ? M2(this.rpc.chains) : M2(this.rpc.optionalChains), this.signer = await Wle.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: e.disableProviderPing, relayUrl: e.relayUrl, storageOptions: e.storageOptions }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let t;
      try {
        const { WalletConnectModal: n } = await import("./index-72zbi8DG.mjs").then((i) => i.i);
        t = n;
      } catch {
        throw new Error("To use QR modal, please install @walletconnect/modal package");
      }
      if (t)
        try {
          this.modal = new t(J1({ projectId: this.rpc.projectId }, this.rpc.qrModalOptions));
        } catch (n) {
          throw this.signer.logger.error(n), new Error("Could not generate WalletConnectModal Instance");
        }
    }
  }
  loadConnectOpts(e) {
    if (!e)
      return;
    const { chains: t, optionalChains: n, rpcMap: i } = e;
    t && Nc(t) && (this.rpc.chains = t.map((s) => this.formatChainId(s)), t.forEach((s) => {
      this.rpc.rpcMap[s] = (i == null ? void 0 : i[s]) || this.getRpcUrl(s);
    })), n && Nc(n) && (this.rpc.optionalChains = [], this.rpc.optionalChains = n == null ? void 0 : n.map((s) => this.formatChainId(s)), n.forEach((s) => {
      this.rpc.rpcMap[s] = (i == null ? void 0 : i[s]) || this.getRpcUrl(s);
    }));
  }
  getRpcUrl(e, t) {
    var n;
    return ((n = this.rpc.rpcMap) == null ? void 0 : n[e]) || `${qle}?chainId=eip155:${e}&projectId=${t || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (!this.session)
      return;
    const e = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), t = this.session.namespaces[`${this.namespace}:${e}`] ? this.session.namespaces[`${this.namespace}:${e}`] : this.session.namespaces[this.namespace];
    this.setChainIds(e ? [this.formatChainId(e)] : t == null ? void 0 : t.accounts), this.setAccounts(t == null ? void 0 : t.accounts);
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(e) {
    return typeof e == "string" || e instanceof String ? [this.parseAccount(e)] : e.map((t) => this.parseAccount(t));
  }
};
const rue = "6.10.0";
function nue(r, e, t) {
  const n = e.split("|").map((s) => s.trim());
  for (let s = 0; s < n.length; s++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof r === e)
          return;
    }
  const i = new Error(`invalid value for type ${e}`);
  throw i.code = "INVALID_ARGUMENT", i.argument = `value.${t}`, i.value = r, i;
}
async function Yi(r) {
  const e = Object.keys(r);
  return (await Promise.all(e.map((n) => Promise.resolve(r[n])))).reduce((n, i, s) => (n[e[s]] = i, n), {});
}
function Et(r, e, t) {
  for (let n in e) {
    let i = e[n];
    const s = t ? t[n] : null;
    s && nue(i, s, n), Object.defineProperty(r, n, { enumerable: !0, value: i, writable: !1 });
  }
}
function Np(r) {
  if (r == null)
    return "null";
  if (Array.isArray(r))
    return "[ " + r.map(Np).join(", ") + " ]";
  if (r instanceof Uint8Array) {
    const e = "0123456789abcdef";
    let t = "0x";
    for (let n = 0; n < r.length; n++)
      t += e[r[n] >> 4], t += e[r[n] & 15];
    return t;
  }
  if (typeof r == "object" && typeof r.toJSON == "function")
    return Np(r.toJSON());
  switch (typeof r) {
    case "boolean":
    case "symbol":
      return r.toString();
    case "bigint":
      return BigInt(r).toString();
    case "number":
      return r.toString();
    case "string":
      return JSON.stringify(r);
    case "object": {
      const e = Object.keys(r);
      return e.sort(), "{ " + e.map((t) => `${Np(t)}: ${Np(r[t])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function $i(r, e) {
  return r && r.code === e;
}
function vC(r) {
  return $i(r, "CALL_EXCEPTION");
}
function En(r, e, t) {
  let n = r;
  {
    const s = [];
    if (t) {
      if ("message" in t || "code" in t || "name" in t)
        throw new Error(`value will overwrite populated values: ${Np(t)}`);
      for (const o in t) {
        if (o === "shortMessage")
          continue;
        const a = t[o];
        s.push(o + "=" + Np(a));
      }
    }
    s.push(`code=${e}`), s.push(`version=${rue}`), s.length && (r += " (" + s.join(", ") + ")");
  }
  let i;
  switch (e) {
    case "INVALID_ARGUMENT":
      i = new TypeError(r);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      i = new RangeError(r);
      break;
    default:
      i = new Error(r);
  }
  return Et(i, { code: e }), t && Object.assign(i, t), i.shortMessage == null && Et(i, { shortMessage: n }), i;
}
function Te(r, e, t, n) {
  if (!r)
    throw En(e, t, n);
}
function me(r, e, t, n) {
  Te(r, e, "INVALID_ARGUMENT", { argument: t, value: n });
}
function Ek(r, e, t) {
  t == null && (t = ""), t && (t = ": " + t), Te(r >= e, "missing arguemnt" + t, "MISSING_ARGUMENT", {
    count: r,
    expectedCount: e
  }), Te(r <= e, "too many arguemnts" + t, "UNEXPECTED_ARGUMENT", {
    count: r,
    expectedCount: e
  });
}
const iue = ["NFD", "NFC", "NFKD", "NFKC"].reduce((r, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    r.push(e);
  } catch {
  }
  return r;
}, []);
function sue(r) {
  Te(iue.indexOf(r) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form: r }
  });
}
function fy(r, e, t) {
  if (t == null && (t = ""), r !== e) {
    let n = t, i = "new";
    t && (n += ".", i += " " + t), Te(!1, `private constructor; use ${n}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: i
    });
  }
}
function xk(r, e, t) {
  if (r instanceof Uint8Array)
    return t ? new Uint8Array(r) : r;
  if (typeof r == "string" && r.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const n = new Uint8Array((r.length - 2) / 2);
    let i = 2;
    for (let s = 0; s < n.length; s++)
      n[s] = parseInt(r.substring(i, i + 2), 16), i += 2;
    return n;
  }
  me(!1, "invalid BytesLike value", e || "value", r);
}
function Tr(r, e) {
  return xk(r, e, !1);
}
function rs(r, e) {
  return xk(r, e, !0);
}
function mn(r, e) {
  return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && r.length !== 2 + 2 * e || e === !0 && r.length % 2 !== 0);
}
function oue(r) {
  return mn(r, !0) || r instanceof Uint8Array;
}
const $T = "0123456789abcdef";
function wt(r) {
  const e = Tr(r);
  let t = "0x";
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    t += $T[(i & 240) >> 4] + $T[i & 15];
  }
  return t;
}
function Zn(r) {
  return "0x" + r.map((e) => wt(e).substring(2)).join("");
}
function Zp(r) {
  return mn(r, !0) ? (r.length - 2) / 2 : Tr(r).length;
}
function xn(r, e, t) {
  const n = Tr(r);
  return t != null && t > n.length && Te(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: n,
    length: n.length,
    offset: t
  }), wt(n.slice(e ?? 0, t ?? n.length));
}
function Sk(r, e, t) {
  const n = Tr(r);
  Te(e >= n.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(n),
    length: e,
    offset: e + 1
  });
  const i = new Uint8Array(e);
  return i.fill(0), t ? i.set(n, e - n.length) : i.set(n, 0), wt(i);
}
function fd(r, e) {
  return Sk(r, e, !0);
}
function aue(r, e) {
  return Sk(r, e, !1);
}
const Q_ = BigInt(0), xa = BigInt(1), Pp = 9007199254740991;
function D2(r, e) {
  const t = Y_(r, "value"), n = BigInt(nr(e, "width"));
  if (Te(t >> n === Q_, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: r
  }), t >> n - xa) {
    const i = (xa << n) - xa;
    return -((~t & i) + xa);
  }
  return t;
}
function Ck(r, e) {
  let t = gt(r, "value");
  const n = BigInt(nr(e, "width")), i = xa << n - xa;
  if (t < Q_) {
    t = -t, Te(t <= i, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
    const s = (xa << n) - xa;
    return (~t & s) + xa;
  } else
    Te(t < i, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
  return t;
}
function cf(r, e) {
  const t = Y_(r, "value"), n = BigInt(nr(e, "bits"));
  return t & (xa << n) - xa;
}
function gt(r, e) {
  switch (typeof r) {
    case "bigint":
      return r;
    case "number":
      return me(Number.isInteger(r), "underflow", e || "value", r), me(r >= -Pp && r <= Pp, "overflow", e || "value", r), BigInt(r);
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return r[0] === "-" && r[1] !== "-" ? -BigInt(r.substring(1)) : BigInt(r);
      } catch (t) {
        me(!1, `invalid BigNumberish string: ${t.message}`, e || "value", r);
      }
  }
  me(!1, "invalid BigNumberish value", e || "value", r);
}
function Y_(r, e) {
  const t = gt(r, e);
  return Te(t >= Q_, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: r
  }), t;
}
const LT = "0123456789abcdef";
function X_(r) {
  if (r instanceof Uint8Array) {
    let e = "0x0";
    for (const t of r)
      e += LT[t >> 4], e += LT[t & 15];
    return BigInt(e);
  }
  return gt(r);
}
function nr(r, e) {
  switch (typeof r) {
    case "bigint":
      return me(r >= -Pp && r <= Pp, "overflow", e || "value", r), Number(r);
    case "number":
      return me(Number.isInteger(r), "underflow", e || "value", r), me(r >= -Pp && r <= Pp, "overflow", e || "value", r), r;
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return nr(BigInt(r), e);
      } catch (t) {
        me(!1, `invalid numeric string: ${t.message}`, e || "value", r);
      }
  }
  me(!1, "invalid numeric value", e || "value", r);
}
function cue(r) {
  return nr(X_(r));
}
function rh(r, e) {
  let n = Y_(r, "value").toString(16);
  if (e == null)
    n.length % 2 && (n = "0" + n);
  else {
    const i = nr(e, "width");
    for (Te(i * 2 >= n.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: r
    }); n.length < i * 2; )
      n = "0" + n;
  }
  return "0x" + n;
}
function to(r) {
  const e = Y_(r, "value");
  if (e === Q_)
    return new Uint8Array([]);
  let t = e.toString(16);
  t.length % 2 && (t = "0" + t);
  const n = new Uint8Array(t.length / 2);
  for (let i = 0; i < n.length; i++) {
    const s = i * 2;
    n[i] = parseInt(t.substring(s, s + 2), 16);
  }
  return n;
}
function Mp(r) {
  let e = wt(oue(r) ? r : to(r)).substring(2);
  for (; e.startsWith("0"); )
    e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
const BT = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const FT = BigInt(58);
function lue(r) {
  const e = Tr(r);
  let t = X_(e), n = "";
  for (; t; )
    n = BT[Number(t % FT)] + n, t /= FT;
  for (let i = 0; i < e.length && !e[i]; i++)
    n = BT[0] + n;
  return n;
}
function uue(r) {
  r = atob(r);
  const e = new Uint8Array(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return Tr(e);
}
function hue(r) {
  const e = Tr(r);
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += String.fromCharCode(e[n]);
  return btoa(t);
}
var i0;
class Ak {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(e, t, n) {
    /**
     *  The event filter.
     */
    _e(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    _e(this, "emitter");
    ye(this, i0, void 0);
    ie(this, i0, t), Et(this, { emitter: e, filter: n });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    j(this, i0) != null && await this.emitter.off(this.filter, j(this, i0));
  }
}
i0 = new WeakMap();
function fue(r, e, t, n, i) {
  me(!1, `invalid codepoint at offset ${e}; ${r}`, "bytes", t);
}
function Ik(r, e, t, n, i) {
  if (r === "BAD_PREFIX" || r === "UNEXPECTED_CONTINUE") {
    let s = 0;
    for (let o = e + 1; o < t.length && t[o] >> 6 === 2; o++)
      s++;
    return s;
  }
  return r === "OVERRUN" ? t.length - e - 1 : 0;
}
function due(r, e, t, n, i) {
  return r === "OVERLONG" ? (me(typeof i == "number", "invalid bad code point for replacement", "badCodepoint", i), n.push(i), 0) : (n.push(65533), Ik(r, e, t));
}
const pue = Object.freeze({
  error: fue,
  ignore: Ik,
  replace: due
});
function gue(r, e) {
  e == null && (e = pue.error);
  const t = Tr(r, "bytes"), n = [];
  let i = 0;
  for (; i < t.length; ) {
    const s = t[i++];
    if (!(s >> 7)) {
      n.push(s);
      continue;
    }
    let o = null, a = null;
    if ((s & 224) === 192)
      o = 1, a = 127;
    else if ((s & 240) === 224)
      o = 2, a = 2047;
    else if ((s & 248) === 240)
      o = 3, a = 65535;
    else {
      (s & 192) === 128 ? i += e("UNEXPECTED_CONTINUE", i - 1, t, n) : i += e("BAD_PREFIX", i - 1, t, n);
      continue;
    }
    if (i - 1 + o >= t.length) {
      i += e("OVERRUN", i - 1, t, n);
      continue;
    }
    let c = s & (1 << 8 - o - 1) - 1;
    for (let u = 0; u < o; u++) {
      let f = t[i];
      if ((f & 192) != 128) {
        i += e("MISSING_CONTINUE", i, t, n), c = null;
        break;
      }
      c = c << 6 | f & 63, i++;
    }
    if (c !== null) {
      if (c > 1114111) {
        i += e("OUT_OF_RANGE", i - 1 - o, t, n, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        i += e("UTF16_SURROGATE", i - 1 - o, t, n, c);
        continue;
      }
      if (c <= a) {
        i += e("OVERLONG", i - 1 - o, t, n, c);
        continue;
      }
      n.push(c);
    }
  }
  return n;
}
function Tl(r, e) {
  e != null && (sue(e), r = r.normalize(e));
  let t = [];
  for (let n = 0; n < r.length; n++) {
    const i = r.charCodeAt(n);
    if (i < 128)
      t.push(i);
    else if (i < 2048)
      t.push(i >> 6 | 192), t.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      n++;
      const s = r.charCodeAt(n);
      me(n < r.length && (s & 64512) === 56320, "invalid surrogate pair", "str", r);
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      t.push(o >> 18 | 240), t.push(o >> 12 & 63 | 128), t.push(o >> 6 & 63 | 128), t.push(o & 63 | 128);
    } else
      t.push(i >> 12 | 224), t.push(i >> 6 & 63 | 128), t.push(i & 63 | 128);
  }
  return new Uint8Array(t);
}
function mue(r) {
  return r.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function bC(r, e) {
  return mue(gue(r, e));
}
function Rk(r) {
  async function e(t, n) {
    const i = t.url.split(":")[0].toLowerCase();
    Te(i === "http" || i === "https", `unsupported protocol ${i}`, "UNSUPPORTED_OPERATION", {
      info: { protocol: i },
      operation: "request"
    }), Te(i === "https" || !t.credentials || t.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let s;
    if (n) {
      const d = new AbortController();
      s = d.signal, n.addListener(() => {
        d.abort();
      });
    }
    const o = {
      method: t.method,
      headers: new Headers(Array.from(t)),
      body: t.body || void 0,
      signal: s
    }, a = await fetch(t.url, o), c = {};
    a.headers.forEach((d, m) => {
      c[m.toLowerCase()] = d;
    });
    const u = await a.arrayBuffer(), f = u == null ? null : new Uint8Array(u);
    return {
      statusCode: a.status,
      statusMessage: a.statusText,
      headers: c,
      body: f
    };
  }
  return e;
}
const wue = 12, yue = 250;
let UT = Rk();
const vue = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), bue = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let m4 = !1;
async function Tk(r, e) {
  try {
    const t = r.match(vue);
    if (!t)
      throw new Error("invalid data");
    return new qu(200, "OK", {
      "content-type": t[1] || "text/plain"
    }, t[2] ? uue(t[3]) : Eue(t[3]));
  } catch {
    return new qu(599, "BAD REQUEST (invalid data: URI)", {}, null, new Pc(r));
  }
}
function Ok(r) {
  async function e(t, n) {
    try {
      const i = t.match(bue);
      if (!i)
        throw new Error("invalid link");
      return new Pc(`${r}${i[2]}`);
    } catch {
      return new qu(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Pc(t));
    }
  }
  return e;
}
const rb = {
  data: Tk,
  ipfs: Ok("https://gateway.ipfs.io/ipfs/")
}, Nk = /* @__PURE__ */ new WeakMap();
var gf, bu;
class _ue {
  constructor(e) {
    ye(this, gf, void 0);
    ye(this, bu, void 0);
    ie(this, gf, []), ie(this, bu, !1), Nk.set(e, () => {
      if (!j(this, bu)) {
        ie(this, bu, !0);
        for (const t of j(this, gf))
          setTimeout(() => {
            t();
          }, 0);
        ie(this, gf, []);
      }
    });
  }
  addListener(e) {
    Te(!j(this, bu), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    }), j(this, gf).push(e);
  }
  get cancelled() {
    return j(this, bu);
  }
  checkSignal() {
    Te(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
gf = new WeakMap(), bu = new WeakMap();
function nb(r) {
  if (r == null)
    throw new Error("missing signal; should not happen");
  return r.checkSignal(), r;
}
var s0, o0, da, ll, a0, c0, si, Qs, ul, mf, wf, yf, ac, hl, _u, vf, Q1;
const l_ = class l_ {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(e) {
    ye(this, vf);
    ye(this, s0, void 0);
    ye(this, o0, void 0);
    ye(this, da, void 0);
    ye(this, ll, void 0);
    ye(this, a0, void 0);
    ye(this, c0, void 0);
    ye(this, si, void 0);
    ye(this, Qs, void 0);
    ye(this, ul, void 0);
    // Hooks
    ye(this, mf, void 0);
    ye(this, wf, void 0);
    ye(this, yf, void 0);
    ye(this, ac, void 0);
    ye(this, hl, void 0);
    ye(this, _u, void 0);
    ie(this, c0, String(e)), ie(this, s0, !1), ie(this, o0, !0), ie(this, da, {}), ie(this, ll, ""), ie(this, a0, 3e5), ie(this, hl, {
      slotInterval: yue,
      maxAttempts: wue
    }), ie(this, _u, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return j(this, c0);
  }
  set url(e) {
    ie(this, c0, String(e));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    return j(this, si) == null ? null : new Uint8Array(j(this, si));
  }
  set body(e) {
    if (e == null)
      ie(this, si, void 0), ie(this, Qs, void 0);
    else if (typeof e == "string")
      ie(this, si, Tl(e)), ie(this, Qs, "text/plain");
    else if (e instanceof Uint8Array)
      ie(this, si, e), ie(this, Qs, "application/octet-stream");
    else if (typeof e == "object")
      ie(this, si, Tl(JSON.stringify(e))), ie(this, Qs, "application/json");
    else
      throw new Error("invalid body");
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return j(this, si) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    return j(this, ll) ? j(this, ll) : this.hasBody() ? "POST" : "GET";
  }
  set method(e) {
    e == null && (e = ""), ie(this, ll, String(e).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const e = Object.assign({}, j(this, da));
    return j(this, ul) && (e.authorization = `Basic ${hue(Tl(j(this, ul)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && j(this, Qs) && (e["content-type"] = j(this, Qs)), this.body && (e["content-length"] = String(this.body.length)), e;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(e, t) {
    j(this, da)[String(e).toLowerCase()] = String(t);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    ie(this, da, {});
  }
  [Symbol.iterator]() {
    const e = this.headers, t = Object.keys(e);
    let n = 0;
    return {
      next: () => {
        if (n < t.length) {
          const i = t[n++];
          return {
            value: [i, e[i]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return j(this, ul) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(e, t) {
    me(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), ie(this, ul, `${e}:${t}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return j(this, o0);
  }
  set allowGzip(e) {
    ie(this, o0, !!e);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!j(this, s0);
  }
  set allowInsecureAuthentication(e) {
    ie(this, s0, !!e);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return j(this, a0);
  }
  set timeout(e) {
    me(e >= 0, "timeout must be non-zero", "timeout", e), ie(this, a0, e);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return j(this, mf) || null;
  }
  set preflightFunc(e) {
    ie(this, mf, e);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return j(this, wf) || null;
  }
  set processFunc(e) {
    ie(this, wf, e);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return j(this, yf) || null;
  }
  set retryFunc(e) {
    ie(this, yf, e);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return j(this, _u) || UT;
  }
  set getUrlFunc(e) {
    ie(this, _u, e);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${j(this, si) ? wt(j(this, si)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(e) {
    e.slotInterval != null && (j(this, hl).slotInterval = e.slotInterval), e.maxAttempts != null && (j(this, hl).maxAttempts = e.maxAttempts);
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    return Te(j(this, ac) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" }), ie(this, ac, new _ue(this)), ke(this, vf, Q1).call(this, 0, jT() + this.timeout, 0, this, new qu(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    Te(j(this, ac) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const e = Nk.get(this);
    if (!e)
      throw new Error("missing signal; should not happen");
    e();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(e) {
    const t = this.url.split(":")[0].toLowerCase(), n = e.split(":")[0].toLowerCase();
    Te(this.method === "GET" && (t !== "https" || n !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
    });
    const i = new l_(e);
    return i.method = "GET", i.allowGzip = this.allowGzip, i.timeout = this.timeout, ie(i, da, Object.assign({}, j(this, da))), j(this, si) && ie(i, si, new Uint8Array(j(this, si))), ie(i, Qs, j(this, Qs)), i;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const e = new l_(this.url);
    return ie(e, ll, j(this, ll)), j(this, si) && ie(e, si, j(this, si)), ie(e, Qs, j(this, Qs)), ie(e, da, Object.assign({}, j(this, da))), ie(e, ul, j(this, ul)), this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), ie(e, mf, j(this, mf)), ie(e, wf, j(this, wf)), ie(e, yf, j(this, yf)), ie(e, _u, j(this, _u)), e;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    m4 = !0;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(e) {
    return rb[e.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(e, t) {
    if (e = e.toLowerCase(), e === "http" || e === "https")
      throw new Error(`cannot intercept ${e}; use registerGetUrl`);
    if (m4)
      throw new Error("gateways locked");
    rb[e] = t;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(e) {
    if (m4)
      throw new Error("gateways locked");
    UT = e;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(e) {
    return Rk();
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return Tk;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(e) {
    return Ok(e);
  }
};
s0 = new WeakMap(), o0 = new WeakMap(), da = new WeakMap(), ll = new WeakMap(), a0 = new WeakMap(), c0 = new WeakMap(), si = new WeakMap(), Qs = new WeakMap(), ul = new WeakMap(), mf = new WeakMap(), wf = new WeakMap(), yf = new WeakMap(), ac = new WeakMap(), hl = new WeakMap(), _u = new WeakMap(), vf = new WeakSet(), Q1 = async function(e, t, n, i, s) {
  var f, d, m;
  if (e >= j(this, hl).maxAttempts)
    return s.makeServerError("exceeded maximum retry limit");
  Te(jT() <= t, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: i
  }), n > 0 && await xue(n);
  let o = this.clone();
  const a = (o.url.split(":")[0] || "").toLowerCase();
  if (a in rb) {
    const y = await rb[a](o.url, nb(j(i, ac)));
    if (y instanceof qu) {
      let b = y;
      if (this.processFunc) {
        nb(j(i, ac));
        try {
          b = await this.processFunc(o, b);
        } catch (I) {
          (I.throttle == null || typeof I.stall != "number") && b.makeServerError("error in post-processing function", I).assertOk();
        }
      }
      return b;
    }
    o = y;
  }
  this.preflightFunc && (o = await this.preflightFunc(o));
  const c = await this.getUrlFunc(o, nb(j(i, ac)));
  let u = new qu(c.statusCode, c.statusMessage, c.headers, c.body, i);
  if (u.statusCode === 301 || u.statusCode === 302) {
    try {
      const y = u.headers.location || "";
      return ke(f = o.redirect(y), vf, Q1).call(f, e + 1, t, 0, i, u);
    } catch {
    }
    return u;
  } else if (u.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(o, u, e))) {
    const y = u.headers["retry-after"];
    let b = j(this, hl).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
    return typeof y == "string" && y.match(/^[1-9][0-9]*$/) && (b = parseInt(y)), ke(d = o.clone(), vf, Q1).call(d, e + 1, t, b, i, u);
  }
  if (this.processFunc) {
    nb(j(i, ac));
    try {
      u = await this.processFunc(o, u);
    } catch (y) {
      (y.throttle == null || typeof y.stall != "number") && u.makeServerError("error in post-processing function", y).assertOk();
      let b = j(this, hl).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
      return y.stall >= 0 && (b = y.stall), ke(m = o.clone(), vf, Q1).call(m, e + 1, t, b, i, u);
    }
  }
  return u;
};
let Pc = l_;
var Sw, Cw, Aw, pa, l0, bf;
const e8 = class e8 {
  constructor(e, t, n, i, s) {
    ye(this, Sw, void 0);
    ye(this, Cw, void 0);
    ye(this, Aw, void 0);
    ye(this, pa, void 0);
    ye(this, l0, void 0);
    ye(this, bf, void 0);
    ie(this, Sw, e), ie(this, Cw, t), ie(this, Aw, Object.keys(n).reduce((o, a) => (o[a.toLowerCase()] = String(n[a]), o), {})), ie(this, pa, i == null ? null : new Uint8Array(i)), ie(this, l0, s || null), ie(this, bf, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${j(this, pa) ? wt(j(this, pa)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return j(this, Sw);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return j(this, Cw);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, j(this, Aw));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return j(this, pa) == null ? null : new Uint8Array(j(this, pa));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return j(this, pa) == null ? "" : bC(j(this, pa));
    } catch {
      Te(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch {
      Te(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const e = this.headers, t = Object.keys(e);
    let n = 0;
    return {
      next: () => {
        if (n < t.length) {
          const i = t[n++];
          return {
            value: [i, e[i]],
            done: !1
          };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(e, t) {
    let n;
    e ? n = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, n = `CLIENT ESCALATED SERVER ERROR (${e})`);
    const i = new e8(599, n, this.headers, this.body, j(this, l0) || void 0);
    return ie(i, bf, { message: e, error: t }), i;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(e, t) {
    t == null ? t = -1 : me(Number.isInteger(t) && t >= 0, "invalid stall timeout", "stall", t);
    const n = new Error(e || "throttling requests");
    throw Et(n, { stall: t, throttle: !0 }), n;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(e) {
    return this.headers[e.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return j(this, pa) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return j(this, l0);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return j(this, bf).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok())
      return;
    let { message: e, error: t } = j(this, bf);
    e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`), Te(!1, e, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: t
    });
  }
};
Sw = new WeakMap(), Cw = new WeakMap(), Aw = new WeakMap(), pa = new WeakMap(), l0 = new WeakMap(), bf = new WeakMap();
let qu = e8;
function jT() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function Eue(r) {
  return Tl(r.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
}
function xue(r) {
  return new Promise((e) => setTimeout(e, r));
}
const Sue = BigInt(-1), ca = BigInt(0), Dp = BigInt(1), Cue = BigInt(5), lp = {};
let Jp = "0000";
for (; Jp.length < 80; )
  Jp += Jp;
function Vh(r) {
  let e = Jp;
  for (; e.length < r; )
    e += e;
  return BigInt("1" + e.substring(0, r));
}
function L1(r, e, t) {
  const n = BigInt(e.width);
  if (e.signed) {
    const i = Dp << n - Dp;
    Te(t == null || r >= -i && r < i, "overflow", "NUMERIC_FAULT", {
      operation: t,
      fault: "overflow",
      value: r
    }), r > ca ? r = D2(cf(r, n), n) : r = -D2(cf(-r, n), n);
  } else {
    const i = Dp << n;
    Te(t == null || r >= 0 && r < i, "overflow", "NUMERIC_FAULT", {
      operation: t,
      fault: "overflow",
      value: r
    }), r = (r % i + i) % i & i - Dp;
  }
  return r;
}
function w4(r) {
  typeof r == "number" && (r = `fixed128x${r}`);
  let e = !0, t = 128, n = 18;
  if (typeof r == "string") {
    if (r !== "fixed")
      if (r === "ufixed")
        e = !1;
      else {
        const s = r.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        me(s, "invalid fixed format", "format", r), e = s[1] !== "u", t = parseInt(s[2]), n = parseInt(s[3]);
      }
  } else if (r) {
    const s = r, o = (a, c, u) => s[a] == null ? u : (me(typeof s[a] === c, "invalid fixed format (" + a + " not " + c + ")", "format." + a, s[a]), s[a]);
    e = o("signed", "boolean", e), t = o("width", "number", t), n = o("decimals", "number", n);
  }
  me(t % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", t), me(n <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", n);
  const i = (e ? "" : "u") + "fixed" + String(t) + "x" + String(n);
  return { signed: e, width: t, decimals: n, name: i };
}
function Aue(r, e) {
  let t = "";
  r < ca && (t = "-", r *= Sue);
  let n = r.toString();
  if (e === 0)
    return t + n;
  for (; n.length <= e; )
    n = Jp + n;
  const i = n.length - e;
  for (n = n.substring(0, i) + "." + n.substring(i); n[0] === "0" && n[1] !== "."; )
    n = n.substring(1);
  for (; n[n.length - 1] === "0" && n[n.length - 2] !== "."; )
    n = n.substring(0, n.length - 1);
  return t + n;
}
var ga, Ur, Ji, fl, Zh, ma, el, Iw, ux, Rw, hx, Tw, fx, Ow, dx;
const du = class du {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(e, t, n) {
    ye(this, fl);
    ye(this, ma);
    ye(this, Iw);
    ye(this, Rw);
    ye(this, Tw);
    ye(this, Ow);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    _e(this, "format");
    ye(this, ga, void 0);
    // The actual value (accounting for decimals)
    ye(this, Ur, void 0);
    // A base-10 value to multiple values by to maintain the magnitude
    ye(this, Ji, void 0);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    _e(this, "_value");
    fy(e, lp, "FixedNumber"), ie(this, Ur, t), ie(this, ga, n);
    const i = Aue(t, n.decimals);
    Et(this, { format: n.name, _value: i }), ie(this, Ji, Vh(n.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return j(this, ga).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return j(this, ga).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return j(this, ga).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return j(this, Ur);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(e) {
    return ke(this, Iw, ux).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(e) {
    return ke(this, Iw, ux).call(this, e, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(e) {
    return ke(this, Rw, hx).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(e) {
    return ke(this, Rw, hx).call(this, e, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(e) {
    return ke(this, Tw, fx).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(e) {
    return ke(this, Tw, fx).call(this, e, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(e) {
    ke(this, fl, Zh).call(this, e);
    const t = j(this, Ur) * j(e, Ur);
    return Te(t % j(this, Ji) === ca, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    }), ke(this, ma, el).call(this, t / j(this, Ji), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(e) {
    return ke(this, Ow, dx).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(e) {
    return ke(this, Ow, dx).call(this, e, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(e) {
    Te(j(e, Ur) !== ca, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    }), ke(this, fl, Zh).call(this, e);
    const t = j(this, Ur) * j(this, Ji);
    return Te(t % j(e, Ur) === ca, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    }), ke(this, ma, el).call(this, t / j(e, Ur), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(e) {
    let t = this.value, n = e.value;
    const i = this.decimals - e.decimals;
    return i > 0 ? n *= Vh(i) : i < 0 && (t *= Vh(-i)), t < n ? -1 : t > n ? 1 : 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(e) {
    return this.cmp(e) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(e) {
    return this.cmp(e) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(e) {
    return this.cmp(e) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(e) {
    return this.cmp(e) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(e) {
    return this.cmp(e) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let e = j(this, Ur);
    return j(this, Ur) < ca && (e -= j(this, Ji) - Dp), e = j(this, Ur) / j(this, Ji) * j(this, Ji), ke(this, ma, el).call(this, e, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let e = j(this, Ur);
    return j(this, Ur) > ca && (e += j(this, Ji) - Dp), e = j(this, Ur) / j(this, Ji) * j(this, Ji), ke(this, ma, el).call(this, e, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(e) {
    if (e == null && (e = 0), e >= this.decimals)
      return this;
    const t = this.decimals - e, n = Cue * Vh(t - 1);
    let i = this.value + n;
    const s = Vh(t);
    return i = i / s * s, L1(i, j(this, ga), "round"), new du(lp, i, j(this, ga));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return j(this, Ur) === ca;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return j(this, Ur) < ca;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(e) {
    return du.fromString(this.toString(), e);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(e, t, n) {
    const i = t == null ? 0 : nr(t), s = w4(n);
    let o = gt(e, "value");
    const a = i - s.decimals;
    if (a > 0) {
      const c = Vh(a);
      Te(o % c === ca, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: e
      }), o /= c;
    } else
      a < 0 && (o *= Vh(-a));
    return L1(o, s, "fromValue"), new du(lp, o, s);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(e, t) {
    const n = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    me(n && n[2].length + n[3].length > 0, "invalid FixedNumber string value", "value", e);
    const i = w4(t);
    let s = n[2] || "0", o = n[3] || "";
    for (; o.length < i.decimals; )
      o += Jp;
    Te(o.substring(i.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: e
    }), o = o.substring(0, i.decimals);
    const a = BigInt(n[1] + s + o);
    return L1(a, i, "fromString"), new du(lp, a, i);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(e, t) {
    let n = X_(Tr(e, "value"));
    const i = w4(t);
    return i.signed && (n = D2(n, i.width)), L1(n, i, "fromBytes"), new du(lp, n, i);
  }
};
ga = new WeakMap(), Ur = new WeakMap(), Ji = new WeakMap(), fl = new WeakSet(), Zh = function(e) {
  me(this.format === e.format, "incompatible format; use fixedNumber.toFormat", "other", e);
}, ma = new WeakSet(), el = function(e, t) {
  return e = L1(e, j(this, ga), t), new du(lp, e, j(this, ga));
}, Iw = new WeakSet(), ux = function(e, t) {
  return ke(this, fl, Zh).call(this, e), ke(this, ma, el).call(this, j(this, Ur) + j(e, Ur), t);
}, Rw = new WeakSet(), hx = function(e, t) {
  return ke(this, fl, Zh).call(this, e), ke(this, ma, el).call(this, j(this, Ur) - j(e, Ur), t);
}, Tw = new WeakSet(), fx = function(e, t) {
  return ke(this, fl, Zh).call(this, e), ke(this, ma, el).call(this, j(this, Ur) * j(e, Ur) / j(this, Ji), t);
}, Ow = new WeakSet(), dx = function(e, t) {
  return Te(j(e, Ur) !== ca, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  }), ke(this, fl, Zh).call(this, e), ke(this, ma, el).call(this, j(this, Ur) * j(this, Ji) / j(e, Ur), t);
};
let lx = du;
function Iue(r) {
  let e = r.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return "0x" + e;
}
function WT(r, e, t) {
  let n = 0;
  for (let i = 0; i < t; i++)
    n = n * 256 + r[e + i];
  return n;
}
function HT(r, e, t, n) {
  const i = [];
  for (; t < e + 1 + n; ) {
    const s = Pk(r, t);
    i.push(s.result), t += s.consumed, Te(t <= e + 1 + n, "child data too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: n,
      offset: e
    });
  }
  return { consumed: 1 + n, result: i };
}
function Pk(r, e) {
  Te(r.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: r,
    length: 0,
    offset: 1
  });
  const t = (n) => {
    Te(n <= r.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: r.length,
      offset: n
    });
  };
  if (r[e] >= 248) {
    const n = r[e] - 247;
    t(e + 1 + n);
    const i = WT(r, e + 1, n);
    return t(e + 1 + n + i), HT(r, e, e + 1 + n, n + i);
  } else if (r[e] >= 192) {
    const n = r[e] - 192;
    return t(e + 1 + n), HT(r, e, e + 1, n);
  } else if (r[e] >= 184) {
    const n = r[e] - 183;
    t(e + 1 + n);
    const i = WT(r, e + 1, n);
    t(e + 1 + n + i);
    const s = wt(r.slice(e + 1 + n, e + 1 + n + i));
    return { consumed: 1 + n + i, result: s };
  } else if (r[e] >= 128) {
    const n = r[e] - 128;
    t(e + 1 + n);
    const i = wt(r.slice(e + 1, e + 1 + n));
    return { consumed: 1 + n, result: i };
  }
  return { consumed: 1, result: Iue(r[e]) };
}
function _C(r) {
  const e = Tr(r, "data"), t = Pk(e, 0);
  return me(t.consumed === e.length, "unexpected junk after rlp payload", "data", r), t.result;
}
function zT(r) {
  const e = [];
  for (; r; )
    e.unshift(r & 255), r >>= 8;
  return e;
}
function Mk(r) {
  if (Array.isArray(r)) {
    let n = [];
    if (r.forEach(function(s) {
      n = n.concat(Mk(s));
    }), n.length <= 55)
      return n.unshift(192 + n.length), n;
    const i = zT(n.length);
    return i.unshift(247 + i.length), i.concat(n);
  }
  const e = Array.prototype.slice.call(Tr(r, "object"));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const t = zT(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
const VT = "0123456789abcdef";
function sw(r) {
  let e = "0x";
  for (const t of Mk(r))
    e += VT[t >> 4], e += VT[t & 15];
  return e;
}
const Rue = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function Tue(r, e) {
  let t = 18;
  if (typeof e == "string") {
    const n = Rue.indexOf(e);
    me(n >= 0, "invalid unit", "unit", e), t = 3 * n;
  } else
    e != null && (t = nr(e, "unit"));
  return lx.fromValue(r, t, { decimals: t, width: 512 }).toString();
}
function Oue(r) {
  return Tue(r, 18);
}
const is = 32, px = new Uint8Array(is), Nue = ["then"], ib = {};
function B1(r, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${r}`);
  throw t.error = e, t;
}
var Eu;
const Sm = class Sm extends Array {
  /**
   *  @private
   */
  constructor(...t) {
    const n = t[0];
    let i = t[1], s = (t[2] || []).slice(), o = !0;
    n !== ib && (i = t, s = [], o = !1);
    super(i.length);
    ye(this, Eu, void 0);
    i.forEach((c, u) => {
      this[u] = c;
    });
    const a = s.reduce((c, u) => (typeof u == "string" && c.set(u, (c.get(u) || 0) + 1), c), /* @__PURE__ */ new Map());
    if (ie(this, Eu, Object.freeze(i.map((c, u) => {
      const f = s[u];
      return f != null && a.get(f) === 1 ? f : null;
    }))), !!o)
      return Object.freeze(this), new Proxy(this, {
        get: (c, u, f) => {
          if (typeof u == "string") {
            if (u.match(/^[0-9]+$/)) {
              const m = nr(u, "%index");
              if (m < 0 || m >= this.length)
                throw new RangeError("out of result range");
              const y = c[m];
              return y instanceof Error && B1(`index ${m}`, y), y;
            }
            if (Nue.indexOf(u) >= 0)
              return Reflect.get(c, u, f);
            const d = c[u];
            if (d instanceof Function)
              return function(...m) {
                return d.apply(this === f ? c : this, m);
              };
            if (!(u in c))
              return c.getValue.apply(this === f ? c : this, [u]);
          }
          return Reflect.get(c, u, f);
        }
      });
  }
  /**
   *  Returns the Result as a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray() {
    const t = [];
    return this.forEach((n, i) => {
      n instanceof Error && B1(`index ${i}`, n), t.push(n);
    }), t;
  }
  /**
   *  Returns the Result as an Object with each name-value pair.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject() {
    return j(this, Eu).reduce((t, n, i) => (Te(n != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), n in t || (t[n] = this.getValue(n)), t), {});
  }
  /**
   *  @_ignore
   */
  slice(t, n) {
    t == null && (t = 0), t < 0 && (t += this.length, t < 0 && (t = 0)), n == null && (n = this.length), n < 0 && (n += this.length, n < 0 && (n = 0)), n > this.length && (n = this.length);
    const i = [], s = [];
    for (let o = t; o < n; o++)
      i.push(this[o]), s.push(j(this, Eu)[o]);
    return new Sm(ib, i, s);
  }
  /**
   *  @_ignore
   */
  filter(t, n) {
    const i = [], s = [];
    for (let o = 0; o < this.length; o++) {
      const a = this[o];
      a instanceof Error && B1(`index ${o}`, a), t.call(n, a, o, this) && (i.push(a), s.push(j(this, Eu)[o]));
    }
    return new Sm(ib, i, s);
  }
  /**
   *  @_ignore
   */
  map(t, n) {
    const i = [];
    for (let s = 0; s < this.length; s++) {
      const o = this[s];
      o instanceof Error && B1(`index ${s}`, o), i.push(t.call(n, o, s, this));
    }
    return i;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(t) {
    const n = j(this, Eu).indexOf(t);
    if (n === -1)
      return;
    const i = this[n];
    return i instanceof Error && B1(`property ${JSON.stringify(t)}`, i.error), i;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(t, n) {
    return new Sm(ib, t, n);
  }
};
Eu = new WeakMap();
let k2 = Sm;
function qT(r) {
  let e = to(r);
  return Te(e.length <= is, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: e, length: is, offset: e.length }), e.length !== is && (e = rs(Zn([px.slice(e.length % is), e]))), e;
}
class zl {
  constructor(e, t, n, i) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    _e(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    _e(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    _e(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    _e(this, "dynamic");
    Et(this, { name: e, type: t, localName: n, dynamic: i }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(e, t) {
    me(!1, e, this.localName, t);
  }
}
var dl, _f, u0, Db;
class gx {
  constructor() {
    ye(this, u0);
    // An array of WordSize lengthed objects to concatenation
    ye(this, dl, void 0);
    ye(this, _f, void 0);
    ie(this, dl, []), ie(this, _f, 0);
  }
  get data() {
    return Zn(j(this, dl));
  }
  get length() {
    return j(this, _f);
  }
  appendWriter(e) {
    return ke(this, u0, Db).call(this, rs(e.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(e) {
    let t = rs(e);
    const n = t.length % is;
    return n && (t = rs(Zn([t, px.slice(n)]))), ke(this, u0, Db).call(this, t);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(e) {
    return ke(this, u0, Db).call(this, qT(e));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const e = j(this, dl).length;
    return j(this, dl).push(px), ie(this, _f, j(this, _f) + is), (t) => {
      j(this, dl)[e] = qT(t);
    };
  }
}
dl = new WeakMap(), _f = new WeakMap(), u0 = new WeakSet(), Db = function(e) {
  return j(this, dl).push(e), ie(this, _f, j(this, _f) + e.length), e.length;
};
var Is, Ys, Ef, xf, xu, Nw, wx, u_, Dk;
const t8 = class t8 {
  constructor(e, t, n) {
    ye(this, Nw);
    ye(this, u_);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    _e(this, "allowLoose");
    ye(this, Is, void 0);
    ye(this, Ys, void 0);
    ye(this, Ef, void 0);
    ye(this, xf, void 0);
    ye(this, xu, void 0);
    Et(this, { allowLoose: !!t }), ie(this, Is, rs(e)), ie(this, Ef, 0), ie(this, xf, null), ie(this, xu, n ?? 1024), ie(this, Ys, 0);
  }
  get data() {
    return wt(j(this, Is));
  }
  get dataLength() {
    return j(this, Is).length;
  }
  get consumed() {
    return j(this, Ys);
  }
  get bytes() {
    return new Uint8Array(j(this, Is));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(e) {
    const t = new t8(j(this, Is).slice(j(this, Ys) + e), this.allowLoose, j(this, xu));
    return ie(t, xf, this), t;
  }
  // Read bytes
  readBytes(e, t) {
    let n = ke(this, u_, Dk).call(this, 0, e, !!t);
    return ke(this, Nw, wx).call(this, e), ie(this, Ys, j(this, Ys) + n.length), n.slice(0, e);
  }
  // Read a numeric values
  readValue() {
    return X_(this.readBytes(is));
  }
  readIndex() {
    return cue(this.readBytes(is));
  }
};
Is = new WeakMap(), Ys = new WeakMap(), Ef = new WeakMap(), xf = new WeakMap(), xu = new WeakMap(), Nw = new WeakSet(), wx = function(e) {
  var t;
  if (j(this, xf))
    return ke(t = j(this, xf), Nw, wx).call(t, e);
  ie(this, Ef, j(this, Ef) + e), Te(j(this, xu) < 1 || j(this, Ef) <= j(this, xu) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${j(this, xu)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: rs(j(this, Is)),
    offset: j(this, Ys),
    length: e,
    info: {
      bytesRead: j(this, Ef),
      dataLength: this.dataLength
    }
  });
}, u_ = new WeakSet(), Dk = function(e, t, n) {
  let i = Math.ceil(t / is) * is;
  return j(this, Ys) + i > j(this, Is).length && (this.allowLoose && n && j(this, Ys) + t <= j(this, Is).length ? i = t : Te(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: rs(j(this, Is)),
    length: j(this, Is).length,
    offset: j(this, Ys) + i
  })), j(this, Is).slice(j(this, Ys), j(this, Ys) + i);
};
let mx = t8;
function $2(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error(`Wrong positive integer: ${r}`);
}
function EC(r, ...e) {
  if (!(r instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${r.length}`);
}
function Pue(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  $2(r.outputLen), $2(r.blockLen);
}
function dg(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function kk(r, e) {
  EC(r);
  const t = e.outputLen;
  if (r.length < t)
    throw new Error(`digestInto() expects output buffer of length at least ${t}`);
}
const y4 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const $k = (r) => r instanceof Uint8Array, Mue = (r) => new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4)), v4 = (r) => new DataView(r.buffer, r.byteOffset, r.byteLength), Xa = (r, e) => r << 32 - e | r >>> e, Due = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Due)
  throw new Error("Non little-endian hardware is not supported");
function kue(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function e3(r) {
  if (typeof r == "string" && (r = kue(r)), !$k(r))
    throw new Error(`expected Uint8Array, got ${typeof r}`);
  return r;
}
function $ue(...r) {
  const e = new Uint8Array(r.reduce((n, i) => n + i.length, 0));
  let t = 0;
  return r.forEach((n) => {
    if (!$k(n))
      throw new Error("Uint8Array expected");
    e.set(n, t), t += n.length;
  }), e;
}
let xC = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function Lk(r) {
  const e = (n) => r().update(e3(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function Lue(r = 32) {
  if (y4 && typeof y4.getRandomValues == "function")
    return y4.getRandomValues(new Uint8Array(r));
  throw new Error("crypto.getRandomValues must be defined");
}
class Bk extends xC {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, Pue(e);
    const n = e3(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, s = new Uint8Array(i);
    s.set(n.length > i ? e.create().update(n).digest() : n);
    for (let o = 0; o < s.length; o++)
      s[o] ^= 54;
    this.iHash.update(s), this.oHash = e.create();
    for (let o = 0; o < s.length; o++)
      s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(e) {
    return dg(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    dg(this), EC(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const Fk = (r, e, t) => new Bk(r, e).update(t).digest();
Fk.create = (r, e) => new Bk(r, e);
function Bue(r, e, t, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(e, t, n);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(t >> i & s), a = Number(t & s), c = n ? 4 : 0, u = n ? 0 : 4;
  r.setUint32(e + c, o, n), r.setUint32(e + u, a, n);
}
class Fue extends xC {
  constructor(e, t, n, i) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = v4(this.buffer);
  }
  update(e) {
    dg(this);
    const { view: t, buffer: n, blockLen: i } = this;
    e = e3(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = v4(e);
        for (; i <= s - o; o += i)
          this.process(c, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    dg(this), kk(e, this), this.finished = !0;
    const { buffer: t, view: n, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);
    for (let d = o; d < i; d++)
      t[d] = 0;
    Bue(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
    const a = v4(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      a.setUint32(4 * d, f[d], s);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;
    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % t && e.buffer.set(n), e;
  }
}
const Uue = (r, e, t) => r & e ^ ~r & t, jue = (r, e, t) => r & e ^ r & t ^ e & t, Wue = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), iu = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), su = /* @__PURE__ */ new Uint32Array(64);
class Hue extends Fue {
  constructor() {
    super(64, 32, 8, !1), this.A = iu[0] | 0, this.B = iu[1] | 0, this.C = iu[2] | 0, this.D = iu[3] | 0, this.E = iu[4] | 0, this.F = iu[5] | 0, this.G = iu[6] | 0, this.H = iu[7] | 0;
  }
  get() {
    const { A: e, B: t, C: n, D: i, E: s, F: o, G: a, H: c } = this;
    return [e, t, n, i, s, o, a, c];
  }
  // prettier-ignore
  set(e, t, n, i, s, o, a, c) {
    this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(e, t) {
    for (let d = 0; d < 16; d++, t += 4)
      su[d] = e.getUint32(t, !1);
    for (let d = 16; d < 64; d++) {
      const m = su[d - 15], y = su[d - 2], b = Xa(m, 7) ^ Xa(m, 18) ^ m >>> 3, I = Xa(y, 17) ^ Xa(y, 19) ^ y >>> 10;
      su[d] = I + su[d - 7] + b + su[d - 16] | 0;
    }
    let { A: n, B: i, C: s, D: o, E: a, F: c, G: u, H: f } = this;
    for (let d = 0; d < 64; d++) {
      const m = Xa(a, 6) ^ Xa(a, 11) ^ Xa(a, 25), y = f + m + Uue(a, c, u) + Wue[d] + su[d] | 0, I = (Xa(n, 2) ^ Xa(n, 13) ^ Xa(n, 22)) + jue(n, i, s) | 0;
      f = u, u = c, c = a, a = o + y | 0, o = s, s = i, i = n, n = y + I | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, u, f);
  }
  roundClean() {
    su.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const zue = /* @__PURE__ */ Lk(() => new Hue()), sb = /* @__PURE__ */ BigInt(2 ** 32 - 1), GT = /* @__PURE__ */ BigInt(32);
function Vue(r, e = !1) {
  return e ? { h: Number(r & sb), l: Number(r >> GT & sb) } : { h: Number(r >> GT & sb) | 0, l: Number(r & sb) | 0 };
}
function que(r, e = !1) {
  let t = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let i = 0; i < r.length; i++) {
    const { h: s, l: o } = Vue(r[i], e);
    [t[i], n[i]] = [s, o];
  }
  return [t, n];
}
const Gue = (r, e, t) => r << t | e >>> 32 - t, Kue = (r, e, t) => e << t | r >>> 32 - t, Zue = (r, e, t) => e << t - 32 | r >>> 64 - t, Jue = (r, e, t) => r << t - 32 | e >>> 64 - t, [Uk, jk, Wk] = [[], [], []], Que = /* @__PURE__ */ BigInt(0), F1 = /* @__PURE__ */ BigInt(1), Yue = /* @__PURE__ */ BigInt(2), Xue = /* @__PURE__ */ BigInt(7), ehe = /* @__PURE__ */ BigInt(256), the = /* @__PURE__ */ BigInt(113);
for (let r = 0, e = F1, t = 1, n = 0; r < 24; r++) {
  [t, n] = [n, (2 * t + 3 * n) % 5], Uk.push(2 * (5 * n + t)), jk.push((r + 1) * (r + 2) / 2 % 64);
  let i = Que;
  for (let s = 0; s < 7; s++)
    e = (e << F1 ^ (e >> Xue) * the) % ehe, e & Yue && (i ^= F1 << (F1 << /* @__PURE__ */ BigInt(s)) - F1);
  Wk.push(i);
}
const [rhe, nhe] = /* @__PURE__ */ que(Wk, !0), KT = (r, e, t) => t > 32 ? Zue(r, e, t) : Gue(r, e, t), ZT = (r, e, t) => t > 32 ? Jue(r, e, t) : Kue(r, e, t);
function ihe(r, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, u = t[c], f = t[c + 1], d = KT(u, f, 1) ^ t[a], m = ZT(u, f, 1) ^ t[a + 1];
      for (let y = 0; y < 50; y += 10)
        r[o + y] ^= d, r[o + y + 1] ^= m;
    }
    let i = r[2], s = r[3];
    for (let o = 0; o < 24; o++) {
      const a = jk[o], c = KT(i, s, a), u = ZT(i, s, a), f = Uk[o];
      i = r[f], s = r[f + 1], r[f] = c, r[f + 1] = u;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        t[a] = r[o + a];
      for (let a = 0; a < 10; a++)
        r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    r[0] ^= rhe[n], r[1] ^= nhe[n];
  }
  t.fill(0);
}
let she = class Hk extends xC {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, t, n, i = !1, s = 24) {
    if (super(), this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, $2(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Mue(this.state);
  }
  keccak() {
    ihe(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    dg(this);
    const { blockLen: t, state: n } = this;
    e = e3(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(t - this.pos, i - s);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[s++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: t, pos: n, blockLen: i } = this;
    e[n] ^= t, t & 128 && n === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    dg(this, !1), EC(e), this.finish();
    const t = this.state, { blockLen: n } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, s - i);
      e.set(t.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return $2(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (kk(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: n, outputLen: i, rounds: s, enableXOF: o } = this;
    return e || (e = new Hk(t, n, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = n, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
};
const ohe = (r, e, t) => Lk(() => new she(e, r, t)), ahe = /* @__PURE__ */ ohe(1, 136, 256 / 8);
let zk = !1;
const Vk = function(r) {
  return ahe(r);
};
let qk = Vk;
function gn(r) {
  const e = Tr(r, "data");
  return wt(qk(e));
}
gn._ = Vk;
gn.lock = function() {
  zk = !0;
};
gn.register = function(r) {
  if (zk)
    throw new TypeError("keccak256 is locked");
  qk = r;
};
Object.freeze(gn);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Gk = BigInt(0), t3 = BigInt(1), che = BigInt(2), r3 = (r) => r instanceof Uint8Array, lhe = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function pg(r) {
  if (!r3(r))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let t = 0; t < r.length; t++)
    e += lhe[r[t]];
  return e;
}
function Kk(r) {
  const e = r.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function SC(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  return BigInt(r === "" ? "0" : `0x${r}`);
}
function gg(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  const e = r.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const t = new Uint8Array(e / 2);
  for (let n = 0; n < t.length; n++) {
    const i = n * 2, s = r.slice(i, i + 2), o = Number.parseInt(s, 16);
    if (Number.isNaN(o) || o < 0)
      throw new Error("Invalid byte sequence");
    t[n] = o;
  }
  return t;
}
function Uf(r) {
  return SC(pg(r));
}
function CC(r) {
  if (!r3(r))
    throw new Error("Uint8Array expected");
  return SC(pg(Uint8Array.from(r).reverse()));
}
function mg(r, e) {
  return gg(r.toString(16).padStart(e * 2, "0"));
}
function AC(r, e) {
  return mg(r, e).reverse();
}
function uhe(r) {
  return gg(Kk(r));
}
function fa(r, e, t) {
  let n;
  if (typeof e == "string")
    try {
      n = gg(e);
    } catch (s) {
      throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${s}`);
    }
  else if (r3(e))
    n = Uint8Array.from(e);
  else
    throw new Error(`${r} must be hex string or Uint8Array`);
  const i = n.length;
  if (typeof t == "number" && i !== t)
    throw new Error(`${r} expected ${t} bytes, got ${i}`);
  return n;
}
function ow(...r) {
  const e = new Uint8Array(r.reduce((n, i) => n + i.length, 0));
  let t = 0;
  return r.forEach((n) => {
    if (!r3(n))
      throw new Error("Uint8Array expected");
    e.set(n, t), t += n.length;
  }), e;
}
function hhe(r, e) {
  if (r.length !== e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
function fhe(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function dhe(r) {
  let e;
  for (e = 0; r > Gk; r >>= t3, e += 1)
    ;
  return e;
}
function phe(r, e) {
  return r >> BigInt(e) & t3;
}
const ghe = (r, e, t) => r | (t ? t3 : Gk) << BigInt(e), IC = (r) => (che << BigInt(r - 1)) - t3, b4 = (r) => new Uint8Array(r), JT = (r) => Uint8Array.from(r);
function Zk(r, e, t) {
  if (typeof r != "number" || r < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof t != "function")
    throw new Error("hmacFn must be a function");
  let n = b4(r), i = b4(r), s = 0;
  const o = () => {
    n.fill(1), i.fill(0), s = 0;
  }, a = (...d) => t(i, n, ...d), c = (d = b4()) => {
    i = a(JT([0]), d), n = a(), d.length !== 0 && (i = a(JT([1]), d), n = a());
  }, u = () => {
    if (s++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const m = [];
    for (; d < e; ) {
      n = a();
      const y = n.slice();
      m.push(y), d += n.length;
    }
    return ow(...m);
  };
  return (d, m) => {
    o(), c(d);
    let y;
    for (; !(y = m(u())); )
      c();
    return o(), y;
  };
}
const mhe = {
  bigint: (r) => typeof r == "bigint",
  function: (r) => typeof r == "function",
  boolean: (r) => typeof r == "boolean",
  string: (r) => typeof r == "string",
  stringOrUint8Array: (r) => typeof r == "string" || r instanceof Uint8Array,
  isSafeInteger: (r) => Number.isSafeInteger(r),
  array: (r) => Array.isArray(r),
  field: (r, e) => e.Fp.isValid(r),
  hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function dy(r, e, t = {}) {
  const n = (i, s, o) => {
    const a = mhe[s];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const c = r[i];
    if (!(o && c === void 0) && !a(c, r))
      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`);
  };
  for (const [i, s] of Object.entries(e))
    n(i, s, !1);
  for (const [i, s] of Object.entries(t))
    n(i, s, !0);
  return r;
}
const whe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: phe,
  bitLen: dhe,
  bitMask: IC,
  bitSet: ghe,
  bytesToHex: pg,
  bytesToNumberBE: Uf,
  bytesToNumberLE: CC,
  concatBytes: ow,
  createHmacDrbg: Zk,
  ensureBytes: fa,
  equalBytes: hhe,
  hexToBytes: gg,
  hexToNumber: SC,
  numberToBytesBE: mg,
  numberToBytesLE: AC,
  numberToHexUnpadded: Kk,
  numberToVarBytesBE: uhe,
  utf8ToBytes: fhe,
  validateObject: dy
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const li = BigInt(0), Ln = BigInt(1), Jh = BigInt(2), yhe = BigInt(3), yx = BigInt(4), QT = BigInt(5), YT = BigInt(8);
BigInt(9);
BigInt(16);
function Os(r, e) {
  const t = r % e;
  return t >= li ? t : e + t;
}
function vhe(r, e, t) {
  if (t <= li || e < li)
    throw new Error("Expected power/modulo > 0");
  if (t === Ln)
    return li;
  let n = Ln;
  for (; e > li; )
    e & Ln && (n = n * r % t), r = r * r % t, e >>= Ln;
  return n;
}
function bo(r, e, t) {
  let n = r;
  for (; e-- > li; )
    n *= n, n %= t;
  return n;
}
function vx(r, e) {
  if (r === li || e <= li)
    throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);
  let t = Os(r, e), n = e, i = li, s = Ln;
  for (; t !== li; ) {
    const a = n / t, c = n % t, u = i - s * a;
    n = t, t = c, i = s, s = u;
  }
  if (n !== Ln)
    throw new Error("invert: does not exist");
  return Os(i, e);
}
function bhe(r) {
  const e = (r - Ln) / Jh;
  let t, n, i;
  for (t = r - Ln, n = 0; t % Jh === li; t /= Jh, n++)
    ;
  for (i = Jh; i < r && vhe(i, e, r) !== r - Ln; i++)
    ;
  if (n === 1) {
    const o = (r + Ln) / yx;
    return function(c, u) {
      const f = c.pow(u, o);
      if (!c.eql(c.sqr(f), u))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const s = (t + Ln) / Jh;
  return function(a, c) {
    if (a.pow(c, e) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = n, f = a.pow(a.mul(a.ONE, i), t), d = a.pow(c, s), m = a.pow(c, t);
    for (; !a.eql(m, a.ONE); ) {
      if (a.eql(m, a.ZERO))
        return a.ZERO;
      let y = 1;
      for (let I = a.sqr(m); y < u && !a.eql(I, a.ONE); y++)
        I = a.sqr(I);
      const b = a.pow(f, Ln << BigInt(u - y - 1));
      f = a.sqr(b), d = a.mul(d, b), m = a.mul(m, f), u = y;
    }
    return d;
  };
}
function _he(r) {
  if (r % yx === yhe) {
    const e = (r + Ln) / yx;
    return function(n, i) {
      const s = n.pow(i, e);
      if (!n.eql(n.sqr(s), i))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  if (r % YT === QT) {
    const e = (r - QT) / YT;
    return function(n, i) {
      const s = n.mul(i, Jh), o = n.pow(s, e), a = n.mul(i, o), c = n.mul(n.mul(a, Jh), o), u = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return bhe(r);
}
const Ehe = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function xhe(r) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, t = Ehe.reduce((n, i) => (n[i] = "function", n), e);
  return dy(r, t);
}
function She(r, e, t) {
  if (t < li)
    throw new Error("Expected power > 0");
  if (t === li)
    return r.ONE;
  if (t === Ln)
    return e;
  let n = r.ONE, i = e;
  for (; t > li; )
    t & Ln && (n = r.mul(n, i)), i = r.sqr(i), t >>= Ln;
  return n;
}
function Che(r, e) {
  const t = new Array(e.length), n = e.reduce((s, o, a) => r.is0(o) ? s : (t[a] = s, r.mul(s, o)), r.ONE), i = r.inv(n);
  return e.reduceRight((s, o, a) => r.is0(o) ? s : (t[a] = r.mul(s, t[a]), r.mul(s, o)), i), t;
}
function Jk(r, e) {
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function Ahe(r, e, t = !1, n = {}) {
  if (r <= li)
    throw new Error(`Expected Field ORDER > 0, got ${r}`);
  const { nBitLength: i, nByteLength: s } = Jk(r, e);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = _he(r), a = Object.freeze({
    ORDER: r,
    BITS: i,
    BYTES: s,
    MASK: IC(i),
    ZERO: li,
    ONE: Ln,
    create: (c) => Os(c, r),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return li <= c && c < r;
    },
    is0: (c) => c === li,
    isOdd: (c) => (c & Ln) === Ln,
    neg: (c) => Os(-c, r),
    eql: (c, u) => c === u,
    sqr: (c) => Os(c * c, r),
    add: (c, u) => Os(c + u, r),
    sub: (c, u) => Os(c - u, r),
    mul: (c, u) => Os(c * u, r),
    pow: (c, u) => She(a, c, u),
    div: (c, u) => Os(c * vx(u, r), r),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => vx(c, r),
    sqrt: n.sqrt || ((c) => o(a, c)),
    invertBatch: (c) => Che(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, f) => f ? u : c,
    toBytes: (c) => t ? AC(c, s) : mg(c, s),
    fromBytes: (c) => {
      if (c.length !== s)
        throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
      return t ? CC(c) : Uf(c);
    }
  });
  return Object.freeze(a);
}
function Qk(r) {
  if (typeof r != "bigint")
    throw new Error("field order must be bigint");
  const e = r.toString(2).length;
  return Math.ceil(e / 8);
}
function Yk(r) {
  const e = Qk(r);
  return e + Math.ceil(e / 2);
}
function Ihe(r, e, t = !1) {
  const n = r.length, i = Qk(e), s = Yk(e);
  if (n < 16 || n < s || n > 1024)
    throw new Error(`expected ${s}-1024 bytes of input, got ${n}`);
  const o = t ? Uf(r) : CC(r), a = Os(o, e - Ln) + Ln;
  return t ? AC(a, i) : mg(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Rhe = BigInt(0), _4 = BigInt(1);
function The(r, e) {
  const t = (i, s) => {
    const o = s.negate();
    return i ? o : s;
  }, n = (i) => {
    const s = Math.ceil(e / i) + 1, o = 2 ** (i - 1);
    return { windows: s, windowSize: o };
  };
  return {
    constTimeNegate: t,
    // non-const time multiplication ladder
    unsafeLadder(i, s) {
      let o = r.ZERO, a = i;
      for (; s > Rhe; )
        s & _4 && (o = o.add(a)), a = a.double(), s >>= _4;
      return o;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, s) {
      const { windows: o, windowSize: a } = n(s), c = [];
      let u = i, f = u;
      for (let d = 0; d < o; d++) {
        f = u, c.push(f);
        for (let m = 1; m < a; m++)
          f = f.add(u), c.push(f);
        u = f.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, s, o) {
      const { windows: a, windowSize: c } = n(i);
      let u = r.ZERO, f = r.BASE;
      const d = BigInt(2 ** i - 1), m = 2 ** i, y = BigInt(i);
      for (let b = 0; b < a; b++) {
        const I = b * c;
        let k = Number(o & d);
        o >>= y, k > c && (k -= m, o += _4);
        const R = I, T = I + Math.abs(k) - 1, $ = b % 2 !== 0, D = k < 0;
        k === 0 ? f = f.add(t($, s[R])) : u = u.add(t(D, s[T]));
      }
      return { p: u, f };
    },
    wNAFCached(i, s, o, a) {
      const c = i._WINDOW_SIZE || 1;
      let u = s.get(i);
      return u || (u = this.precomputeWindow(i, c), c !== 1 && s.set(i, a(u))), this.wNAF(c, u, o);
    }
  };
}
function Xk(r) {
  return xhe(r.Fp), dy(r, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Jk(r.n, r.nBitLength),
    ...r,
    p: r.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Ohe(r) {
  const e = Xk(r);
  dy(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: t, Fp: n, a: i } = e;
  if (t) {
    if (!n.eql(i, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: Nhe, hexToBytes: Phe } = whe, lf = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(r) {
    const { Err: e } = lf;
    if (r.length < 2 || r[0] !== 2)
      throw new e("Invalid signature integer tag");
    const t = r[1], n = r.subarray(2, t + 2);
    if (!t || n.length !== t)
      throw new e("Invalid signature integer: wrong length");
    if (n[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (n[0] === 0 && !(n[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: Nhe(n), l: r.subarray(t + 2) };
  },
  toSig(r) {
    const { Err: e } = lf, t = typeof r == "string" ? Phe(r) : r;
    if (!(t instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = t.length;
    if (n < 2 || t[0] != 48)
      throw new e("Invalid signature tag");
    if (t[1] !== n - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: i, l: s } = lf._parseInt(t.subarray(2)), { d: o, l: a } = lf._parseInt(s);
    if (a.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: i, s: o };
  },
  hexFromSig(r) {
    const e = (u) => Number.parseInt(u[0], 16) & 8 ? "00" + u : u, t = (u) => {
      const f = u.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, n = e(t(r.s)), i = e(t(r.r)), s = n.length / 2, o = i.length / 2, a = t(s), c = t(o);
    return `30${t(o + s + 4)}02${c}${i}02${a}${n}`;
  }
}, Sl = BigInt(0), Po = BigInt(1);
BigInt(2);
const XT = BigInt(3);
BigInt(4);
function Mhe(r) {
  const e = Ohe(r), { Fp: t } = e, n = e.toBytes || ((b, I, k) => {
    const R = I.toAffine();
    return ow(Uint8Array.from([4]), t.toBytes(R.x), t.toBytes(R.y));
  }), i = e.fromBytes || ((b) => {
    const I = b.subarray(1), k = t.fromBytes(I.subarray(0, t.BYTES)), R = t.fromBytes(I.subarray(t.BYTES, 2 * t.BYTES));
    return { x: k, y: R };
  });
  function s(b) {
    const { a: I, b: k } = e, R = t.sqr(b), T = t.mul(R, b);
    return t.add(t.add(T, t.mul(b, I)), k);
  }
  if (!t.eql(t.sqr(e.Gy), s(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function o(b) {
    return typeof b == "bigint" && Sl < b && b < e.n;
  }
  function a(b) {
    if (!o(b))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(b) {
    const { allowedPrivateKeyLengths: I, nByteLength: k, wrapPrivateKey: R, n: T } = e;
    if (I && typeof b != "bigint") {
      if (b instanceof Uint8Array && (b = pg(b)), typeof b != "string" || !I.includes(b.length))
        throw new Error("Invalid key");
      b = b.padStart(k * 2, "0");
    }
    let $;
    try {
      $ = typeof b == "bigint" ? b : Uf(fa("private key", b, k));
    } catch {
      throw new Error(`private key must be ${k} bytes, hex or bigint, not ${typeof b}`);
    }
    return R && ($ = Os($, T)), a($), $;
  }
  const u = /* @__PURE__ */ new Map();
  function f(b) {
    if (!(b instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(I, k, R) {
      if (this.px = I, this.py = k, this.pz = R, I == null || !t.isValid(I))
        throw new Error("x required");
      if (k == null || !t.isValid(k))
        throw new Error("y required");
      if (R == null || !t.isValid(R))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(I) {
      const { x: k, y: R } = I || {};
      if (!I || !t.isValid(k) || !t.isValid(R))
        throw new Error("invalid affine point");
      if (I instanceof d)
        throw new Error("projective point not allowed");
      const T = ($) => t.eql($, t.ZERO);
      return T(k) && T(R) ? d.ZERO : new d(k, R, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(I) {
      const k = t.invertBatch(I.map((R) => R.pz));
      return I.map((R, T) => R.toAffine(k[T])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(I) {
      const k = d.fromAffine(i(fa("pointHex", I)));
      return k.assertValidity(), k;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(I) {
      return d.BASE.multiply(c(I));
    }
    // "Private method", don't use it directly
    _setWindowSize(I) {
      this._WINDOW_SIZE = I, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !t.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: I, y: k } = this.toAffine();
      if (!t.isValid(I) || !t.isValid(k))
        throw new Error("bad point: x or y not FE");
      const R = t.sqr(k), T = s(I);
      if (!t.eql(R, T))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: I } = this.toAffine();
      if (t.isOdd)
        return !t.isOdd(I);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(I) {
      f(I);
      const { px: k, py: R, pz: T } = this, { px: $, py: D, pz: L } = I, P = t.eql(t.mul(k, L), t.mul($, T)), v = t.eql(t.mul(R, L), t.mul(D, T));
      return P && v;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, t.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: I, b: k } = e, R = t.mul(k, XT), { px: T, py: $, pz: D } = this;
      let L = t.ZERO, P = t.ZERO, v = t.ZERO, F = t.mul(T, T), X = t.mul($, $), te = t.mul(D, D), se = t.mul(T, $);
      return se = t.add(se, se), v = t.mul(T, D), v = t.add(v, v), L = t.mul(I, v), P = t.mul(R, te), P = t.add(L, P), L = t.sub(X, P), P = t.add(X, P), P = t.mul(L, P), L = t.mul(se, L), v = t.mul(R, v), te = t.mul(I, te), se = t.sub(F, te), se = t.mul(I, se), se = t.add(se, v), v = t.add(F, F), F = t.add(v, F), F = t.add(F, te), F = t.mul(F, se), P = t.add(P, F), te = t.mul($, D), te = t.add(te, te), F = t.mul(te, se), L = t.sub(L, F), v = t.mul(te, X), v = t.add(v, v), v = t.add(v, v), new d(L, P, v);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(I) {
      f(I);
      const { px: k, py: R, pz: T } = this, { px: $, py: D, pz: L } = I;
      let P = t.ZERO, v = t.ZERO, F = t.ZERO;
      const X = e.a, te = t.mul(e.b, XT);
      let se = t.mul(k, $), we = t.mul(R, D), H = t.mul(T, L), p = t.add(k, R), w = t.add($, D);
      p = t.mul(p, w), w = t.add(se, we), p = t.sub(p, w), w = t.add(k, T);
      let x = t.add($, L);
      return w = t.mul(w, x), x = t.add(se, H), w = t.sub(w, x), x = t.add(R, T), P = t.add(D, L), x = t.mul(x, P), P = t.add(we, H), x = t.sub(x, P), F = t.mul(X, w), P = t.mul(te, H), F = t.add(P, F), P = t.sub(we, F), F = t.add(we, F), v = t.mul(P, F), we = t.add(se, se), we = t.add(we, se), H = t.mul(X, H), w = t.mul(te, w), we = t.add(we, H), H = t.sub(se, H), H = t.mul(X, H), w = t.add(w, H), se = t.mul(we, w), v = t.add(v, se), se = t.mul(x, w), P = t.mul(p, P), P = t.sub(P, se), se = t.mul(p, we), F = t.mul(x, F), F = t.add(F, se), new d(P, v, F);
    }
    subtract(I) {
      return this.add(I.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(I) {
      return y.wNAFCached(this, u, I, (k) => {
        const R = t.invertBatch(k.map((T) => T.pz));
        return k.map((T, $) => T.toAffine(R[$])).map(d.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(I) {
      const k = d.ZERO;
      if (I === Sl)
        return k;
      if (a(I), I === Po)
        return this;
      const { endo: R } = e;
      if (!R)
        return y.unsafeLadder(this, I);
      let { k1neg: T, k1: $, k2neg: D, k2: L } = R.splitScalar(I), P = k, v = k, F = this;
      for (; $ > Sl || L > Sl; )
        $ & Po && (P = P.add(F)), L & Po && (v = v.add(F)), F = F.double(), $ >>= Po, L >>= Po;
      return T && (P = P.negate()), D && (v = v.negate()), v = new d(t.mul(v.px, R.beta), v.py, v.pz), P.add(v);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(I) {
      a(I);
      let k = I, R, T;
      const { endo: $ } = e;
      if ($) {
        const { k1neg: D, k1: L, k2neg: P, k2: v } = $.splitScalar(k);
        let { p: F, f: X } = this.wNAF(L), { p: te, f: se } = this.wNAF(v);
        F = y.constTimeNegate(D, F), te = y.constTimeNegate(P, te), te = new d(t.mul(te.px, $.beta), te.py, te.pz), R = F.add(te), T = X.add(se);
      } else {
        const { p: D, f: L } = this.wNAF(k);
        R = D, T = L;
      }
      return d.normalizeZ([R, T])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(I, k, R) {
      const T = d.BASE, $ = (L, P) => P === Sl || P === Po || !L.equals(T) ? L.multiplyUnsafe(P) : L.multiply(P), D = $(this, k).add($(I, R));
      return D.is0() ? void 0 : D;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(I) {
      const { px: k, py: R, pz: T } = this, $ = this.is0();
      I == null && (I = $ ? t.ONE : t.inv(T));
      const D = t.mul(k, I), L = t.mul(R, I), P = t.mul(T, I);
      if ($)
        return { x: t.ZERO, y: t.ZERO };
      if (!t.eql(P, t.ONE))
        throw new Error("invZ was invalid");
      return { x: D, y: L };
    }
    isTorsionFree() {
      const { h: I, isTorsionFree: k } = e;
      if (I === Po)
        return !0;
      if (k)
        return k(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: I, clearCofactor: k } = e;
      return I === Po ? this : k ? k(d, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(I = !0) {
      return this.assertValidity(), n(d, this, I);
    }
    toHex(I = !0) {
      return pg(this.toRawBytes(I));
    }
  }
  d.BASE = new d(e.Gx, e.Gy, t.ONE), d.ZERO = new d(t.ZERO, t.ONE, t.ZERO);
  const m = e.nBitLength, y = The(d, e.endo ? Math.ceil(m / 2) : m);
  return {
    CURVE: e,
    ProjectivePoint: d,
    normPrivateKeyToScalar: c,
    weierstrassEquation: s,
    isWithinCurveOrder: o
  };
}
function Dhe(r) {
  const e = Xk(r);
  return dy(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function khe(r) {
  const e = Dhe(r), { Fp: t, n } = e, i = t.BYTES + 1, s = 2 * t.BYTES + 1;
  function o(w) {
    return Sl < w && w < t.ORDER;
  }
  function a(w) {
    return Os(w, n);
  }
  function c(w) {
    return vx(w, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: f, weierstrassEquation: d, isWithinCurveOrder: m } = Mhe({
    ...e,
    toBytes(w, x, N) {
      const O = x.toAffine(), U = t.toBytes(O.x), q = ow;
      return N ? q(Uint8Array.from([x.hasEvenY() ? 2 : 3]), U) : q(Uint8Array.from([4]), U, t.toBytes(O.y));
    },
    fromBytes(w) {
      const x = w.length, N = w[0], O = w.subarray(1);
      if (x === i && (N === 2 || N === 3)) {
        const U = Uf(O);
        if (!o(U))
          throw new Error("Point is not on curve");
        const q = d(U);
        let B = t.sqrt(q);
        const E = (B & Po) === Po;
        return (N & 1) === 1 !== E && (B = t.neg(B)), { x: U, y: B };
      } else if (x === s && N === 4) {
        const U = t.fromBytes(O.subarray(0, t.BYTES)), q = t.fromBytes(O.subarray(t.BYTES, 2 * t.BYTES));
        return { x: U, y: q };
      } else
        throw new Error(`Point of length ${x} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);
    }
  }), y = (w) => pg(mg(w, e.nByteLength));
  function b(w) {
    const x = n >> Po;
    return w > x;
  }
  function I(w) {
    return b(w) ? a(-w) : w;
  }
  const k = (w, x, N) => Uf(w.slice(x, N));
  class R {
    constructor(x, N, O) {
      this.r = x, this.s = N, this.recovery = O, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(x) {
      const N = e.nByteLength;
      return x = fa("compactSignature", x, N * 2), new R(k(x, 0, N), k(x, N, 2 * N));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(x) {
      const { r: N, s: O } = lf.toSig(fa("DER", x));
      return new R(N, O);
    }
    assertValidity() {
      if (!m(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!m(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(x) {
      return new R(this.r, this.s, x);
    }
    recoverPublicKey(x) {
      const { r: N, s: O, recovery: U } = this, q = v(fa("msgHash", x));
      if (U == null || ![0, 1, 2, 3].includes(U))
        throw new Error("recovery id invalid");
      const B = U === 2 || U === 3 ? N + e.n : N;
      if (B >= t.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const E = U & 1 ? "03" : "02", V = u.fromHex(E + y(B)), be = c(B), ve = a(-q * be), ne = a(O * be), K = u.BASE.multiplyAndAddUnsafe(V, ve, ne);
      if (!K)
        throw new Error("point at infinify");
      return K.assertValidity(), K;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return b(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new R(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return gg(this.toDERHex());
    }
    toDERHex() {
      return lf.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return gg(this.toCompactHex());
    }
    toCompactHex() {
      return y(this.r) + y(this.s);
    }
  }
  const T = {
    isValidPrivateKey(w) {
      try {
        return f(w), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const w = Yk(e.n);
      return Ihe(e.randomBytes(w), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(w = 8, x = u.BASE) {
      return x._setWindowSize(w), x.multiply(BigInt(3)), x;
    }
  };
  function $(w, x = !0) {
    return u.fromPrivateKey(w).toRawBytes(x);
  }
  function D(w) {
    const x = w instanceof Uint8Array, N = typeof w == "string", O = (x || N) && w.length;
    return x ? O === i || O === s : N ? O === 2 * i || O === 2 * s : w instanceof u;
  }
  function L(w, x, N = !0) {
    if (D(w))
      throw new Error("first arg must be private key");
    if (!D(x))
      throw new Error("second arg must be public key");
    return u.fromHex(x).multiply(f(w)).toRawBytes(N);
  }
  const P = e.bits2int || function(w) {
    const x = Uf(w), N = w.length * 8 - e.nBitLength;
    return N > 0 ? x >> BigInt(N) : x;
  }, v = e.bits2int_modN || function(w) {
    return a(P(w));
  }, F = IC(e.nBitLength);
  function X(w) {
    if (typeof w != "bigint")
      throw new Error("bigint expected");
    if (!(Sl <= w && w < F))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return mg(w, e.nByteLength);
  }
  function te(w, x, N = se) {
    if (["recovered", "canonical"].some((ee) => ee in N))
      throw new Error("sign() legacy options not supported");
    const { hash: O, randomBytes: U } = e;
    let { lowS: q, prehash: B, extraEntropy: E } = N;
    q == null && (q = !0), w = fa("msgHash", w), B && (w = fa("prehashed msgHash", O(w)));
    const V = v(w), be = f(x), ve = [X(be), X(V)];
    if (E != null) {
      const ee = E === !0 ? U(t.BYTES) : E;
      ve.push(fa("extraEntropy", ee));
    }
    const ne = ow(...ve), K = V;
    function Y(ee) {
      const S = P(ee);
      if (!m(S))
        return;
      const M = c(S), G = u.BASE.multiply(S).toAffine(), ue = a(G.x);
      if (ue === Sl)
        return;
      const Ee = a(M * a(K + ue * be));
      if (Ee === Sl)
        return;
      let Le = (G.x === ue ? 0 : 2) | Number(G.y & Po), Fe = Ee;
      return q && b(Ee) && (Fe = I(Ee), Le ^= 1), new R(ue, Fe, Le);
    }
    return { seed: ne, k2sig: Y };
  }
  const se = { lowS: e.lowS, prehash: !1 }, we = { lowS: e.lowS, prehash: !1 };
  function H(w, x, N = se) {
    const { seed: O, k2sig: U } = te(w, x, N), q = e;
    return Zk(q.hash.outputLen, q.nByteLength, q.hmac)(O, U);
  }
  u.BASE._setWindowSize(8);
  function p(w, x, N, O = we) {
    var G;
    const U = w;
    if (x = fa("msgHash", x), N = fa("publicKey", N), "strict" in O)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: q, prehash: B } = O;
    let E, V;
    try {
      if (typeof U == "string" || U instanceof Uint8Array)
        try {
          E = R.fromDER(U);
        } catch (ue) {
          if (!(ue instanceof lf.Err))
            throw ue;
          E = R.fromCompact(U);
        }
      else if (typeof U == "object" && typeof U.r == "bigint" && typeof U.s == "bigint") {
        const { r: ue, s: Ee } = U;
        E = new R(ue, Ee);
      } else
        throw new Error("PARSE");
      V = u.fromHex(N);
    } catch (ue) {
      if (ue.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (q && E.hasHighS())
      return !1;
    B && (x = e.hash(x));
    const { r: be, s: ve } = E, ne = v(x), K = c(ve), Y = a(ne * K), ee = a(be * K), S = (G = u.BASE.multiplyAndAddUnsafe(V, Y, ee)) == null ? void 0 : G.toAffine();
    return S ? a(S.x) === be : !1;
  }
  return {
    CURVE: e,
    getPublicKey: $,
    getSharedSecret: L,
    sign: H,
    verify: p,
    ProjectivePoint: u,
    Signature: R,
    utils: T
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function $he(r) {
  return {
    hash: r,
    hmac: (e, ...t) => Fk(r, e, $ue(...t)),
    randomBytes: Lue
  };
}
function Lhe(r, e) {
  const t = (n) => khe({ ...r, ...$he(n) });
  return Object.freeze({ ...t(e), create: t });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const e$ = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), e7 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Bhe = BigInt(1), bx = BigInt(2), t7 = (r, e) => (r + e / bx) / e;
function Fhe(r) {
  const e = e$, t = BigInt(3), n = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), u = r * r * r % e, f = u * u * r % e, d = bo(f, t, e) * f % e, m = bo(d, t, e) * f % e, y = bo(m, bx, e) * u % e, b = bo(y, i, e) * y % e, I = bo(b, s, e) * b % e, k = bo(I, a, e) * I % e, R = bo(k, c, e) * k % e, T = bo(R, a, e) * I % e, $ = bo(T, t, e) * f % e, D = bo($, o, e) * b % e, L = bo(D, n, e) * u % e, P = bo(L, bx, e);
  if (!_x.eql(_x.sqr(P), r))
    throw new Error("Cannot find square root");
  return P;
}
const _x = Ahe(e$, void 0, void 0, { sqrt: Fhe }), lu = Lhe({
  a: BigInt(0),
  b: BigInt(7),
  Fp: _x,
  n: e7,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (r) => {
      const e = e7, t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Bhe * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s = t, o = BigInt("0x100000000000000000000000000000000"), a = t7(s * r, e), c = t7(-n * r, e);
      let u = Os(r - a * t - c * i, e), f = Os(-a * n - c * s, e);
      const d = u > o, m = f > o;
      if (d && (u = e - u), m && (f = e - f), u > o || f > o)
        throw new Error("splitScalar: Endomorphism failed, k=" + r);
      return { k1neg: d, k1: u, k2neg: m, k2: f };
    }
  }
}, zue);
BigInt(0);
lu.ProjectivePoint;
const Ex = "0x0000000000000000000000000000000000000000", r7 = "0x0000000000000000000000000000000000000000000000000000000000000000", n7 = BigInt(0), i7 = BigInt(1), s7 = BigInt(2), o7 = BigInt(27), a7 = BigInt(28), ob = BigInt(35), up = {};
function c7(r) {
  return fd(to(r), 32);
}
var h0, f0, d0, Sf;
const ua = class ua {
  /**
   *  @private
   */
  constructor(e, t, n, i) {
    ye(this, h0, void 0);
    ye(this, f0, void 0);
    ye(this, d0, void 0);
    ye(this, Sf, void 0);
    fy(e, up, "Signature"), ie(this, h0, t), ie(this, f0, n), ie(this, d0, i), ie(this, Sf, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return j(this, h0);
  }
  set r(e) {
    me(Zp(e) === 32, "invalid r", "value", e), ie(this, h0, wt(e));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return j(this, f0);
  }
  set s(e) {
    me(Zp(e) === 32, "invalid s", "value", e);
    const t = wt(e);
    me(parseInt(t.substring(0, 3)) < 8, "non-canonical s", "value", t), ie(this, f0, t);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return j(this, d0);
  }
  set v(e) {
    const t = nr(e, "value");
    me(t === 27 || t === 28, "invalid v", "v", e), ie(this, d0, t);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return j(this, Sf);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : ua.getChainId(e);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const e = Tr(this.s);
    return this.yParity && (e[0] |= 128), wt(e);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return Zn([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return Zn([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const e = new ua(up, this.r, this.s, this.v);
    return this.networkV && ie(e, Sf, this.networkV), e;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(e) {
    const t = gt(e, "v");
    return t == o7 || t == a7 ? n7 : (me(t >= ob, "invalid EIP-155 v", "v", e), (t - ob) / s7);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(e, t) {
    return gt(e) * s7 + BigInt(35 + t - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(e) {
    const t = gt(e);
    return t === n7 || t === o7 ? 27 : t === i7 || t === a7 ? 28 : (me(t >= ob, "invalid v", "v", e), t & i7 ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(e) {
    function t(u, f) {
      me(u, f, "signature", e);
    }
    if (e == null)
      return new ua(up, r7, r7, 27);
    if (typeof e == "string") {
      const u = Tr(e, "signature");
      if (u.length === 64) {
        const f = wt(u.slice(0, 32)), d = u.slice(32, 64), m = d[0] & 128 ? 28 : 27;
        return d[0] &= 127, new ua(up, f, wt(d), m);
      }
      if (u.length === 65) {
        const f = wt(u.slice(0, 32)), d = u.slice(32, 64);
        t((d[0] & 128) === 0, "non-canonical s");
        const m = ua.getNormalizedV(u[64]);
        return new ua(up, f, wt(d), m);
      }
      t(!1, "invalid raw signature length");
    }
    if (e instanceof ua)
      return e.clone();
    const n = e.r;
    t(n != null, "missing r");
    const i = c7(n), s = function(u, f) {
      if (u != null)
        return c7(u);
      if (f != null) {
        t(mn(f, 32), "invalid yParityAndS");
        const d = Tr(f);
        return d[0] &= 127, wt(d);
      }
      t(!1, "missing s");
    }(e.s, e.yParityAndS);
    t((Tr(s)[0] & 128) == 0, "non-canonical s");
    const { networkV: o, v: a } = function(u, f, d) {
      if (u != null) {
        const m = gt(u);
        return {
          networkV: m >= ob ? m : void 0,
          v: ua.getNormalizedV(m)
        };
      }
      if (f != null)
        return t(mn(f, 32), "invalid yParityAndS"), { v: Tr(f)[0] & 128 ? 28 : 27 };
      if (d != null) {
        switch (nr(d, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        t(!1, "invalid yParity");
      }
      t(!1, "missing v");
    }(e.v, e.yParityAndS, e.yParity), c = new ua(up, i, s, a);
    return o && ie(c, Sf, o), t(e.yParity == null || nr(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), t(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
};
h0 = new WeakMap(), f0 = new WeakMap(), d0 = new WeakMap(), Sf = new WeakMap();
let ka = ua;
var pl;
const rf = class rf {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(e) {
    ye(this, pl, void 0);
    me(Zp(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), ie(this, pl, wt(e));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return j(this, pl);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return rf.computePublicKey(j(this, pl));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return rf.computePublicKey(j(this, pl), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(e) {
    me(Zp(e) === 32, "invalid digest length", "digest", e);
    const t = lu.sign(rs(e), rs(j(this, pl)), {
      lowS: !0
    });
    return ka.from({
      r: rh(t.r, 32),
      s: rh(t.s, 32),
      v: t.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(e) {
    const t = rf.computePublicKey(e);
    return wt(lu.getSharedSecret(rs(j(this, pl)), Tr(t), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(e, t) {
    let n = Tr(e, "key");
    if (n.length === 32) {
      const s = lu.getPublicKey(n, !!t);
      return wt(s);
    }
    if (n.length === 64) {
      const s = new Uint8Array(65);
      s[0] = 4, s.set(n, 1), n = s;
    }
    const i = lu.ProjectivePoint.fromHex(n);
    return wt(i.toRawBytes(t));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(e, t) {
    me(Zp(e) === 32, "invalid digest length", "digest", e);
    const n = ka.from(t);
    let i = lu.Signature.fromCompact(rs(Zn([n.r, n.s])));
    i = i.addRecoveryBit(n.yParity);
    const s = i.recoverPublicKey(rs(e));
    return me(s != null, "invalid signautre for digest", "signature", t), "0x" + s.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(e, t, n) {
    const i = lu.ProjectivePoint.fromHex(rf.computePublicKey(e).substring(2)), s = lu.ProjectivePoint.fromHex(rf.computePublicKey(t).substring(2));
    return "0x" + i.add(s).toHex(!!n);
  }
};
pl = new WeakMap();
let aw = rf;
const Uhe = BigInt(0), jhe = BigInt(36);
function l7(r) {
  r = r.toLowerCase();
  const e = r.substring(2).split(""), t = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    t[i] = e[i].charCodeAt(0);
  const n = Tr(gn(t));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const RC = {};
for (let r = 0; r < 10; r++)
  RC[String(r)] = String(r);
for (let r = 0; r < 26; r++)
  RC[String.fromCharCode(65 + r)] = String(10 + r);
const u7 = 15;
function Whe(r) {
  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
  let e = r.split("").map((n) => RC[n]).join("");
  for (; e.length >= u7; ) {
    let n = e.substring(0, u7);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
const Hhe = function() {
  const r = {};
  for (let e = 0; e < 36; e++) {
    const t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    r[t] = BigInt(e);
  }
  return r;
}();
function zhe(r) {
  r = r.toLowerCase();
  let e = Uhe;
  for (let t = 0; t < r.length; t++)
    e = e * jhe + Hhe[r[t]];
  return e;
}
function fr(r) {
  if (me(typeof r == "string", "invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    r.startsWith("0x") || (r = "0x" + r);
    const e = l7(r);
    return me(!r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === r, "bad address checksum", "address", r), e;
  }
  if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    me(r.substring(2, 4) === Whe(r), "bad icap checksum", "address", r);
    let e = zhe(r.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return l7("0x" + e);
  }
  me(!1, "invalid address", "address", r);
}
function Vhe(r) {
  const e = fr(r.from);
  let n = gt(r.nonce, "tx.nonce").toString(16);
  return n === "0" ? n = "0x" : n.length % 2 ? n = "0x0" + n : n = "0x" + n, fr(xn(gn(sw([e, n])), 12));
}
function t$(r) {
  return r && typeof r.getAddress == "function";
}
async function E4(r, e) {
  const t = await e;
  return (t == null || t === "0x0000000000000000000000000000000000000000") && (Te(typeof r != "string", "unconfigured name", "UNCONFIGURED_NAME", { value: r }), me(!1, "invalid AddressLike value; did not resolve to a value address", "target", r)), fr(t);
}
function ss(r, e) {
  if (typeof r == "string")
    return r.match(/^0x[0-9a-f]{40}$/i) ? fr(r) : (Te(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" }), E4(r, e.resolveName(r)));
  if (t$(r))
    return E4(r, r.getAddress());
  if (r && typeof r.then == "function")
    return E4(r, r);
  me(!1, "unsupported addressable value", "target", r);
}
const rl = {};
function nt(r, e) {
  let t = !1;
  return e < 0 && (t = !0, e *= -1), new Li(rl, `${t ? "" : "u"}int${e}`, r, { signed: t, width: e });
}
function Er(r, e) {
  return new Li(rl, `bytes${e || ""}`, r, { size: e });
}
const h7 = Symbol.for("_ethers_typed");
var Cf;
const sl = class sl {
  /**
   *  @_ignore:
   */
  constructor(e, t, n, i) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    _e(this, "type");
    /**
     *  The actual value.
     */
    _e(this, "value");
    ye(this, Cf, void 0);
    /**
     *  @_ignore:
     */
    _e(this, "_typedSymbol");
    i == null && (i = null), fy(rl, e, "Typed"), Et(this, { _typedSymbol: h7, type: t, value: n }), ie(this, Cf, i), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((e) => e.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return j(this, Cf);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return j(this, Cf) === !0 ? -1 : j(this, Cf) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(e, t) {
    return new sl(rl, e, t);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(e) {
    return nt(e, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(e) {
    return nt(e, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(e) {
    return nt(e, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(e) {
    return nt(e, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(e) {
    return nt(e, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(e) {
    return nt(e, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(e) {
    return nt(e, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(e) {
    return nt(e, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(e) {
    return nt(e, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(e) {
    return nt(e, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(e) {
    return nt(e, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(e) {
    return nt(e, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(e) {
    return nt(e, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(e) {
    return nt(e, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(e) {
    return nt(e, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(e) {
    return nt(e, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(e) {
    return nt(e, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(e) {
    return nt(e, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(e) {
    return nt(e, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(e) {
    return nt(e, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(e) {
    return nt(e, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(e) {
    return nt(e, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(e) {
    return nt(e, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(e) {
    return nt(e, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(e) {
    return nt(e, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(e) {
    return nt(e, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(e) {
    return nt(e, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(e) {
    return nt(e, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(e) {
    return nt(e, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(e) {
    return nt(e, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(e) {
    return nt(e, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(e) {
    return nt(e, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(e) {
    return nt(e, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(e) {
    return nt(e, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(e) {
    return nt(e, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(e) {
    return nt(e, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(e) {
    return nt(e, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(e) {
    return nt(e, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(e) {
    return nt(e, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(e) {
    return nt(e, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(e) {
    return nt(e, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(e) {
    return nt(e, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(e) {
    return nt(e, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(e) {
    return nt(e, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(e) {
    return nt(e, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(e) {
    return nt(e, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(e) {
    return nt(e, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(e) {
    return nt(e, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(e) {
    return nt(e, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(e) {
    return nt(e, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(e) {
    return nt(e, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(e) {
    return nt(e, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(e) {
    return nt(e, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(e) {
    return nt(e, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(e) {
    return nt(e, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(e) {
    return nt(e, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(e) {
    return nt(e, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(e) {
    return nt(e, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(e) {
    return nt(e, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(e) {
    return nt(e, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(e) {
    return nt(e, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(e) {
    return nt(e, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(e) {
    return nt(e, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(e) {
    return nt(e, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(e) {
    return nt(e, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(e) {
    return nt(e, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(e) {
    return Er(e, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(e) {
    return Er(e, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(e) {
    return Er(e, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(e) {
    return Er(e, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(e) {
    return Er(e, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(e) {
    return Er(e, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(e) {
    return Er(e, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(e) {
    return Er(e, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(e) {
    return Er(e, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(e) {
    return Er(e, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(e) {
    return Er(e, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(e) {
    return Er(e, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(e) {
    return Er(e, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(e) {
    return Er(e, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(e) {
    return Er(e, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(e) {
    return Er(e, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(e) {
    return Er(e, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(e) {
    return Er(e, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(e) {
    return Er(e, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(e) {
    return Er(e, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(e) {
    return Er(e, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(e) {
    return Er(e, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(e) {
    return Er(e, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(e) {
    return Er(e, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(e) {
    return Er(e, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(e) {
    return Er(e, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(e) {
    return Er(e, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(e) {
    return Er(e, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(e) {
    return Er(e, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(e) {
    return Er(e, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(e) {
    return Er(e, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(e) {
    return Er(e, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(e) {
    return new sl(rl, "address", e);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(e) {
    return new sl(rl, "bool", !!e);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(e) {
    return new sl(rl, "bytes", e);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(e) {
    return new sl(rl, "string", e);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(e, t) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(e, t) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(e) {
    return new sl(rl, "overrides", Object.assign({}, e));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(e) {
    return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === h7;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(e, t) {
    if (sl.isTyped(e)) {
      if (e.type !== t)
        throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);
      return e.value;
    }
    return e;
  }
};
Cf = new WeakMap();
let Li = sl;
class qhe extends zl {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    let n = Li.dereference(t, "string");
    try {
      n = fr(n);
    } catch (i) {
      return this._throwError(i.message, t);
    }
    return e.writeValue(n);
  }
  decode(e) {
    return fr(rh(e.readValue(), 20));
  }
}
class Ghe extends zl {
  constructor(t) {
    super(t.name, t.type, "_", t.dynamic);
    _e(this, "coder");
    this.coder = t;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(t, n) {
    return this.coder.encode(t, n);
  }
  decode(t) {
    return this.coder.decode(t);
  }
}
function r$(r, e, t) {
  let n = [];
  if (Array.isArray(t))
    n = t;
  else if (t && typeof t == "object") {
    let c = {};
    n = e.map((u) => {
      const f = u.localName;
      return Te(f, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: t }), Te(!c[f], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: t }), c[f] = !0, t[f];
    });
  } else
    me(!1, "invalid tuple value", "tuple", t);
  me(e.length === n.length, "types/value length mismatch", "tuple", t);
  let i = new gx(), s = new gx(), o = [];
  e.forEach((c, u) => {
    let f = n[u];
    if (c.dynamic) {
      let d = s.length;
      c.encode(s, f);
      let m = i.writeUpdatableValue();
      o.push((y) => {
        m(y + d);
      });
    } else
      c.encode(i, f);
  }), o.forEach((c) => {
    c(i.length);
  });
  let a = r.appendWriter(i);
  return a += r.appendWriter(s), a;
}
function n$(r, e) {
  let t = [], n = [], i = r.subReader(0);
  return e.forEach((s) => {
    let o = null;
    if (s.dynamic) {
      let a = r.readIndex(), c = i.subReader(a);
      try {
        o = s.decode(c);
      } catch (u) {
        if ($i(u, "BUFFER_OVERRUN"))
          throw u;
        o = u, o.baseType = s.name, o.name = s.localName, o.type = s.type;
      }
    } else
      try {
        o = s.decode(r);
      } catch (a) {
        if ($i(a, "BUFFER_OVERRUN"))
          throw a;
        o = a, o.baseType = s.name, o.name = s.localName, o.type = s.type;
      }
    if (o == null)
      throw new Error("investigate");
    t.push(o), n.push(s.localName || null);
  }), k2.fromItems(t, n);
}
class Khe extends zl {
  constructor(t, n, i) {
    const s = t.type + "[" + (n >= 0 ? n : "") + "]", o = n === -1 || t.dynamic;
    super("array", s, i, o);
    _e(this, "coder");
    _e(this, "length");
    Et(this, { coder: t, length: n });
  }
  defaultValue() {
    const t = this.coder.defaultValue(), n = [];
    for (let i = 0; i < this.length; i++)
      n.push(t);
    return n;
  }
  encode(t, n) {
    const i = Li.dereference(n, "array");
    Array.isArray(i) || this._throwError("expected array value", i);
    let s = this.length;
    s === -1 && (s = i.length, t.writeValue(i.length)), Ek(i.length, s, "coder array" + (this.localName ? " " + this.localName : ""));
    let o = [];
    for (let a = 0; a < i.length; a++)
      o.push(this.coder);
    return r$(t, o, i);
  }
  decode(t) {
    let n = this.length;
    n === -1 && (n = t.readIndex(), Te(n * is <= t.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: t.bytes, offset: n * is, length: t.dataLength }));
    let i = [];
    for (let s = 0; s < n; s++)
      i.push(new Ghe(this.coder));
    return n$(t, i);
  }
}
class Zhe extends zl {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    const n = Li.dereference(t, "bool");
    return e.writeValue(n ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
}
class i$ extends zl {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, t) {
    t = rs(t);
    let n = e.writeValue(t.length);
    return n += e.writeBytes(t), n;
  }
  decode(e) {
    return e.readBytes(e.readIndex(), !0);
  }
}
class Jhe extends i$ {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return wt(super.decode(e));
  }
}
class Qhe extends zl {
  constructor(t, n) {
    let i = "bytes" + String(t);
    super(i, i, n, !1);
    _e(this, "size");
    Et(this, { size: t }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(t, n) {
    let i = rs(Li.dereference(n, this.type));
    return i.length !== this.size && this._throwError("incorrect data length", n), t.writeBytes(i);
  }
  decode(t) {
    return wt(t.readBytes(this.size));
  }
}
const Yhe = new Uint8Array([]);
class Xhe extends zl {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError("not null", t), e.writeBytes(Yhe);
  }
  decode(e) {
    return e.readBytes(0), null;
  }
}
const efe = BigInt(0), tfe = BigInt(1), rfe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class nfe extends zl {
  constructor(t, n, i) {
    const s = (n ? "int" : "uint") + t * 8;
    super(s, s, i, !1);
    _e(this, "size");
    _e(this, "signed");
    Et(this, { size: t, signed: n }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(t, n) {
    let i = gt(Li.dereference(n, this.type)), s = cf(rfe, is * 8);
    if (this.signed) {
      let o = cf(s, this.size * 8 - 1);
      (i > o || i < -(o + tfe)) && this._throwError("value out-of-bounds", n), i = Ck(i, 8 * is);
    } else
      (i < efe || i > cf(s, this.size * 8)) && this._throwError("value out-of-bounds", n);
    return t.writeValue(i);
  }
  decode(t) {
    let n = cf(t.readValue(), this.size * 8);
    return this.signed && (n = D2(n, this.size * 8)), n;
  }
}
class ife extends i$ {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, Tl(Li.dereference(t, "string")));
  }
  decode(e) {
    return bC(super.decode(e));
  }
}
class ab extends zl {
  constructor(t, n) {
    let i = !1;
    const s = [];
    t.forEach((a) => {
      a.dynamic && (i = !0), s.push(a.type);
    });
    const o = "tuple(" + s.join(",") + ")";
    super("tuple", o, n, i);
    _e(this, "coders");
    Et(this, { coders: Object.freeze(t.slice()) });
  }
  defaultValue() {
    const t = [];
    this.coders.forEach((i) => {
      t.push(i.defaultValue());
    });
    const n = this.coders.reduce((i, s) => {
      const o = s.localName;
      return o && (i[o] || (i[o] = 0), i[o]++), i;
    }, {});
    return this.coders.forEach((i, s) => {
      let o = i.localName;
      !o || n[o] !== 1 || (o === "length" && (o = "_length"), t[o] == null && (t[o] = t[s]));
    }), Object.freeze(t);
  }
  encode(t, n) {
    const i = Li.dereference(n, "tuple");
    return r$(t, this.coders, i);
  }
  decode(t) {
    return n$(t, this.coders);
  }
}
function dd(r) {
  return gn(Tl(r));
}
var sfe = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const f7 = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), d7 = 4;
function ofe(r) {
  let e = 0;
  function t() {
    return r[e++] << 8 | r[e++];
  }
  let n = t(), i = 1, s = [0, 1];
  for (let L = 1; L < n; L++)
    s.push(i += t());
  let o = t(), a = e;
  e += o;
  let c = 0, u = 0;
  function f() {
    return c == 0 && (u = u << 8 | r[e++], c = 8), u >> --c & 1;
  }
  const d = 31, m = 2 ** d, y = m >>> 1, b = y >> 1, I = m - 1;
  let k = 0;
  for (let L = 0; L < d; L++)
    k = k << 1 | f();
  let R = [], T = 0, $ = m;
  for (; ; ) {
    let L = Math.floor(((k - T + 1) * i - 1) / $), P = 0, v = n;
    for (; v - P > 1; ) {
      let te = P + v >>> 1;
      L < s[te] ? v = te : P = te;
    }
    if (P == 0)
      break;
    R.push(P);
    let F = T + Math.floor($ * s[P] / i), X = T + Math.floor($ * s[P + 1] / i) - 1;
    for (; !((F ^ X) & y); )
      k = k << 1 & I | f(), F = F << 1 & I, X = X << 1 & I | 1;
    for (; F & ~X & b; )
      k = k & y | k << 1 & I >>> 1 | f(), F = F << 1 ^ y, X = (X ^ y) << 1 | y | 1;
    T = F, $ = 1 + X - F;
  }
  let D = n - 4;
  return R.map((L) => {
    switch (L - D) {
      case 3:
        return D + 65792 + (r[a++] << 16 | r[a++] << 8 | r[a++]);
      case 2:
        return D + 256 + (r[a++] << 8 | r[a++]);
      case 1:
        return D + r[a++];
      default:
        return L - 1;
    }
  });
}
function afe(r) {
  let e = 0;
  return () => r[e++];
}
function s$(r) {
  return afe(ofe(cfe(r)));
}
function cfe(r) {
  let e = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, s) => e[i.charCodeAt(0)] = s);
  let t = r.length, n = new Uint8Array(6 * t >> 3);
  for (let i = 0, s = 0, o = 0, a = 0; i < t; i++)
    a = a << 6 | e[r.charCodeAt(i)], o += 6, o >= 8 && (n[s++] = a >> (o -= 8));
  return n;
}
function lfe(r) {
  return r & 1 ? ~r >> 1 : r >> 1;
}
function ufe(r, e) {
  let t = Array(r);
  for (let n = 0, i = 0; n < r; n++)
    t[n] = i += lfe(e());
  return t;
}
function cw(r, e = 0) {
  let t = [];
  for (; ; ) {
    let n = r(), i = r();
    if (!i)
      break;
    e += n;
    for (let s = 0; s < i; s++)
      t.push(e + s);
    e += i + 1;
  }
  return t;
}
function o$(r) {
  return lw(() => {
    let e = cw(r);
    if (e.length)
      return e;
  });
}
function a$(r) {
  let e = [];
  for (; ; ) {
    let t = r();
    if (t == 0)
      break;
    e.push(hfe(t, r));
  }
  for (; ; ) {
    let t = r() - 1;
    if (t < 0)
      break;
    e.push(ffe(t, r));
  }
  return e.flat();
}
function lw(r) {
  let e = [];
  for (; ; ) {
    let t = r(e.length);
    if (!t)
      break;
    e.push(t);
  }
  return e;
}
function c$(r, e, t) {
  let n = Array(r).fill().map(() => []);
  for (let i = 0; i < e; i++)
    ufe(r, t).forEach((s, o) => n[o].push(s));
  return n;
}
function hfe(r, e) {
  let t = 1 + e(), n = e(), i = lw(e);
  return c$(i.length, 1 + r, e).flatMap((o, a) => {
    let [c, ...u] = o;
    return Array(i[a]).fill().map((f, d) => {
      let m = d * n;
      return [c + d * t, u.map((y) => y + m)];
    });
  });
}
function ffe(r, e) {
  let t = 1 + e();
  return c$(t, 1 + r, e).map((i) => [i[0], i.slice(1)]);
}
function dfe(r) {
  let e = [], t = cw(r);
  return i(n([]), []), e;
  function n(s) {
    let o = r(), a = lw(() => {
      let c = cw(r).map((u) => t[u]);
      if (c.length)
        return n(c);
    });
    return { S: o, B: a, Q: s };
  }
  function i({ S: s, B: o }, a, c) {
    if (!(s & 4 && c === a[a.length - 1])) {
      s & 2 && (c = a[a.length - 1]), s & 1 && e.push(a);
      for (let u of o)
        for (let f of u.Q)
          i(u, [...a, f], c);
    }
  }
}
function pfe(r) {
  return r.toString(16).toUpperCase().padStart(2, "0");
}
function l$(r) {
  return `{${pfe(r)}}`;
}
function gfe(r) {
  let e = [];
  for (let t = 0, n = r.length; t < n; ) {
    let i = r.codePointAt(t);
    t += i < 65536 ? 1 : 2, e.push(i);
  }
  return e;
}
function wg(r) {
  let t = r.length;
  if (t < 4096)
    return String.fromCodePoint(...r);
  let n = [];
  for (let i = 0; i < t; )
    n.push(String.fromCodePoint(...r.slice(i, i += 4096)));
  return n.join("");
}
function mfe(r, e) {
  let t = r.length, n = t - e.length;
  for (let i = 0; n == 0 && i < t; i++)
    n = r[i] - e[i];
  return n;
}
var wfe = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const uw = 44032, L2 = 4352, B2 = 4449, F2 = 4519, u$ = 19, h$ = 21, yg = 28, U2 = h$ * yg, yfe = u$ * U2, vfe = uw + yfe, bfe = L2 + u$, _fe = B2 + h$, Efe = F2 + yg;
function Y1(r) {
  return r >> 24 & 255;
}
function f$(r) {
  return r & 16777215;
}
let xx, p7, Sx, kb;
function xfe() {
  let r = s$(wfe);
  xx = new Map(o$(r).flatMap((e, t) => e.map((n) => [n, t + 1 << 24]))), p7 = new Set(cw(r)), Sx = /* @__PURE__ */ new Map(), kb = /* @__PURE__ */ new Map();
  for (let [e, t] of a$(r)) {
    if (!p7.has(e) && t.length == 2) {
      let [n, i] = t, s = kb.get(n);
      s || (s = /* @__PURE__ */ new Map(), kb.set(n, s)), s.set(i, e);
    }
    Sx.set(e, t.reverse());
  }
}
function d$(r) {
  return r >= uw && r < vfe;
}
function Sfe(r, e) {
  if (r >= L2 && r < bfe && e >= B2 && e < _fe)
    return uw + (r - L2) * U2 + (e - B2) * yg;
  if (d$(r) && e > F2 && e < Efe && (r - uw) % yg == 0)
    return r + (e - F2);
  {
    let t = kb.get(r);
    return t && (t = t.get(e), t) ? t : -1;
  }
}
function p$(r) {
  xx || xfe();
  let e = [], t = [], n = !1;
  function i(s) {
    let o = xx.get(s);
    o && (n = !0, s |= o), e.push(s);
  }
  for (let s of r)
    for (; ; ) {
      if (s < 128)
        e.push(s);
      else if (d$(s)) {
        let o = s - uw, a = o / U2 | 0, c = o % U2 / yg | 0, u = o % yg;
        i(L2 + a), i(B2 + c), u > 0 && i(F2 + u);
      } else {
        let o = Sx.get(s);
        o ? t.push(...o) : i(s);
      }
      if (!t.length)
        break;
      s = t.pop();
    }
  if (n && e.length > 1) {
    let s = Y1(e[0]);
    for (let o = 1; o < e.length; o++) {
      let a = Y1(e[o]);
      if (a == 0 || s <= a) {
        s = a;
        continue;
      }
      let c = o - 1;
      for (; ; ) {
        let u = e[c + 1];
        if (e[c + 1] = e[c], e[c] = u, !c || (s = Y1(e[--c]), s <= a))
          break;
      }
      s = Y1(e[o]);
    }
  }
  return e;
}
function Cfe(r) {
  let e = [], t = [], n = -1, i = 0;
  for (let s of r) {
    let o = Y1(s), a = f$(s);
    if (n == -1)
      o == 0 ? n = a : e.push(a);
    else if (i > 0 && i >= o)
      o == 0 ? (e.push(n, ...t), t.length = 0, n = a) : t.push(a), i = o;
    else {
      let c = Sfe(n, a);
      c >= 0 ? n = c : i == 0 && o == 0 ? (e.push(n), n = a) : (t.push(a), i = o);
    }
  }
  return n >= 0 && e.push(n, ...t), e;
}
function g$(r) {
  return p$(r).map(f$);
}
function Afe(r) {
  return Cfe(p$(r));
}
const g7 = 45, m$ = ".", w$ = 65039, y$ = 1, kp = (r) => Array.from(r);
function hw(r, e) {
  return r.P.has(e) || r.Q.has(e);
}
class Ife extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let Cx, v$, uf, Ax, b$, Qp, x4, Cp, _$, m7, Ix;
function TC() {
  if (Cx)
    return;
  let r = s$(sfe);
  const e = () => cw(r), t = () => new Set(e());
  Cx = new Map(a$(r)), v$ = t(), uf = e(), Ax = new Set(e().map((f) => uf[f])), uf = new Set(uf), b$ = t(), t();
  let n = o$(r), i = r();
  const s = () => new Set(e().flatMap((f) => n[f]).concat(e()));
  Qp = lw((f) => {
    let d = lw(r).map((m) => m + 96);
    if (d.length) {
      let m = f >= i;
      d[0] -= 32, d = wg(d), m && (d = `Restricted[${d}]`);
      let y = s(), b = s(), I = !r();
      return { N: d, P: y, Q: b, M: I, R: m };
    }
  }), x4 = t(), Cp = /* @__PURE__ */ new Map();
  let o = e().concat(kp(x4)).sort((f, d) => f - d);
  o.forEach((f, d) => {
    let m = r(), y = o[d] = m ? o[d - m] : { V: [], M: /* @__PURE__ */ new Map() };
    y.V.push(f), x4.has(f) || Cp.set(f, y);
  });
  for (let { V: f, M: d } of new Set(Cp.values())) {
    let m = [];
    for (let b of f) {
      let I = Qp.filter((R) => hw(R, b)), k = m.find(({ G: R }) => I.some((T) => R.has(T)));
      k || (k = { G: /* @__PURE__ */ new Set(), V: [] }, m.push(k)), k.V.push(b), I.forEach((R) => k.G.add(R));
    }
    let y = m.flatMap((b) => kp(b.G));
    for (let { G: b, V: I } of m) {
      let k = new Set(y.filter((R) => !b.has(R)));
      for (let R of I)
        d.set(R, k);
    }
  }
  let a = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  const u = (f) => a.has(f) ? c.add(f) : a.add(f);
  for (let f of Qp) {
    for (let d of f.P)
      u(d);
    for (let d of f.Q)
      u(d);
  }
  for (let f of a)
    !Cp.has(f) && !c.has(f) && Cp.set(f, y$);
  _$ = new Set(kp(a).concat(kp(g$(a)))), m7 = dfe(r).map((f) => Ife.from(f)).sort(mfe), Ix = /* @__PURE__ */ new Map();
  for (let f of m7) {
    let d = [Ix];
    for (let m of f) {
      let y = d.map((b) => {
        let I = b.get(m);
        return I || (I = /* @__PURE__ */ new Map(), b.set(m, I)), I;
      });
      m === w$ ? d.push(...y) : d = y;
    }
    for (let m of d)
      m.V = f;
  }
}
function OC(r) {
  return (E$(r) ? "" : `${NC(n3([r]))} `) + l$(r);
}
function NC(r) {
  return `"${r}"`;
}
function Rfe(r) {
  if (r.length >= 4 && r[2] == g7 && r[3] == g7)
    throw new Error(`invalid label extension: "${wg(r.slice(0, 4))}"`);
}
function Tfe(r) {
  for (let t = r.lastIndexOf(95); t > 0; )
    if (r[--t] !== 95)
      throw new Error("underscore allowed only at start");
}
function Ofe(r) {
  let e = r[0], t = f7.get(e);
  if (t)
    throw fm(`leading ${t}`);
  let n = r.length, i = -1;
  for (let s = 1; s < n; s++) {
    e = r[s];
    let o = f7.get(e);
    if (o) {
      if (i == s)
        throw fm(`${t} + ${o}`);
      i = s + 1, t = o;
    }
  }
  if (i == n)
    throw fm(`trailing ${t}`);
}
function n3(r, e = l$) {
  let t = [];
  Nfe(r[0]) && t.push("");
  let n = 0, i = r.length;
  for (let s = 0; s < i; s++) {
    let o = r[s];
    E$(o) && (t.push(wg(r.slice(n, s))), t.push(e(o)), n = s + 1);
  }
  return t.push(wg(r.slice(n, i))), t.join("");
}
function Nfe(r) {
  return TC(), uf.has(r);
}
function E$(r) {
  return TC(), b$.has(r);
}
function Pfe(r) {
  return $fe(Mfe(r, Afe, Ffe));
}
function Mfe(r, e, t) {
  if (!r)
    return [];
  TC();
  let n = 0;
  return r.split(m$).map((i) => {
    let s = gfe(i), o = {
      input: s,
      offset: n
      // codepoint, not substring!
    };
    n += s.length + 1;
    try {
      let a = o.tokens = Bfe(s, e, t), c = a.length, u;
      if (!c)
        throw new Error("empty label");
      let f = o.output = a.flat();
      if (Tfe(f), !(o.emoji = c > 1 || a[0].is_emoji) && f.every((m) => m < 128))
        Rfe(f), u = "ASCII";
      else {
        let m = a.flatMap((y) => y.is_emoji ? [] : y);
        if (!m.length)
          u = "Emoji";
        else {
          if (uf.has(f[0]))
            throw fm("leading combining mark");
          for (let I = 1; I < c; I++) {
            let k = a[I];
            if (!k.is_emoji && uf.has(k[0]))
              throw fm(`emoji + combining mark: "${wg(a[I - 1])} + ${n3([k[0]])}"`);
          }
          Ofe(f);
          let y = kp(new Set(m)), [b] = kfe(y);
          Lfe(b, m), Dfe(b, y), u = b.N;
        }
      }
      o.type = u;
    } catch (a) {
      o.error = a;
    }
    return o;
  });
}
function Dfe(r, e) {
  let t, n = [];
  for (let i of e) {
    let s = Cp.get(i);
    if (s === y$)
      return;
    if (s) {
      let o = s.M.get(i);
      if (t = t ? t.filter((a) => o.has(a)) : kp(o), !t.length)
        return;
    } else
      n.push(i);
  }
  if (t) {
    for (let i of t)
      if (n.every((s) => hw(i, s)))
        throw new Error(`whole-script confusable: ${r.N}/${i.N}`);
  }
}
function kfe(r) {
  let e = Qp;
  for (let t of r) {
    let n = e.filter((i) => hw(i, t));
    if (!n.length)
      throw Qp.some((i) => hw(i, t)) ? S$(e[0], t) : x$(t);
    if (e = n, n.length == 1)
      break;
  }
  return e;
}
function $fe(r) {
  return r.map(({ input: e, error: t, output: n }) => {
    if (t) {
      let i = t.message;
      throw new Error(r.length == 1 ? i : `Invalid label ${NC(n3(e))}: ${i}`);
    }
    return wg(n);
  }).join(m$);
}
function x$(r) {
  return new Error(`disallowed character: ${OC(r)}`);
}
function S$(r, e) {
  let t = OC(e), n = Qp.find((i) => i.P.has(e));
  return n && (t = `${n.N} ${t}`), new Error(`illegal mixture: ${r.N} + ${t}`);
}
function fm(r) {
  return new Error(`illegal placement: ${r}`);
}
function Lfe(r, e) {
  for (let t of e)
    if (!hw(r, t))
      throw S$(r, t);
  if (r.M) {
    let t = g$(e);
    for (let n = 1, i = t.length; n < i; n++)
      if (Ax.has(t[n])) {
        let s = n + 1;
        for (let o; s < i && Ax.has(o = t[s]); s++)
          for (let a = n; a < s; a++)
            if (t[a] == o)
              throw new Error(`duplicate non-spacing marks: ${OC(o)}`);
        if (s - n > d7)
          throw new Error(`excessive non-spacing marks: ${NC(n3(t.slice(n - 1, s)))} (${s - n}/${d7})`);
        n = s;
      }
  }
}
function Bfe(r, e, t) {
  let n = [], i = [];
  for (r = r.slice().reverse(); r.length; ) {
    let s = Ufe(r);
    if (s)
      i.length && (n.push(e(i)), i = []), n.push(t(s));
    else {
      let o = r.pop();
      if (_$.has(o))
        i.push(o);
      else {
        let a = Cx.get(o);
        if (a)
          i.push(...a);
        else if (!v$.has(o))
          throw x$(o);
      }
    }
  }
  return i.length && n.push(e(i)), n;
}
function Ffe(r) {
  return r.filter((e) => e != w$);
}
function Ufe(r, e) {
  let t = Ix, n, i = r.length;
  for (; i && (t = t.get(r[--i]), !!t); ) {
    let { V: s } = t;
    s && (n = s, e && e.push(...r.slice(i).reverse()), r.length = i);
  }
  return n;
}
const C$ = new Uint8Array(32);
C$.fill(0);
function w7(r) {
  return me(r.length !== 0, "invalid ENS name; empty component", "comp", r), r;
}
function A$(r) {
  const e = Tl(jfe(r)), t = [];
  if (r.length === 0)
    return t;
  let n = 0;
  for (let i = 0; i < e.length; i++)
    e[i] === 46 && (t.push(w7(e.slice(n, i))), n = i + 1);
  return me(n < e.length, "invalid ENS name; empty component", "name", r), t.push(w7(e.slice(n))), t;
}
function jfe(r) {
  try {
    if (r.length === 0)
      throw new Error("empty label");
    return Pfe(r);
  } catch (e) {
    me(!1, `invalid ENS name (${e.message})`, "name", r);
  }
}
function Rx(r) {
  me(typeof r == "string", "invalid ENS name; not a string", "name", r), me(r.length, "invalid ENS name (empty label)", "name", r);
  let e = C$;
  const t = A$(r);
  for (; t.length; )
    e = gn(Zn([e, gn(t.pop())]));
  return wt(e);
}
function Wfe(r) {
  return wt(Zn(A$(r).map((e) => {
    if (e.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const t = new Uint8Array(e.length + 1);
    return t.set(e, 1), t[0] = t.length - 1, t;
  }))) + "00";
}
function S4(r, e) {
  return {
    address: fr(r),
    storageKeys: e.map((t, n) => (me(mn(t, 32), "invalid slot", `storageKeys[${n}]`, t), t.toLowerCase()))
  };
}
function Dd(r) {
  if (Array.isArray(r))
    return r.map((t, n) => Array.isArray(t) ? (me(t.length === 2, "invalid slot set", `value[${n}]`, t), S4(t[0], t[1])) : (me(t != null && typeof t == "object", "invalid address-slot set", "value", r), S4(t.address, t.storageKeys)));
  me(r != null && typeof r == "object", "invalid access list", "value", r);
  const e = Object.keys(r).map((t) => {
    const n = r[t].reduce((i, s) => (i[s] = !0, i), {});
    return S4(t, Object.keys(n).sort());
  });
  return e.sort((t, n) => t.address.localeCompare(n.address)), e;
}
function Hfe(r) {
  let e;
  return typeof r == "string" ? e = aw.computePublicKey(r, !1) : e = r.publicKey, fr(gn("0x" + e.substring(4)).substring(26));
}
function zfe(r, e) {
  return Hfe(aw.recoverPublicKey(r, e));
}
const Ns = BigInt(0), Vfe = BigInt(2), qfe = BigInt(27), Gfe = BigInt(28), Kfe = BigInt(35), Zfe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function PC(r) {
  return r === "0x" ? null : fr(r);
}
function I$(r, e) {
  try {
    return Dd(r);
  } catch (t) {
    me(!1, t.message, e, r);
  }
}
function i3(r, e) {
  return r === "0x" ? 0 : nr(r, e);
}
function es(r, e) {
  if (r === "0x")
    return Ns;
  const t = gt(r, e);
  return me(t <= Zfe, "value exceeds uint size", e, t), t;
}
function gi(r, e) {
  const t = gt(r, "value"), n = to(t);
  return me(n.length <= 32, "value too large", `tx.${e}`, t), n;
}
function R$(r) {
  return Dd(r).map((e) => [e.address, e.storageKeys]);
}
function Jfe(r) {
  const e = _C(r);
  me(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", r);
  const t = {
    type: 0,
    nonce: i3(e[0], "nonce"),
    gasPrice: es(e[1], "gasPrice"),
    gasLimit: es(e[2], "gasLimit"),
    to: PC(e[3]),
    value: es(e[4], "value"),
    data: wt(e[5]),
    chainId: Ns
  };
  if (e.length === 6)
    return t;
  const n = es(e[6], "v"), i = es(e[7], "r"), s = es(e[8], "s");
  if (i === Ns && s === Ns)
    t.chainId = n;
  else {
    let o = (n - Kfe) / Vfe;
    o < Ns && (o = Ns), t.chainId = o, me(o !== Ns || n === qfe || n === Gfe, "non-canonical legacy v", "v", e[6]), t.signature = ka.from({
      r: fd(e[7], 32),
      s: fd(e[8], 32),
      v: n
    }), t.hash = gn(r);
  }
  return t;
}
function y7(r, e) {
  const t = [
    gi(r.nonce || 0, "nonce"),
    gi(r.gasPrice || 0, "gasPrice"),
    gi(r.gasLimit || 0, "gasLimit"),
    r.to != null ? fr(r.to) : "0x",
    gi(r.value || 0, "value"),
    r.data || "0x"
  ];
  let n = Ns;
  if (r.chainId != Ns)
    n = gt(r.chainId, "tx.chainId"), me(!e || e.networkV == null || e.legacyChainId === n, "tx.chainId/sig.v mismatch", "sig", e);
  else if (r.signature) {
    const s = r.signature.legacyChainId;
    s != null && (n = s);
  }
  if (!e)
    return n !== Ns && (t.push(to(n)), t.push("0x"), t.push("0x")), sw(t);
  let i = BigInt(27 + e.yParity);
  return n !== Ns ? i = ka.getChainIdV(n, e.v) : BigInt(e.v) !== i && me(!1, "tx.chainId/sig.v mismatch", "sig", e), t.push(to(i)), t.push(to(e.r)), t.push(to(e.s)), sw(t);
}
function T$(r, e) {
  let t;
  try {
    if (t = i3(e[0], "yParity"), t !== 0 && t !== 1)
      throw new Error("bad yParity");
  } catch {
    me(!1, "invalid yParity", "yParity", e[0]);
  }
  const n = fd(e[1], 32), i = fd(e[2], 32), s = ka.from({ r: n, s: i, yParity: t });
  r.signature = s;
}
function Qfe(r) {
  const e = _C(Tr(r).slice(1));
  me(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", wt(r));
  const t = es(e[2], "maxPriorityFeePerGas"), n = es(e[3], "maxFeePerGas"), i = {
    type: 2,
    chainId: es(e[0], "chainId"),
    nonce: i3(e[1], "nonce"),
    maxPriorityFeePerGas: t,
    maxFeePerGas: n,
    gasPrice: null,
    gasLimit: es(e[4], "gasLimit"),
    to: PC(e[5]),
    value: es(e[6], "value"),
    data: wt(e[7]),
    accessList: I$(e[8], "accessList")
  };
  return e.length === 9 || (i.hash = gn(r), T$(i, e.slice(9))), i;
}
function v7(r, e) {
  const t = [
    gi(r.chainId || 0, "chainId"),
    gi(r.nonce || 0, "nonce"),
    gi(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    gi(r.maxFeePerGas || 0, "maxFeePerGas"),
    gi(r.gasLimit || 0, "gasLimit"),
    r.to != null ? fr(r.to) : "0x",
    gi(r.value || 0, "value"),
    r.data || "0x",
    R$(r.accessList || [])
  ];
  return e && (t.push(gi(e.yParity, "yParity")), t.push(to(e.r)), t.push(to(e.s))), Zn(["0x02", sw(t)]);
}
function Yfe(r) {
  const e = _C(Tr(r).slice(1));
  me(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", wt(r));
  const t = {
    type: 1,
    chainId: es(e[0], "chainId"),
    nonce: i3(e[1], "nonce"),
    gasPrice: es(e[2], "gasPrice"),
    gasLimit: es(e[3], "gasLimit"),
    to: PC(e[4]),
    value: es(e[5], "value"),
    data: wt(e[6]),
    accessList: I$(e[7], "accessList")
  };
  return e.length === 8 || (t.hash = gn(r), T$(t, e.slice(8))), t;
}
function b7(r, e) {
  const t = [
    gi(r.chainId || 0, "chainId"),
    gi(r.nonce || 0, "nonce"),
    gi(r.gasPrice || 0, "gasPrice"),
    gi(r.gasLimit || 0, "gasLimit"),
    r.to != null ? fr(r.to) : "0x",
    gi(r.value || 0, "value"),
    r.data || "0x",
    R$(r.accessList || [])
  ];
  return e && (t.push(gi(e.yParity, "recoveryParam")), t.push(to(e.r)), t.push(to(e.s))), Zn(["0x01", sw(t)]);
}
var gl, p0, g0, m0, w0, y0, v0, b0, _0, E0, x0, S0;
const pu = class pu {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    ye(this, gl, void 0);
    ye(this, p0, void 0);
    ye(this, g0, void 0);
    ye(this, m0, void 0);
    ye(this, w0, void 0);
    ye(this, y0, void 0);
    ye(this, v0, void 0);
    ye(this, b0, void 0);
    ye(this, _0, void 0);
    ye(this, E0, void 0);
    ye(this, x0, void 0);
    ye(this, S0, void 0);
    ie(this, gl, null), ie(this, p0, null), ie(this, m0, 0), ie(this, w0, BigInt(0)), ie(this, y0, null), ie(this, v0, null), ie(this, b0, null), ie(this, g0, "0x"), ie(this, _0, BigInt(0)), ie(this, E0, BigInt(0)), ie(this, x0, null), ie(this, S0, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return j(this, gl);
  }
  set type(e) {
    switch (e) {
      case null:
        ie(this, gl, null);
        break;
      case 0:
      case "legacy":
        ie(this, gl, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        ie(this, gl, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        ie(this, gl, 2);
        break;
      default:
        me(!1, "unsupported transaction type", "type", e);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    return j(this, p0);
  }
  set to(e) {
    ie(this, p0, e == null ? null : fr(e));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return j(this, m0);
  }
  set nonce(e) {
    ie(this, m0, nr(e, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return j(this, w0);
  }
  set gasLimit(e) {
    ie(this, w0, gt(e));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const e = j(this, y0);
    return e == null && (this.type === 0 || this.type === 1) ? Ns : e;
  }
  set gasPrice(e) {
    ie(this, y0, e == null ? null : gt(e, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const e = j(this, v0);
    return e ?? (this.type === 2 ? Ns : null);
  }
  set maxPriorityFeePerGas(e) {
    ie(this, v0, e == null ? null : gt(e, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const e = j(this, b0);
    return e ?? (this.type === 2 ? Ns : null);
  }
  set maxFeePerGas(e) {
    ie(this, b0, e == null ? null : gt(e, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return j(this, g0);
  }
  set data(e) {
    ie(this, g0, wt(e));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return j(this, _0);
  }
  set value(e) {
    ie(this, _0, gt(e, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return j(this, E0);
  }
  set chainId(e) {
    ie(this, E0, gt(e));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return j(this, x0) || null;
  }
  set signature(e) {
    ie(this, x0, e == null ? null : ka.from(e));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const e = j(this, S0) || null;
    return e ?? (this.type === 1 || this.type === 2 ? [] : null);
  }
  set accessList(e) {
    ie(this, S0, e == null ? null : Dd(e));
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : gn(this.serialized);
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return gn(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : zfe(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : aw.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    switch (Te(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" }), this.inferType()) {
      case 0:
        return y7(this, this.signature);
      case 1:
        return b7(this, this.signature);
      case 2:
        return v7(this, this.signature);
    }
    Te(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    switch (this.inferType()) {
      case 0:
        return y7(this);
      case 1:
        return b7(this);
      case 2:
        return v7(this);
    }
    Te(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".unsignedSerialized" });
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    return this.inferTypes().pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const e = this.gasPrice != null, t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, n = this.accessList != null;
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && Te(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), Te(!t || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), Te(this.type !== 0 || !n, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const i = [];
    return this.type != null ? i.push(this.type) : t ? i.push(2) : e ? (i.push(1), n || i.push(0)) : n ? (i.push(1), i.push(2)) : (i.push(0), i.push(1), i.push(2)), i.sort(), i;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return pu.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const e = (t) => t == null ? null : t.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(e) {
    if (e == null)
      return new pu();
    if (typeof e == "string") {
      const n = Tr(e);
      if (n[0] >= 127)
        return pu.from(Jfe(n));
      switch (n[0]) {
        case 1:
          return pu.from(Yfe(n));
        case 2:
          return pu.from(Qfe(n));
      }
      Te(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const t = new pu();
    return e.type != null && (t.type = e.type), e.to != null && (t.to = e.to), e.nonce != null && (t.nonce = e.nonce), e.gasLimit != null && (t.gasLimit = e.gasLimit), e.gasPrice != null && (t.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (t.maxFeePerGas = e.maxFeePerGas), e.data != null && (t.data = e.data), e.value != null && (t.value = e.value), e.chainId != null && (t.chainId = e.chainId), e.signature != null && (t.signature = ka.from(e.signature)), e.accessList != null && (t.accessList = e.accessList), e.hash != null && (me(t.isSigned(), "unsigned transaction cannot define hash", "tx", e), me(t.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (me(t.isSigned(), "unsigned transaction cannot define from", "tx", e), me(t.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), t;
  }
};
gl = new WeakMap(), p0 = new WeakMap(), g0 = new WeakMap(), m0 = new WeakMap(), w0 = new WeakMap(), y0 = new WeakMap(), v0 = new WeakMap(), b0 = new WeakMap(), _0 = new WeakMap(), E0 = new WeakMap(), x0 = new WeakMap(), S0 = new WeakMap();
let j2 = pu;
const O$ = new Uint8Array(32);
O$.fill(0);
const Xfe = BigInt(-1), N$ = BigInt(0), P$ = BigInt(1), ede = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function tde(r) {
  const e = Tr(r), t = e.length % 32;
  return t ? Zn([e, O$.slice(t)]) : wt(e);
}
const rde = rh(P$, 32), nde = rh(N$, 32), _7 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, C4 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function E7(r) {
  return function(e) {
    return me(typeof e == "string", `invalid domain value for ${JSON.stringify(r)}`, `domain.${r}`, e), e;
  };
}
const ide = {
  name: E7("name"),
  version: E7("version"),
  chainId: function(r) {
    const e = gt(r, "domain.chainId");
    return me(e >= 0, "invalid chain ID", "domain.chainId", r), Number.isSafeInteger(e) ? Number(e) : Mp(e);
  },
  verifyingContract: function(r) {
    try {
      return fr(r).toLowerCase();
    } catch {
    }
    me(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", r);
  },
  salt: function(r) {
    const e = Tr(r, "domain.salt");
    return me(e.length === 32, 'invalid domain value "salt"', "domain.salt", r), wt(e);
  }
};
function A4(r) {
  {
    const e = r.match(/^(u?)int(\d*)$/);
    if (e) {
      const t = e[1] === "", n = parseInt(e[2] || "256");
      me(n % 8 === 0 && n !== 0 && n <= 256 && (e[2] == null || e[2] === String(n)), "invalid numeric width", "type", r);
      const i = cf(ede, t ? n - 1 : n), s = t ? (i + P$) * Xfe : N$;
      return function(o) {
        const a = gt(o, "value");
        return me(a >= s && a <= i, `value out-of-bounds for ${r}`, "value", a), rh(t ? Ck(a, 256) : a, 32);
      };
    }
  }
  {
    const e = r.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return me(t !== 0 && t <= 32 && e[1] === String(t), "invalid bytes width", "type", r), function(n) {
        const i = Tr(n);
        return me(i.length === t, `invalid length for ${r}`, "value", n), tde(n);
      };
    }
  }
  switch (r) {
    case "address":
      return function(e) {
        return fd(fr(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? rde : nde;
      };
    case "bytes":
      return function(e) {
        return gn(e);
      };
    case "string":
      return function(e) {
        return dd(e);
      };
  }
  return null;
}
function x7(r, e) {
  return `${r}(${e.map(({ name: t, type: n }) => n + " " + t).join(",")})`;
}
var Pw, ml, C0, h_, M$;
const Co = class Co {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(e) {
    ye(this, h_);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    _e(this, "primaryType");
    ye(this, Pw, void 0);
    ye(this, ml, void 0);
    ye(this, C0, void 0);
    ie(this, Pw, JSON.stringify(e)), ie(this, ml, /* @__PURE__ */ new Map()), ie(this, C0, /* @__PURE__ */ new Map());
    const t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
    Object.keys(e).forEach((a) => {
      t.set(a, /* @__PURE__ */ new Set()), n.set(a, []), i.set(a, /* @__PURE__ */ new Set());
    });
    for (const a in e) {
      const c = /* @__PURE__ */ new Set();
      for (const u of e[a]) {
        me(!c.has(u.name), `duplicate variable name ${JSON.stringify(u.name)} in ${JSON.stringify(a)}`, "types", e), c.add(u.name);
        const f = u.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
        me(f !== a, `circular type reference to ${JSON.stringify(f)}`, "types", e), !A4(f) && (me(n.has(f), `unknown type ${JSON.stringify(f)}`, "types", e), n.get(f).push(a), t.get(a).add(f));
      }
    }
    const s = Array.from(n.keys()).filter((a) => n.get(a).length === 0);
    me(s.length !== 0, "missing primary type", "types", e), me(s.length === 1, `ambiguous primary types or unused types: ${s.map((a) => JSON.stringify(a)).join(", ")}`, "types", e), Et(this, { primaryType: s[0] });
    function o(a, c) {
      me(!c.has(a), `circular type reference to ${JSON.stringify(a)}`, "types", e), c.add(a);
      for (const u of t.get(a))
        if (n.has(u)) {
          o(u, c);
          for (const f of c)
            i.get(f).add(u);
        }
      c.delete(a);
    }
    o(this.primaryType, /* @__PURE__ */ new Set());
    for (const [a, c] of i) {
      const u = Array.from(c);
      u.sort(), j(this, ml).set(a, x7(a, e[a]) + u.map((f) => x7(f, e[f])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(j(this, Pw));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(e) {
    let t = j(this, C0).get(e);
    return t || (t = ke(this, h_, M$).call(this, e), j(this, C0).set(e, t)), t;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(e) {
    const t = j(this, ml).get(e);
    return me(t, `unknown type: ${JSON.stringify(e)}`, "name", e), t;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(e, t) {
    return gn(this.encodeData(e, t));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  /**
   *  @_ignore:
   */
  _visit(e, t, n) {
    if (A4(e))
      return n(e, t);
    const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i)
      return me(!i[3] || parseInt(i[3]) === t.length, `array length mismatch; expected length ${parseInt(i[3])}`, "value", t), t.map((o) => this._visit(i[1], o, n));
    const s = this.types[e];
    if (s)
      return s.reduce((o, { name: a, type: c }) => (o[a] = this._visit(c, t[a], n), o), {});
    me(!1, `unknown type: ${e}`, "type", e);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(e) {
    return new Co(e);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(e) {
    return Co.from(e).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(e, t, n) {
    return Co.from(t).hashStruct(e, n);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(e) {
    const t = [];
    for (const n in e) {
      if (e[n] == null)
        continue;
      const i = _7[n];
      me(i, `invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", e), t.push({ name: n, type: i });
    }
    return t.sort((n, i) => C4.indexOf(n.name) - C4.indexOf(i.name)), Co.hashStruct("EIP712Domain", { EIP712Domain: t }, e);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(e, t, n) {
    return Zn([
      "0x1901",
      Co.hashDomain(e),
      Co.from(t).hash(n)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(e, t, n) {
    return gn(Co.encode(e, t, n));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(e, t, n, i) {
    e = Object.assign({}, e);
    for (const a in e)
      e[a] == null && delete e[a];
    const s = {};
    e.verifyingContract && !mn(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
    const o = Co.from(t);
    o.visit(n, (a, c) => (a === "address" && !mn(c, 20) && (s[c] = "0x"), c));
    for (const a in s)
      s[a] = await i(a);
    return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), n = o.visit(n, (a, c) => a === "address" && s[c] ? s[c] : c), { domain: e, value: n };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(e, t, n) {
    Co.hashDomain(e);
    const i = {}, s = [];
    C4.forEach((c) => {
      const u = e[c];
      u != null && (i[c] = ide[c](u), s.push({ name: c, type: _7[c] }));
    });
    const o = Co.from(t), a = Object.assign({}, t);
    return me(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", t), a.EIP712Domain = s, o.encode(n), {
      types: a,
      domain: i,
      primaryType: o.primaryType,
      message: o.visit(n, (c, u) => {
        if (c.match(/^bytes(\d*)/))
          return wt(Tr(u));
        if (c.match(/^u?int/))
          return gt(u).toString();
        switch (c) {
          case "address":
            return u.toLowerCase();
          case "bool":
            return !!u;
          case "string":
            return me(typeof u == "string", "invalid string", "value", u), u;
        }
        me(!1, "unsupported type", "type", c);
      })
    };
  }
};
Pw = new WeakMap(), ml = new WeakMap(), C0 = new WeakMap(), h_ = new WeakSet(), M$ = function(e) {
  {
    const i = A4(e);
    if (i)
      return i;
  }
  const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
  if (t) {
    const i = t[1], s = this.getEncoder(i);
    return (o) => {
      me(!t[3] || parseInt(t[3]) === o.length, `array length mismatch; expected length ${parseInt(t[3])}`, "value", o);
      let a = o.map(s);
      return j(this, ml).has(i) && (a = a.map(gn)), gn(Zn(a));
    };
  }
  const n = this.types[e];
  if (n) {
    const i = dd(j(this, ml).get(e));
    return (s) => {
      const o = n.map(({ name: a, type: c }) => {
        const u = this.getEncoder(c)(s[a]);
        return j(this, ml).has(c) ? gn(u) : u;
      });
      return o.unshift(i), Zn(o);
    };
  }
  me(!1, `unknown type: ${e}`, "type", e);
};
let W2 = Co;
function os(r) {
  const e = /* @__PURE__ */ new Set();
  return r.forEach((t) => e.add(t)), Object.freeze(e);
}
const sde = "external public payable", ode = os(sde.split(" ")), D$ = "constant external internal payable private public pure view", ade = os(D$.split(" ")), k$ = "constructor error event fallback function receive struct", $$ = os(k$.split(" ")), L$ = "calldata memory storage payable indexed", cde = os(L$.split(" ")), lde = "tuple returns", ude = [k$, L$, lde, D$].join(" "), hde = os(ude.split(" ")), fde = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, dde = new RegExp("^(\\s*)"), pde = new RegExp("^([0-9]+)"), gde = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), B$ = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), F$ = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var pi, wa, Mw, Tx;
const f_ = class f_ {
  constructor(e) {
    ye(this, Mw);
    ye(this, pi, void 0);
    ye(this, wa, void 0);
    ie(this, pi, 0), ie(this, wa, e.slice());
  }
  get offset() {
    return j(this, pi);
  }
  get length() {
    return j(this, wa).length - j(this, pi);
  }
  clone() {
    return new f_(j(this, wa));
  }
  reset() {
    ie(this, pi, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(e) {
    const t = this.peek();
    if (t.type !== "KEYWORD" || !e.has(t.text))
      throw new Error(`expected keyword ${t.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(e) {
    if (this.peek().type !== e)
      throw new Error(`expected ${e}; got ${JSON.stringify(this.peek())}`);
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const t = ke(this, Mw, Tx).call(this, j(this, pi) + 1, e.match + 1);
    return ie(this, pi, e.match + 1), t;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const t = [];
    for (; j(this, pi) < e.match - 1; ) {
      const n = this.peek().linkNext;
      t.push(ke(this, Mw, Tx).call(this, j(this, pi) + 1, n)), ie(this, pi, n);
    }
    return ie(this, pi, e.match + 1), t;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (j(this, pi) >= j(this, wa).length)
      throw new Error("out-of-bounds");
    return j(this, wa)[j(this, pi)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(e) {
    const t = this.peekType("KEYWORD");
    return t != null && e.has(t) ? t : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(e) {
    if (this.length === 0)
      return null;
    const t = this.peek();
    return t.type === e ? t.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const e = this.peek();
    return S1(this, pi)._++, e;
  }
  toString() {
    const e = [];
    for (let t = j(this, pi); t < j(this, wa).length; t++) {
      const n = j(this, wa)[t];
      e.push(`${n.type}:${n.text}`);
    }
    return `<TokenString ${e.join(" ")}>`;
  }
};
pi = new WeakMap(), wa = new WeakMap(), Mw = new WeakSet(), Tx = function(e = 0, t = 0) {
  return new f_(j(this, wa).slice(e, t).map((n) => Object.freeze(Object.assign({}, n, {
    match: n.match - e,
    linkBack: n.linkBack - e,
    linkNext: n.linkNext - e
  }))));
};
let $a = f_;
function mh(r) {
  const e = [], t = (o) => {
    const a = s < r.length ? JSON.stringify(r[s]) : "$EOI";
    throw new Error(`invalid token ${a} at ${s}: ${o}`);
  };
  let n = [], i = [], s = 0;
  for (; s < r.length; ) {
    let o = r.substring(s), a = o.match(dde);
    a && (s += a[1].length, o = r.substring(s));
    const c = { depth: n.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: s, value: -1 };
    e.push(c);
    let u = fde[o[0]] || "";
    if (u) {
      if (c.type = u, c.text = o[0], s++, u === "OPEN_PAREN")
        n.push(e.length - 1), i.push(e.length - 1);
      else if (u == "CLOSE_PAREN")
        n.length === 0 && t("no matching open bracket"), c.match = n.pop(), e[c.match].match = e.length - 1, c.depth--, c.linkBack = i.pop(), e[c.linkBack].linkNext = e.length - 1;
      else if (u === "COMMA")
        c.linkBack = i.pop(), e[c.linkBack].linkNext = e.length - 1, i.push(e.length - 1);
      else if (u === "OPEN_BRACKET")
        c.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let f = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          const d = e.pop().text;
          f = d + f, e[e.length - 1].value = nr(d);
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += f;
      }
      continue;
    }
    if (a = o.match(gde), a) {
      if (c.text = a[1], s += c.text.length, hde.has(c.text)) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(F$)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (a = o.match(pde), a) {
      c.text = a[1], c.type = "NUMBER", s += c.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${s}`);
  }
  return new $a(e.map((o) => Object.freeze(o)));
}
function S7(r, e) {
  let t = [];
  for (const n in e.keys())
    r.has(n) && t.push(n);
  if (t.length > 1)
    throw new Error(`conflicting types: ${t.join(", ")}`);
}
function s3(r, e) {
  if (e.peekKeyword($$)) {
    const t = e.pop().text;
    if (t !== r)
      throw new Error(`expected ${r}, got ${t}`);
  }
  return e.popType("ID");
}
function kl(r, e) {
  const t = /* @__PURE__ */ new Set();
  for (; ; ) {
    const n = r.peekType("KEYWORD");
    if (n == null || e && !e.has(n))
      break;
    if (r.pop(), t.has(n))
      throw new Error(`duplicate keywords: ${JSON.stringify(n)}`);
    t.add(n);
  }
  return Object.freeze(t);
}
function U$(r) {
  let e = kl(r, ade);
  return S7(e, os("constant payable nonpayable".split(" "))), S7(e, os("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
}
function Ol(r, e) {
  return r.popParams().map((t) => yi.from(t, e));
}
function j$(r) {
  if (r.peekType("AT")) {
    if (r.pop(), r.peekType("NUMBER"))
      return gt(r.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function pd(r) {
  if (r.length)
    throw new Error(`unexpected tokens: ${r.toString()}`);
}
const mde = new RegExp(/^(.*)\[([0-9]*)\]$/);
function C7(r) {
  const e = r.match(F$);
  if (me(e, "invalid type", "type", r), r === "uint")
    return "uint256";
  if (r === "int")
    return "int256";
  if (e[2]) {
    const t = parseInt(e[2]);
    me(t !== 0 && t <= 32, "invalid bytes length", "type", r);
  } else if (e[3]) {
    const t = parseInt(e[3]);
    me(t !== 0 && t <= 256 && t % 8 === 0, "invalid numeric width", "type", r);
  }
  return r;
}
const pn = {}, ks = Symbol.for("_ethers_internal"), A7 = "_ParamTypeInternal", I7 = "_ErrorInternal", R7 = "_EventInternal", T7 = "_ConstructorInternal", O7 = "_FallbackInternal", N7 = "_FunctionInternal", P7 = "_StructInternal";
var A0, $b;
const Ao = class Ao {
  /**
   *  @private
   */
  constructor(e, t, n, i, s, o, a, c) {
    ye(this, A0);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    _e(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    _e(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    _e(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    _e(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    _e(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    _e(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    _e(this, "arrayChildren");
    if (fy(e, pn, "ParamType"), Object.defineProperty(this, ks, { value: A7 }), o && (o = Object.freeze(o.slice())), i === "array") {
      if (a == null || c == null)
        throw new Error("");
    } else if (a != null || c != null)
      throw new Error("");
    if (i === "tuple") {
      if (o == null)
        throw new Error("");
    } else if (o != null)
      throw new Error("");
    Et(this, {
      name: t,
      type: n,
      baseType: i,
      indexed: s,
      components: o,
      arrayLength: a,
      arrayChildren: c
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json") {
      const n = this.name || "";
      if (this.isArray()) {
        const s = JSON.parse(this.arrayChildren.format("json"));
        return s.name = n, s.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(s);
      }
      const i = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: n
      };
      return typeof this.indexed == "boolean" && (i.indexed = this.indexed), this.isTuple() && (i.components = this.components.map((s) => JSON.parse(s.format(e)))), JSON.stringify(i);
    }
    let t = "";
    return this.isArray() ? (t += this.arrayChildren.format(e), t += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? t += "(" + this.components.map((n) => n.format(e)).join(e === "full" ? ", " : ",") + ")" : t += this.type, e !== "sighash" && (this.indexed === !0 && (t += " indexed"), e === "full" && this.name && (t += " " + this.name)), t;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(e, t) {
    if (this.isArray()) {
      if (!Array.isArray(e))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && e.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const n = this;
      return e.map((i) => n.arrayChildren.walk(i, t));
    }
    if (this.isTuple()) {
      if (!Array.isArray(e))
        throw new Error("invalid tuple value");
      if (e.length !== this.components.length)
        throw new Error("array is wrong length");
      const n = this;
      return e.map((i, s) => n.components[s].walk(i, t));
    }
    return t(this.type, e);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS naes by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(e, t) {
    const n = [], i = [e];
    return ke(this, A0, $b).call(this, n, e, t, (s) => {
      i[0] = s;
    }), n.length && await Promise.all(n), i[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(e, t) {
    if (Ao.isParamType(e))
      return e;
    if (typeof e == "string")
      try {
        return Ao.from(mh(e), t);
      } catch {
        me(!1, "invalid param type", "obj", e);
      }
    else if (e instanceof $a) {
      let a = "", c = "", u = null;
      kl(e, os(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (c = "tuple", u = e.popParams().map((I) => Ao.from(I)), a = `tuple(${u.map((I) => I.format()).join(",")})`) : (a = C7(e.popType("TYPE")), c = a);
      let f = null, d = null;
      for (; e.length && e.peekType("BRACKET"); ) {
        const I = e.pop();
        f = new Ao(pn, "", a, c, null, u, d, f), d = I.value, a += I.text, c = "array", u = null;
      }
      let m = null;
      if (kl(e, cde).has("indexed")) {
        if (!t)
          throw new Error("");
        m = !0;
      }
      const b = e.peekType("ID") ? e.pop().text : "";
      if (e.length)
        throw new Error("leftover tokens");
      return new Ao(pn, b, a, c, m, u, d, f);
    }
    const n = e.name;
    me(!n || typeof n == "string" && n.match(B$), "invalid name", "obj.name", n);
    let i = e.indexed;
    i != null && (me(t, "parameter cannot be indexed", "obj.indexed", e.indexed), i = !!i);
    let s = e.type, o = s.match(mde);
    if (o) {
      const a = parseInt(o[2] || "-1"), c = Ao.from({
        type: o[1],
        components: e.components
      });
      return new Ao(pn, n || "", s, "array", i, null, a, c);
    }
    if (s === "tuple" || s.startsWith(
      "tuple("
      /* fix: ) */
    ) || s.startsWith(
      "("
      /* fix: ) */
    )) {
      const a = e.components != null ? e.components.map((u) => Ao.from(u)) : null;
      return new Ao(pn, n || "", s, "tuple", i, a, null, null);
    }
    return s = C7(e.type), new Ao(pn, n || "", s, s, i, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(e) {
    return e && e[ks] === A7;
  }
};
A0 = new WeakSet(), $b = function(e, t, n, i) {
  if (this.isArray()) {
    if (!Array.isArray(t))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && t.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const o = this.arrayChildren, a = t.slice();
    a.forEach((c, u) => {
      var f;
      ke(f = o, A0, $b).call(f, e, c, n, (d) => {
        a[u] = d;
      });
    }), i(a);
    return;
  }
  if (this.isTuple()) {
    const o = this.components;
    let a;
    if (Array.isArray(t))
      a = t.slice();
    else {
      if (t == null || typeof t != "object")
        throw new Error("invalid tuple value");
      a = o.map((c) => {
        if (!c.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(c.name in t))
          throw new Error(`missing value for component ${c.name}`);
        return t[c.name];
      });
    }
    if (a.length !== this.components.length)
      throw new Error("array is wrong length");
    a.forEach((c, u) => {
      var f;
      ke(f = o[u], A0, $b).call(f, e, c, n, (d) => {
        a[u] = d;
      });
    }), i(a);
    return;
  }
  const s = n(this.type, t);
  s.then ? e.push(async function() {
    i(await s);
  }()) : i(s);
};
let yi = Ao;
class gd {
  /**
   *  @private
   */
  constructor(e, t, n) {
    /**
     *  The type of the fragment.
     */
    _e(this, "type");
    /**
     *  The inputs for the fragment.
     */
    _e(this, "inputs");
    fy(e, pn, "Fragment"), n = Object.freeze(n.slice()), Et(this, { type: t, inputs: n });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(e) {
    if (typeof e == "string") {
      try {
        gd.from(JSON.parse(e));
      } catch {
      }
      return gd.from(mh(e));
    }
    if (e instanceof $a)
      switch (e.peekKeyword($$)) {
        case "constructor":
          return Al.from(e);
        case "error":
          return Ps.from(e);
        case "event":
          return gc.from(e);
        case "fallback":
        case "receive":
          return ol.from(e);
        case "function":
          return mc.from(e);
        case "struct":
          return jf.from(e);
      }
    else if (typeof e == "object") {
      switch (e.type) {
        case "constructor":
          return Al.from(e);
        case "error":
          return Ps.from(e);
        case "event":
          return gc.from(e);
        case "fallback":
        case "receive":
          return ol.from(e);
        case "function":
          return mc.from(e);
        case "struct":
          return jf.from(e);
      }
      Te(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    me(!1, "unsupported frgament object", "obj", e);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(e) {
    return Al.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(e) {
    return Ps.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(e) {
    return gc.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(e) {
    return mc.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(e) {
    return jf.isFragment(e);
  }
}
class o3 extends gd {
  /**
   *  @private
   */
  constructor(t, n, i, s) {
    super(t, n, s);
    /**
     *  The name of the fragment.
     */
    _e(this, "name");
    me(typeof i == "string" && i.match(B$), "invalid identifier", "name", i), s = Object.freeze(s.slice()), Et(this, { name: i });
  }
}
function fw(r, e) {
  return "(" + e.map((t) => t.format(r)).join(r === "full" ? ", " : ",") + ")";
}
class Ps extends o3 {
  /**
   *  @private
   */
  constructor(e, t, n) {
    super(e, "error", t, n), Object.defineProperty(this, ks, { value: I7 });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return dd(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(e)))
      });
    const t = [];
    return e !== "sighash" && t.push("error"), t.push(this.name + fw(e, this.inputs)), t.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(e) {
    if (Ps.isFragment(e))
      return e;
    if (typeof e == "string")
      return Ps.from(mh(e));
    if (e instanceof $a) {
      const t = s3("error", e), n = Ol(e);
      return pd(e), new Ps(pn, t, n);
    }
    return new Ps(pn, e.name, e.inputs ? e.inputs.map(yi.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(e) {
    return e && e[ks] === I7;
  }
}
class gc extends o3 {
  /**
   *  @private
   */
  constructor(t, n, i, s) {
    super(t, "event", n, i);
    /**
     *  Whether this event is anonymous.
     */
    _e(this, "anonymous");
    Object.defineProperty(this, ks, { value: R7 }), Et(this, { anonymous: s });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return dd(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(t)))
      });
    const n = [];
    return t !== "sighash" && n.push("event"), n.push(this.name + fw(t, this.inputs)), t !== "sighash" && this.anonymous && n.push("anonymous"), n.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(t, n) {
    return n = (n || []).map((s) => yi.from(s)), new gc(pn, t, n, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(t) {
    if (gc.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return gc.from(mh(t));
      } catch {
        me(!1, "invalid event fragment", "obj", t);
      }
    else if (t instanceof $a) {
      const n = s3("event", t), i = Ol(t, !0), s = !!kl(t, os(["anonymous"])).has("anonymous");
      return pd(t), new gc(pn, n, i, s);
    }
    return new gc(pn, t.name, t.inputs ? t.inputs.map((n) => yi.from(n, !0)) : [], !!t.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(t) {
    return t && t[ks] === R7;
  }
}
class Al extends gd {
  /**
   *  @private
   */
  constructor(t, n, i, s, o) {
    super(t, n, i);
    /**
     *  Whether the constructor can receive an endowment.
     */
    _e(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    _e(this, "gas");
    Object.defineProperty(this, ks, { value: T7 }), Et(this, { payable: s, gas: o });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(t) {
    if (Te(t != null && t !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), t === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(t)))
      });
    const n = [`constructor${fw(t, this.inputs)}`];
    return this.payable && n.push("payable"), this.gas != null && n.push(`@${this.gas.toString()}`), n.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(t) {
    if (Al.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return Al.from(mh(t));
      } catch {
        me(!1, "invalid constuctor fragment", "obj", t);
      }
    else if (t instanceof $a) {
      kl(t, os(["constructor"]));
      const n = Ol(t), i = !!kl(t, ode).has("payable"), s = j$(t);
      return pd(t), new Al(pn, "constructor", n, i, s);
    }
    return new Al(pn, "constructor", t.inputs ? t.inputs.map(yi.from) : [], !!t.payable, t.gas != null ? t.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(t) {
    return t && t[ks] === T7;
  }
}
class ol extends gd {
  constructor(t, n, i) {
    super(t, "fallback", n);
    /**
     *  If the function can be sent value during invocation.
     */
    _e(this, "payable");
    Object.defineProperty(this, ks, { value: O7 }), Et(this, { payable: i });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(t) {
    const n = this.inputs.length === 0 ? "receive" : "fallback";
    if (t === "json") {
      const i = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: n, stateMutability: i });
    }
    return `${n}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(t) {
    if (ol.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return ol.from(mh(t));
      } catch {
        me(!1, "invalid fallback fragment", "obj", t);
      }
    else if (t instanceof $a) {
      const n = t.toString(), i = t.peekKeyword(os(["fallback", "receive"]));
      if (me(i, "type must be fallback or receive", "obj", n), t.popKeyword(os(["fallback", "receive"])) === "receive") {
        const c = Ol(t);
        return me(c.length === 0, "receive cannot have arguments", "obj.inputs", c), kl(t, os(["payable"])), pd(t), new ol(pn, [], !0);
      }
      let o = Ol(t);
      o.length ? me(o.length === 1 && o[0].type === "bytes", "invalid fallback inputs", "obj.inputs", o.map((c) => c.format("minimal")).join(", ")) : o = [yi.from("bytes")];
      const a = U$(t);
      if (me(a === "nonpayable" || a === "payable", "fallback cannot be constants", "obj.stateMutability", a), kl(t, os(["returns"])).has("returns")) {
        const c = Ol(t);
        me(c.length === 1 && c[0].type === "bytes", "invalid fallback outputs", "obj.outputs", c.map((u) => u.format("minimal")).join(", "));
      }
      return pd(t), new ol(pn, o, a === "payable");
    }
    if (t.type === "receive")
      return new ol(pn, [], !0);
    if (t.type === "fallback") {
      const n = [yi.from("bytes")], i = t.stateMutability === "payable";
      return new ol(pn, n, i);
    }
    me(!1, "invalid fallback description", "obj", t);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(t) {
    return t && t[ks] === O7;
  }
}
class mc extends o3 {
  /**
   *  @private
   */
  constructor(t, n, i, s, o, a) {
    super(t, "function", n, s);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    _e(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    _e(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    _e(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    _e(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    _e(this, "gas");
    Object.defineProperty(this, ks, { value: N7 }), o = Object.freeze(o.slice()), Et(this, { constant: i === "view" || i === "pure", gas: a, outputs: o, payable: i === "payable", stateMutability: i });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return dd(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(t))),
        outputs: this.outputs.map((i) => JSON.parse(i.format(t)))
      });
    const n = [];
    return t !== "sighash" && n.push("function"), n.push(this.name + fw(t, this.inputs)), t !== "sighash" && (this.stateMutability !== "nonpayable" && n.push(this.stateMutability), this.outputs && this.outputs.length && (n.push("returns"), n.push(fw(t, this.outputs))), this.gas != null && n.push(`@${this.gas.toString()}`)), n.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(t, n) {
    return n = (n || []).map((s) => yi.from(s)), new mc(pn, t, "view", n, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(t) {
    if (mc.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return mc.from(mh(t));
      } catch {
        me(!1, "invalid function fragment", "obj", t);
      }
    else if (t instanceof $a) {
      const i = s3("function", t), s = Ol(t), o = U$(t);
      let a = [];
      kl(t, os(["returns"])).has("returns") && (a = Ol(t));
      const c = j$(t);
      return pd(t), new mc(pn, i, o, s, a, c);
    }
    let n = t.stateMutability;
    return n == null && (n = "payable", typeof t.constant == "boolean" ? (n = "view", t.constant || (n = "payable", typeof t.payable == "boolean" && !t.payable && (n = "nonpayable"))) : typeof t.payable == "boolean" && !t.payable && (n = "nonpayable")), new mc(pn, t.name, n, t.inputs ? t.inputs.map(yi.from) : [], t.outputs ? t.outputs.map(yi.from) : [], t.gas != null ? t.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(t) {
    return t && t[ks] === N7;
  }
}
class jf extends o3 {
  /**
   *  @private
   */
  constructor(e, t, n) {
    super(e, "struct", t, n), Object.defineProperty(this, ks, { value: P7 });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(e) {
    if (typeof e == "string")
      try {
        return jf.from(mh(e));
      } catch {
        me(!1, "invalid struct fragment", "obj", e);
      }
    else if (e instanceof $a) {
      const t = s3("struct", e), n = Ol(e);
      return pd(e), new jf(pn, t, n);
    }
    return new jf(pn, e.name, e.inputs ? e.inputs.map(yi.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(e) {
    return e && e[ks] === P7;
  }
}
const Ua = /* @__PURE__ */ new Map();
Ua.set(0, "GENERIC_PANIC");
Ua.set(1, "ASSERT_FALSE");
Ua.set(17, "OVERFLOW");
Ua.set(18, "DIVIDE_BY_ZERO");
Ua.set(33, "ENUM_RANGE_ERROR");
Ua.set(34, "BAD_STORAGE_DATA");
Ua.set(49, "STACK_UNDERFLOW");
Ua.set(50, "ARRAY_RANGE_ERROR");
Ua.set(65, "OUT_OF_MEMORY");
Ua.set(81, "UNINITIALIZED_FUNCTION_CALL");
const wde = new RegExp(/^bytes([0-9]*)$/), yde = new RegExp(/^(u?int)([0-9]*)$/);
let I4 = null, M7 = 1024;
function vde(r, e, t, n) {
  let i = "missing revert data", s = null;
  const o = null;
  let a = null;
  if (t) {
    i = "execution reverted";
    const u = Tr(t);
    if (t = wt(t), u.length === 0)
      i += " (no data present; likely require(false) occurred", s = "require(false)";
    else if (u.length % 32 !== 4)
      i += " (could not decode reason; invalid data length)";
    else if (wt(u.slice(0, 4)) === "0x08c379a0")
      try {
        s = n.decode(["string"], u.slice(4))[0], a = {
          signature: "Error(string)",
          name: "Error",
          args: [s]
        }, i += `: ${JSON.stringify(s)}`;
      } catch {
        i += " (could not decode reason; invalid string data)";
      }
    else if (wt(u.slice(0, 4)) === "0x4e487b71")
      try {
        const f = Number(n.decode(["uint256"], u.slice(4))[0]);
        a = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [f]
        }, s = `Panic due to ${Ua.get(f) || "UNKNOWN"}(${f})`, i += `: ${s}`;
      } catch {
        i += " (could not decode panic code)";
      }
    else
      i += " (unknown custom error)";
  }
  const c = {
    to: e.to ? fr(e.to) : null,
    data: e.data || "0x"
  };
  return e.from && (c.from = fr(e.from)), En(i, "CALL_EXCEPTION", {
    action: r,
    data: t,
    reason: s,
    transaction: c,
    invocation: o,
    revert: a
  });
}
var Su, Ap;
const d_ = class d_ {
  constructor() {
    ye(this, Su);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(e) {
    const t = e.map((i) => ke(this, Su, Ap).call(this, yi.from(i)));
    return new ab(t, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(e, t) {
    Ek(t.length, e.length, "types/values length mismatch");
    const n = e.map((o) => ke(this, Su, Ap).call(this, yi.from(o))), i = new ab(n, "_"), s = new gx();
    return i.encode(s, t), s.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(e, t, n) {
    const i = e.map((o) => ke(this, Su, Ap).call(this, yi.from(o)));
    return new ab(i, "_").decode(new mx(t, n, M7));
  }
  static _setDefaultMaxInflation(e) {
    me(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), M7 = e;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return I4 == null && (I4 = new d_()), I4;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(e, t, n) {
    return vde(e, t, n, d_.defaultAbiCoder());
  }
};
Su = new WeakSet(), Ap = function(e) {
  if (e.isArray())
    return new Khe(ke(this, Su, Ap).call(this, e.arrayChildren), e.arrayLength, e.name);
  if (e.isTuple())
    return new ab(e.components.map((n) => ke(this, Su, Ap).call(this, n)), e.name);
  switch (e.baseType) {
    case "address":
      return new qhe(e.name);
    case "bool":
      return new Zhe(e.name);
    case "string":
      return new ife(e.name);
    case "bytes":
      return new Jhe(e.name);
    case "":
      return new Xhe(e.name);
  }
  let t = e.type.match(yde);
  if (t) {
    let n = parseInt(t[2] || "256");
    return me(n !== 0 && n <= 256 && n % 8 === 0, "invalid " + t[1] + " bit length", "param", e), new nfe(n / 8, t[1] === "int", e.name);
  }
  if (t = e.type.match(wde), t) {
    let n = parseInt(t[1]);
    return me(n !== 0 && n <= 32, "invalid bytes length", "param", e), new Qhe(n, e.name);
  }
  me(!1, "invalid type", "type", e.type);
};
let dw = d_;
class bde {
  /**
   *  @_ignore:
   */
  constructor(e, t, n) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    _e(this, "fragment");
    /**
     *  The name of the Event.
     */
    _e(this, "name");
    /**
     *  The full Event signature.
     */
    _e(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    _e(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    _e(this, "args");
    const i = e.name, s = e.format();
    Et(this, {
      fragment: e,
      name: i,
      signature: s,
      topic: t,
      args: n
    });
  }
}
class _de {
  /**
   *  @_ignore:
   */
  constructor(e, t, n, i) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    _e(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    _e(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    _e(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    _e(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    _e(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    _e(this, "value");
    const s = e.name, o = e.format();
    Et(this, {
      fragment: e,
      name: s,
      args: n,
      signature: o,
      selector: t,
      value: i
    });
  }
}
class Ede {
  /**
   *  @_ignore:
   */
  constructor(e, t, n) {
    /**
     *  The matching fragment.
     */
    _e(this, "fragment");
    /**
     *  The name of the Error.
     */
    _e(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    _e(this, "args");
    /**
     *  The full Error signature.
     */
    _e(this, "signature");
    /**
     *  The selector for the Error.
     */
    _e(this, "selector");
    const i = e.name, s = e.format();
    Et(this, {
      fragment: e,
      name: i,
      args: n,
      signature: s,
      selector: t
    });
  }
}
class D7 {
  /**
   *  @_ignore:
   */
  constructor(e) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    _e(this, "hash");
    /**
     *  @_ignore:
     */
    _e(this, "_isIndexed");
    Et(this, { hash: e, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const k7 = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, $7 = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (r) => `reverted with reason string ${JSON.stringify(r)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (r) => {
      let e = "unknown panic code";
      return r >= 0 && r <= 255 && k7[r.toString()] && (e = k7[r.toString()]), `reverted with panic code 0x${r.toString(16)} (${e})`;
    }
  }
};
var cc, lc, uc, Ni, I0, Lb, R0, Bb;
const Bp = class Bp {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(e) {
    // Find a function definition by any means necessary (unless it is ambiguous)
    ye(this, I0);
    // Find an event definition by any means necessary (unless it is ambiguous)
    ye(this, R0);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    _e(this, "fragments");
    /**
     *  The Contract constructor.
     */
    _e(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    _e(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    _e(this, "receive");
    ye(this, cc, void 0);
    ye(this, lc, void 0);
    ye(this, uc, void 0);
    //    #structs: Map<string, StructFragment>;
    ye(this, Ni, void 0);
    let t = [];
    typeof e == "string" ? t = JSON.parse(e) : t = e, ie(this, uc, /* @__PURE__ */ new Map()), ie(this, cc, /* @__PURE__ */ new Map()), ie(this, lc, /* @__PURE__ */ new Map());
    const n = [];
    for (const o of t)
      try {
        n.push(gd.from(o));
      } catch (a) {
        console.log("EE", a);
      }
    Et(this, {
      fragments: Object.freeze(n)
    });
    let i = null, s = !1;
    ie(this, Ni, this.getAbiCoder()), this.fragments.forEach((o, a) => {
      let c;
      switch (o.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          Et(this, { deploy: o });
          return;
        case "fallback":
          o.inputs.length === 0 ? s = !0 : (me(!i || o.payable !== i.payable, "conflicting fallback fragments", `fragments[${a}]`, o), i = o, s = i.payable);
          return;
        case "function":
          c = j(this, uc);
          break;
        case "event":
          c = j(this, lc);
          break;
        case "error":
          c = j(this, cc);
          break;
        default:
          return;
      }
      const u = o.format();
      c.has(u) || c.set(u, o);
    }), this.deploy || Et(this, {
      deploy: Al.from("constructor()")
    }), Et(this, { fallback: i, receive: s });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(e) {
    const t = e ? "minimal" : "full";
    return this.fragments.map((i) => i.format(t));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const e = this.fragments.map((t) => t.format("json"));
    return JSON.stringify(e.map((t) => JSON.parse(t)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return dw.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(e) {
    const t = ke(this, I0, Lb).call(this, e, null, !1);
    return me(t, "no matching function", "key", e), t.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(e) {
    return !!ke(this, I0, Lb).call(this, e, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(e, t) {
    return ke(this, I0, Lb).call(this, e, t || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(e) {
    const t = Array.from(j(this, uc).keys());
    t.sort((n, i) => n.localeCompare(i));
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      e(j(this, uc).get(i), n);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(e) {
    const t = ke(this, R0, Bb).call(this, e, null, !1);
    return me(t, "no matching event", "key", e), t.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(e) {
    return !!ke(this, R0, Bb).call(this, e, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(e, t) {
    return ke(this, R0, Bb).call(this, e, t || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(e) {
    const t = Array.from(j(this, lc).keys());
    t.sort((n, i) => n.localeCompare(i));
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      e(j(this, lc).get(i), n);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(e, t) {
    if (mn(e)) {
      const i = e.toLowerCase();
      if ($7[i])
        return Ps.from($7[i].signature);
      for (const s of j(this, cc).values())
        if (i === s.selector)
          return s;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const i = [];
      for (const [s, o] of j(this, cc))
        s.split(
          "("
          /* fix:) */
        )[0] === e && i.push(o);
      if (i.length === 0)
        return e === "Error" ? Ps.from("error Error(string)") : e === "Panic" ? Ps.from("error Panic(uint256)") : null;
      if (i.length > 1) {
        const s = i.map((o) => JSON.stringify(o.format())).join(", ");
        me(!1, `ambiguous error description (i.e. ${s})`, "name", e);
      }
      return i[0];
    }
    if (e = Ps.from(e).format(), e === "Error(string)")
      return Ps.from("error Error(string)");
    if (e === "Panic(uint256)")
      return Ps.from("error Panic(uint256)");
    const n = j(this, cc).get(e);
    return n || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(e) {
    const t = Array.from(j(this, cc).keys());
    t.sort((n, i) => n.localeCompare(i));
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      e(j(this, cc).get(i), n);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(e, t) {
    return j(this, Ni).decode(e, t);
  }
  _encodeParams(e, t) {
    return j(this, Ni).encode(e, t);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(e, t) {
    if (typeof e == "string") {
      const n = this.getError(e);
      me(n, "unknown error", "fragment", e), e = n;
    }
    return me(xn(t, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", t), this._decodeParams(e.inputs, xn(t, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(e, t) {
    if (typeof e == "string") {
      const n = this.getError(e);
      me(n, "unknown error", "fragment", e), e = n;
    }
    return Zn([
      e.selector,
      this._encodeParams(e.inputs, t || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      me(n, "unknown function", "fragment", e), e = n;
    }
    return me(xn(t, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", t), this._decodeParams(e.inputs, xn(t, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      me(n, "unknown function", "fragment", e), e = n;
    }
    return Zn([
      e.selector,
      this._encodeParams(e.inputs, t || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(e, t) {
    if (typeof e == "string") {
      const s = this.getFunction(e);
      me(s, "unknown function", "fragment", e), e = s;
    }
    let n = "invalid length for result data";
    const i = rs(t);
    if (i.length % 32 === 0)
      try {
        return j(this, Ni).decode(e.outputs, i);
      } catch {
        n = "could not decode result data";
      }
    Te(!1, n, "BAD_DATA", {
      value: wt(i),
      info: { method: e.name, signature: e.format() }
    });
  }
  makeError(e, t) {
    const n = Tr(e, "data"), i = dw.getBuiltinCallException("call", t, n);
    if (i.message.startsWith("execution reverted (unknown custom error)")) {
      const a = wt(n.slice(0, 4)), c = this.getError(a);
      if (c)
        try {
          const u = j(this, Ni).decode(c.inputs, n.slice(4));
          i.revert = {
            name: c.name,
            signature: c.format(),
            args: u
          }, i.reason = i.revert.signature, i.message = `execution reverted: ${i.reason}`;
        } catch {
          i.message = "execution reverted (coult not decode custom error)";
        }
    }
    const o = this.parseTransaction(t);
    return o && (i.invocation = {
      method: o.name,
      signature: o.signature,
      args: o.args
    }), i;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      me(n, "unknown function", "fragment", e), e = n;
    }
    return wt(j(this, Ni).encode(e.outputs, t || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, t) {
    if (typeof e == "string") {
      const s = this.getEvent(e);
      me(s, "unknown event", "eventFragment", e), e = s;
    }
    Te(t.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", { count: t.length, expectedCount: e.inputs.length });
    const n = [];
    e.anonymous || n.push(e.topicHash);
    const i = (s, o) => s.type === "string" ? dd(o) : s.type === "bytes" ? gn(wt(o)) : (s.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : s.type.match(/^u?int/) ? o = rh(o) : s.type.match(/^bytes/) ? o = aue(o, 32) : s.type === "address" && j(this, Ni).encode(["address"], [o]), fd(wt(o), 32));
    for (t.forEach((s, o) => {
      const a = e.inputs[o];
      if (!a.indexed) {
        me(s == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, s);
        return;
      }
      s == null ? n.push(null) : a.baseType === "array" || a.baseType === "tuple" ? me(!1, "filtering with tuples or arrays not supported", "contract." + a.name, s) : Array.isArray(s) ? n.push(s.map((c) => i(a, c))) : n.push(i(a, s));
    }); n.length && n[n.length - 1] === null; )
      n.pop();
    return n;
  }
  encodeEventLog(e, t) {
    if (typeof e == "string") {
      const o = this.getEvent(e);
      me(o, "unknown event", "eventFragment", e), e = o;
    }
    const n = [], i = [], s = [];
    return e.anonymous || n.push(e.topicHash), me(t.length === e.inputs.length, "event arguments/values mismatch", "values", t), e.inputs.forEach((o, a) => {
      const c = t[a];
      if (o.indexed)
        if (o.type === "string")
          n.push(dd(c));
        else if (o.type === "bytes")
          n.push(gn(c));
        else {
          if (o.baseType === "tuple" || o.baseType === "array")
            throw new Error("not implemented");
          n.push(j(this, Ni).encode([o.type], [c]));
        }
      else
        i.push(o), s.push(c);
    }), {
      data: j(this, Ni).encode(i, s),
      topics: n
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, t, n) {
    if (typeof e == "string") {
      const y = this.getEvent(e);
      me(y, "unknown event", "eventFragment", e), e = y;
    }
    if (n != null && !e.anonymous) {
      const y = e.topicHash;
      me(mn(n[0], 32) && n[0].toLowerCase() === y, "fragment/topic mismatch", "topics[0]", n[0]), n = n.slice(1);
    }
    const i = [], s = [], o = [];
    e.inputs.forEach((y, b) => {
      y.indexed ? y.type === "string" || y.type === "bytes" || y.baseType === "tuple" || y.baseType === "array" ? (i.push(yi.from({ type: "bytes32", name: y.name })), o.push(!0)) : (i.push(y), o.push(!1)) : (s.push(y), o.push(!1));
    });
    const a = n != null ? j(this, Ni).decode(i, Zn(n)) : null, c = j(this, Ni).decode(s, t, !0), u = [], f = [];
    let d = 0, m = 0;
    return e.inputs.forEach((y, b) => {
      let I = null;
      if (y.indexed)
        if (a == null)
          I = new D7(null);
        else if (o[b])
          I = new D7(a[m++]);
        else
          try {
            I = a[m++];
          } catch (k) {
            I = k;
          }
      else
        try {
          I = c[d++];
        } catch (k) {
          I = k;
        }
      u.push(I), f.push(y.name || null);
    }), k2.fromItems(u, f);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(e) {
    const t = Tr(e.data, "tx.data"), n = gt(e.value != null ? e.value : 0, "tx.value"), i = this.getFunction(wt(t.slice(0, 4)));
    if (!i)
      return null;
    const s = j(this, Ni).decode(i.inputs, t.slice(4));
    return new _de(i, i.selector, s, n);
  }
  parseCallResult(e) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(e) {
    const t = this.getEvent(e.topics[0]);
    return !t || t.anonymous ? null : new bde(t, t.topicHash, this.decodeEventLog(t, e.data, e.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(e) {
    const t = wt(e), n = this.getError(xn(t, 0, 4));
    if (!n)
      return null;
    const i = j(this, Ni).decode(n.inputs, xn(t, 4));
    return new Ede(n, n.selector, i);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(e) {
    return e instanceof Bp ? e : typeof e == "string" ? new Bp(JSON.parse(e)) : typeof e.format == "function" ? new Bp(e.format("json")) : new Bp(e);
  }
};
cc = new WeakMap(), lc = new WeakMap(), uc = new WeakMap(), Ni = new WeakMap(), I0 = new WeakSet(), Lb = function(e, t, n) {
  if (mn(e)) {
    const s = e.toLowerCase();
    for (const o of j(this, uc).values())
      if (s === o.selector)
        return o;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const s = [];
    for (const [o, a] of j(this, uc))
      o.split(
        "("
        /* fix:) */
      )[0] === e && s.push(a);
    if (t) {
      const o = t.length > 0 ? t[t.length - 1] : null;
      let a = t.length, c = !0;
      Li.isTyped(o) && o.type === "overrides" && (c = !1, a--);
      for (let u = s.length - 1; u >= 0; u--) {
        const f = s[u].inputs.length;
        f !== a && (!c || f !== a - 1) && s.splice(u, 1);
      }
      for (let u = s.length - 1; u >= 0; u--) {
        const f = s[u].inputs;
        for (let d = 0; d < t.length; d++)
          if (Li.isTyped(t[d])) {
            if (d >= f.length) {
              if (t[d].type === "overrides")
                continue;
              s.splice(u, 1);
              break;
            }
            if (t[d].type !== f[d].baseType) {
              s.splice(u, 1);
              break;
            }
          }
      }
    }
    if (s.length === 1 && t && t.length !== s[0].inputs.length) {
      const o = t[t.length - 1];
      (o == null || Array.isArray(o) || typeof o != "object") && s.splice(0, 1);
    }
    if (s.length === 0)
      return null;
    if (s.length > 1 && n) {
      const o = s.map((a) => JSON.stringify(a.format())).join(", ");
      me(!1, `ambiguous function description (i.e. matches ${o})`, "key", e);
    }
    return s[0];
  }
  const i = j(this, uc).get(mc.from(e).format());
  return i || null;
}, R0 = new WeakSet(), Bb = function(e, t, n) {
  if (mn(e)) {
    const s = e.toLowerCase();
    for (const o of j(this, lc).values())
      if (s === o.topicHash)
        return o;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const s = [];
    for (const [o, a] of j(this, lc))
      o.split(
        "("
        /* fix:) */
      )[0] === e && s.push(a);
    if (t) {
      for (let o = s.length - 1; o >= 0; o--)
        s[o].inputs.length < t.length && s.splice(o, 1);
      for (let o = s.length - 1; o >= 0; o--) {
        const a = s[o].inputs;
        for (let c = 0; c < t.length; c++)
          if (Li.isTyped(t[c]) && t[c].type !== a[c].baseType) {
            s.splice(o, 1);
            break;
          }
      }
    }
    if (s.length === 0)
      return null;
    if (s.length > 1 && n) {
      const o = s.map((a) => JSON.stringify(a.format())).join(", ");
      me(!1, `ambiguous event description (i.e. matches ${o})`, "key", e);
    }
    return s[0];
  }
  const i = j(this, lc).get(gc.from(e).format());
  return i || null;
};
let Ox = Bp;
const W$ = BigInt(0);
function dm(r) {
  return r ?? null;
}
function ki(r) {
  return r == null ? null : r.toString();
}
class L7 {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(e, t, n) {
    /**
     *  The gas price for legacy networks.
     */
    _e(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    _e(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    _e(this, "maxPriorityFeePerGas");
    Et(this, {
      gasPrice: dm(e),
      maxFeePerGas: dm(t),
      maxPriorityFeePerGas: dm(n)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice: e, maxFeePerGas: t, maxPriorityFeePerGas: n } = this;
    return {
      _type: "FeeData",
      gasPrice: ki(e),
      maxFeePerGas: ki(t),
      maxPriorityFeePerGas: ki(n)
    };
  }
}
function H2(r) {
  const e = {};
  r.to && (e.to = r.to), r.from && (e.from = r.from), r.data && (e.data = wt(r.data));
  const t = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const i of t)
    !(i in r) || r[i] == null || (e[i] = gt(r[i], `request.${i}`));
  const n = "type,nonce".split(/,/);
  for (const i of n)
    !(i in r) || r[i] == null || (e[i] = nr(r[i], `request.${i}`));
  return r.accessList && (e.accessList = Dd(r.accessList)), "blockTag" in r && (e.blockTag = r.blockTag), "enableCcipRead" in r && (e.enableCcipRead = !!r.enableCcipRead), "customData" in r && (e.customData = r.customData), e;
}
var wl;
class xde {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(e, t) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    _e(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    _e(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    _e(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    _e(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    _e(this, "parentHash");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    _e(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    _e(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    _e(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    _e(this, "gasUsed");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    _e(this, "miner");
    /**
     *  Any extra data the validator wished to include.
     */
    _e(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    _e(this, "baseFeePerGas");
    ye(this, wl, void 0);
    ie(this, wl, e.transactions.map((n) => typeof n != "string" ? new pw(n, t) : n)), Et(this, {
      provider: t,
      hash: dm(e.hash),
      number: e.number,
      timestamp: e.timestamp,
      parentHash: e.parentHash,
      nonce: e.nonce,
      difficulty: e.difficulty,
      gasLimit: e.gasLimit,
      gasUsed: e.gasUsed,
      miner: e.miner,
      extraData: e.extraData,
      baseFeePerGas: dm(e.baseFeePerGas)
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return j(this, wl).map((e) => typeof e == "string" ? e : e.hash);
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const e = j(this, wl).slice();
    return e.length === 0 ? [] : (Te(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    }), e);
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas: e, difficulty: t, extraData: n, gasLimit: i, gasUsed: s, hash: o, miner: a, nonce: c, number: u, parentHash: f, timestamp: d, transactions: m } = this;
    return {
      _type: "Block",
      baseFeePerGas: ki(e),
      difficulty: ki(t),
      extraData: n,
      gasLimit: ki(i),
      gasUsed: ki(s),
      hash: o,
      miner: a,
      nonce: c,
      number: u,
      parentHash: f,
      timestamp: d,
      transactions: m
    };
  }
  [Symbol.iterator]() {
    let e = 0;
    const t = this.transactions;
    return {
      next: () => e < this.length ? {
        value: t[e++],
        done: !1
      } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return j(this, wl).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(e) {
    let t;
    if (typeof e == "number")
      t = j(this, wl)[e];
    else {
      const n = e.toLowerCase();
      for (const i of j(this, wl))
        if (typeof i == "string") {
          if (i !== n)
            continue;
          t = i;
          break;
        } else {
          if (i.hash === n)
            continue;
          t = i;
          break;
        }
    }
    if (t == null)
      throw new Error("no such tx");
    return typeof t == "string" ? await this.provider.getTransaction(t) : t;
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(e) {
    const t = this.prefetchedTransactions;
    if (typeof e == "number")
      return t[e];
    e = e.toLowerCase();
    for (const n of t)
      if (n.hash === e)
        return n;
    me(!1, "no matching transaction", "indexOrHash", e);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined())
      throw new Error("");
    return Sde(this);
  }
}
wl = new WeakMap();
class py {
  /**
   *  @_ignore:
   */
  constructor(e, t) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    _e(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    _e(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    _e(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    _e(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    _e(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    _e(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    _e(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    _e(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    _e(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    _e(this, "transactionIndex");
    this.provider = t;
    const n = Object.freeze(e.topics.slice());
    Et(this, {
      transactionHash: e.transactionHash,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      removed: e.removed,
      address: e.address,
      data: e.data,
      topics: n,
      index: e.index,
      transactionIndex: e.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address: e, blockHash: t, blockNumber: n, data: i, index: s, removed: o, topics: a, transactionHash: c, transactionIndex: u } = this;
    return {
      _type: "log",
      address: e,
      blockHash: t,
      blockNumber: n,
      data: i,
      index: s,
      removed: o,
      topics: a,
      transactionHash: c,
      transactionIndex: u
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    return Te(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.transactionHash);
    return Te(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const e = await this.provider.getTransactionReceipt(this.transactionHash);
    return Te(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return Cde(this);
  }
}
var Dw;
class H$ {
  /**
   *  @_ignore:
   */
  constructor(e, t) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    _e(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    _e(this, "to");
    /**
     *  The sender of the transaction.
     */
    _e(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    _e(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    _e(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    _e(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    _e(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    _e(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    _e(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    _e(this, "gasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    _e(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    _e(this, "gasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    _e(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    _e(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    _e(this, "root");
    ye(this, Dw, void 0);
    ie(this, Dw, Object.freeze(e.logs.map((i) => new py(i, t))));
    let n = W$;
    e.effectiveGasPrice != null ? n = e.effectiveGasPrice : e.gasPrice != null && (n = e.gasPrice), Et(this, {
      provider: t,
      to: e.to,
      from: e.from,
      contractAddress: e.contractAddress,
      hash: e.hash,
      index: e.index,
      blockHash: e.blockHash,
      blockNumber: e.blockNumber,
      logsBloom: e.logsBloom,
      gasUsed: e.gasUsed,
      cumulativeGasUsed: e.cumulativeGasUsed,
      gasPrice: n,
      type: e.type,
      //byzantium: tx.byzantium,
      status: e.status,
      root: e.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return j(this, Dw);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: e,
      from: t,
      contractAddress: n,
      hash: i,
      index: s,
      blockHash: o,
      blockNumber: a,
      logsBloom: c,
      logs: u,
      //byzantium, 
      status: f,
      root: d
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash: o,
      blockNumber: a,
      //byzantium, 
      contractAddress: n,
      cumulativeGasUsed: ki(this.cumulativeGasUsed),
      from: t,
      gasPrice: ki(this.gasPrice),
      gasUsed: ki(this.gasUsed),
      hash: i,
      index: s,
      logs: u,
      logsBloom: c,
      root: d,
      status: f,
      to: e
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.length ? { value: this.logs[e++], done: !1 } : { value: void 0, done: !0 }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const e = await this.provider.getBlock(this.blockHash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const e = await this.provider.getTransaction(this.hash);
    if (e == null)
      throw new Error("TODO");
    return e;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return V$(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(e) {
    return Te(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" }), z$(this, e);
  }
}
Dw = new WeakMap();
var Cu;
const r8 = class r8 {
  /**
   *  @_ignore:
   */
  constructor(e, t) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    _e(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    _e(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    _e(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    _e(this, "index");
    /**
     *  The transaction hash.
     */
    _e(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    _e(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    _e(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    _e(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    _e(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    _e(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    _e(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    _e(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    _e(this, "maxFeePerGas");
    /**
     *  The data.
     */
    _e(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    _e(this, "value");
    /**
     *  The chain ID.
     */
    _e(this, "chainId");
    /**
     *  The signature.
     */
    _e(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    _e(this, "accessList");
    ye(this, Cu, void 0);
    this.provider = t, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, ie(this, Cu, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber: e, blockHash: t, index: n, hash: i, type: s, to: o, from: a, nonce: c, data: u, signature: f, accessList: d } = this;
    return {
      _type: "TransactionReceipt",
      accessList: d,
      blockNumber: e,
      blockHash: t,
      chainId: ki(this.chainId),
      data: u,
      from: a,
      gasLimit: ki(this.gasLimit),
      gasPrice: ki(this.gasPrice),
      hash: i,
      maxFeePerGas: ki(this.maxFeePerGas),
      maxPriorityFeePerGas: ki(this.maxPriorityFeePerGas),
      nonce: c,
      signature: f,
      to: o,
      index: n,
      type: s,
      value: ki(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let e = this.blockNumber;
    if (e == null) {
      const n = await this.getTransaction();
      n && (e = n.blockNumber);
    }
    if (e == null)
      return null;
    const t = this.provider.getBlock(e);
    if (t == null)
      throw new Error("TODO");
    return t;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: t, blockNumber: n } = await Yi({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      return t == null || t.blockNumber == null ? 0 : n - t.blockNumber + 1;
    }
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(e, t) {
    const n = e ?? 1, i = t ?? 0;
    let s = j(this, Cu), o = -1, a = s === -1;
    const c = async () => {
      if (a)
        return null;
      const { blockNumber: m, nonce: y } = await Yi({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (y < this.nonce) {
        s = m;
        return;
      }
      if (a)
        return null;
      const b = await this.getTransaction();
      if (!(b && b.blockNumber != null))
        for (o === -1 && (o = s - 3, o < j(this, Cu) && (o = j(this, Cu))); o <= m; ) {
          if (a)
            return null;
          const I = await this.provider.getBlock(o, !0);
          if (I == null)
            return;
          for (const k of I)
            if (k === this.hash)
              return;
          for (let k = 0; k < I.length; k++) {
            const R = await I.getTransaction(k);
            if (R.from === this.from && R.nonce === this.nonce) {
              if (a)
                return null;
              const T = await this.provider.getTransactionReceipt(R.hash);
              if (T == null || m - T.blockNumber + 1 < n)
                return;
              let $ = "replaced";
              R.data === this.data && R.to === this.to && R.value === this.value ? $ = "repriced" : R.data === "0x" && R.from === R.to && R.value === W$ && ($ = "cancelled"), Te(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: $ === "replaced" || $ === "cancelled",
                reason: $,
                replacement: R.replaceableTransaction(s),
                hash: R.hash,
                receipt: T
              });
            }
          }
          o++;
        }
    }, u = (m) => {
      if (m == null || m.status !== 0)
        return m;
      Te(!1, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: m.to,
          from: m.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: m
      });
    }, f = await this.provider.getTransactionReceipt(this.hash);
    if (n === 0)
      return u(f);
    if (f) {
      if (await f.confirmations() >= n)
        return u(f);
    } else if (await c(), n === 0)
      return null;
    return await new Promise((m, y) => {
      const b = [], I = () => {
        b.forEach((R) => R());
      };
      if (b.push(() => {
        a = !0;
      }), i > 0) {
        const R = setTimeout(() => {
          I(), y(En("wait for transaction timeout", "TIMEOUT"));
        }, i);
        b.push(() => {
          clearTimeout(R);
        });
      }
      const k = async (R) => {
        if (await R.confirmations() >= n) {
          I();
          try {
            m(u(R));
          } catch (T) {
            y(T);
          }
        }
      };
      if (b.push(() => {
        this.provider.off(this.hash, k);
      }), this.provider.on(this.hash, k), s >= 0) {
        const R = async () => {
          try {
            await c();
          } catch (T) {
            if ($i(T, "TRANSACTION_REPLACED")) {
              I(), y(T);
              return;
            }
          }
          a || this.provider.once("block", R);
        };
        b.push(() => {
          this.provider.off("block", R);
        }), this.provider.once("block", R);
      }
    });
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    return Te(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), V$(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(e) {
    return Te(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), Te(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" }), z$(this, e);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(e) {
    me(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
    const t = new r8(this, this.provider);
    return ie(t, Cu, e), t;
  }
};
Cu = new WeakMap();
let pw = r8;
function Sde(r) {
  return { orphan: "drop-block", hash: r.hash, number: r.number };
}
function z$(r, e) {
  return { orphan: "reorder-transaction", tx: r, other: e };
}
function V$(r) {
  return { orphan: "drop-transaction", tx: r };
}
function Cde(r) {
  return { orphan: "drop-log", log: {
    transactionHash: r.transactionHash,
    blockHash: r.blockHash,
    blockNumber: r.blockNumber,
    address: r.address,
    data: r.data,
    topics: Object.freeze(r.topics.slice()),
    index: r.index
  } };
}
class MC extends py {
  /**
   * @_ignore:
   */
  constructor(t, n, i) {
    super(t, t.provider);
    /**
     *  The Contract Interface.
     */
    _e(this, "interface");
    /**
     *  The matching event.
     */
    _e(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    _e(this, "args");
    const s = n.decodeEventLog(i, t.data, t.topics);
    Et(this, { args: s, fragment: i, interface: n });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class q$ extends py {
  /**
   * @_ignore:
   */
  constructor(t, n) {
    super(t, t.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    _e(this, "error");
    Et(this, { error: n });
  }
}
var T0;
class Ade extends H$ {
  /**
   *  @_ignore:
   */
  constructor(t, n, i) {
    super(i, n);
    ye(this, T0, void 0);
    ie(this, T0, t);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((t) => {
      const n = t.topics.length ? j(this, T0).getEvent(t.topics[0]) : null;
      if (n)
        try {
          return new MC(t, j(this, T0), n);
        } catch (i) {
          return new q$(t, i);
        }
      return t;
    });
  }
}
T0 = new WeakMap();
var kw;
class DC extends pw {
  /**
   *  @_ignore:
   */
  constructor(t, n, i) {
    super(i, n);
    ye(this, kw, void 0);
    ie(this, kw, t);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(t) {
    const n = await super.wait(t);
    return n == null ? null : new Ade(j(this, kw), this.provider, n);
  }
}
kw = new WeakMap();
class G$ extends Ak {
  /**
   *  @_event:
   */
  constructor(t, n, i, s) {
    super(t, n, i);
    /**
     *  The log with no matching events.
     */
    _e(this, "log");
    Et(this, { log: s });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class Ide extends G$ {
  /**
   *  @_ignore:
   */
  constructor(e, t, n, i, s) {
    super(e, t, n, new MC(s, e.interface, i));
    const o = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
    Et(this, { args: o, fragment: i });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const B7 = BigInt(0);
function K$(r) {
  return r && typeof r.call == "function";
}
function Z$(r) {
  return r && typeof r.estimateGas == "function";
}
function a3(r) {
  return r && typeof r.resolveName == "function";
}
function J$(r) {
  return r && typeof r.sendTransaction == "function";
}
function Q$(r) {
  if (r != null) {
    if (a3(r))
      return r;
    if (r.provider)
      return r.provider;
  }
}
var $w;
class Rde {
  constructor(e, t, n) {
    ye(this, $w, void 0);
    _e(this, "fragment");
    if (Et(this, { fragment: t }), t.inputs.length < n.length)
      throw new Error("too many arguments");
    const i = md(e.runner, "resolveName"), s = a3(i) ? i : null;
    ie(this, $w, async function() {
      const o = await Promise.all(t.inputs.map((a, c) => n[c] == null ? null : a.walkAsync(n[c], (f, d) => f === "address" ? Array.isArray(d) ? Promise.all(d.map((m) => ss(m, s))) : ss(d, s) : d)));
      return e.interface.encodeFilterTopics(t, o);
    }());
  }
  getTopicFilter() {
    return j(this, $w);
  }
}
$w = new WeakMap();
function md(r, e) {
  return r == null ? null : typeof r[e] == "function" ? r : r.provider && typeof r.provider[e] == "function" ? r.provider : null;
}
function hf(r) {
  return r == null ? null : r.provider || null;
}
async function Y$(r, e) {
  const t = Li.dereference(r, "overrides");
  me(typeof t == "object", "invalid overrides parameter", "overrides", r);
  const n = H2(t);
  return me(n.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", n.to), me(n.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", n.data), n.from && (n.from = n.from), n;
}
async function Tde(r, e, t) {
  const n = md(r, "resolveName"), i = a3(n) ? n : null;
  return await Promise.all(e.map((s, o) => s.walkAsync(t[o], (a, c) => (c = Li.dereference(c, a), a === "address" ? ss(c, i) : c))));
}
function Ode(r) {
  const e = async function(o) {
    const a = await Y$(o, ["data"]);
    a.to = await r.getAddress(), a.from && (a.from = await ss(a.from, Q$(r.runner)));
    const c = r.interface, u = gt(a.value || B7, "overrides.value") === B7, f = (a.data || "0x") === "0x";
    c.fallback && !c.fallback.payable && c.receive && !f && !u && me(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", o), me(c.fallback || f, "cannot send data to receive-only contract", "overrides.data", a.data);
    const d = c.receive || c.fallback && c.fallback.payable;
    return me(d || u, "cannot send value to non-payable fallback", "overrides.value", a.value), me(c.fallback || f, "cannot send data to receive-only contract", "overrides.data", a.data), a;
  }, t = async function(o) {
    const a = md(r.runner, "call");
    Te(K$(a), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const c = await e(o);
    try {
      return await a.call(c);
    } catch (u) {
      throw vC(u) && u.data ? r.interface.makeError(u.data, c) : u;
    }
  }, n = async function(o) {
    const a = r.runner;
    Te(J$(a), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const c = await a.sendTransaction(await e(o)), u = hf(r.runner);
    return new DC(r.interface, u, c);
  }, i = async function(o) {
    const a = md(r.runner, "estimateGas");
    return Te(Z$(a), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await a.estimateGas(await e(o));
  }, s = async (o) => await n(o);
  return Et(s, {
    _contract: r,
    estimateGas: i,
    populateTransaction: e,
    send: n,
    staticCall: t
  }), s;
}
function Nde(r, e) {
  const t = function(...u) {
    const f = r.interface.getFunction(e, u);
    return Te(f, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: u }
    }), f;
  }, n = async function(...u) {
    const f = t(...u);
    let d = {};
    if (f.inputs.length + 1 === u.length && (d = await Y$(u.pop()), d.from && (d.from = await ss(d.from, Q$(r.runner)))), f.inputs.length !== u.length)
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    const m = await Tde(r.runner, f.inputs, u);
    return Object.assign({}, d, await Yi({
      to: r.getAddress(),
      data: r.interface.encodeFunctionData(f, m)
    }));
  }, i = async function(...u) {
    const f = await a(...u);
    return f.length === 1 ? f[0] : f;
  }, s = async function(...u) {
    const f = r.runner;
    Te(J$(f), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const d = await f.sendTransaction(await n(...u)), m = hf(r.runner);
    return new DC(r.interface, m, d);
  }, o = async function(...u) {
    const f = md(r.runner, "estimateGas");
    return Te(Z$(f), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" }), await f.estimateGas(await n(...u));
  }, a = async function(...u) {
    const f = md(r.runner, "call");
    Te(K$(f), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const d = await n(...u);
    let m = "0x";
    try {
      m = await f.call(d);
    } catch (b) {
      throw vC(b) && b.data ? r.interface.makeError(b.data, d) : b;
    }
    const y = t(...u);
    return r.interface.decodeFunctionResult(y, m);
  }, c = async (...u) => t(...u).constant ? await i(...u) : await s(...u);
  return Et(c, {
    name: r.interface.getFunctionName(e),
    _contract: r,
    _key: e,
    getFragment: t,
    estimateGas: o,
    populateTransaction: n,
    send: s,
    staticCall: i,
    staticCallResult: a
  }), Object.defineProperty(c, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const u = r.interface.getFunction(e);
      return Te(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), u;
    }
  }), c;
}
function Pde(r, e) {
  const t = function(...i) {
    const s = r.interface.getEvent(e, i);
    return Te(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: e, args: i }
    }), s;
  }, n = function(...i) {
    return new Rde(r, t(...i), i);
  };
  return Et(n, {
    name: r.interface.getEventName(e),
    _contract: r,
    _key: e,
    getFragment: t
  }), Object.defineProperty(n, "fragment", {
    configurable: !1,
    enumerable: !0,
    get: () => {
      const i = r.interface.getEvent(e);
      return Te(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: e }
      }), i;
    }
  }), n;
}
const z2 = Symbol.for("_ethersInternal_contract"), X$ = /* @__PURE__ */ new WeakMap();
function Mde(r, e) {
  X$.set(r[z2], e);
}
function Js(r) {
  return X$.get(r[z2]);
}
function Dde(r) {
  return r && typeof r == "object" && "getTopicFilter" in r && typeof r.getTopicFilter == "function" && r.fragment;
}
async function kC(r, e) {
  let t, n = null;
  if (Array.isArray(e)) {
    const s = function(o) {
      if (mn(o, 32))
        return o;
      const a = r.interface.getEvent(o);
      return me(a, "unknown fragment", "name", o), a.topicHash;
    };
    t = e.map((o) => o == null ? null : Array.isArray(o) ? o.map(s) : s(o));
  } else
    e === "*" ? t = [null] : typeof e == "string" ? mn(e, 32) ? t = [e] : (n = r.interface.getEvent(e), me(n, "unknown fragment", "event", e), t = [n.topicHash]) : Dde(e) ? t = await e.getTopicFilter() : "fragment" in e ? (n = e.fragment, t = [n.topicHash]) : me(!1, "unknown event name", "event", e);
  t = t.map((s) => {
    if (s == null)
      return null;
    if (Array.isArray(s)) {
      const o = Array.from(new Set(s.map((a) => a.toLowerCase())).values());
      return o.length === 1 ? o[0] : (o.sort(), o);
    }
    return s.toLowerCase();
  });
  const i = t.map((s) => s == null ? "null" : Array.isArray(s) ? s.join("|") : s).join("&");
  return { fragment: n, tag: i, topics: t };
}
async function X1(r, e) {
  const { subs: t } = Js(r);
  return t.get((await kC(r, e)).tag) || null;
}
async function F7(r, e, t) {
  const n = hf(r.runner);
  Te(n, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation: e });
  const { fragment: i, tag: s, topics: o } = await kC(r, t), { addr: a, subs: c } = Js(r);
  let u = c.get(s);
  if (!u) {
    const d = { address: a || r, topics: o }, m = (k) => {
      let R = i;
      if (R == null)
        try {
          R = r.interface.getEvent(k.topics[0]);
        } catch {
        }
      if (R) {
        const T = R, $ = i ? r.interface.decodeEventLog(i, k.data, k.topics) : [];
        Px(r, t, $, (D) => new Ide(r, D, t, T, k));
      } else
        Px(r, t, [], (T) => new G$(r, T, t, k));
    };
    let y = [];
    u = { tag: s, listeners: [], start: () => {
      y.length || y.push(n.on(d, m));
    }, stop: async () => {
      if (y.length == 0)
        return;
      let k = y;
      y = [], await Promise.all(k), n.off(d, m);
    } }, c.set(s, u);
  }
  return u;
}
let Nx = Promise.resolve();
async function kde(r, e, t, n) {
  await Nx;
  const i = await X1(r, e);
  if (!i)
    return !1;
  const s = i.listeners.length;
  return i.listeners = i.listeners.filter(({ listener: o, once: a }) => {
    const c = Array.from(t);
    n && c.push(n(a ? null : o));
    try {
      o.call(r, ...c);
    } catch {
    }
    return !a;
  }), i.listeners.length === 0 && (i.stop(), Js(r).subs.delete(i.tag)), s > 0;
}
async function Px(r, e, t, n) {
  try {
    await Nx;
  } catch {
  }
  const i = kde(r, e, t, n);
  return Nx = i, await i;
}
const cb = ["then"];
var vAe;
const Cm = class Cm {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(e, t, n, i) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    _e(this, "target");
    /**
     *  The contract Interface.
     */
    _e(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    _e(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    _e(this, "filters");
    /**
     *  @_ignore:
     */
    _e(this, vAe);
    /**
     *  The fallback or receive function if any.
     */
    _e(this, "fallback");
    me(typeof e == "string" || t$(e), "invalid value for Contract target", "target", e), n == null && (n = null);
    const s = Ox.from(t);
    Et(this, { target: e, runner: n, interface: s }), Object.defineProperty(this, z2, { value: {} });
    let o, a = null, c = null;
    if (i) {
      const d = hf(n);
      c = new DC(this.interface, d, i);
    }
    let u = /* @__PURE__ */ new Map();
    if (typeof e == "string")
      if (mn(e))
        a = e, o = Promise.resolve(e);
      else {
        const d = md(n, "resolveName");
        if (!a3(d))
          throw En("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        o = d.resolveName(e).then((m) => {
          if (m == null)
            throw En("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: e
            });
          return Js(this).addr = m, m;
        });
      }
    else
      o = e.getAddress().then((d) => {
        if (d == null)
          throw new Error("TODO");
        return Js(this).addr = d, d;
      });
    Mde(this, { addrPromise: o, addr: a, deployTx: c, subs: u });
    const f = new Proxy({}, {
      get: (d, m, y) => {
        if (typeof m == "symbol" || cb.indexOf(m) >= 0)
          return Reflect.get(d, m, y);
        try {
          return this.getEvent(m);
        } catch (b) {
          if (!$i(b, "INVALID_ARGUMENT") || b.argument !== "key")
            throw b;
        }
      },
      has: (d, m) => cb.indexOf(m) >= 0 ? Reflect.has(d, m) : Reflect.has(d, m) || this.interface.hasEvent(String(m))
    });
    return Et(this, { filters: f }), Et(this, {
      fallback: s.receive || s.fallback ? Ode(this) : null
    }), new Proxy(this, {
      get: (d, m, y) => {
        if (typeof m == "symbol" || m in d || cb.indexOf(m) >= 0)
          return Reflect.get(d, m, y);
        try {
          return d.getFunction(m);
        } catch (b) {
          if (!$i(b, "INVALID_ARGUMENT") || b.argument !== "key")
            throw b;
        }
      },
      has: (d, m) => typeof m == "symbol" || m in d || cb.indexOf(m) >= 0 ? Reflect.has(d, m) : d.interface.hasFunction(m)
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(e) {
    return new Cm(this.target, this.interface, e);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(e) {
    return new Cm(e, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await Js(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const e = hf(this.runner);
    Te(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const t = await e.getCode(await this.getAddress());
    return t === "0x" ? null : t;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const e = this.deploymentTransaction();
    if (e)
      return await e.wait(), this;
    if (await this.getDeployedCode() != null)
      return this;
    const n = hf(this.runner);
    return Te(n != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" }), new Promise((i, s) => {
      const o = async () => {
        try {
          if (await this.getDeployedCode() != null)
            return i(this);
          n.once("block", o);
        } catch (a) {
          s(a);
        }
      };
      o();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return Js(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(e) {
    return typeof e != "string" && (e = e.format()), Nde(this, e);
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(e) {
    return typeof e != "string" && (e = e.format()), Pde(this, e);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(e) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(e, t, n) {
    t == null && (t = 0), n == null && (n = "latest");
    const { addr: i, addrPromise: s } = Js(this), o = i || await s, { fragment: a, topics: c } = await kC(this, e), u = { address: o, topics: c, fromBlock: t, toBlock: n }, f = hf(this.runner);
    return Te(f, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" }), (await f.getLogs(u)).map((d) => {
      let m = a;
      if (m == null)
        try {
          m = this.interface.getEvent(d.topics[0]);
        } catch {
        }
      if (m)
        try {
          return new MC(d, this.interface, m);
        } catch (y) {
          return new q$(d, y);
        }
      return new py(d, f);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(e, t) {
    const n = await F7(this, "on", e);
    return n.listeners.push({ listener: t, once: !1 }), n.start(), this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(e, t) {
    const n = await F7(this, "once", e);
    return n.listeners.push({ listener: t, once: !0 }), n.start(), this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(e, ...t) {
    return await Px(this, e, t, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(e) {
    if (e) {
      const i = await X1(this, e);
      return i ? i.listeners.length : 0;
    }
    const { subs: t } = Js(this);
    let n = 0;
    for (const { listeners: i } of t.values())
      n += i.length;
    return n;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(e) {
    if (e) {
      const i = await X1(this, e);
      return i ? i.listeners.map(({ listener: s }) => s) : [];
    }
    const { subs: t } = Js(this);
    let n = [];
    for (const { listeners: i } of t.values())
      n = n.concat(i.map(({ listener: s }) => s));
    return n;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(e, t) {
    const n = await X1(this, e);
    if (!n)
      return this;
    if (t) {
      const i = n.listeners.map(({ listener: s }) => s).indexOf(t);
      i >= 0 && n.listeners.splice(i, 1);
    }
    return (t == null || n.listeners.length === 0) && (n.stop(), Js(this).subs.delete(n.tag)), this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(e) {
    if (e) {
      const t = await X1(this, e);
      if (!t)
        return this;
      t.stop(), Js(this).subs.delete(t.tag);
    } else {
      const { subs: t } = Js(this);
      for (const { tag: n, stop: i } of t.values())
        i(), t.delete(n);
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(e, t) {
    return await this.on(e, t);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(e, t) {
    return await this.off(e, t);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(e) {
    class t extends Cm {
      constructor(i, s = null) {
        super(i, e, s);
      }
    }
    return t;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(e, t, n) {
    return n == null && (n = null), new this(e, t, n);
  }
};
vAe = z2;
let Mx = Cm;
function $de() {
  return Mx;
}
class pm extends $de() {
}
function R4(r) {
  return r.match(/^ipfs:\/\/ipfs\//i) ? r = r.substring(12) : r.match(/^ipfs:\/\//i) ? r = r.substring(7) : me(!1, "unsupported IPFS format", "link", r), `https://gateway.ipfs.io/ipfs/${r}`;
}
class Lde {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(e) {
    /**
     *  The name.
     */
    _e(this, "name");
    Et(this, { name: e });
  }
  connect(e) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(e) {
    return !1;
  }
  /**
   *  Resovles to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(e, t) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resovles to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(e, t) {
    throw new Error("unsupported coin");
  }
}
const eL = new RegExp("^(ipfs)://(.*)$", "i"), U7 = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  eL,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
var Au, Af, Iu, Ip, p_, tL;
const Fp = class Fp {
  constructor(e, t, n) {
    ye(this, Iu);
    /**
     *  The connected provider.
     */
    _e(this, "provider");
    /**
     *  The address of the resolver.
     */
    _e(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    _e(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    ye(this, Au, void 0);
    ye(this, Af, void 0);
    Et(this, { provider: e, address: t, name: n }), ie(this, Au, null), ie(this, Af, new pm(t, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], e));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    return j(this, Au) == null && ie(this, Au, (async () => {
      try {
        return await j(this, Af).supportsInterface("0x9061b923");
      } catch (e) {
        if ($i(e, "CALL_EXCEPTION"))
          return !1;
        throw ie(this, Au, null), e;
      }
    })()), await j(this, Au);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(e) {
    if (e == null && (e = 60), e === 60)
      try {
        const s = await ke(this, Iu, Ip).call(this, "addr(bytes32)");
        return s == null || s === Ex ? null : s;
      } catch (s) {
        if ($i(s, "CALL_EXCEPTION"))
          return null;
        throw s;
      }
    if (e >= 0 && e < 2147483648) {
      let s = e + 2147483648;
      const o = await ke(this, Iu, Ip).call(this, "addr(bytes32,uint)", [s]);
      if (mn(o, 20))
        return fr(o);
    }
    let t = null;
    for (const s of this.provider.plugins)
      if (s instanceof Lde && s.supportsCoinType(e)) {
        t = s;
        break;
      }
    if (t == null)
      return null;
    const n = await ke(this, Iu, Ip).call(this, "addr(bytes32,uint)", [e]);
    if (n == null || n === "0x")
      return null;
    const i = await t.decodeAddress(e, n);
    if (i != null)
      return i;
    Te(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${e})`,
      info: { coinType: e, data: n }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(e) {
    const t = await ke(this, Iu, Ip).call(this, "text(bytes32,string)", [e]);
    return t == null || t === "0x" ? null : t;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const e = await ke(this, Iu, Ip).call(this, "contenthash(bytes32)");
    if (e == null || e === "0x")
      return null;
    const t = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (t) {
      const i = t[1] === "e3010170" ? "ipfs" : "ipns", s = parseInt(t[4], 16);
      if (t[5].length === s * 2)
        return `${i}://${lue("0x" + t[2])}`;
    }
    const n = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (n && n[1].length === 64)
      return `bzz://${n[1]}`;
    Te(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: e }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    return (await this._getAvatar()).url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const e = [{ type: "name", value: this.name }];
    try {
      const t = await this.getText("avatar");
      if (t == null)
        return e.push({ type: "!avatar", value: "" }), { url: null, linkage: e };
      e.push({ type: "avatar", value: t });
      for (let n = 0; n < U7.length; n++) {
        const i = t.match(U7[n]);
        if (i == null)
          continue;
        const s = i[1].toLowerCase();
        switch (s) {
          case "https":
          case "data":
            return e.push({ type: "url", value: t }), { linkage: e, url: t };
          case "ipfs": {
            const o = R4(t);
            return e.push({ type: "ipfs", value: t }), e.push({ type: "url", value: o }), { linkage: e, url: o };
          }
          case "erc721":
          case "erc1155": {
            const o = s === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            e.push({ type: s, value: t });
            const a = await this.getAddress();
            if (a == null)
              return e.push({ type: "!owner", value: "" }), { url: null, linkage: e };
            const c = (i[2] || "").split("/");
            if (c.length !== 2)
              return e.push({ type: `!${s}caip`, value: i[2] || "" }), { url: null, linkage: e };
            const u = c[1], f = new pm(c[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (s === "erc721") {
              const I = await f.ownerOf(u);
              if (a !== I)
                return e.push({ type: "!owner", value: I }), { url: null, linkage: e };
              e.push({ type: "owner", value: I });
            } else if (s === "erc1155") {
              const I = await f.balanceOf(a, u);
              if (!I)
                return e.push({ type: "!balance", value: "0" }), { url: null, linkage: e };
              e.push({ type: "balance", value: I.toString() });
            }
            let d = await f[o](u);
            if (d == null || d === "0x")
              return e.push({ type: "!metadata-url", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata-url-base", value: d }), s === "erc1155" && (d = d.replace("{id}", rh(u, 32).substring(2)), e.push({ type: "metadata-url-expanded", value: d })), d.match(/^ipfs:/i) && (d = R4(d)), e.push({ type: "metadata-url", value: d });
            let m = {};
            const y = await new Pc(d).send();
            y.assertOk();
            try {
              m = y.bodyJson;
            } catch {
              try {
                e.push({ type: "!metadata", value: y.bodyText });
              } catch {
                const R = y.body;
                return R && e.push({ type: "!metadata", value: wt(R) }), { url: null, linkage: e };
              }
              return { url: null, linkage: e };
            }
            if (!m)
              return e.push({ type: "!metadata", value: "" }), { url: null, linkage: e };
            e.push({ type: "metadata", value: JSON.stringify(m) });
            let b = m.image;
            if (typeof b != "string")
              return e.push({ type: "!imageUrl", value: "" }), { url: null, linkage: e };
            if (!b.match(/^(https:\/\/|data:)/i)) {
              if (b.match(eL) == null)
                return e.push({ type: "!imageUrl-ipfs", value: b }), { url: null, linkage: e };
              e.push({ type: "imageUrl-ipfs", value: b }), b = R4(b);
            }
            return e.push({ type: "url", value: b }), { linkage: e, url: b };
          }
        }
      }
    } catch {
    }
    return { linkage: e, url: null };
  }
  static async getEnsAddress(e) {
    const t = await e.getNetwork(), n = t.getPlugin("org.ethers.plugins.network.Ens");
    return Te(n, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: t }
    }), n.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(e, t) {
    var i;
    let n = t;
    for (; ; ) {
      if (n === "" || n === "." || t !== "eth" && n === "eth")
        return null;
      const s = await ke(i = Fp, p_, tL).call(i, e, n);
      if (s != null) {
        const o = new Fp(e, s, t);
        return n !== t && !await o.supportsWildcard() ? null : o;
      }
      n = n.split(".").slice(1).join(".");
    }
  }
};
Au = new WeakMap(), Af = new WeakMap(), Iu = new WeakSet(), Ip = async function(e, t) {
  t = (t || []).slice();
  const n = j(this, Af).interface;
  t.unshift(Rx(this.name));
  let i = null;
  await this.supportsWildcard() && (i = n.getFunction(e), Te(i, "missing fragment", "UNKNOWN_ERROR", {
    info: { funcName: e }
  }), t = [
    Wfe(this.name),
    n.encodeFunctionData(i, t)
  ], e = "resolve(bytes,bytes)"), t.push({
    enableCcipRead: !0
  });
  try {
    const s = await j(this, Af)[e](...t);
    return i ? n.decodeFunctionResult(i, s)[0] : s;
  } catch (s) {
    if (!$i(s, "CALL_EXCEPTION"))
      throw s;
  }
  return null;
}, p_ = new WeakSet(), tL = async function(e, t) {
  const n = await Fp.getEnsAddress(e);
  try {
    const s = await new pm(n, [
      "function resolver(bytes32) view returns (address)"
    ], e).resolver(Rx(t), {
      enableCcipRead: !0
    });
    return s === Ex ? null : s;
  } catch (i) {
    throw i;
  }
  return null;
}, ye(Fp, p_);
let V2 = Fp;
const j7 = BigInt(0);
function dn(r, e) {
  return function(t) {
    return t == null ? e : r(t);
  };
}
function $C(r) {
  return (e) => {
    if (!Array.isArray(e))
      throw new Error("not an array");
    return e.map((t) => r(t));
  };
}
function gy(r, e) {
  return (t) => {
    const n = {};
    for (const i in r) {
      let s = i;
      if (e && i in e && !(s in t)) {
        for (const o of e[i])
          if (o in t) {
            s = o;
            break;
          }
      }
      try {
        const o = r[i](t[s]);
        o !== void 0 && (n[i] = o);
      } catch (o) {
        const a = o instanceof Error ? o.message : "not-an-error";
        Te(!1, `invalid value for value.${i} (${a})`, "BAD_DATA", { value: t });
      }
    }
    return n;
  };
}
function Bde(r) {
  switch (r) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  me(!1, `invalid boolean; ${JSON.stringify(r)}`, "value", r);
}
function vg(r) {
  return me(mn(r, !0), "invalid data", "value", r), r;
}
function $o(r) {
  return me(mn(r, 32), "invalid hash", "value", r), r;
}
const Fde = gy({
  address: fr,
  blockHash: $o,
  blockNumber: nr,
  data: vg,
  index: nr,
  removed: dn(Bde, !1),
  topics: $C($o),
  transactionHash: $o,
  transactionIndex: nr
}, {
  index: ["logIndex"]
});
function Ude(r) {
  return Fde(r);
}
const jde = gy({
  hash: dn($o),
  parentHash: $o,
  number: nr,
  timestamp: nr,
  nonce: dn(vg),
  difficulty: gt,
  gasLimit: gt,
  gasUsed: gt,
  miner: dn(fr),
  extraData: vg,
  baseFeePerGas: dn(gt)
});
function Wde(r) {
  const e = jde(r);
  return e.transactions = r.transactions.map((t) => typeof t == "string" ? t : rL(t)), e;
}
const Hde = gy({
  transactionIndex: nr,
  blockNumber: nr,
  transactionHash: $o,
  address: fr,
  topics: $C($o),
  data: vg,
  index: nr,
  blockHash: $o
}, {
  index: ["logIndex"]
});
function zde(r) {
  return Hde(r);
}
const Vde = gy({
  to: dn(fr, null),
  from: dn(fr, null),
  contractAddress: dn(fr, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: nr,
  root: dn(wt),
  gasUsed: gt,
  logsBloom: dn(vg),
  blockHash: $o,
  hash: $o,
  logs: $C(zde),
  blockNumber: nr,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: gt,
  effectiveGasPrice: dn(gt),
  status: dn(nr),
  type: dn(nr, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function qde(r) {
  return Vde(r);
}
function rL(r) {
  r.to && gt(r.to) === j7 && (r.to = "0x0000000000000000000000000000000000000000");
  const e = gy({
    hash: $o,
    type: (t) => t === "0x" || t == null ? 0 : nr(t),
    accessList: dn(Dd, null),
    blockHash: dn($o, null),
    blockNumber: dn(nr, null),
    transactionIndex: dn(nr, null),
    //confirmations: allowNull(getNumber, null),
    from: fr,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: dn(gt),
    maxPriorityFeePerGas: dn(gt),
    maxFeePerGas: dn(gt),
    gasLimit: gt,
    to: dn(fr, null),
    value: gt,
    nonce: nr,
    data: vg,
    creates: dn(fr, null),
    chainId: dn(gt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"]
  })(r);
  if (e.to == null && e.creates == null && (e.creates = Vhe(e)), (r.type === 1 || r.type === 2) && r.accessList == null && (e.accessList = []), r.signature ? e.signature = ka.from(r.signature) : e.signature = ka.from(r), e.chainId == null) {
    const t = e.signature.legacyChainId;
    t != null && (e.chainId = t);
  }
  return e.blockHash && gt(e.blockHash) === j7 && (e.blockHash = null), e;
}
const Gde = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class my {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(e) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    _e(this, "name");
    Et(this, { name: e });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new my(this.name);
  }
}
class c3 extends my {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(t, n) {
    t == null && (t = 0);
    super(`org.ethers.network.plugins.GasCost#${t || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    _e(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    _e(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    _e(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    _e(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    _e(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    _e(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    _e(this, "txAccessListAddress");
    const i = { effectiveBlock: t };
    function s(o, a) {
      let c = (n || {})[o];
      c == null && (c = a), me(typeof c == "number", `invalud value for ${o}`, "costs", n), i[o] = c;
    }
    s("txBase", 21e3), s("txCreate", 32e3), s("txDataZero", 4), s("txDataNonzero", 16), s("txAccessListStorageKey", 1900), s("txAccessListAddress", 2400), Et(this, i);
  }
  clone() {
    return new c3(this.effectiveBlock, this);
  }
}
class l3 extends my {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(t, n) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    _e(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    _e(this, "targetNetwork");
    Et(this, {
      address: t || Gde,
      targetNetwork: n ?? 1
    });
  }
  clone() {
    return new l3(this.address, this.targetNetwork);
  }
}
var Lw, Bw;
class Kde extends my {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(t, n) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    ye(this, Lw, void 0);
    ye(this, Bw, void 0);
    ie(this, Lw, t), ie(this, Bw, n);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return j(this, Lw);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return j(this, Bw);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
Lw = new WeakMap(), Bw = new WeakMap();
const T4 = /* @__PURE__ */ new Map();
var O0, N0, Ru;
const Up = class Up {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(e, t) {
    ye(this, O0, void 0);
    ye(this, N0, void 0);
    ye(this, Ru, void 0);
    ie(this, O0, e), ie(this, N0, gt(t)), ie(this, Ru, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return j(this, O0);
  }
  set name(e) {
    ie(this, O0, e);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return j(this, N0);
  }
  set chainId(e) {
    ie(this, N0, gt(e, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(e) {
    if (e == null)
      return !1;
    if (typeof e == "string") {
      try {
        return this.chainId === gt(e);
      } catch {
      }
      return this.name === e;
    }
    if (typeof e == "number" || typeof e == "bigint") {
      try {
        return this.chainId === gt(e);
      } catch {
      }
      return !1;
    }
    if (typeof e == "object") {
      if (e.chainId != null) {
        try {
          return this.chainId === gt(e.chainId);
        } catch {
        }
        return !1;
      }
      return e.name != null ? this.name === e.name : !1;
    }
    return !1;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(j(this, Ru).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(e) {
    if (j(this, Ru).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return j(this, Ru).set(e.name, e.clone()), this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(e) {
    return j(this, Ru).get(e) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(e) {
    return this.plugins.filter((t) => t.name.split("#")[0] === e);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const e = new Up(this.name, this.chainId);
    return this.plugins.forEach((t) => {
      e.attachPlugin(t.clone());
    }), e;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(e) {
    const t = this.getPlugin("org.ethers.plugins.network.GasCost") || new c3();
    let n = t.txBase;
    if (e.to == null && (n += t.txCreate), e.data)
      for (let i = 2; i < e.data.length; i += 2)
        e.data.substring(i, i + 2) === "00" ? n += t.txDataZero : n += t.txDataNonzero;
    if (e.accessList) {
      const i = Dd(e.accessList);
      for (const s in i)
        n += t.txAccessListAddress + t.txAccessListStorageKey * i[s].storageKeys.length;
    }
    return n;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(e) {
    if (Zde(), e == null)
      return Up.from("mainnet");
    if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
      const t = T4.get(e);
      if (t)
        return t();
      if (typeof e == "bigint")
        return new Up("unknown", e);
      me(!1, "unknown network", "network", e);
    }
    if (typeof e.clone == "function")
      return e.clone();
    if (typeof e == "object") {
      me(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
      const t = new Up(e.name, e.chainId);
      return (e.ensAddress || e.ensNetwork != null) && t.attachPlugin(new l3(e.ensAddress, e.ensNetwork)), t;
    }
    me(!1, "invalid network", "network", e);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(e, t) {
    typeof e == "number" && (e = BigInt(e));
    const n = T4.get(e);
    n && me(!1, `conflicting network for ${JSON.stringify(n.name)}`, "nameOrChainId", e), T4.set(e, t);
  }
};
O0 = new WeakMap(), N0 = new WeakMap(), Ru = new WeakMap();
let Ca = Up;
function W7(r, e) {
  const t = String(r);
  if (!t.match(/^[0-9.]+$/))
    throw new Error(`invalid gwei value: ${r}`);
  const n = t.split(".");
  if (n.length === 1 && n.push(""), n.length !== 2)
    throw new Error(`invalid gwei value: ${r}`);
  for (; n[1].length < e; )
    n[1] += "0";
  if (n[1].length > 9) {
    let i = BigInt(n[1].substring(0, 9));
    n[1].substring(9).match(/^0+$/) || i++, n[1] = i.toString();
  }
  return BigInt(n[0] + n[1]);
}
function H7(r) {
  return new Kde(r, async (e, t, n) => {
    n.setHeader("User-Agent", "ethers");
    let i;
    try {
      const [s, o] = await Promise.all([
        n.send(),
        e()
      ]);
      i = s;
      const a = i.bodyJson.standard;
      return {
        gasPrice: o.gasPrice,
        maxFeePerGas: W7(a.maxFee, 9),
        maxPriorityFeePerGas: W7(a.maxPriorityFee, 9)
      };
    } catch (s) {
      Te(!1, `error encountered with polygon gas station (${JSON.stringify(n.url)})`, "SERVER_ERROR", { request: n, response: i, error: s });
    }
  });
}
let z7 = !1;
function Zde() {
  if (z7)
    return;
  z7 = !0;
  function r(e, t, n) {
    const i = function() {
      const s = new Ca(e, t);
      return n.ensNetwork != null && s.attachPlugin(new l3(null, n.ensNetwork)), s.attachPlugin(new c3()), (n.plugins || []).forEach((o) => {
        s.attachPlugin(o);
      }), s;
    };
    Ca.register(e, i), Ca.register(t, i), n.altNames && n.altNames.forEach((s) => {
      Ca.register(s, i);
    });
  }
  r("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }), r("ropsten", 3, { ensNetwork: 3 }), r("rinkeby", 4, { ensNetwork: 4 }), r("goerli", 5, { ensNetwork: 5 }), r("kovan", 42, { ensNetwork: 42 }), r("sepolia", 11155111, { ensNetwork: 11155111 }), r("classic", 61, {}), r("classicKotti", 6, {}), r("arbitrum", 42161, {
    ensNetwork: 1
  }), r("arbitrum-goerli", 421613, {}), r("base", 8453, { ensNetwork: 1 }), r("base-goerli", 84531, {}), r("base-sepolia", 84532, {}), r("bnb", 56, { ensNetwork: 1 }), r("bnbt", 97, {}), r("linea", 59144, { ensNetwork: 1 }), r("linea-goerli", 59140, {}), r("matic", 137, {
    ensNetwork: 1,
    plugins: [
      H7("https://gasstation.polygon.technology/v2")
    ]
  }), r("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      H7("https://gasstation-testnet.polygon.technology/v2")
    ]
  }), r("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  }), r("optimism-goerli", 420, {}), r("xdai", 100, { ensNetwork: 1 });
}
function Dx(r) {
  return JSON.parse(JSON.stringify(r));
}
var yl, Ro, Tu, hc, P0, Fb;
class Jde {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    ye(this, P0);
    ye(this, yl, void 0);
    ye(this, Ro, void 0);
    ye(this, Tu, void 0);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    ye(this, hc, void 0);
    ie(this, yl, e), ie(this, Ro, null), ie(this, Tu, 4e3), ie(this, hc, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return j(this, Tu);
  }
  set pollingInterval(e) {
    ie(this, Tu, e);
  }
  start() {
    j(this, Ro) || (ie(this, Ro, j(this, yl)._setTimeout(ke(this, P0, Fb).bind(this), j(this, Tu))), ke(this, P0, Fb).call(this));
  }
  stop() {
    j(this, Ro) && (j(this, yl)._clearTimeout(j(this, Ro)), ie(this, Ro, null));
  }
  pause(e) {
    this.stop(), e && ie(this, hc, -2);
  }
  resume() {
    this.start();
  }
}
yl = new WeakMap(), Ro = new WeakMap(), Tu = new WeakMap(), hc = new WeakMap(), P0 = new WeakSet(), Fb = async function() {
  try {
    const e = await j(this, yl).getBlockNumber();
    if (j(this, hc) === -2) {
      ie(this, hc, e);
      return;
    }
    if (e !== j(this, hc)) {
      for (let t = j(this, hc) + 1; t <= e; t++) {
        if (j(this, Ro) == null)
          return;
        await j(this, yl).emit("block", t);
      }
      ie(this, hc, e);
    }
  } catch {
  }
  j(this, Ro) != null && ie(this, Ro, j(this, yl)._setTimeout(ke(this, P0, Fb).bind(this), j(this, Tu)));
};
var If, Rf, Ou;
class LC {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(e) {
    ye(this, If, void 0);
    ye(this, Rf, void 0);
    ye(this, Ou, void 0);
    ie(this, If, e), ie(this, Ou, !1), ie(this, Rf, (t) => {
      this._poll(t, j(this, If));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(e, t) {
    throw new Error("sub-classes must override this");
  }
  start() {
    j(this, Ou) || (ie(this, Ou, !0), j(this, Rf).call(this, -2), j(this, If).on("block", j(this, Rf)));
  }
  stop() {
    j(this, Ou) && (ie(this, Ou, !1), j(this, If).off("block", j(this, Rf)));
  }
  pause(e) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
If = new WeakMap(), Rf = new WeakMap(), Ou = new WeakMap();
var M0, vl;
class Qde extends LC {
  constructor(t, n) {
    super(t);
    ye(this, M0, void 0);
    ye(this, vl, void 0);
    ie(this, M0, n), ie(this, vl, -2);
  }
  pause(t) {
    t && ie(this, vl, -2), super.pause(t);
  }
  async _poll(t, n) {
    const i = await n.getBlock(j(this, M0));
    i != null && (j(this, vl) === -2 ? ie(this, vl, i.number) : i.number > j(this, vl) && (n.emit(j(this, M0), i.number), ie(this, vl, i.number)));
  }
}
M0 = new WeakMap(), vl = new WeakMap();
var g_;
class Yde extends LC {
  constructor(t, n) {
    super(t);
    ye(this, g_, void 0);
    ie(this, g_, Dx(n));
  }
  async _poll(t, n) {
    throw new Error("@TODO");
  }
}
g_ = new WeakMap();
var D0;
class Xde extends LC {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(t, n) {
    super(t);
    ye(this, D0, void 0);
    ie(this, D0, n);
  }
  async _poll(t, n) {
    const i = await n.getTransactionReceipt(j(this, D0));
    i && n.emit(j(this, D0), i);
  }
}
D0 = new WeakMap();
var bl, k0, $0, Nu, To, m_, nL;
class BC {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(e, t) {
    ye(this, m_);
    ye(this, bl, void 0);
    ye(this, k0, void 0);
    ye(this, $0, void 0);
    ye(this, Nu, void 0);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    ye(this, To, void 0);
    ie(this, bl, e), ie(this, k0, Dx(t)), ie(this, $0, ke(this, m_, nL).bind(this)), ie(this, Nu, !1), ie(this, To, -2);
  }
  start() {
    j(this, Nu) || (ie(this, Nu, !0), j(this, To) === -2 && j(this, bl).getBlockNumber().then((e) => {
      ie(this, To, e);
    }), j(this, bl).on("block", j(this, $0)));
  }
  stop() {
    j(this, Nu) && (ie(this, Nu, !1), j(this, bl).off("block", j(this, $0)));
  }
  pause(e) {
    this.stop(), e && ie(this, To, -2);
  }
  resume() {
    this.start();
  }
}
bl = new WeakMap(), k0 = new WeakMap(), $0 = new WeakMap(), Nu = new WeakMap(), To = new WeakMap(), m_ = new WeakSet(), nL = async function(e) {
  if (j(this, To) === -2)
    return;
  const t = Dx(j(this, k0));
  t.fromBlock = j(this, To) + 1, t.toBlock = e;
  const n = await j(this, bl).getLogs(t);
  if (n.length === 0) {
    j(this, To) < e - 60 && ie(this, To, e - 60);
    return;
  }
  for (const i of n)
    j(this, bl).emit(j(this, k0), i), ie(this, To, i.blockNumber);
};
const epe = BigInt(2), tpe = 10;
function lb(r) {
  return r && typeof r.then == "function";
}
function Ub(r, e) {
  return r + ":" + JSON.stringify(e, (t, n) => {
    if (n == null)
      return "null";
    if (typeof n == "bigint")
      return `bigint:${n.toString()}`;
    if (typeof n == "string")
      return n.toLowerCase();
    if (typeof n == "object" && !Array.isArray(n)) {
      const i = Object.keys(n);
      return i.sort(), i.reduce((s, o) => (s[o] = n[o], s), {});
    }
    return n;
  });
}
class q2 {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(e) {
    /**
     *  The name fof the event.
     */
    _e(this, "name");
    Et(this, { name: e });
  }
  start() {
  }
  stop() {
  }
  pause(e) {
  }
  resume() {
  }
}
function rpe(r) {
  return JSON.parse(JSON.stringify(r));
}
function kx(r) {
  return r = Array.from(new Set(r).values()), r.sort(), r;
}
async function O4(r, e) {
  if (r == null)
    throw new Error("invalid event");
  if (Array.isArray(r) && (r = { topics: r }), typeof r == "string")
    switch (r) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return { type: r, tag: r };
    }
  if (mn(r, 32)) {
    const t = r.toLowerCase();
    return { type: "transaction", tag: Ub("tx", { hash: t }), hash: t };
  }
  if (r.orphan) {
    const t = r;
    return { type: "orphan", tag: Ub("orphan", t), filter: rpe(t) };
  }
  if (r.address || r.topics) {
    const t = r, n = {
      topics: (t.topics || []).map((i) => i == null ? null : Array.isArray(i) ? kx(i.map((s) => s.toLowerCase())) : i.toLowerCase())
    };
    if (t.address) {
      const i = [], s = [], o = (a) => {
        mn(a) ? i.push(a) : s.push((async () => {
          i.push(await ss(a, e));
        })());
      };
      Array.isArray(t.address) ? t.address.forEach(o) : o(t.address), s.length && await Promise.all(s), n.address = kx(i.map((a) => a.toLowerCase()));
    }
    return { filter: n, tag: Ub("event", n), type: "event" };
  }
  me(!1, "unknown ProviderEvent", "event", r);
}
function N4() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const npe = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
var Pi, Pu, Mi, L0, Xs, Tf, Mu, _l, Fw, Oo, B0, F0, Qi, Gs, Uw, $x, jw, Lx, Of, em, Ww, Bx, Nf, tm, U0, jb;
class ipe {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(e, t) {
    // Shares multiple identical requests made during the same 250ms
    ye(this, Qi);
    ye(this, Uw);
    ye(this, jw);
    // Account
    ye(this, Of);
    ye(this, Ww);
    ye(this, Nf);
    ye(this, U0);
    ye(this, Pi, void 0);
    ye(this, Pu, void 0);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    ye(this, Mi, void 0);
    ye(this, L0, void 0);
    ye(this, Xs, void 0);
    ye(this, Tf, void 0);
    ye(this, Mu, void 0);
    // The most recent block number if running an event or -1 if no "block" event
    ye(this, _l, void 0);
    ye(this, Fw, void 0);
    ye(this, Oo, void 0);
    ye(this, B0, void 0);
    ye(this, F0, void 0);
    if (ie(this, F0, Object.assign({}, npe, t || {})), e === "any")
      ie(this, Tf, !0), ie(this, Xs, null);
    else if (e) {
      const n = Ca.from(e);
      ie(this, Tf, !1), ie(this, Xs, Promise.resolve(n)), setTimeout(() => {
        this.emit("network", n, null);
      }, 0);
    } else
      ie(this, Tf, !1), ie(this, Xs, null);
    ie(this, _l, -1), ie(this, Mu, /* @__PURE__ */ new Map()), ie(this, Pi, /* @__PURE__ */ new Map()), ie(this, Pu, /* @__PURE__ */ new Map()), ie(this, Mi, null), ie(this, L0, !1), ie(this, Fw, 1), ie(this, Oo, /* @__PURE__ */ new Map()), ie(this, B0, !1);
  }
  get pollingInterval() {
    return j(this, F0).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(j(this, Pu).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(e) {
    if (j(this, Pu).get(e.name))
      throw new Error(`cannot replace existing plugin: ${e.name} `);
    return j(this, Pu).set(e.name, e.connect(this)), this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(e) {
    return j(this, Pu).get(e) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return j(this, B0);
  }
  set disableCcipRead(e) {
    ie(this, B0, !!e);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(e, t, n) {
    if (this.disableCcipRead || n.length === 0 || e.to == null)
      return null;
    const i = e.to.toLowerCase(), s = t.toLowerCase(), o = [];
    for (let a = 0; a < n.length; a++) {
      const c = n[a], u = c.replace("{sender}", i).replace("{data}", s), f = new Pc(u);
      c.indexOf("{data}") === -1 && (f.body = { data: s, sender: i }), this.emit("debug", { action: "sendCcipReadFetchRequest", request: f, index: a, urls: n });
      let d = "unknown error";
      const m = await f.send();
      try {
        const y = m.bodyJson;
        if (y.data)
          return this.emit("debug", { action: "receiveCcipReadFetchResult", request: f, result: y }), y.data;
        y.message && (d = y.message), this.emit("debug", { action: "receiveCcipReadFetchError", request: f, result: y });
      } catch {
      }
      Te(m.statusCode < 400 || m.statusCode >= 500, `response not found during CCIP fetch: ${d}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: e, info: { url: c, errorMessage: d } }), o.push(d);
    }
    Te(!1, `error encountered during CCIP fetch: ${o.map((a) => JSON.stringify(a)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: e,
      info: { urls: n, errorMessages: o }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(e, t) {
    return new xde(Wde(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(e, t) {
    return new py(Ude(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(e, t) {
    return new H$(qde(e), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(e, t) {
    return new pw(rL(e), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    Te(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(e) {
    Te(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
      operation: e.method,
      info: e
    });
  }
  // State
  async getBlockNumber() {
    const e = nr(await ke(this, Qi, Gs).call(this, { method: "getBlockNumber" }), "%response");
    return j(this, _l) >= 0 && ie(this, _l, e), e;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(e) {
    return ss(e, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(e) {
    if (e == null)
      return "latest";
    switch (e) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return e;
    }
    if (mn(e))
      return mn(e, 32) ? e : Mp(e);
    if (typeof e == "bigint" && (e = nr(e, "blockTag")), typeof e == "number")
      return e >= 0 ? Mp(e) : j(this, _l) >= 0 ? Mp(j(this, _l) + e) : this.getBlockNumber().then((t) => Mp(t + e));
    me(!1, "invalid blockTag", "blockTag", e);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(e) {
    const t = (e.topics || []).map((c) => c == null ? null : Array.isArray(c) ? kx(c.map((u) => u.toLowerCase())) : c.toLowerCase()), n = "blockHash" in e ? e.blockHash : void 0, i = (c, u, f) => {
      let d;
      switch (c.length) {
        case 0:
          break;
        case 1:
          d = c[0];
          break;
        default:
          c.sort(), d = c;
      }
      if (n && (u != null || f != null))
        throw new Error("invalid filter");
      const m = {};
      return d && (m.address = d), t.length && (m.topics = t), u && (m.fromBlock = u), f && (m.toBlock = f), n && (m.blockHash = n), m;
    };
    let s = [];
    if (e.address)
      if (Array.isArray(e.address))
        for (const c of e.address)
          s.push(this._getAddress(c));
      else
        s.push(this._getAddress(e.address));
    let o;
    "fromBlock" in e && (o = this._getBlockTag(e.fromBlock));
    let a;
    return "toBlock" in e && (a = this._getBlockTag(e.toBlock)), s.filter((c) => typeof c != "string").length || o != null && typeof o != "string" || a != null && typeof a != "string" ? Promise.all([Promise.all(s), o, a]).then((c) => i(c[0], c[1], c[2])) : i(s, o, a);
  }
  /**
   *  Returns or resovles to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(e) {
    const t = H2(e), n = [];
    if (["to", "from"].forEach((i) => {
      if (t[i] == null)
        return;
      const s = ss(t[i], this);
      lb(s) ? n.push(async function() {
        t[i] = await s;
      }()) : t[i] = s;
    }), t.blockTag != null) {
      const i = this._getBlockTag(t.blockTag);
      lb(i) ? n.push(async function() {
        t.blockTag = await i;
      }()) : t.blockTag = i;
    }
    return n.length ? async function() {
      return await Promise.all(n), t;
    }() : t;
  }
  async getNetwork() {
    if (j(this, Xs) == null) {
      const i = (async () => {
        try {
          const s = await this._detectNetwork();
          return this.emit("network", s, null), s;
        } catch (s) {
          throw j(this, Xs) === i && ie(this, Xs, null), s;
        }
      })();
      return ie(this, Xs, i), (await i).clone();
    }
    const e = j(this, Xs), [t, n] = await Promise.all([
      e,
      this._detectNetwork()
      // The actual connected network
    ]);
    return t.chainId !== n.chainId && (j(this, Tf) ? (this.emit("network", n, t), j(this, Xs) === e && ie(this, Xs, Promise.resolve(n))) : Te(!1, `network changed: ${t.chainId} => ${n.chainId} `, "NETWORK_ERROR", {
      event: "changed"
    })), t.clone();
  }
  async getFeeData() {
    const e = await this.getNetwork(), t = async () => {
      const { _block: i, gasPrice: s, priorityFee: o } = await Yi({
        _block: ke(this, Ww, Bx).call(this, "latest", !1),
        gasPrice: (async () => {
          try {
            const f = await ke(this, Qi, Gs).call(this, { method: "getGasPrice" });
            return gt(f, "%response");
          } catch {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const f = await ke(this, Qi, Gs).call(this, { method: "getPriorityFee" });
            return gt(f, "%response");
          } catch {
          }
          return null;
        })()
      });
      let a = null, c = null;
      const u = this._wrapBlock(i, e);
      return u && u.baseFeePerGas && (c = o ?? BigInt("1000000000"), a = u.baseFeePerGas * epe + c), new L7(s, a, c);
    }, n = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (n) {
      const i = new Pc(n.url), s = await n.processFunc(t, this, i);
      return new L7(s.gasPrice, s.maxFeePerGas, s.maxPriorityFeePerGas);
    }
    return await t();
  }
  async estimateGas(e) {
    let t = this._getTransactionRequest(e);
    return lb(t) && (t = await t), gt(await ke(this, Qi, Gs).call(this, {
      method: "estimateGas",
      transaction: t
    }), "%response");
  }
  async call(e) {
    const { tx: t, blockTag: n } = await Yi({
      tx: this._getTransactionRequest(e),
      blockTag: this._getBlockTag(e.blockTag)
    });
    return await ke(this, jw, Lx).call(this, ke(this, Uw, $x).call(this, t, n, e.enableCcipRead ? 0 : -1));
  }
  async getBalance(e, t) {
    return gt(await ke(this, Of, em).call(this, { method: "getBalance" }, e, t), "%response");
  }
  async getTransactionCount(e, t) {
    return nr(await ke(this, Of, em).call(this, { method: "getTransactionCount" }, e, t), "%response");
  }
  async getCode(e, t) {
    return wt(await ke(this, Of, em).call(this, { method: "getCode" }, e, t));
  }
  async getStorage(e, t, n) {
    const i = gt(t, "position");
    return wt(await ke(this, Of, em).call(this, { method: "getStorage", position: i }, e, n));
  }
  // Write
  async broadcastTransaction(e) {
    const { blockNumber: t, hash: n, network: i } = await Yi({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: e
      }),
      network: this.getNetwork()
    }), s = j2.from(e);
    if (s.hash !== n)
      throw new Error("@TODO: the returned hash did not match");
    return this._wrapTransactionResponse(s, i).replaceableTransaction(t);
  }
  // Queries
  async getBlock(e, t) {
    const { network: n, params: i } = await Yi({
      network: this.getNetwork(),
      params: ke(this, Ww, Bx).call(this, e, !!t)
    });
    return i == null ? null : this._wrapBlock(i, n);
  }
  async getTransaction(e) {
    const { network: t, params: n } = await Yi({
      network: this.getNetwork(),
      params: ke(this, Qi, Gs).call(this, { method: "getTransaction", hash: e })
    });
    return n == null ? null : this._wrapTransactionResponse(n, t);
  }
  async getTransactionReceipt(e) {
    const { network: t, params: n } = await Yi({
      network: this.getNetwork(),
      params: ke(this, Qi, Gs).call(this, { method: "getTransactionReceipt", hash: e })
    });
    if (n == null)
      return null;
    if (n.gasPrice == null && n.effectiveGasPrice == null) {
      const i = await ke(this, Qi, Gs).call(this, { method: "getTransaction", hash: e });
      if (i == null)
        throw new Error("report this; could not find tx or effectiveGasPrice");
      n.effectiveGasPrice = i.gasPrice;
    }
    return this._wrapTransactionReceipt(n, t);
  }
  async getTransactionResult(e) {
    const { result: t } = await Yi({
      network: this.getNetwork(),
      result: ke(this, Qi, Gs).call(this, { method: "getTransactionResult", hash: e })
    });
    return t == null ? null : wt(t);
  }
  // Bloom-filter Queries
  async getLogs(e) {
    let t = this._getFilter(e);
    lb(t) && (t = await t);
    const { network: n, params: i } = await Yi({
      network: this.getNetwork(),
      params: ke(this, Qi, Gs).call(this, { method: "getLogs", filter: t })
    });
    return i.map((s) => this._wrapLog(s, n));
  }
  // ENS
  _getProvider(e) {
    Te(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(e) {
    return await V2.fromName(this, e);
  }
  async getAvatar(e) {
    const t = await this.getResolver(e);
    return t ? await t.getAvatar() : null;
  }
  async resolveName(e) {
    const t = await this.getResolver(e);
    return t ? await t.getAddress() : null;
  }
  async lookupAddress(e) {
    e = fr(e);
    const t = Rx(e.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const n = await V2.getEnsAddress(this), s = await new pm(n, [
        "function resolver(bytes32) view returns (address)"
      ], this).resolver(t);
      if (s == null || s === Ex)
        return null;
      const a = await new pm(s, [
        "function name(bytes32) view returns (string)"
      ], this).name(t);
      return await this.resolveName(a) !== e ? null : a;
    } catch (n) {
      if ($i(n, "BAD_DATA") && n.value === "0x" || $i(n, "CALL_EXCEPTION"))
        return null;
      throw n;
    }
    return null;
  }
  async waitForTransaction(e, t, n) {
    const i = t ?? 1;
    return i === 0 ? this.getTransactionReceipt(e) : new Promise(async (s, o) => {
      let a = null;
      const c = async (u) => {
        try {
          const f = await this.getTransactionReceipt(e);
          if (f != null && u - f.blockNumber + 1 >= i) {
            s(f), a && (clearTimeout(a), a = null);
            return;
          }
        } catch (f) {
          console.log("EEE", f);
        }
        this.once("block", c);
      };
      n != null && (a = setTimeout(() => {
        a != null && (a = null, this.off("block", c), o(En("timeout", "TIMEOUT", { reason: "timeout" })));
      }, n)), c(await this.getBlockNumber());
    });
  }
  async waitForBlock(e) {
    Te(!1, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(e) {
    const t = j(this, Oo).get(e);
    t && (t.timer && clearTimeout(t.timer), j(this, Oo).delete(e));
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(e, t) {
    t == null && (t = 0);
    const n = S1(this, Fw)._++, i = () => {
      j(this, Oo).delete(n), e();
    };
    if (this.paused)
      j(this, Oo).set(n, { timer: null, func: i, time: t });
    else {
      const s = setTimeout(i, t);
      j(this, Oo).set(n, { timer: s, func: i, time: N4() });
    }
    return n;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(e) {
    for (const t of j(this, Pi).values())
      e(t.subscriber);
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(e) {
    switch (e.type) {
      case "debug":
      case "error":
      case "network":
        return new q2(e.type);
      case "block": {
        const t = new Jde(this);
        return t.pollingInterval = this.pollingInterval, t;
      }
      case "safe":
      case "finalized":
        return new Qde(this, e.type);
      case "event":
        return new BC(this, e.filter);
      case "transaction":
        return new Xde(this, e.hash);
      case "orphan":
        return new Yde(this, e.filter);
    }
    throw new Error(`unsupported event: ${e.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(e, t) {
    for (const n of j(this, Pi).values())
      if (n.subscriber === e) {
        n.started && n.subscriber.stop(), n.subscriber = t, n.started && t.start(), j(this, Mi) != null && t.pause(j(this, Mi));
        break;
      }
  }
  async on(e, t) {
    const n = await ke(this, U0, jb).call(this, e);
    return n.listeners.push({ listener: t, once: !1 }), n.started || (n.subscriber.start(), n.started = !0, j(this, Mi) != null && n.subscriber.pause(j(this, Mi))), this;
  }
  async once(e, t) {
    const n = await ke(this, U0, jb).call(this, e);
    return n.listeners.push({ listener: t, once: !0 }), n.started || (n.subscriber.start(), n.started = !0, j(this, Mi) != null && n.subscriber.pause(j(this, Mi))), this;
  }
  async emit(e, ...t) {
    const n = await ke(this, Nf, tm).call(this, e, t);
    if (!n || n.listeners.length === 0)
      return !1;
    const i = n.listeners.length;
    return n.listeners = n.listeners.filter(({ listener: s, once: o }) => {
      const a = new Ak(this, o ? null : s, e);
      try {
        s.call(this, ...t, a);
      } catch {
      }
      return !o;
    }), n.listeners.length === 0 && (n.started && n.subscriber.stop(), j(this, Pi).delete(n.tag)), i > 0;
  }
  async listenerCount(e) {
    if (e) {
      const n = await ke(this, Nf, tm).call(this, e);
      return n ? n.listeners.length : 0;
    }
    let t = 0;
    for (const { listeners: n } of j(this, Pi).values())
      t += n.length;
    return t;
  }
  async listeners(e) {
    if (e) {
      const n = await ke(this, Nf, tm).call(this, e);
      return n ? n.listeners.map(({ listener: i }) => i) : [];
    }
    let t = [];
    for (const { listeners: n } of j(this, Pi).values())
      t = t.concat(n.map(({ listener: i }) => i));
    return t;
  }
  async off(e, t) {
    const n = await ke(this, Nf, tm).call(this, e);
    if (!n)
      return this;
    if (t) {
      const i = n.listeners.map(({ listener: s }) => s).indexOf(t);
      i >= 0 && n.listeners.splice(i, 1);
    }
    return (!t || n.listeners.length === 0) && (n.started && n.subscriber.stop(), j(this, Pi).delete(n.tag)), this;
  }
  async removeAllListeners(e) {
    if (e) {
      const { tag: t, started: n, subscriber: i } = await ke(this, U0, jb).call(this, e);
      n && i.stop(), j(this, Pi).delete(t);
    } else
      for (const [t, { started: n, subscriber: i }] of j(this, Pi))
        n && i.stop(), j(this, Pi).delete(t);
    return this;
  }
  // Alias for "on"
  async addListener(e, t) {
    return await this.on(e, t);
  }
  // Alias for "off"
  async removeListener(e, t) {
    return this.off(e, t);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return j(this, L0);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const e of j(this, Oo).keys())
      this._clearTimeout(e);
    ie(this, L0, !0);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return j(this, Mi) != null;
  }
  set paused(e) {
    !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(e) {
    if (ie(this, _l, -1), j(this, Mi) != null) {
      if (j(this, Mi) == !!e)
        return;
      Te(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((t) => t.pause(e)), ie(this, Mi, !!e);
    for (const t of j(this, Oo).values())
      t.timer && clearTimeout(t.timer), t.time = N4() - t.time;
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (j(this, Mi) != null) {
      this._forEachSubscriber((e) => e.resume()), ie(this, Mi, null);
      for (const e of j(this, Oo).values()) {
        let t = e.time;
        t < 0 && (t = 0), e.time = N4(), setTimeout(e.func, t);
      }
    }
  }
}
Pi = new WeakMap(), Pu = new WeakMap(), Mi = new WeakMap(), L0 = new WeakMap(), Xs = new WeakMap(), Tf = new WeakMap(), Mu = new WeakMap(), _l = new WeakMap(), Fw = new WeakMap(), Oo = new WeakMap(), B0 = new WeakMap(), F0 = new WeakMap(), Qi = new WeakSet(), Gs = async function(e) {
  const t = j(this, F0).cacheTimeout;
  if (t < 0)
    return await this._perform(e);
  const n = Ub(e.method, e);
  let i = j(this, Mu).get(n);
  return i || (i = this._perform(e), j(this, Mu).set(n, i), setTimeout(() => {
    j(this, Mu).get(n) === i && j(this, Mu).delete(n);
  }, t)), await i;
}, Uw = new WeakSet(), $x = async function(e, t, n) {
  Te(n < tpe, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, e, { blockTag: t, enableCcipRead: !0 })
  });
  const i = H2(e);
  try {
    return wt(await this._perform({ method: "call", transaction: i, blockTag: t }));
  } catch (s) {
    if (!this.disableCcipRead && vC(s) && s.data && n >= 0 && t === "latest" && i.to != null && xn(s.data, 0, 4) === "0x556f1830") {
      const o = s.data, a = await ss(i.to, this);
      let c;
      try {
        c = lpe(xn(s.data, 4));
      } catch (d) {
        Te(!1, d.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: i,
          info: { data: o }
        });
      }
      Te(c.sender.toLowerCase() === a.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: o,
        reason: "OffchainLookup",
        transaction: i,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: c.errorArgs
        }
      });
      const u = await this.ccipReadFetch(i, c.calldata, c.urls);
      Te(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: i,
        info: { data: s.data, errorArgs: c.errorArgs }
      });
      const f = {
        to: a,
        data: Zn([c.selector, cpe([u, c.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: f });
      try {
        const d = await ke(this, Uw, $x).call(this, f, t, n + 1);
        return this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, f), result: d }), d;
      } catch (d) {
        throw this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, f), error: d }), d;
      }
    }
    throw s;
  }
}, jw = new WeakSet(), Lx = async function(e) {
  const { value: t } = await Yi({
    network: this.getNetwork(),
    value: e
  });
  return t;
}, Of = new WeakSet(), em = async function(e, t, n) {
  let i = this._getAddress(t), s = this._getBlockTag(n);
  return (typeof i != "string" || typeof s != "string") && ([i, s] = await Promise.all([i, s])), await ke(this, jw, Lx).call(this, ke(this, Qi, Gs).call(this, Object.assign(e, { address: i, blockTag: s })));
}, Ww = new WeakSet(), Bx = async function(e, t) {
  if (mn(e, 32))
    return await ke(this, Qi, Gs).call(this, {
      method: "getBlock",
      blockHash: e,
      includeTransactions: t
    });
  let n = this._getBlockTag(e);
  return typeof n != "string" && (n = await n), await ke(this, Qi, Gs).call(this, {
    method: "getBlock",
    blockTag: n,
    includeTransactions: t
  });
}, Nf = new WeakSet(), tm = async function(e, t) {
  let n = await O4(e, this);
  return n.type === "event" && t && t.length > 0 && t[0].removed === !0 && (n = await O4({ orphan: "drop-log", log: t[0] }, this)), j(this, Pi).get(n.tag) || null;
}, U0 = new WeakSet(), jb = async function(e) {
  const t = await O4(e, this), n = t.tag;
  let i = j(this, Pi).get(n);
  return i || (i = { subscriber: this._getSubscriber(t), tag: n, addressableMap: /* @__PURE__ */ new WeakMap(), nameMap: /* @__PURE__ */ new Map(), started: !1, listeners: [] }, j(this, Pi).set(n, i)), i;
};
function spe(r, e) {
  try {
    const t = Fx(r, e);
    if (t)
      return bC(t);
  } catch {
  }
  return null;
}
function Fx(r, e) {
  if (r === "0x")
    return null;
  try {
    const t = nr(xn(r, e, e + 32)), n = nr(xn(r, t, t + 32));
    return xn(r, t + 32, t + 32 + n);
  } catch {
  }
  return null;
}
function V7(r) {
  const e = to(r);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function ope(r) {
  if (r.length % 32 === 0)
    return r;
  const e = new Uint8Array(Math.ceil(r.length / 32) * 32);
  return e.set(r), e;
}
const ape = new Uint8Array([]);
function cpe(r) {
  const e = [];
  let t = 0;
  for (let n = 0; n < r.length; n++)
    e.push(ape), t += 32;
  for (let n = 0; n < r.length; n++) {
    const i = Tr(r[n]);
    e[n] = V7(t), e.push(V7(i.length)), e.push(ope(i)), t += 32 + Math.ceil(i.length / 32) * 32;
  }
  return Zn(e);
}
const q7 = "0x0000000000000000000000000000000000000000000000000000000000000000";
function lpe(r) {
  const e = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  Te(Zp(r) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const t = xn(r, 0, 32);
  Te(xn(t, 0, 12) === xn(q7, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  }), e.sender = xn(t, 12);
  try {
    const n = [], i = nr(xn(r, 32, 64)), s = nr(xn(r, i, i + 32)), o = xn(r, i + 32);
    for (let a = 0; a < s; a++) {
      const c = spe(o, a * 32);
      if (c == null)
        throw new Error("abort");
      n.push(c);
    }
    e.urls = n;
  } catch {
    Te(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const n = Fx(r, 64);
    if (n == null)
      throw new Error("abort");
    e.calldata = n;
  } catch {
    Te(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  Te(xn(r, 100, 128) === xn(q7, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  }), e.selector = xn(r, 96, 100);
  try {
    const n = Fx(r, 128);
    if (n == null)
      throw new Error("abort");
    e.extraData = n;
  } catch {
    Te(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((n) => e[n]), e;
}
function hp(r, e) {
  if (r.provider)
    return r.provider;
  Te(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
}
async function G7(r, e) {
  let t = H2(e);
  if (t.to != null && (t.to = ss(t.to, r)), t.from != null) {
    const n = t.from;
    t.from = Promise.all([
      r.getAddress(),
      ss(n, r)
    ]).then(([i, s]) => (me(i.toLowerCase() === s.toLowerCase(), "transaction from mismatch", "tx.from", s), i));
  } else
    t.from = r.getAddress();
  return await Yi(t);
}
class upe {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(e) {
    /**
     *  The provider this signer is connected to.
     */
    _e(this, "provider");
    Et(this, { provider: e || null });
  }
  async getNonce(e) {
    return hp(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e);
  }
  async populateCall(e) {
    return await G7(this, e);
  }
  async populateTransaction(e) {
    const t = hp(this, "populateTransaction"), n = await G7(this, e);
    n.nonce == null && (n.nonce = await this.getNonce("pending")), n.gasLimit == null && (n.gasLimit = await this.estimateGas(n));
    const i = await this.provider.getNetwork();
    if (n.chainId != null) {
      const o = gt(n.chainId);
      me(o === i.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId);
    } else
      n.chainId = i.chainId;
    const s = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null;
    if (n.gasPrice != null && (n.type === 2 || s) ? me(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (n.type === 0 || n.type === 1) && s && me(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (n.type === 2 || n.type == null) && n.maxFeePerGas != null && n.maxPriorityFeePerGas != null)
      n.type = 2;
    else if (n.type === 0 || n.type === 1) {
      const o = await t.getFeeData();
      Te(o.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      }), n.gasPrice == null && (n.gasPrice = o.gasPrice);
    } else {
      const o = await t.getFeeData();
      if (n.type == null)
        if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
          if (n.type = 2, n.gasPrice != null) {
            const a = n.gasPrice;
            delete n.gasPrice, n.maxFeePerGas = a, n.maxPriorityFeePerGas = a;
          } else
            n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
        else
          o.gasPrice != null ? (Te(!s, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          }), n.gasPrice == null && (n.gasPrice = o.gasPrice), n.type = 0) : Te(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
      else
        n.type === 2 && (n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas));
    }
    return await Yi(n);
  }
  async estimateGas(e) {
    return hp(this, "estimateGas").estimateGas(await this.populateCall(e));
  }
  async call(e) {
    return hp(this, "call").call(await this.populateCall(e));
  }
  async resolveName(e) {
    return await hp(this, "resolveName").resolveName(e);
  }
  async sendTransaction(e) {
    const t = hp(this, "sendTransaction"), n = await this.populateTransaction(e);
    delete n.from;
    const i = j2.from(n);
    return await t.broadcastTransaction(await this.signTransaction(i));
  }
}
const K7 = /* @__PURE__ */ new Set();
function hpe(r) {
  K7.has(r) || (K7.add(r), console.log("========= NOTICE ========="), console.log(`Request-Rate Exceeded for ${r} (this message will not be repeated)`), console.log(""), console.log("The default API keys for each service are provided as a highly-throttled,"), console.log("community resource for low-traffic projects and early prototyping."), console.log(""), console.log("While your application will continue to function, we highly recommended"), console.log("signing up for your own API keys to improve performance, increase your"), console.log("request rate/limit and enable other perks, such as metrics and advanced APIs."), console.log(""), console.log("For more details: https://docs.ethers.org/api-keys/"), console.log("=========================="));
}
function fpe(r) {
  return JSON.parse(JSON.stringify(r));
}
var Rs, fc, Pf, Du, Mf, j0, Hw, Ux, zw, jx;
class iL {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(e) {
    ye(this, Hw);
    ye(this, zw);
    ye(this, Rs, void 0);
    ye(this, fc, void 0);
    ye(this, Pf, void 0);
    ye(this, Du, void 0);
    ye(this, Mf, void 0);
    ye(this, j0, void 0);
    ie(this, Rs, e), ie(this, fc, null), ie(this, Pf, ke(this, Hw, Ux).bind(this)), ie(this, Du, !1), ie(this, Mf, null), ie(this, j0, !1);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(e) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(e, t) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(e) {
    throw new Error("subclasses must override this");
  }
  start() {
    j(this, Du) || (ie(this, Du, !0), ke(this, Hw, Ux).call(this, -2));
  }
  stop() {
    j(this, Du) && (ie(this, Du, !1), ie(this, j0, !0), ke(this, zw, jx).call(this), j(this, Rs).off("block", j(this, Pf)));
  }
  pause(e) {
    e && ke(this, zw, jx).call(this), j(this, Rs).off("block", j(this, Pf));
  }
  resume() {
    this.start();
  }
}
Rs = new WeakMap(), fc = new WeakMap(), Pf = new WeakMap(), Du = new WeakMap(), Mf = new WeakMap(), j0 = new WeakMap(), Hw = new WeakSet(), Ux = async function(e) {
  try {
    j(this, fc) == null && ie(this, fc, this._subscribe(j(this, Rs)));
    let t = null;
    try {
      t = await j(this, fc);
    } catch (s) {
      if (!$i(s, "UNSUPPORTED_OPERATION") || s.operation !== "eth_newFilter")
        throw s;
    }
    if (t == null) {
      ie(this, fc, null), j(this, Rs)._recoverSubscriber(this, this._recover(j(this, Rs)));
      return;
    }
    const n = await j(this, Rs).getNetwork();
    if (j(this, Mf) || ie(this, Mf, n), j(this, Mf).chainId !== n.chainId)
      throw new Error("chaid changed");
    if (j(this, j0))
      return;
    const i = await j(this, Rs).send("eth_getFilterChanges", [t]);
    await this._emitResults(j(this, Rs), i);
  } catch (t) {
    console.log("@TODO", t);
  }
  j(this, Rs).once("block", j(this, Pf));
}, zw = new WeakSet(), jx = function() {
  const e = j(this, fc);
  e && (ie(this, fc, null), e.then((t) => {
    j(this, Rs).send("eth_uninstallFilter", [t]);
  }));
};
var Df;
class dpe extends iL {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(t, n) {
    super(t);
    ye(this, Df, void 0);
    ie(this, Df, fpe(n));
  }
  _recover(t) {
    return new BC(t, j(this, Df));
  }
  async _subscribe(t) {
    return await t.send("eth_newFilter", [j(this, Df)]);
  }
  async _emitResults(t, n) {
    for (const i of n)
      t.emit(j(this, Df), t._wrapLog(i, t._network));
  }
}
Df = new WeakMap();
class ppe extends iL {
  async _subscribe(e) {
    return await e.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(e, t) {
    for (const n of t)
      e.emit("pending", n);
  }
}
const gpe = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Wb(r) {
  if (r == null || gpe.indexOf(typeof r) >= 0 || typeof r.getAddress == "function")
    return r;
  if (Array.isArray(r))
    return r.map(Wb);
  if (typeof r == "object")
    return Object.keys(r).reduce((e, t) => (e[t] = r[t], e), {});
  throw new Error(`should not happen: ${r} (${typeof r})`);
}
function mpe(r) {
  return new Promise((e) => {
    setTimeout(e, r);
  });
}
function fp(r) {
  return r && r.toLowerCase();
}
function Z7(r) {
  return r && typeof r.pollingInterval == "number";
}
const wpe = {
  polling: !1,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class P4 extends upe {
  constructor(t, n) {
    super(t);
    _e(this, "address");
    n = fr(n), Et(this, { address: n });
  }
  connect(t) {
    Te(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(t) {
    return await this.populateCall(t);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(t) {
    const n = Wb(t), i = [];
    if (n.from) {
      const o = n.from;
      i.push((async () => {
        const a = await ss(o, this.provider);
        me(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", t), n.from = a;
      })());
    } else
      n.from = this.address;
    if (n.gasLimit == null && i.push((async () => {
      n.gasLimit = await this.provider.estimateGas({ ...n, from: this.address });
    })()), n.to != null) {
      const o = n.to;
      i.push((async () => {
        n.to = await ss(o, this.provider);
      })());
    }
    i.length && await Promise.all(i);
    const s = this.provider.getRpcTransaction(n);
    return this.provider.send("eth_sendTransaction", [s]);
  }
  async sendTransaction(t) {
    const n = await this.provider.getBlockNumber(), i = await this.sendUncheckedTransaction(t);
    return await new Promise((s, o) => {
      const a = [1e3, 100];
      let c = 0;
      const u = async () => {
        try {
          const f = await this.provider.getTransaction(i);
          if (f != null) {
            s(f.replaceableTransaction(n));
            return;
          }
        } catch (f) {
          if ($i(f, "CANCELLED") || $i(f, "BAD_DATA") || $i(f, "NETWORK_ERROR")) {
            f.info == null && (f.info = {}), f.info.sendTransactionHash = i, o(f);
            return;
          }
          if ($i(f, "INVALID_ARGUMENT") && (c++, f.info == null && (f.info = {}), f.info.sendTransactionHash = i, c > 10)) {
            o(f);
            return;
          }
          this.provider.emit("error", En("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: f }));
        }
        this.provider._setTimeout(() => {
          u();
        }, a.pop() || 4e3);
      };
      u();
    });
  }
  async signTransaction(t) {
    const n = Wb(t);
    if (n.from) {
      const s = await ss(n.from, this.provider);
      me(s != null && s.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", t), n.from = s;
    } else
      n.from = this.address;
    const i = this.provider.getRpcTransaction(n);
    return await this.provider.send("eth_signTransaction", [i]);
  }
  async signMessage(t) {
    const n = typeof t == "string" ? Tl(t) : t;
    return await this.provider.send("personal_sign", [
      wt(n),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(t, n, i) {
    const s = Wb(i), o = await W2.resolveNames(t, n, s, async (a) => {
      const c = await ss(a);
      return me(c != null, "TypedData does not support null address", "value", a), c;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(W2.getPayload(o.domain, n, o.value))
    ]);
  }
  async unlock(t) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      t,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(t) {
    const n = typeof t == "string" ? Tl(t) : t;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      wt(n)
    ]);
  }
}
var kf, W0, El, dc, ya, No, Ts, Vw, Wx;
class sL extends ipe {
  constructor(t, n) {
    super(t, n);
    ye(this, Vw);
    ye(this, kf, void 0);
    // The next ID to use for the JSON-RPC ID field
    ye(this, W0, void 0);
    // Payloads are queued and triggered in batches using the drainTimer
    ye(this, El, void 0);
    ye(this, dc, void 0);
    ye(this, ya, void 0);
    ye(this, No, void 0);
    ye(this, Ts, void 0);
    ie(this, W0, 1), ie(this, kf, Object.assign({}, wpe, n || {})), ie(this, El, []), ie(this, dc, null), ie(this, No, null), ie(this, Ts, null);
    {
      let s = null;
      const o = new Promise((a) => {
        s = a;
      });
      ie(this, ya, { promise: o, resolve: s });
    }
    const i = this._getOption("staticNetwork");
    typeof i == "boolean" ? (me(!i || t !== "any", "staticNetwork cannot be used on special network 'any'", "options", n), i && t != null && ie(this, No, Ca.from(t))) : i && (me(t == null || i.matches(t), "staticNetwork MUST match network object", "options", n), ie(this, No, i));
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(t) {
    return j(this, kf)[t];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    return Te(j(this, No), "network is not available yet", "NETWORK_ERROR"), j(this, No);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(t) {
    if (t.method === "call" || t.method === "estimateGas") {
      let i = t.transaction;
      if (i && i.type != null && gt(i.type) && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
        const s = await this.getFeeData();
        s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (t = Object.assign({}, t, {
          transaction: Object.assign({}, i, { type: void 0 })
        }));
      }
    }
    const n = this.getRpcRequest(t);
    return n != null ? await this.send(n.method, n.args) : super._perform(t);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const t = this._getOption("staticNetwork");
    if (t)
      if (t === !0) {
        if (j(this, No))
          return j(this, No);
      } else
        return t;
    return j(this, Ts) ? await j(this, Ts) : this.ready ? (ie(this, Ts, (async () => {
      try {
        const n = Ca.from(gt(await this.send("eth_chainId", [])));
        return ie(this, Ts, null), n;
      } catch (n) {
        throw ie(this, Ts, null), n;
      }
    })()), await j(this, Ts)) : (ie(this, Ts, (async () => {
      const n = {
        id: S1(this, W0)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload: n });
      let i;
      try {
        i = (await this._send(n))[0], ie(this, Ts, null);
      } catch (s) {
        throw ie(this, Ts, null), this.emit("debug", { action: "receiveRpcError", error: s }), s;
      }
      if (this.emit("debug", { action: "receiveRpcResult", result: i }), "result" in i)
        return Ca.from(gt(i.result));
      throw this.getRpcError(n, i);
    })()), await j(this, Ts));
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    j(this, ya) == null || j(this, ya).resolve == null || (j(this, ya).resolve(), ie(this, ya, null), (async () => {
      for (; j(this, No) == null && !this.destroyed; )
        try {
          ie(this, No, await this._detectNetwork());
        } catch (t) {
          if (this.destroyed)
            break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", En("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: t } })), await mpe(1e3);
        }
      ke(this, Vw, Wx).call(this);
    })());
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (j(this, ya) != null)
      return await j(this, ya).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(t) {
    return t.type === "pending" ? new ppe(this) : t.type === "event" ? this._getOption("polling") ? new BC(this, t.filter) : new dpe(this, t.filter) : t.type === "orphan" && t.filter.orphan === "drop-log" ? new q2("orphan") : super._getSubscriber(t);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return j(this, ya) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(t) {
    const n = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((i) => {
      if (t[i] == null)
        return;
      let s = i;
      i === "gasLimit" && (s = "gas"), n[s] = Mp(gt(t[i], `tx.${i}`));
    }), ["from", "to", "data"].forEach((i) => {
      t[i] != null && (n[i] = wt(t[i]));
    }), t.accessList && (n.accessList = Dd(t.accessList)), n;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(t) {
    switch (t.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [fp(t.address), t.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [fp(t.address), t.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [fp(t.address), t.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            fp(t.address),
            "0x" + t.position.toString(16),
            t.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [t.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in t)
          return {
            method: "eth_getBlockByNumber",
            args: [t.blockTag, !!t.includeTransactions]
          };
        if ("blockHash" in t)
          return {
            method: "eth_getBlockByHash",
            args: [t.blockHash, !!t.includeTransactions]
          };
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [t.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [t.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(t.transaction), t.blockTag]
        };
      case "estimateGas":
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(t.transaction)]
        };
      case "getLogs":
        return t.filter && t.filter.address != null && (Array.isArray(t.filter.address) ? t.filter.address = t.filter.address.map(fp) : t.filter.address = fp(t.filter.address)), { method: "eth_getLogs", args: [t.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(t, n) {
    const { method: i } = t, { error: s } = n;
    if (i === "eth_estimateGas" && s.message) {
      const c = s.message;
      if (!c.match(/revert/i) && c.match(/insufficient funds/i))
        return En("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: t.params[0],
          info: { payload: t, error: s }
        });
    }
    if (i === "eth_call" || i === "eth_estimateGas") {
      const c = Hx(s), u = dw.getBuiltinCallException(i === "eth_call" ? "call" : "estimateGas", t.params[0], c ? c.data : null);
      return u.info = { error: s, payload: t }, u;
    }
    const o = JSON.stringify(vpe(s));
    if (typeof s.message == "string" && s.message.match(/user denied|ethers-user-denied/i))
      return En("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[i] || "unknown",
        reason: "rejected",
        info: { payload: t, error: s }
      });
    if (i === "eth_sendRawTransaction" || i === "eth_sendTransaction") {
      const c = t.params[0];
      if (o.match(/insufficient funds|base fee exceeds gas limit/i))
        return En("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: c,
          info: { error: s }
        });
      if (o.match(/nonce/i) && o.match(/too low/i))
        return En("nonce has already been used", "NONCE_EXPIRED", { transaction: c, info: { error: s } });
      if (o.match(/replacement transaction/i) && o.match(/underpriced/i))
        return En("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: c, info: { error: s } });
      if (o.match(/only replay-protected/i))
        return En("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: i,
          info: { transaction: c, info: { error: s } }
        });
    }
    let a = !!o.match(/the method .* does not exist/i);
    return a || s && s.details && s.details.startsWith("Unauthorized method:") && (a = !0), a ? En("unsupported operation", "UNSUPPORTED_OPERATION", {
      operation: t.method,
      info: { error: s, payload: t }
    }) : En("could not coalesce error", "UNKNOWN_ERROR", { error: s, payload: t });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(t, n) {
    if (this.destroyed)
      return Promise.reject(En("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: t }));
    const i = S1(this, W0)._++, s = new Promise((o, a) => {
      j(this, El).push({
        resolve: o,
        reject: a,
        payload: { method: t, params: n, id: i, jsonrpc: "2.0" }
      });
    });
    return ke(this, Vw, Wx).call(this), s;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(t) {
    t == null && (t = 0);
    const n = this.send("eth_accounts", []);
    if (typeof t == "number") {
      const s = await n;
      if (t >= s.length)
        throw new Error("no such account");
      return new P4(this, s[t]);
    }
    const { accounts: i } = await Yi({
      network: this.getNetwork(),
      accounts: n
    });
    t = fr(t);
    for (const s of i)
      if (fr(s) === t)
        return new P4(this, t);
    throw new Error("invalid account");
  }
  async listAccounts() {
    return (await this.send("eth_accounts", [])).map((n) => new P4(this, n));
  }
  destroy() {
    j(this, dc) && (clearTimeout(j(this, dc)), ie(this, dc, null));
    for (const { payload: t, reject: n } of j(this, El))
      n(En("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: t.method }));
    ie(this, El, []), super.destroy();
  }
}
kf = new WeakMap(), W0 = new WeakMap(), El = new WeakMap(), dc = new WeakMap(), ya = new WeakMap(), No = new WeakMap(), Ts = new WeakMap(), Vw = new WeakSet(), Wx = function() {
  if (j(this, dc))
    return;
  const t = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  ie(this, dc, setTimeout(() => {
    ie(this, dc, null);
    const n = j(this, El);
    for (ie(this, El, []); n.length; ) {
      const i = [n.shift()];
      for (; n.length && i.length !== j(this, kf).batchMaxCount; )
        if (i.push(n.shift()), JSON.stringify(i.map((o) => o.payload)).length > j(this, kf).batchMaxSize) {
          n.unshift(i.pop());
          break;
        }
      (async () => {
        const s = i.length === 1 ? i[0].payload : i.map((o) => o.payload);
        this.emit("debug", { action: "sendRpcPayload", payload: s });
        try {
          const o = await this._send(s);
          this.emit("debug", { action: "receiveRpcResult", result: o });
          for (const { resolve: a, reject: c, payload: u } of i) {
            if (this.destroyed) {
              c(En("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: u.method }));
              continue;
            }
            const f = o.filter((d) => d.id === u.id)[0];
            if (f == null) {
              const d = En("missing response for request", "BAD_DATA", {
                value: o,
                info: { payload: u }
              });
              this.emit("error", d), c(d);
              continue;
            }
            if ("error" in f) {
              c(this.getRpcError(u, f));
              continue;
            }
            a(f.result);
          }
        } catch (o) {
          this.emit("debug", { action: "receiveRpcError", error: o });
          for (const { reject: a } of i)
            a(o);
        }
      })();
    }
  }, t));
};
var ku;
class ype extends sL {
  constructor(t, n) {
    super(t, n);
    ye(this, ku, void 0);
    ie(this, ku, 4e3);
  }
  _getSubscriber(t) {
    const n = super._getSubscriber(t);
    return Z7(n) && (n.pollingInterval = j(this, ku)), n;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return j(this, ku);
  }
  set pollingInterval(t) {
    if (!Number.isInteger(t) || t < 0)
      throw new Error("invalid interval");
    ie(this, ku, t), this._forEachSubscriber((n) => {
      Z7(n) && (n.pollingInterval = j(this, ku));
    });
  }
}
ku = new WeakMap();
var H0;
class oL extends ype {
  constructor(t, n, i) {
    t == null && (t = "http://localhost:8545");
    super(n, i);
    ye(this, H0, void 0);
    typeof t == "string" ? ie(this, H0, new Pc(t)) : ie(this, H0, t.clone());
  }
  _getConnection() {
    return j(this, H0).clone();
  }
  async send(t, n) {
    return await this._start(), await super.send(t, n);
  }
  async _send(t) {
    const n = this._getConnection();
    n.body = JSON.stringify(t), n.setHeader("content-type", "application/json");
    const i = await n.send();
    i.assertOk();
    let s = i.bodyJson;
    return Array.isArray(s) || (s = [s]), s;
  }
}
H0 = new WeakMap();
function Hx(r) {
  if (r == null)
    return null;
  if (typeof r.message == "string" && r.message.match(/revert/i) && mn(r.data))
    return { message: r.message, data: r.data };
  if (typeof r == "object") {
    for (const e in r) {
      const t = Hx(r[e]);
      if (t)
        return t;
    }
    return null;
  }
  if (typeof r == "string")
    try {
      return Hx(JSON.parse(r));
    } catch {
    }
  return null;
}
function zx(r, e) {
  if (r != null) {
    if (typeof r.message == "string" && e.push(r.message), typeof r == "object")
      for (const t in r)
        zx(r[t], e);
    if (typeof r == "string")
      try {
        return zx(JSON.parse(r), e);
      } catch {
      }
  }
}
function vpe(r) {
  const e = [];
  return zx(r, e), e;
}
function bpe() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const _pe = bpe().WebSocket;
var xl, qw, $u, $f, Lu;
class FC {
  /**
   *  Creates a new **SocketSubscriber** attached to %%provider%% listening
   *  to %%filter%%.
   */
  constructor(e, t) {
    ye(this, xl, void 0);
    ye(this, qw, void 0);
    ye(this, $u, void 0);
    ye(this, $f, void 0);
    ye(this, Lu, void 0);
    ie(this, xl, e), ie(this, qw, JSON.stringify(t)), ie(this, $u, null), ie(this, $f, null), ie(this, Lu, null);
  }
  /**
   *  The filter.
   */
  get filter() {
    return JSON.parse(j(this, qw));
  }
  start() {
    ie(this, $u, j(this, xl).send("eth_subscribe", this.filter).then((e) => (j(this, xl)._register(e, this), e)));
  }
  stop() {
    j(this, $u).then((e) => {
      j(this, xl).send("eth_unsubscribe", [e]);
    }), ie(this, $u, null);
  }
  // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
  //        and resume
  pause(e) {
    Te(e, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" }), ie(this, $f, !!e);
  }
  resume() {
    ie(this, $f, null);
  }
  /**
   *  @_ignore:
   */
  _handleMessage(e) {
    if (j(this, $u) != null && j(this, $f) === null) {
      let t = j(this, Lu);
      t == null ? t = this._emit(j(this, xl), e) : t = t.then(async () => {
        await this._emit(j(this, xl), e);
      }), ie(this, Lu, t.then(() => {
        j(this, Lu) === t && ie(this, Lu, null);
      }));
    }
  }
  /**
   *  Sub-classes **must** override this to emit the events on the
   *  provider.
   */
  async _emit(e, t) {
    throw new Error("sub-classes must implemente this; _emit");
  }
}
xl = new WeakMap(), qw = new WeakMap(), $u = new WeakMap(), $f = new WeakMap(), Lu = new WeakMap();
class Epe extends FC {
  /**
   *  @_ignore:
   */
  constructor(e) {
    super(e, ["newHeads"]);
  }
  async _emit(e, t) {
    e.emit("block", parseInt(t.number));
  }
}
class xpe extends FC {
  /**
   *  @_ignore:
   */
  constructor(e) {
    super(e, ["newPendingTransactions"]);
  }
  async _emit(e, t) {
    e.emit("pending", t);
  }
}
var Gw;
class Spe extends FC {
  /**
   *  @_ignore:
   */
  constructor(t, n) {
    super(t, ["logs", n]);
    ye(this, Gw, void 0);
    ie(this, Gw, JSON.stringify(n));
  }
  /**
   *  The filter.
   */
  get logFilter() {
    return JSON.parse(j(this, Gw));
  }
  async _emit(t, n) {
    t.emit(this.logFilter, t._wrapLog(n, t._network));
  }
}
Gw = new WeakMap();
var Lf, z0, Bu;
class Cpe extends sL {
  /**
   *  Creates a new **SocketProvider** connected to %%network%%.
   *
   *  If unspecified, the network will be discovered.
   */
  constructor(t, n) {
    const i = Object.assign({}, n ?? {});
    me(i.batchMaxCount == null || i.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", n), i.batchMaxCount = 1, i.staticNetwork == null && (i.staticNetwork = !0);
    super(t, i);
    ye(this, Lf, void 0);
    // Maps each filterId to its subscriber
    ye(this, z0, void 0);
    // If any events come in before a subscriber has finished
    // registering, queue them
    ye(this, Bu, void 0);
    ie(this, Lf, /* @__PURE__ */ new Map()), ie(this, z0, /* @__PURE__ */ new Map()), ie(this, Bu, /* @__PURE__ */ new Map());
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _getSubscriber(t) {
    switch (t.type) {
      case "close":
        return new q2("close");
      case "block":
        return new Epe(this);
      case "pending":
        return new xpe(this);
      case "event":
        return new Spe(this, t.filter);
      case "orphan":
        if (t.filter.orphan === "drop-log")
          return new q2("drop-log");
    }
    return super._getSubscriber(t);
  }
  /**
   *  Register a new subscriber. This is used internalled by Subscribers
   *  and generally is unecessary unless extending capabilities.
   */
  _register(t, n) {
    j(this, z0).set(t, n);
    const i = j(this, Bu).get(t);
    if (i) {
      for (const s of i)
        n._handleMessage(s);
      j(this, Bu).delete(t);
    }
  }
  async _send(t) {
    me(!Array.isArray(t), "WebSocket does not support batch send", "payload", t);
    const n = new Promise((i, s) => {
      j(this, Lf).set(t.id, { payload: t, resolve: i, reject: s });
    });
    return await this._waitUntilReady(), await this._write(JSON.stringify(t)), [await n];
  }
  // Sub-classes must call this once they are connected
  /*
      async _start(): Promise<void> {
          if (this.#ready) { return; }
  
          for (const { payload } of this.#callbacks.values()) {
              await this._write(JSON.stringify(payload));
          }
  
          this.#ready = (async function() {
              await super._start();
          })();
      }
      */
  /**
   *  Sub-classes **must** call this with messages received over their
   *  transport to be processed and dispatched.
   */
  async _processMessage(t) {
    const n = JSON.parse(t);
    if (n && typeof n == "object" && "id" in n) {
      const i = j(this, Lf).get(n.id);
      if (i == null) {
        this.emit("error", En("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result: n
        }));
        return;
      }
      j(this, Lf).delete(n.id), i.resolve(n);
    } else if (n && n.method === "eth_subscription") {
      const i = n.params.subscription, s = j(this, z0).get(i);
      if (s)
        s._handleMessage(n.params.result);
      else {
        let o = j(this, Bu).get(i);
        o == null && (o = [], j(this, Bu).set(i, o)), o.push(n.params.result);
      }
    } else {
      this.emit("error", En("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result: n
      }));
      return;
    }
  }
  /**
   *  Sub-classes **must** override this to send %%message%% over their
   *  transport.
   */
  async _write(t) {
    throw new Error("sub-classes must override this");
  }
}
Lf = new WeakMap(), z0 = new WeakMap(), Bu = new WeakMap();
var Bf, va;
class Ape extends Cpe {
  constructor(t, n, i) {
    super(n, i);
    ye(this, Bf, void 0);
    ye(this, va, void 0);
    typeof t == "string" ? (ie(this, Bf, () => new _pe(t)), ie(this, va, j(this, Bf).call(this))) : typeof t == "function" ? (ie(this, Bf, t), ie(this, va, t())) : (ie(this, Bf, null), ie(this, va, t)), this.websocket.onopen = async () => {
      try {
        await this._start(), this.resume();
      } catch (s) {
        console.log("failed to start WebsocketProvider", s);
      }
    }, this.websocket.onmessage = (s) => {
      this._processMessage(s.data);
    };
  }
  get websocket() {
    if (j(this, va) == null)
      throw new Error("websocket closed");
    return j(this, va);
  }
  async _write(t) {
    this.websocket.send(t);
  }
  async destroy() {
    j(this, va) != null && (j(this, va).close(), ie(this, va, null)), super.destroy();
  }
}
Bf = new WeakMap(), va = new WeakMap();
const rm = "84842078b09946638c03157f83405213";
function Ipe(r) {
  switch (r) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
  }
  me(!1, "unsupported network", "network", r);
}
class Rpe extends Ape {
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  constructor(t, n) {
    const i = new gw(t, n), s = i._getConnection();
    Te(!s.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const o = s.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(o, t);
    /**
     *  The Project ID for the INFURA connection.
     */
    _e(this, "projectId");
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    _e(this, "projectSecret");
    Et(this, {
      projectId: i.projectId,
      projectSecret: i.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === rm;
  }
}
class gw extends oL {
  /**
   *  Creates a new **InfuraProvider**.
   */
  constructor(t, n, i) {
    t == null && (t = "mainnet");
    const s = Ca.from(t);
    n == null && (n = rm), i == null && (i = null);
    const o = gw.getRequest(s, n, i);
    super(o, s, { staticNetwork: s });
    /**
     *  The Project ID for the INFURA connection.
     */
    _e(this, "projectId");
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    _e(this, "projectSecret");
    Et(this, { projectId: n, projectSecret: i });
  }
  _getProvider(t) {
    try {
      return new gw(t, this.projectId, this.projectSecret);
    } catch {
    }
    return super._getProvider(t);
  }
  isCommunityResource() {
    return this.projectId === rm;
  }
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  static getWebSocketProvider(t, n) {
    return new Rpe(t, n);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%projectId%% and %%projectSecret%%.
   */
  static getRequest(t, n, i) {
    n == null && (n = rm), i == null && (i = null);
    const s = new Pc(`https://${Ipe(t.name)}/v3/${n}`);
    return s.allowGzip = !0, i && s.setCredentials("", i), n === rm && (s.retryFunc = async (o, a, c) => (hpe("InfuraProvider"), !0)), s;
  }
}
const vr = {
  WALLET_ID: "@w3m/wallet_id",
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3
}, ri = {
  getCaipDefaultChain(r) {
    if (r)
      return {
        id: `${Je.EIP155}:${r.chainId}`,
        name: r.name,
        imageId: Ti.EIP155NetworkImageIds[r.chainId]
      };
  },
  hexStringToNumber(r) {
    const e = r.startsWith("0x") ? r.slice(2) : r;
    return parseInt(e, 16);
  },
  numberToHexString(r) {
    return `0x${r.toString(16)}`;
  },
  async getUserInfo(r) {
    const [e, t] = await Promise.all([
      ri.getAddress(r),
      ri.getChainId(r)
    ]);
    return { chainId: t, address: e };
  },
  async getChainId(r) {
    const e = await r.request({ method: "eth_chainId" });
    return Number(e);
  },
  async getAddress(r) {
    const [e] = await r.request({ method: "eth_accounts" });
    return e;
  },
  async addEthereumChain(r, e) {
    await r.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: ri.numberToHexString(e.chainId),
          rpcUrls: [e.rpcUrl],
          chainName: e.name,
          nativeCurrency: {
            name: e.currency,
            decimals: 18,
            symbol: e.currency
          },
          blockExplorerUrls: [e.explorerUrl],
          iconUrls: [Ti.EIP155NetworkImageIds[e.chainId]]
        }
      ]
    });
  }
}, Ai = ji({
  provider: void 0,
  providerType: void 0,
  address: void 0,
  chainId: void 0,
  isConnected: !1
}), Ze = {
  state: Ai,
  subscribeKey(r, e) {
    return Wo(Ai, r, e);
  },
  subscribe(r) {
    return Mc(Ai, () => r(Ai));
  },
  setProvider(r) {
    r && (Ai.provider = V0(r));
  },
  setProviderType(r) {
    Ai.providerType = r;
  },
  setAddress(r) {
    Ai.address = r;
  },
  setChainId(r) {
    Ai.chainId = r;
  },
  setIsConnected(r) {
    Ai.isConnected = r;
  },
  setError(r) {
    Ai.error = r;
  },
  reset() {
    Ai.provider = void 0, Ai.address = void 0, Ai.chainId = void 0, Ai.providerType = void 0, Ai.isConnected = !1, Ai.error = void 0;
  }
};
class Tpe extends xee {
  constructor(e) {
    const { ethersConfig: t, siweConfig: n, chains: i, defaultChain: s, tokens: o, chainImages: a, _sdkVersion: c, ...u } = e;
    if (!t)
      throw new Error("web3modal:constructor - ethersConfig is undefined");
    if (!u.projectId)
      throw new Error("web3modal:constructor - projectId is undefined");
    const f = {
      switchCaipNetwork: async (m) => {
        const y = Zv.caipNetworkIdToNumber(m == null ? void 0 : m.id);
        if (y)
          try {
            await this.switchNetwork(y);
          } catch (b) {
            Ze.setError(b);
          }
      },
      getApprovedCaipNetworksData: async () => new Promise(async (m) => {
        var b, I, k, R;
        const y = localStorage.getItem(vr.WALLET_ID);
        if (y != null && y.includes(Je.WALLET_CONNECT_CONNECTOR_ID)) {
          const T = await this.getWalletConnectProvider();
          if (!T)
            throw new Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
          const $ = (I = (b = T.signer) == null ? void 0 : b.session) == null ? void 0 : I.namespaces, D = (k = $ == null ? void 0 : $[Je.EIP155]) == null ? void 0 : k.methods, L = (R = $ == null ? void 0 : $[Je.EIP155]) == null ? void 0 : R.chains, P = {
            supportsAllNetworks: (D == null ? void 0 : D.includes(Je.ADD_CHAIN_METHOD)) ?? !1,
            approvedCaipNetworkIds: L
          };
          m(P);
        } else
          m({
            approvedCaipNetworkIds: void 0,
            supportsAllNetworks: !0
          });
      })
    }, d = {
      connectWalletConnect: async (m) => {
        const y = await this.getWalletConnectProvider();
        if (!y)
          throw new Error("connectionControllerClient:getWalletConnectUri - provider is undefined");
        y.on("display_uri", (b) => {
          m(b);
        }), await y.connect(), await this.setWalletConnectProvider();
      },
      connectExternal: async ({ id: m, info: y, provider: b }) => {
        if (m === Je.INJECTED_CONNECTOR_ID) {
          const I = t.injected;
          if (!I)
            throw new Error("connectionControllerClient:connectInjected - provider is undefined");
          try {
            await I.request({ method: "eth_requestAccounts" }), this.setInjectedProvider(t);
          } catch (k) {
            Ze.setError(k);
          }
        } else if (m === Je.EIP6963_CONNECTOR_ID && y && b)
          try {
            await b.request({ method: "eth_requestAccounts" }), this.setEIP6963Provider(b, y.name);
          } catch (I) {
            Ze.setError(I);
          }
        else if (m === Je.COINBASE_CONNECTOR_ID) {
          const I = t.coinbase;
          if (!I)
            throw new Error("connectionControllerClient:connectCoinbase - connector is undefined");
          try {
            await I.request({ method: "eth_requestAccounts" }), this.setCoinbaseProvider(t);
          } catch (k) {
            Ze.setError(k);
          }
        } else
          m === Je.EMAIL_CONNECTOR_ID && this.setEmailProvider();
      },
      checkInstalled(m) {
        return m ? t.injected && !(window != null && window.ethereum) ? !1 : m.some((y) => {
          var b;
          return !!((b = window.ethereum) != null && b[String(y)]);
        }) : !!window.ethereum;
      },
      disconnect: async () => {
        var b, I;
        const m = Ze.state.provider, y = Ze.state.providerType;
        localStorage.removeItem(vr.WALLET_ID), Ze.reset(), (b = n == null ? void 0 : n.options) != null && b.signOutOnDisconnect && await n.signOut(), y === Je.WALLET_CONNECT_CONNECTOR_ID ? (await m.disconnect(), m == null || m.emit("disconnect")) : y !== Je.EMAIL_CONNECTOR_ID ? m == null || m.emit("disconnect") : (I = this.emailProvider) == null || I.disconnect(), m == null || m.emit("disconnect");
      },
      signMessage: async (m) => {
        const y = Ze.state.provider;
        if (!y)
          throw new Error("connectionControllerClient:signMessage - provider is undefined");
        return await y.request({
          method: "personal_sign",
          params: [m, this.getAddress()]
        });
      }
    };
    super({
      networkControllerClient: f,
      connectionControllerClient: d,
      siweControllerClient: n,
      defaultChain: ri.getCaipDefaultChain(s),
      tokens: Zv.getCaipTokens(o),
      _sdkVersion: c ?? `html-ethers-${Je.VERSION}`,
      ...u
    }), this.hasSyncedConnectedAccount = !1, this.EIP6963Providers = [], this.options = void 0, this.options = e, this.metadata = t.metadata, this.projectId = u.projectId, this.chains = i, this.createProvider(), Ze.subscribeKey("address", () => {
      this.syncAccount();
    }), Ze.subscribeKey("chainId", () => {
      this.syncNetwork(a);
    }), this.syncRequestedNetworks(i, a), this.syncConnectors(t), t.EIP6963 && typeof window < "u" && (this.listenConnectors(t.EIP6963), this.checkActive6963Provider()), t.email && this.syncEmailConnector(u.projectId), t.injected && this.checkActiveInjectedProvider(t), t.coinbase && this.checkActiveCoinbaseProvider(t);
  }
  getState() {
    const e = super.getState();
    return {
      ...e,
      selectedNetworkId: Zv.caipNetworkIdToNumber(e.selectedNetworkId)
    };
  }
  subscribeState(e) {
    return super.subscribeState((t) => e({
      ...t,
      selectedNetworkId: Zv.caipNetworkIdToNumber(t.selectedNetworkId)
    }));
  }
  setAddress(e) {
    const t = e ? fr(e) : void 0;
    Ze.setAddress(t);
  }
  getAddress() {
    const { address: e } = Ze.state;
    return e ? fr(e) : void 0;
  }
  getError() {
    return Ze.state.error;
  }
  getChainId() {
    return Ze.state.chainId;
  }
  getIsConnected() {
    return Ze.state.isConnected;
  }
  getWalletProvider() {
    return Ze.state.provider;
  }
  getWalletProviderType() {
    return Ze.state.providerType;
  }
  subscribeProvider(e) {
    return Ze.subscribe(e);
  }
  async disconnect() {
    const { provider: e, providerType: t } = Ze.state;
    if (localStorage.removeItem(vr.WALLET_ID), Ze.reset(), t === "injected" || t === "eip6963")
      e == null || e.emit("disconnect");
    else {
      const n = e;
      if (n)
        try {
          await n.disconnect();
        } catch (i) {
          Ze.setError(i);
        }
    }
  }
  createProvider() {
    return !this.walletConnectProviderInitPromise && typeof window < "u" && (this.walletConnectProviderInitPromise = this.initWalletConnectProvider()), this.walletConnectProviderInitPromise;
  }
  async initWalletConnectProvider() {
    const e = {
      projectId: this.projectId,
      showQrModal: !1,
      rpcMap: this.chains ? this.chains.reduce((t, n) => (t[n.chainId] = n.rpcUrl, t), {}) : {},
      optionalChains: [...this.chains.map((t) => t.chainId)],
      metadata: {
        name: this.metadata ? this.metadata.name : "",
        description: this.metadata ? this.metadata.description : "",
        url: this.metadata ? this.metadata.url : "",
        icons: this.metadata ? this.metadata.icons : [""]
      }
    };
    this.walletConnectProvider = await tue.init(e), await this.checkActiveWalletConnectProvider();
  }
  async getWalletConnectProvider() {
    if (!this.walletConnectProvider)
      try {
        await this.createProvider();
      } catch (e) {
        Ze.setError(e);
      }
    return this.walletConnectProvider;
  }
  syncRequestedNetworks(e, t) {
    const n = e == null ? void 0 : e.map((i) => ({
      id: `${Je.EIP155}:${i.chainId}`,
      name: i.name,
      imageId: Ti.EIP155NetworkImageIds[i.chainId],
      imageUrl: t == null ? void 0 : t[i.chainId]
    }));
    this.setRequestedCaipNetworks(n ?? []);
  }
  async checkActiveWalletConnectProvider() {
    const e = await this.getWalletConnectProvider(), t = localStorage.getItem(vr.WALLET_ID);
    e && t === Je.WALLET_CONNECT_CONNECTOR_ID && await this.setWalletConnectProvider();
  }
  checkActiveInjectedProvider(e) {
    const t = e.injected, n = localStorage.getItem(vr.WALLET_ID);
    t && n === Je.INJECTED_CONNECTOR_ID && (this.setInjectedProvider(e), this.watchInjected(e));
  }
  checkActiveCoinbaseProvider(e) {
    var i;
    const t = e.coinbase, n = localStorage.getItem(vr.WALLET_ID);
    t && n === Je.COINBASE_CONNECTOR_ID && (t._addresses && ((i = t._addresses) == null ? void 0 : i.length) > 0 ? (this.setCoinbaseProvider(e), this.watchCoinbase(e)) : (localStorage.removeItem(vr.WALLET_ID), Ze.reset()));
  }
  checkActive6963Provider() {
    const e = window == null ? void 0 : window.localStorage.getItem(vr.WALLET_ID);
    if (e) {
      const t = this.EIP6963Providers.find((n) => n.name === e);
      t && this.setEIP6963Provider(t.provider, t.name);
    }
  }
  async setWalletConnectProvider() {
    var t;
    window == null || window.localStorage.setItem(vr.WALLET_ID, Je.WALLET_CONNECT_CONNECTOR_ID);
    const e = await this.getWalletConnectProvider();
    e && (Ze.setChainId(e.chainId), Ze.setProviderType("walletConnect"), Ze.setProvider(e), Ze.setIsConnected(!0), this.setAddress((t = e.accounts) == null ? void 0 : t[0]), this.watchWalletConnect());
  }
  async setInjectedProvider(e) {
    window == null || window.localStorage.setItem(vr.WALLET_ID, Je.INJECTED_CONNECTOR_ID);
    const t = e.injected;
    if (t) {
      const { address: n, chainId: i } = await ri.getUserInfo(t);
      n && i && (Ze.setChainId(i), Ze.setProviderType("injected"), Ze.setProvider(e.injected), Ze.setIsConnected(!0), this.setAddress(n), this.watchCoinbase(e));
    }
  }
  async setEIP6963Provider(e, t) {
    if (window == null || window.localStorage.setItem(vr.WALLET_ID, t), e) {
      const { address: n, chainId: i } = await ri.getUserInfo(e);
      n && i && (Ze.setChainId(i), Ze.setProviderType("eip6963"), Ze.setProvider(e), Ze.setIsConnected(!0), this.setAddress(n), this.watchEIP6963(e));
    }
  }
  async setCoinbaseProvider(e) {
    window == null || window.localStorage.setItem(vr.WALLET_ID, Je.COINBASE_CONNECTOR_ID);
    const t = e.coinbase;
    if (t) {
      const { address: n, chainId: i } = await ri.getUserInfo(t);
      n && i && (Ze.setChainId(i), Ze.setProviderType("coinbaseWallet"), Ze.setProvider(e.coinbase), Ze.setIsConnected(!0), this.setAddress(n), this.watchCoinbase(e));
    }
  }
  async setEmailProvider() {
    if (window == null || window.localStorage.setItem(vr.WALLET_ID, Je.EMAIL_CONNECTOR_ID), this.emailProvider) {
      const { address: e, chainId: t } = await this.emailProvider.connect();
      super.setLoading(!1), e && t && (Ze.setChainId(t), Ze.setProviderType(Je.EMAIL_CONNECTOR_ID), Ze.setProvider(this.emailProvider), Ze.setIsConnected(!0), Ze.setAddress(e), this.watchEmail());
    }
  }
  async watchWalletConnect() {
    const e = await this.getWalletConnectProvider();
    function t() {
      localStorage.removeItem(vr.WALLET_ID), Ze.reset(), e == null || e.removeListener("disconnect", t), e == null || e.removeListener("accountsChanged", i), e == null || e.removeListener("chainChanged", n);
    }
    function n(s) {
      if (s) {
        const o = ri.hexStringToNumber(s);
        Ze.setChainId(o);
      }
    }
    const i = async (s) => {
      s.length > 0 && await this.setWalletConnectProvider();
    };
    e && (e.on("disconnect", t), e.on("accountsChanged", i), e.on("chainChanged", n));
  }
  watchInjected(e) {
    const t = e.injected;
    function n() {
      localStorage.removeItem(vr.WALLET_ID), Ze.reset(), t == null || t.removeListener("disconnect", n), t == null || t.removeListener("accountsChanged", i), t == null || t.removeListener("chainChanged", s);
    }
    function i(o) {
      const a = o == null ? void 0 : o[0];
      a ? Ze.setAddress(fr(a)) : (localStorage.removeItem(vr.WALLET_ID), Ze.reset());
    }
    function s(o) {
      if (o) {
        const a = typeof o == "string" ? ri.hexStringToNumber(o) : Number(o);
        Ze.setChainId(a);
      }
    }
    t && (t.on("disconnect", n), t.on("accountsChanged", i), t.on("chainChanged", s));
  }
  watchEIP6963(e) {
    function t() {
      localStorage.removeItem(vr.WALLET_ID), Ze.reset(), e.removeListener("disconnect", t), e.removeListener("accountsChanged", n), e.removeListener("chainChanged", i);
    }
    function n(s) {
      const o = s == null ? void 0 : s[0];
      o ? Ze.setAddress(fr(o)) : (localStorage.removeItem(vr.WALLET_ID), Ze.reset());
    }
    function i(s) {
      if (s) {
        const o = typeof s == "string" ? ri.hexStringToNumber(s) : Number(s);
        Ze.setChainId(o);
      }
    }
    e && (e.on("disconnect", t), e.on("accountsChanged", n), e.on("chainChanged", i));
  }
  watchCoinbase(e) {
    const t = e.coinbase, n = localStorage.getItem(vr.WALLET_ID);
    function i() {
      localStorage.removeItem(vr.WALLET_ID), Ze.reset(), t == null || t.removeListener("disconnect", i), t == null || t.removeListener("accountsChanged", s), t == null || t.removeListener("chainChanged", o);
    }
    function s(a) {
      const c = a == null ? void 0 : a[0];
      c ? Ze.setAddress(fr(c)) : (localStorage.removeItem(vr.WALLET_ID), Ze.reset());
    }
    function o(a) {
      if (a && n === Je.COINBASE_CONNECTOR_ID) {
        const c = Number(a);
        Ze.setChainId(c);
      }
    }
    t && (t.on("disconnect", i), t.on("accountsChanged", s), t.on("chainChanged", o));
  }
  watchEmail() {
    this.emailProvider && (this.emailProvider.onRpcRequest((e) => {
      const n = e.payload;
      DM.SAFE_RPC_METHODS.includes(n.method) || super.open({ view: "ApproveTransaction" });
    }), this.emailProvider.onRpcResponse(() => {
      super.close();
    }), this.emailProvider.onIsConnected(() => {
      super.setLoading(!1);
    }));
  }
  async syncAccount() {
    const e = Ze.state.address, t = Ze.state.chainId, n = Ze.state.isConnected;
    if (this.resetAccount(), n && e && t) {
      const i = `${Je.EIP155}:${t}:${e}`;
      this.setIsConnected(n), this.setCaipAddress(i), await Promise.all([
        this.syncProfile(e),
        this.syncBalance(e),
        this.getApprovedCaipNetworksData()
      ]), this.hasSyncedConnectedAccount = !0;
    } else
      !n && this.hasSyncedConnectedAccount && (this.resetWcConnection(), this.resetNetwork());
  }
  async syncNetwork(e) {
    const t = Ze.state.address, n = Ze.state.chainId, i = Ze.state.isConnected;
    if (this.chains) {
      const s = this.chains.find((o) => o.chainId === n);
      if (s) {
        const o = `${Je.EIP155}:${s.chainId}`;
        if (this.setCaipNetwork({
          id: o,
          name: s.name,
          imageId: Ti.EIP155NetworkImageIds[s.chainId],
          imageUrl: e == null ? void 0 : e[s.chainId]
        }), i && t) {
          const a = `${Je.EIP155}:${n}:${t}`;
          if (this.setCaipAddress(a), s.explorerUrl) {
            const c = `${s.explorerUrl}/address/${t}`;
            this.setAddressExplorerUrl(c);
          } else
            this.setAddressExplorerUrl(void 0);
          this.hasSyncedConnectedAccount && (await this.syncProfile(t), await this.syncBalance(t));
        }
      }
    }
  }
  async syncProfile(e) {
    if (Ze.state.chainId === 1) {
      const n = new gw("mainnet"), i = await n.lookupAddress(e), s = await n.getAvatar(e);
      i && this.setProfileName(i), s && this.setProfileImage(s);
    } else
      this.setProfileName(null), this.setProfileImage(null);
  }
  async syncBalance(e) {
    const t = Ze.state.chainId;
    if (t && this.chains) {
      const n = this.chains.find((i) => i.chainId === t);
      if (n) {
        const i = new oL(n.rpcUrl, {
          chainId: t,
          name: n.name
        });
        if (i) {
          const s = await i.getBalance(e), o = Oue(s);
          this.setBalance(o, n.currency);
        }
      }
    }
  }
  async switchNetwork(e) {
    var i, s, o, a, c, u, f, d, m;
    const t = Ze.state.provider, n = Ze.state.providerType;
    if (this.chains) {
      const y = this.chains.find((b) => b.chainId === e);
      if (n === Je.WALLET_CONNECT_CONNECTOR_ID && y) {
        const b = t;
        if (b)
          try {
            await b.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: ri.numberToHexString(y.chainId) }]
            }), Ze.setChainId(e);
          } catch (I) {
            if (I.code === vr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || I.code === vr.ERROR_CODE_DEFAULT || ((s = (i = I == null ? void 0 : I.data) == null ? void 0 : i.originalError) == null ? void 0 : s.code) === vr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID)
              await ri.addEthereumChain(b, y);
            else
              throw new Error("Chain is not supported");
          }
      } else if (n === Je.INJECTED_CONNECTOR_ID && y) {
        const b = t;
        if (b)
          try {
            await b.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: ri.numberToHexString(y.chainId) }]
            }), Ze.setChainId(y.chainId);
          } catch (I) {
            if (I.code === vr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || I.code === vr.ERROR_CODE_DEFAULT || ((a = (o = I == null ? void 0 : I.data) == null ? void 0 : o.originalError) == null ? void 0 : a.code) === vr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID)
              await ri.addEthereumChain(b, y);
            else
              throw new Error("Chain is not supported");
          }
      } else if (n === Je.EIP6963_CONNECTOR_ID && y) {
        const b = t;
        if (b)
          try {
            await b.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: ri.numberToHexString(y.chainId) }]
            }), Ze.setChainId(y.chainId);
          } catch (I) {
            if (I.code === vr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || I.code === vr.ERROR_CODE_DEFAULT || ((u = (c = I == null ? void 0 : I.data) == null ? void 0 : c.originalError) == null ? void 0 : u.code) === vr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID)
              await ri.addEthereumChain(b, y);
            else
              throw new Error("Chain is not supported");
          }
      } else if (n === Je.COINBASE_CONNECTOR_ID && y) {
        const b = t;
        if (b)
          try {
            await b.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: ri.numberToHexString(y.chainId) }]
            }), Ze.setChainId(y.chainId);
          } catch (I) {
            (I.code === vr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || I.code === vr.ERROR_CODE_DEFAULT || ((d = (f = I == null ? void 0 : I.data) == null ? void 0 : f.originalError) == null ? void 0 : d.code) === vr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) && await ri.addEthereumChain(b, y);
          }
      } else if (n === Je.EMAIL_CONNECTOR_ID && this.emailProvider && y != null && y.chainId)
        try {
          await ((m = this.emailProvider) == null ? void 0 : m.switchNetwork(y == null ? void 0 : y.chainId)), Ze.setChainId(y.chainId);
        } catch {
          throw new Error("Switching chain failed");
        }
    }
  }
  syncConnectors(e) {
    var i, s, o, a, c, u;
    const t = [], n = Ti.ConnectorTypesMap[Je.WALLET_CONNECT_CONNECTOR_ID];
    if (t.push({
      id: Je.WALLET_CONNECT_CONNECTOR_ID,
      explorerId: Ti.ConnectorExplorerIds[Je.WALLET_CONNECT_CONNECTOR_ID],
      imageId: Ti.ConnectorImageIds[Je.WALLET_CONNECT_CONNECTOR_ID],
      imageUrl: (s = (i = this.options) == null ? void 0 : i.connectorImages) == null ? void 0 : s[Je.WALLET_CONNECT_CONNECTOR_ID],
      name: Ti.ConnectorNamesMap[Je.WALLET_CONNECT_CONNECTOR_ID],
      type: n
    }), e.injected) {
      const f = Ti.ConnectorTypesMap[Je.INJECTED_CONNECTOR_ID];
      t.push({
        id: Je.INJECTED_CONNECTOR_ID,
        explorerId: Ti.ConnectorExplorerIds[Je.INJECTED_CONNECTOR_ID],
        imageId: Ti.ConnectorImageIds[Je.INJECTED_CONNECTOR_ID],
        imageUrl: (a = (o = this.options) == null ? void 0 : o.connectorImages) == null ? void 0 : a[Je.INJECTED_CONNECTOR_ID],
        name: Ti.ConnectorNamesMap[Je.INJECTED_CONNECTOR_ID],
        type: f
      });
    }
    e.coinbase && t.push({
      id: Je.COINBASE_CONNECTOR_ID,
      explorerId: Ti.ConnectorExplorerIds[Je.COINBASE_CONNECTOR_ID],
      imageId: Ti.ConnectorImageIds[Je.COINBASE_CONNECTOR_ID],
      imageUrl: (u = (c = this.options) == null ? void 0 : c.connectorImages) == null ? void 0 : u[Je.COINBASE_CONNECTOR_ID],
      name: Ti.ConnectorNamesMap[Je.COINBASE_CONNECTOR_ID],
      type: "EXTERNAL"
    }), this.setConnectors(t);
  }
  async syncEmailConnector(e) {
    if (typeof window < "u") {
      this.emailProvider = new HX(e), this.addConnector({
        id: Je.EMAIL_CONNECTOR_ID,
        type: "EMAIL",
        name: "Email",
        provider: this.emailProvider
      }), super.setLoading(!0);
      const t = this.emailProvider.getLoginEmailUsed();
      super.setLoading(t), await this.emailProvider.isConnected() ? this.setEmailProvider() : super.setLoading(!1);
    }
  }
  eip6963EventHandler(e) {
    var t, n;
    if (e.detail) {
      const { info: i, provider: s } = e.detail;
      if (!this.getConnectors().find((c) => c.name === i.name)) {
        const c = Ti.ConnectorTypesMap[Je.EIP6963_CONNECTOR_ID];
        {
          this.addConnector({
            id: Je.EIP6963_CONNECTOR_ID,
            type: c,
            imageUrl: i.icon ?? ((n = (t = this.options) == null ? void 0 : t.connectorImages) == null ? void 0 : n[Je.EIP6963_CONNECTOR_ID]),
            name: i.name,
            provider: s,
            info: i
          });
          const u = {
            name: i.name,
            provider: s
          };
          this.EIP6963Providers.push(u);
        }
      }
    }
  }
  listenConnectors(e) {
    if (typeof window < "u" && e) {
      const t = this.eip6963EventHandler.bind(this);
      window.addEventListener(Je.EIP6963_ANNOUNCE_EVENT, t), window.dispatchEvent(new Event(Je.EIP6963_REQUEST_EVENT));
    }
  }
}
var Vg = {}, u3 = {};
u3.byteLength = Ppe;
u3.toByteArray = Dpe;
u3.fromByteArray = Lpe;
var wc = [], Io = [], Ope = typeof Uint8Array < "u" ? Uint8Array : Array, M4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var dp = 0, Npe = M4.length; dp < Npe; ++dp)
  wc[dp] = M4[dp], Io[M4.charCodeAt(dp)] = dp;
Io[45] = 62;
Io[95] = 63;
function aL(r) {
  var e = r.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var t = r.indexOf("=");
  t === -1 && (t = e);
  var n = t === e ? 0 : 4 - t % 4;
  return [t, n];
}
function Ppe(r) {
  var e = aL(r), t = e[0], n = e[1];
  return (t + n) * 3 / 4 - n;
}
function Mpe(r, e, t) {
  return (e + t) * 3 / 4 - t;
}
function Dpe(r) {
  var e, t = aL(r), n = t[0], i = t[1], s = new Ope(Mpe(r, n, i)), o = 0, a = i > 0 ? n - 4 : n, c;
  for (c = 0; c < a; c += 4)
    e = Io[r.charCodeAt(c)] << 18 | Io[r.charCodeAt(c + 1)] << 12 | Io[r.charCodeAt(c + 2)] << 6 | Io[r.charCodeAt(c + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
  return i === 2 && (e = Io[r.charCodeAt(c)] << 2 | Io[r.charCodeAt(c + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = Io[r.charCodeAt(c)] << 10 | Io[r.charCodeAt(c + 1)] << 4 | Io[r.charCodeAt(c + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
}
function kpe(r) {
  return wc[r >> 18 & 63] + wc[r >> 12 & 63] + wc[r >> 6 & 63] + wc[r & 63];
}
function $pe(r, e, t) {
  for (var n, i = [], s = e; s < t; s += 3)
    n = (r[s] << 16 & 16711680) + (r[s + 1] << 8 & 65280) + (r[s + 2] & 255), i.push(kpe(n));
  return i.join("");
}
function Lpe(r) {
  for (var e, t = r.length, n = t % 3, i = [], s = 16383, o = 0, a = t - n; o < a; o += s)
    i.push($pe(r, o, o + s > a ? a : o + s));
  return n === 1 ? (e = r[t - 1], i.push(
    wc[e >> 2] + wc[e << 4 & 63] + "=="
  )) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i.push(
    wc[e >> 10] + wc[e >> 4 & 63] + wc[e << 2 & 63] + "="
  )), i.join("");
}
var UC = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
UC.read = function(r, e, t, n, i) {
  var s, o, a = i * 8 - n - 1, c = (1 << a) - 1, u = c >> 1, f = -7, d = t ? i - 1 : 0, m = t ? -1 : 1, y = r[e + d];
  for (d += m, s = y & (1 << -f) - 1, y >>= -f, f += a; f > 0; s = s * 256 + r[e + d], d += m, f -= 8)
    ;
  for (o = s & (1 << -f) - 1, s >>= -f, f += n; f > 0; o = o * 256 + r[e + d], d += m, f -= 8)
    ;
  if (s === 0)
    s = 1 - u;
  else {
    if (s === c)
      return o ? NaN : (y ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), s = s - u;
  }
  return (y ? -1 : 1) * o * Math.pow(2, s - n);
};
UC.write = function(r, e, t, n, i, s) {
  var o, a, c, u = s * 8 - i - 1, f = (1 << u) - 1, d = f >> 1, m = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : s - 1, b = n ? 1 : -1, I = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = f) : (o = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + d >= 1 ? e += m / c : e += m * Math.pow(2, 1 - d), e * c >= 2 && (o++, c /= 2), o + d >= f ? (a = 0, o = f) : o + d >= 1 ? (a = (e * c - 1) * Math.pow(2, i), o = o + d) : (a = e * Math.pow(2, d - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + y] = a & 255, y += b, a /= 256, i -= 8)
    ;
  for (o = o << i | a, u += i; u > 0; r[t + y] = o & 255, y += b, o /= 256, u -= 8)
    ;
  r[t + y - b] |= I * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(r) {
  const e = u3, t = UC, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  r.Buffer = a, r.SlowBuffer = T, r.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  r.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const W = new Uint8Array(1), _ = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(_, Uint8Array.prototype), Object.setPrototypeOf(W, _), W.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function o(W) {
    if (W > i)
      throw new RangeError('The value "' + W + '" is invalid for option "size"');
    const _ = new Uint8Array(W);
    return Object.setPrototypeOf(_, a.prototype), _;
  }
  function a(W, _, A) {
    if (typeof W == "number") {
      if (typeof _ == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return d(W);
    }
    return c(W, _, A);
  }
  a.poolSize = 8192;
  function c(W, _, A) {
    if (typeof W == "string")
      return m(W, _);
    if (ArrayBuffer.isView(W))
      return b(W);
    if (W == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof W
      );
    if (lt(W, ArrayBuffer) || W && lt(W.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (lt(W, SharedArrayBuffer) || W && lt(W.buffer, SharedArrayBuffer)))
      return I(W, _, A);
    if (typeof W == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const J = W.valueOf && W.valueOf();
    if (J != null && J !== W)
      return a.from(J, _, A);
    const ae = k(W);
    if (ae)
      return ae;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof W[Symbol.toPrimitive] == "function")
      return a.from(W[Symbol.toPrimitive]("string"), _, A);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof W
    );
  }
  a.from = function(W, _, A) {
    return c(W, _, A);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function u(W) {
    if (typeof W != "number")
      throw new TypeError('"size" argument must be of type number');
    if (W < 0)
      throw new RangeError('The value "' + W + '" is invalid for option "size"');
  }
  function f(W, _, A) {
    return u(W), W <= 0 ? o(W) : _ !== void 0 ? typeof A == "string" ? o(W).fill(_, A) : o(W).fill(_) : o(W);
  }
  a.alloc = function(W, _, A) {
    return f(W, _, A);
  };
  function d(W) {
    return u(W), o(W < 0 ? 0 : R(W) | 0);
  }
  a.allocUnsafe = function(W) {
    return d(W);
  }, a.allocUnsafeSlow = function(W) {
    return d(W);
  };
  function m(W, _) {
    if ((typeof _ != "string" || _ === "") && (_ = "utf8"), !a.isEncoding(_))
      throw new TypeError("Unknown encoding: " + _);
    const A = $(W, _) | 0;
    let J = o(A);
    const ae = J.write(W, _);
    return ae !== A && (J = J.slice(0, ae)), J;
  }
  function y(W) {
    const _ = W.length < 0 ? 0 : R(W.length) | 0, A = o(_);
    for (let J = 0; J < _; J += 1)
      A[J] = W[J] & 255;
    return A;
  }
  function b(W) {
    if (lt(W, Uint8Array)) {
      const _ = new Uint8Array(W);
      return I(_.buffer, _.byteOffset, _.byteLength);
    }
    return y(W);
  }
  function I(W, _, A) {
    if (_ < 0 || W.byteLength < _)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (W.byteLength < _ + (A || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let J;
    return _ === void 0 && A === void 0 ? J = new Uint8Array(W) : A === void 0 ? J = new Uint8Array(W, _) : J = new Uint8Array(W, _, A), Object.setPrototypeOf(J, a.prototype), J;
  }
  function k(W) {
    if (a.isBuffer(W)) {
      const _ = R(W.length) | 0, A = o(_);
      return A.length === 0 || W.copy(A, 0, 0, _), A;
    }
    if (W.length !== void 0)
      return typeof W.length != "number" || qe(W.length) ? o(0) : y(W);
    if (W.type === "Buffer" && Array.isArray(W.data))
      return y(W.data);
  }
  function R(W) {
    if (W >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return W | 0;
  }
  function T(W) {
    return +W != W && (W = 0), a.alloc(+W);
  }
  a.isBuffer = function(_) {
    return _ != null && _._isBuffer === !0 && _ !== a.prototype;
  }, a.compare = function(_, A) {
    if (lt(_, Uint8Array) && (_ = a.from(_, _.offset, _.byteLength)), lt(A, Uint8Array) && (A = a.from(A, A.offset, A.byteLength)), !a.isBuffer(_) || !a.isBuffer(A))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (_ === A)
      return 0;
    let J = _.length, ae = A.length;
    for (let le = 0, ge = Math.min(J, ae); le < ge; ++le)
      if (_[le] !== A[le]) {
        J = _[le], ae = A[le];
        break;
      }
    return J < ae ? -1 : ae < J ? 1 : 0;
  }, a.isEncoding = function(_) {
    switch (String(_).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, a.concat = function(_, A) {
    if (!Array.isArray(_))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (_.length === 0)
      return a.alloc(0);
    let J;
    if (A === void 0)
      for (A = 0, J = 0; J < _.length; ++J)
        A += _[J].length;
    const ae = a.allocUnsafe(A);
    let le = 0;
    for (J = 0; J < _.length; ++J) {
      let ge = _[J];
      if (lt(ge, Uint8Array))
        le + ge.length > ae.length ? (a.isBuffer(ge) || (ge = a.from(ge)), ge.copy(ae, le)) : Uint8Array.prototype.set.call(
          ae,
          ge,
          le
        );
      else if (a.isBuffer(ge))
        ge.copy(ae, le);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      le += ge.length;
    }
    return ae;
  };
  function $(W, _) {
    if (a.isBuffer(W))
      return W.length;
    if (ArrayBuffer.isView(W) || lt(W, ArrayBuffer))
      return W.byteLength;
    if (typeof W != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof W
      );
    const A = W.length, J = arguments.length > 2 && arguments[2] === !0;
    if (!J && A === 0)
      return 0;
    let ae = !1;
    for (; ; )
      switch (_) {
        case "ascii":
        case "latin1":
        case "binary":
          return A;
        case "utf8":
        case "utf-8":
          return De(W).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return A * 2;
        case "hex":
          return A >>> 1;
        case "base64":
          return Qe(W).length;
        default:
          if (ae)
            return J ? -1 : De(W).length;
          _ = ("" + _).toLowerCase(), ae = !0;
      }
  }
  a.byteLength = $;
  function D(W, _, A) {
    let J = !1;
    if ((_ === void 0 || _ < 0) && (_ = 0), _ > this.length || ((A === void 0 || A > this.length) && (A = this.length), A <= 0) || (A >>>= 0, _ >>>= 0, A <= _))
      return "";
    for (W || (W = "utf8"); ; )
      switch (W) {
        case "hex":
          return U(this, _, A);
        case "utf8":
        case "utf-8":
          return p(this, _, A);
        case "ascii":
          return N(this, _, A);
        case "latin1":
        case "binary":
          return O(this, _, A);
        case "base64":
          return H(this, _, A);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return q(this, _, A);
        default:
          if (J)
            throw new TypeError("Unknown encoding: " + W);
          W = (W + "").toLowerCase(), J = !0;
      }
  }
  a.prototype._isBuffer = !0;
  function L(W, _, A) {
    const J = W[_];
    W[_] = W[A], W[A] = J;
  }
  a.prototype.swap16 = function() {
    const _ = this.length;
    if (_ % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let A = 0; A < _; A += 2)
      L(this, A, A + 1);
    return this;
  }, a.prototype.swap32 = function() {
    const _ = this.length;
    if (_ % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let A = 0; A < _; A += 4)
      L(this, A, A + 3), L(this, A + 1, A + 2);
    return this;
  }, a.prototype.swap64 = function() {
    const _ = this.length;
    if (_ % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let A = 0; A < _; A += 8)
      L(this, A, A + 7), L(this, A + 1, A + 6), L(this, A + 2, A + 5), L(this, A + 3, A + 4);
    return this;
  }, a.prototype.toString = function() {
    const _ = this.length;
    return _ === 0 ? "" : arguments.length === 0 ? p(this, 0, _) : D.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(_) {
    if (!a.isBuffer(_))
      throw new TypeError("Argument must be a Buffer");
    return this === _ ? !0 : a.compare(this, _) === 0;
  }, a.prototype.inspect = function() {
    let _ = "";
    const A = r.INSPECT_MAX_BYTES;
    return _ = this.toString("hex", 0, A).replace(/(.{2})/g, "$1 ").trim(), this.length > A && (_ += " ... "), "<Buffer " + _ + ">";
  }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(_, A, J, ae, le) {
    if (lt(_, Uint8Array) && (_ = a.from(_, _.offset, _.byteLength)), !a.isBuffer(_))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof _
      );
    if (A === void 0 && (A = 0), J === void 0 && (J = _ ? _.length : 0), ae === void 0 && (ae = 0), le === void 0 && (le = this.length), A < 0 || J > _.length || ae < 0 || le > this.length)
      throw new RangeError("out of range index");
    if (ae >= le && A >= J)
      return 0;
    if (ae >= le)
      return -1;
    if (A >= J)
      return 1;
    if (A >>>= 0, J >>>= 0, ae >>>= 0, le >>>= 0, this === _)
      return 0;
    let ge = le - ae, je = J - A;
    const Ue = Math.min(ge, je), it = this.slice(ae, le), jt = _.slice(A, J);
    for (let at = 0; at < Ue; ++at)
      if (it[at] !== jt[at]) {
        ge = it[at], je = jt[at];
        break;
      }
    return ge < je ? -1 : je < ge ? 1 : 0;
  };
  function P(W, _, A, J, ae) {
    if (W.length === 0)
      return -1;
    if (typeof A == "string" ? (J = A, A = 0) : A > 2147483647 ? A = 2147483647 : A < -2147483648 && (A = -2147483648), A = +A, qe(A) && (A = ae ? 0 : W.length - 1), A < 0 && (A = W.length + A), A >= W.length) {
      if (ae)
        return -1;
      A = W.length - 1;
    } else if (A < 0)
      if (ae)
        A = 0;
      else
        return -1;
    if (typeof _ == "string" && (_ = a.from(_, J)), a.isBuffer(_))
      return _.length === 0 ? -1 : v(W, _, A, J, ae);
    if (typeof _ == "number")
      return _ = _ & 255, typeof Uint8Array.prototype.indexOf == "function" ? ae ? Uint8Array.prototype.indexOf.call(W, _, A) : Uint8Array.prototype.lastIndexOf.call(W, _, A) : v(W, [_], A, J, ae);
    throw new TypeError("val must be string, number or Buffer");
  }
  function v(W, _, A, J, ae) {
    let le = 1, ge = W.length, je = _.length;
    if (J !== void 0 && (J = String(J).toLowerCase(), J === "ucs2" || J === "ucs-2" || J === "utf16le" || J === "utf-16le")) {
      if (W.length < 2 || _.length < 2)
        return -1;
      le = 2, ge /= 2, je /= 2, A /= 2;
    }
    function Ue(jt, at) {
      return le === 1 ? jt[at] : jt.readUInt16BE(at * le);
    }
    let it;
    if (ae) {
      let jt = -1;
      for (it = A; it < ge; it++)
        if (Ue(W, it) === Ue(_, jt === -1 ? 0 : it - jt)) {
          if (jt === -1 && (jt = it), it - jt + 1 === je)
            return jt * le;
        } else
          jt !== -1 && (it -= it - jt), jt = -1;
    } else
      for (A + je > ge && (A = ge - je), it = A; it >= 0; it--) {
        let jt = !0;
        for (let at = 0; at < je; at++)
          if (Ue(W, it + at) !== Ue(_, at)) {
            jt = !1;
            break;
          }
        if (jt)
          return it;
      }
    return -1;
  }
  a.prototype.includes = function(_, A, J) {
    return this.indexOf(_, A, J) !== -1;
  }, a.prototype.indexOf = function(_, A, J) {
    return P(this, _, A, J, !0);
  }, a.prototype.lastIndexOf = function(_, A, J) {
    return P(this, _, A, J, !1);
  };
  function F(W, _, A, J) {
    A = Number(A) || 0;
    const ae = W.length - A;
    J ? (J = Number(J), J > ae && (J = ae)) : J = ae;
    const le = _.length;
    J > le / 2 && (J = le / 2);
    let ge;
    for (ge = 0; ge < J; ++ge) {
      const je = parseInt(_.substr(ge * 2, 2), 16);
      if (qe(je))
        return ge;
      W[A + ge] = je;
    }
    return ge;
  }
  function X(W, _, A, J) {
    return We(De(_, W.length - A), W, A, J);
  }
  function te(W, _, A, J) {
    return We(dt(_), W, A, J);
  }
  function se(W, _, A, J) {
    return We(Qe(_), W, A, J);
  }
  function we(W, _, A, J) {
    return We(or(_, W.length - A), W, A, J);
  }
  a.prototype.write = function(_, A, J, ae) {
    if (A === void 0)
      ae = "utf8", J = this.length, A = 0;
    else if (J === void 0 && typeof A == "string")
      ae = A, J = this.length, A = 0;
    else if (isFinite(A))
      A = A >>> 0, isFinite(J) ? (J = J >>> 0, ae === void 0 && (ae = "utf8")) : (ae = J, J = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const le = this.length - A;
    if ((J === void 0 || J > le) && (J = le), _.length > 0 && (J < 0 || A < 0) || A > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ae || (ae = "utf8");
    let ge = !1;
    for (; ; )
      switch (ae) {
        case "hex":
          return F(this, _, A, J);
        case "utf8":
        case "utf-8":
          return X(this, _, A, J);
        case "ascii":
        case "latin1":
        case "binary":
          return te(this, _, A, J);
        case "base64":
          return se(this, _, A, J);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return we(this, _, A, J);
        default:
          if (ge)
            throw new TypeError("Unknown encoding: " + ae);
          ae = ("" + ae).toLowerCase(), ge = !0;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function H(W, _, A) {
    return _ === 0 && A === W.length ? e.fromByteArray(W) : e.fromByteArray(W.slice(_, A));
  }
  function p(W, _, A) {
    A = Math.min(W.length, A);
    const J = [];
    let ae = _;
    for (; ae < A; ) {
      const le = W[ae];
      let ge = null, je = le > 239 ? 4 : le > 223 ? 3 : le > 191 ? 2 : 1;
      if (ae + je <= A) {
        let Ue, it, jt, at;
        switch (je) {
          case 1:
            le < 128 && (ge = le);
            break;
          case 2:
            Ue = W[ae + 1], (Ue & 192) === 128 && (at = (le & 31) << 6 | Ue & 63, at > 127 && (ge = at));
            break;
          case 3:
            Ue = W[ae + 1], it = W[ae + 2], (Ue & 192) === 128 && (it & 192) === 128 && (at = (le & 15) << 12 | (Ue & 63) << 6 | it & 63, at > 2047 && (at < 55296 || at > 57343) && (ge = at));
            break;
          case 4:
            Ue = W[ae + 1], it = W[ae + 2], jt = W[ae + 3], (Ue & 192) === 128 && (it & 192) === 128 && (jt & 192) === 128 && (at = (le & 15) << 18 | (Ue & 63) << 12 | (it & 63) << 6 | jt & 63, at > 65535 && at < 1114112 && (ge = at));
        }
      }
      ge === null ? (ge = 65533, je = 1) : ge > 65535 && (ge -= 65536, J.push(ge >>> 10 & 1023 | 55296), ge = 56320 | ge & 1023), J.push(ge), ae += je;
    }
    return x(J);
  }
  const w = 4096;
  function x(W) {
    const _ = W.length;
    if (_ <= w)
      return String.fromCharCode.apply(String, W);
    let A = "", J = 0;
    for (; J < _; )
      A += String.fromCharCode.apply(
        String,
        W.slice(J, J += w)
      );
    return A;
  }
  function N(W, _, A) {
    let J = "";
    A = Math.min(W.length, A);
    for (let ae = _; ae < A; ++ae)
      J += String.fromCharCode(W[ae] & 127);
    return J;
  }
  function O(W, _, A) {
    let J = "";
    A = Math.min(W.length, A);
    for (let ae = _; ae < A; ++ae)
      J += String.fromCharCode(W[ae]);
    return J;
  }
  function U(W, _, A) {
    const J = W.length;
    (!_ || _ < 0) && (_ = 0), (!A || A < 0 || A > J) && (A = J);
    let ae = "";
    for (let le = _; le < A; ++le)
      ae += Ye[W[le]];
    return ae;
  }
  function q(W, _, A) {
    const J = W.slice(_, A);
    let ae = "";
    for (let le = 0; le < J.length - 1; le += 2)
      ae += String.fromCharCode(J[le] + J[le + 1] * 256);
    return ae;
  }
  a.prototype.slice = function(_, A) {
    const J = this.length;
    _ = ~~_, A = A === void 0 ? J : ~~A, _ < 0 ? (_ += J, _ < 0 && (_ = 0)) : _ > J && (_ = J), A < 0 ? (A += J, A < 0 && (A = 0)) : A > J && (A = J), A < _ && (A = _);
    const ae = this.subarray(_, A);
    return Object.setPrototypeOf(ae, a.prototype), ae;
  };
  function B(W, _, A) {
    if (W % 1 !== 0 || W < 0)
      throw new RangeError("offset is not uint");
    if (W + _ > A)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(_, A, J) {
    _ = _ >>> 0, A = A >>> 0, J || B(_, A, this.length);
    let ae = this[_], le = 1, ge = 0;
    for (; ++ge < A && (le *= 256); )
      ae += this[_ + ge] * le;
    return ae;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(_, A, J) {
    _ = _ >>> 0, A = A >>> 0, J || B(_, A, this.length);
    let ae = this[_ + --A], le = 1;
    for (; A > 0 && (le *= 256); )
      ae += this[_ + --A] * le;
    return ae;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(_, A) {
    return _ = _ >>> 0, A || B(_, 1, this.length), this[_];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 2, this.length), this[_] | this[_ + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 2, this.length), this[_] << 8 | this[_ + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 4, this.length), (this[_] | this[_ + 1] << 8 | this[_ + 2] << 16) + this[_ + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 4, this.length), this[_] * 16777216 + (this[_ + 1] << 16 | this[_ + 2] << 8 | this[_ + 3]);
  }, a.prototype.readBigUInt64LE = st(function(_) {
    _ = _ >>> 0, ue(_, "offset");
    const A = this[_], J = this[_ + 7];
    (A === void 0 || J === void 0) && Ee(_, this.length - 8);
    const ae = A + this[++_] * 2 ** 8 + this[++_] * 2 ** 16 + this[++_] * 2 ** 24, le = this[++_] + this[++_] * 2 ** 8 + this[++_] * 2 ** 16 + J * 2 ** 24;
    return BigInt(ae) + (BigInt(le) << BigInt(32));
  }), a.prototype.readBigUInt64BE = st(function(_) {
    _ = _ >>> 0, ue(_, "offset");
    const A = this[_], J = this[_ + 7];
    (A === void 0 || J === void 0) && Ee(_, this.length - 8);
    const ae = A * 2 ** 24 + this[++_] * 2 ** 16 + this[++_] * 2 ** 8 + this[++_], le = this[++_] * 2 ** 24 + this[++_] * 2 ** 16 + this[++_] * 2 ** 8 + J;
    return (BigInt(ae) << BigInt(32)) + BigInt(le);
  }), a.prototype.readIntLE = function(_, A, J) {
    _ = _ >>> 0, A = A >>> 0, J || B(_, A, this.length);
    let ae = this[_], le = 1, ge = 0;
    for (; ++ge < A && (le *= 256); )
      ae += this[_ + ge] * le;
    return le *= 128, ae >= le && (ae -= Math.pow(2, 8 * A)), ae;
  }, a.prototype.readIntBE = function(_, A, J) {
    _ = _ >>> 0, A = A >>> 0, J || B(_, A, this.length);
    let ae = A, le = 1, ge = this[_ + --ae];
    for (; ae > 0 && (le *= 256); )
      ge += this[_ + --ae] * le;
    return le *= 128, ge >= le && (ge -= Math.pow(2, 8 * A)), ge;
  }, a.prototype.readInt8 = function(_, A) {
    return _ = _ >>> 0, A || B(_, 1, this.length), this[_] & 128 ? (255 - this[_] + 1) * -1 : this[_];
  }, a.prototype.readInt16LE = function(_, A) {
    _ = _ >>> 0, A || B(_, 2, this.length);
    const J = this[_] | this[_ + 1] << 8;
    return J & 32768 ? J | 4294901760 : J;
  }, a.prototype.readInt16BE = function(_, A) {
    _ = _ >>> 0, A || B(_, 2, this.length);
    const J = this[_ + 1] | this[_] << 8;
    return J & 32768 ? J | 4294901760 : J;
  }, a.prototype.readInt32LE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 4, this.length), this[_] | this[_ + 1] << 8 | this[_ + 2] << 16 | this[_ + 3] << 24;
  }, a.prototype.readInt32BE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 4, this.length), this[_] << 24 | this[_ + 1] << 16 | this[_ + 2] << 8 | this[_ + 3];
  }, a.prototype.readBigInt64LE = st(function(_) {
    _ = _ >>> 0, ue(_, "offset");
    const A = this[_], J = this[_ + 7];
    (A === void 0 || J === void 0) && Ee(_, this.length - 8);
    const ae = this[_ + 4] + this[_ + 5] * 2 ** 8 + this[_ + 6] * 2 ** 16 + (J << 24);
    return (BigInt(ae) << BigInt(32)) + BigInt(A + this[++_] * 2 ** 8 + this[++_] * 2 ** 16 + this[++_] * 2 ** 24);
  }), a.prototype.readBigInt64BE = st(function(_) {
    _ = _ >>> 0, ue(_, "offset");
    const A = this[_], J = this[_ + 7];
    (A === void 0 || J === void 0) && Ee(_, this.length - 8);
    const ae = (A << 24) + // Overflow
    this[++_] * 2 ** 16 + this[++_] * 2 ** 8 + this[++_];
    return (BigInt(ae) << BigInt(32)) + BigInt(this[++_] * 2 ** 24 + this[++_] * 2 ** 16 + this[++_] * 2 ** 8 + J);
  }), a.prototype.readFloatLE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 4, this.length), t.read(this, _, !0, 23, 4);
  }, a.prototype.readFloatBE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 4, this.length), t.read(this, _, !1, 23, 4);
  }, a.prototype.readDoubleLE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 8, this.length), t.read(this, _, !0, 52, 8);
  }, a.prototype.readDoubleBE = function(_, A) {
    return _ = _ >>> 0, A || B(_, 8, this.length), t.read(this, _, !1, 52, 8);
  };
  function E(W, _, A, J, ae, le) {
    if (!a.isBuffer(W))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (_ > ae || _ < le)
      throw new RangeError('"value" argument is out of bounds');
    if (A + J > W.length)
      throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(_, A, J, ae) {
    if (_ = +_, A = A >>> 0, J = J >>> 0, !ae) {
      const je = Math.pow(2, 8 * J) - 1;
      E(this, _, A, J, je, 0);
    }
    let le = 1, ge = 0;
    for (this[A] = _ & 255; ++ge < J && (le *= 256); )
      this[A + ge] = _ / le & 255;
    return A + J;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(_, A, J, ae) {
    if (_ = +_, A = A >>> 0, J = J >>> 0, !ae) {
      const je = Math.pow(2, 8 * J) - 1;
      E(this, _, A, J, je, 0);
    }
    let le = J - 1, ge = 1;
    for (this[A + le] = _ & 255; --le >= 0 && (ge *= 256); )
      this[A + le] = _ / ge & 255;
    return A + J;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 1, 255, 0), this[A] = _ & 255, A + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 2, 65535, 0), this[A] = _ & 255, this[A + 1] = _ >>> 8, A + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 2, 65535, 0), this[A] = _ >>> 8, this[A + 1] = _ & 255, A + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 4, 4294967295, 0), this[A + 3] = _ >>> 24, this[A + 2] = _ >>> 16, this[A + 1] = _ >>> 8, this[A] = _ & 255, A + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 4, 4294967295, 0), this[A] = _ >>> 24, this[A + 1] = _ >>> 16, this[A + 2] = _ >>> 8, this[A + 3] = _ & 255, A + 4;
  };
  function V(W, _, A, J, ae) {
    G(_, J, ae, W, A, 7);
    let le = Number(_ & BigInt(4294967295));
    W[A++] = le, le = le >> 8, W[A++] = le, le = le >> 8, W[A++] = le, le = le >> 8, W[A++] = le;
    let ge = Number(_ >> BigInt(32) & BigInt(4294967295));
    return W[A++] = ge, ge = ge >> 8, W[A++] = ge, ge = ge >> 8, W[A++] = ge, ge = ge >> 8, W[A++] = ge, A;
  }
  function be(W, _, A, J, ae) {
    G(_, J, ae, W, A, 7);
    let le = Number(_ & BigInt(4294967295));
    W[A + 7] = le, le = le >> 8, W[A + 6] = le, le = le >> 8, W[A + 5] = le, le = le >> 8, W[A + 4] = le;
    let ge = Number(_ >> BigInt(32) & BigInt(4294967295));
    return W[A + 3] = ge, ge = ge >> 8, W[A + 2] = ge, ge = ge >> 8, W[A + 1] = ge, ge = ge >> 8, W[A] = ge, A + 8;
  }
  a.prototype.writeBigUInt64LE = st(function(_, A = 0) {
    return V(this, _, A, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeBigUInt64BE = st(function(_, A = 0) {
    return be(this, _, A, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeIntLE = function(_, A, J, ae) {
    if (_ = +_, A = A >>> 0, !ae) {
      const Ue = Math.pow(2, 8 * J - 1);
      E(this, _, A, J, Ue - 1, -Ue);
    }
    let le = 0, ge = 1, je = 0;
    for (this[A] = _ & 255; ++le < J && (ge *= 256); )
      _ < 0 && je === 0 && this[A + le - 1] !== 0 && (je = 1), this[A + le] = (_ / ge >> 0) - je & 255;
    return A + J;
  }, a.prototype.writeIntBE = function(_, A, J, ae) {
    if (_ = +_, A = A >>> 0, !ae) {
      const Ue = Math.pow(2, 8 * J - 1);
      E(this, _, A, J, Ue - 1, -Ue);
    }
    let le = J - 1, ge = 1, je = 0;
    for (this[A + le] = _ & 255; --le >= 0 && (ge *= 256); )
      _ < 0 && je === 0 && this[A + le + 1] !== 0 && (je = 1), this[A + le] = (_ / ge >> 0) - je & 255;
    return A + J;
  }, a.prototype.writeInt8 = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 1, 127, -128), _ < 0 && (_ = 255 + _ + 1), this[A] = _ & 255, A + 1;
  }, a.prototype.writeInt16LE = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 2, 32767, -32768), this[A] = _ & 255, this[A + 1] = _ >>> 8, A + 2;
  }, a.prototype.writeInt16BE = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 2, 32767, -32768), this[A] = _ >>> 8, this[A + 1] = _ & 255, A + 2;
  }, a.prototype.writeInt32LE = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 4, 2147483647, -2147483648), this[A] = _ & 255, this[A + 1] = _ >>> 8, this[A + 2] = _ >>> 16, this[A + 3] = _ >>> 24, A + 4;
  }, a.prototype.writeInt32BE = function(_, A, J) {
    return _ = +_, A = A >>> 0, J || E(this, _, A, 4, 2147483647, -2147483648), _ < 0 && (_ = 4294967295 + _ + 1), this[A] = _ >>> 24, this[A + 1] = _ >>> 16, this[A + 2] = _ >>> 8, this[A + 3] = _ & 255, A + 4;
  }, a.prototype.writeBigInt64LE = st(function(_, A = 0) {
    return V(this, _, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a.prototype.writeBigInt64BE = st(function(_, A = 0) {
    return be(this, _, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ve(W, _, A, J, ae, le) {
    if (A + J > W.length)
      throw new RangeError("Index out of range");
    if (A < 0)
      throw new RangeError("Index out of range");
  }
  function ne(W, _, A, J, ae) {
    return _ = +_, A = A >>> 0, ae || ve(W, _, A, 4), t.write(W, _, A, J, 23, 4), A + 4;
  }
  a.prototype.writeFloatLE = function(_, A, J) {
    return ne(this, _, A, !0, J);
  }, a.prototype.writeFloatBE = function(_, A, J) {
    return ne(this, _, A, !1, J);
  };
  function K(W, _, A, J, ae) {
    return _ = +_, A = A >>> 0, ae || ve(W, _, A, 8), t.write(W, _, A, J, 52, 8), A + 8;
  }
  a.prototype.writeDoubleLE = function(_, A, J) {
    return K(this, _, A, !0, J);
  }, a.prototype.writeDoubleBE = function(_, A, J) {
    return K(this, _, A, !1, J);
  }, a.prototype.copy = function(_, A, J, ae) {
    if (!a.isBuffer(_))
      throw new TypeError("argument should be a Buffer");
    if (J || (J = 0), !ae && ae !== 0 && (ae = this.length), A >= _.length && (A = _.length), A || (A = 0), ae > 0 && ae < J && (ae = J), ae === J || _.length === 0 || this.length === 0)
      return 0;
    if (A < 0)
      throw new RangeError("targetStart out of bounds");
    if (J < 0 || J >= this.length)
      throw new RangeError("Index out of range");
    if (ae < 0)
      throw new RangeError("sourceEnd out of bounds");
    ae > this.length && (ae = this.length), _.length - A < ae - J && (ae = _.length - A + J);
    const le = ae - J;
    return this === _ && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(A, J, ae) : Uint8Array.prototype.set.call(
      _,
      this.subarray(J, ae),
      A
    ), le;
  }, a.prototype.fill = function(_, A, J, ae) {
    if (typeof _ == "string") {
      if (typeof A == "string" ? (ae = A, A = 0, J = this.length) : typeof J == "string" && (ae = J, J = this.length), ae !== void 0 && typeof ae != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ae == "string" && !a.isEncoding(ae))
        throw new TypeError("Unknown encoding: " + ae);
      if (_.length === 1) {
        const ge = _.charCodeAt(0);
        (ae === "utf8" && ge < 128 || ae === "latin1") && (_ = ge);
      }
    } else
      typeof _ == "number" ? _ = _ & 255 : typeof _ == "boolean" && (_ = Number(_));
    if (A < 0 || this.length < A || this.length < J)
      throw new RangeError("Out of range index");
    if (J <= A)
      return this;
    A = A >>> 0, J = J === void 0 ? this.length : J >>> 0, _ || (_ = 0);
    let le;
    if (typeof _ == "number")
      for (le = A; le < J; ++le)
        this[le] = _;
    else {
      const ge = a.isBuffer(_) ? _ : a.from(_, ae), je = ge.length;
      if (je === 0)
        throw new TypeError('The value "' + _ + '" is invalid for argument "value"');
      for (le = 0; le < J - A; ++le)
        this[le + A] = ge[le % je];
    }
    return this;
  };
  const Y = {};
  function ee(W, _, A) {
    Y[W] = class extends A {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: _.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${W}]`, this.stack, delete this.name;
      }
      get code() {
        return W;
      }
      set code(ae) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ae,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${W}]: ${this.message}`;
      }
    };
  }
  ee(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(W) {
      return W ? `${W} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ee(
    "ERR_INVALID_ARG_TYPE",
    function(W, _) {
      return `The "${W}" argument must be of type number. Received type ${typeof _}`;
    },
    TypeError
  ), ee(
    "ERR_OUT_OF_RANGE",
    function(W, _, A) {
      let J = `The value of "${W}" is out of range.`, ae = A;
      return Number.isInteger(A) && Math.abs(A) > 2 ** 32 ? ae = S(String(A)) : typeof A == "bigint" && (ae = String(A), (A > BigInt(2) ** BigInt(32) || A < -(BigInt(2) ** BigInt(32))) && (ae = S(ae)), ae += "n"), J += ` It must be ${_}. Received ${ae}`, J;
    },
    RangeError
  );
  function S(W) {
    let _ = "", A = W.length;
    const J = W[0] === "-" ? 1 : 0;
    for (; A >= J + 4; A -= 3)
      _ = `_${W.slice(A - 3, A)}${_}`;
    return `${W.slice(0, A)}${_}`;
  }
  function M(W, _, A) {
    ue(_, "offset"), (W[_] === void 0 || W[_ + A] === void 0) && Ee(_, W.length - (A + 1));
  }
  function G(W, _, A, J, ae, le) {
    if (W > A || W < _) {
      const ge = typeof _ == "bigint" ? "n" : "";
      let je;
      throw le > 3 ? _ === 0 || _ === BigInt(0) ? je = `>= 0${ge} and < 2${ge} ** ${(le + 1) * 8}${ge}` : je = `>= -(2${ge} ** ${(le + 1) * 8 - 1}${ge}) and < 2 ** ${(le + 1) * 8 - 1}${ge}` : je = `>= ${_}${ge} and <= ${A}${ge}`, new Y.ERR_OUT_OF_RANGE("value", je, W);
    }
    M(J, ae, le);
  }
  function ue(W, _) {
    if (typeof W != "number")
      throw new Y.ERR_INVALID_ARG_TYPE(_, "number", W);
  }
  function Ee(W, _, A) {
    throw Math.floor(W) !== W ? (ue(W, A), new Y.ERR_OUT_OF_RANGE(A || "offset", "an integer", W)) : _ < 0 ? new Y.ERR_BUFFER_OUT_OF_BOUNDS() : new Y.ERR_OUT_OF_RANGE(
      A || "offset",
      `>= ${A ? 1 : 0} and <= ${_}`,
      W
    );
  }
  const Le = /[^+/0-9A-Za-z-_]/g;
  function Fe(W) {
    if (W = W.split("=")[0], W = W.trim().replace(Le, ""), W.length < 2)
      return "";
    for (; W.length % 4 !== 0; )
      W = W + "=";
    return W;
  }
  function De(W, _) {
    _ = _ || 1 / 0;
    let A;
    const J = W.length;
    let ae = null;
    const le = [];
    for (let ge = 0; ge < J; ++ge) {
      if (A = W.charCodeAt(ge), A > 55295 && A < 57344) {
        if (!ae) {
          if (A > 56319) {
            (_ -= 3) > -1 && le.push(239, 191, 189);
            continue;
          } else if (ge + 1 === J) {
            (_ -= 3) > -1 && le.push(239, 191, 189);
            continue;
          }
          ae = A;
          continue;
        }
        if (A < 56320) {
          (_ -= 3) > -1 && le.push(239, 191, 189), ae = A;
          continue;
        }
        A = (ae - 55296 << 10 | A - 56320) + 65536;
      } else
        ae && (_ -= 3) > -1 && le.push(239, 191, 189);
      if (ae = null, A < 128) {
        if ((_ -= 1) < 0)
          break;
        le.push(A);
      } else if (A < 2048) {
        if ((_ -= 2) < 0)
          break;
        le.push(
          A >> 6 | 192,
          A & 63 | 128
        );
      } else if (A < 65536) {
        if ((_ -= 3) < 0)
          break;
        le.push(
          A >> 12 | 224,
          A >> 6 & 63 | 128,
          A & 63 | 128
        );
      } else if (A < 1114112) {
        if ((_ -= 4) < 0)
          break;
        le.push(
          A >> 18 | 240,
          A >> 12 & 63 | 128,
          A >> 6 & 63 | 128,
          A & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return le;
  }
  function dt(W) {
    const _ = [];
    for (let A = 0; A < W.length; ++A)
      _.push(W.charCodeAt(A) & 255);
    return _;
  }
  function or(W, _) {
    let A, J, ae;
    const le = [];
    for (let ge = 0; ge < W.length && !((_ -= 2) < 0); ++ge)
      A = W.charCodeAt(ge), J = A >> 8, ae = A % 256, le.push(ae), le.push(J);
    return le;
  }
  function Qe(W) {
    return e.toByteArray(Fe(W));
  }
  function We(W, _, A, J) {
    let ae;
    for (ae = 0; ae < J && !(ae + A >= _.length || ae >= W.length); ++ae)
      _[ae + A] = W[ae];
    return ae;
  }
  function lt(W, _) {
    return W instanceof _ || W != null && W.constructor != null && W.constructor.name != null && W.constructor.name === _.name;
  }
  function qe(W) {
    return W !== W;
  }
  const Ye = function() {
    const W = "0123456789abcdef", _ = new Array(256);
    for (let A = 0; A < 16; ++A) {
      const J = A * 16;
      for (let ae = 0; ae < 16; ++ae)
        _[J + ae] = W[A] + W[ae];
    }
    return _;
  }();
  function st(W) {
    return typeof BigInt > "u" ? Ge : W;
  }
  function Ge() {
    throw new Error("BigInt not supported");
  }
})(Vg);
var CP;
typeof window < "u" && (window.Buffer || (window.Buffer = Vg.Buffer), window.global || (window.global = window), window.process || (window.process = {}), (CP = window.process) != null && CP.env || (window.process = { env: {} }));
var cL = {}, mw = {}, h3 = {};
Object.defineProperty(h3, "__esModule", { value: !0 });
h3.walletLogo = void 0;
const Bpe = (r, e) => {
  let t;
  switch (r) {
    case "standard":
      return t = e, `data:image/svg+xml,%3Csvg width='${e}' height='${t}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    case "circle":
      return t = e, `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${e}' height='${t}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
    case "text":
      return t = (0.1 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogo":
      return t = (0.25 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    case "textLight":
      return t = (0.1 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogoLight":
      return t = (0.25 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    default:
      return t = e, `data:image/svg+xml,%3Csvg width='${e}' height='${t}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
  }
};
h3.walletLogo = Bpe;
var f3 = {};
Object.defineProperty(f3, "__esModule", { value: !0 });
f3.LINK_API_URL = void 0;
f3.LINK_API_URL = "https://www.walletlink.org";
var d3 = {};
Object.defineProperty(d3, "__esModule", { value: !0 });
d3.ScopedLocalStorage = void 0;
class Fpe {
  constructor(e) {
    this.scope = e;
  }
  setItem(e, t) {
    localStorage.setItem(this.scopedKey(e), t);
  }
  getItem(e) {
    return localStorage.getItem(this.scopedKey(e));
  }
  removeItem(e) {
    localStorage.removeItem(this.scopedKey(e));
  }
  clear() {
    const e = this.scopedKey(""), t = [];
    for (let n = 0; n < localStorage.length; n++) {
      const i = localStorage.key(n);
      typeof i == "string" && i.startsWith(e) && t.push(i);
    }
    t.forEach((n) => localStorage.removeItem(n));
  }
  scopedKey(e) {
    return `${this.scope}:${e}`;
  }
}
d3.ScopedLocalStorage = Fpe;
var bg = {}, kd = {};
Object.defineProperty(kd, "__esModule", { value: !0 });
const Upe = Wi;
function J7(r, e, t) {
  try {
    Reflect.apply(r, e, t);
  } catch (n) {
    setTimeout(() => {
      throw n;
    });
  }
}
function jpe(r) {
  const e = r.length, t = new Array(e);
  for (let n = 0; n < e; n += 1)
    t[n] = r[n];
  return t;
}
let Wpe = class extends Upe.EventEmitter {
  emit(e, ...t) {
    let n = e === "error";
    const i = this._events;
    if (i !== void 0)
      n = n && i.error === void 0;
    else if (!n)
      return !1;
    if (n) {
      let o;
      if (t.length > 0 && ([o] = t), o instanceof Error)
        throw o;
      const a = new Error(`Unhandled error.${o ? ` (${o.message})` : ""}`);
      throw a.context = o, a;
    }
    const s = i[e];
    if (s === void 0)
      return !1;
    if (typeof s == "function")
      J7(s, this, t);
    else {
      const o = s.length, a = jpe(s);
      for (let c = 0; c < o; c += 1)
        J7(a[c], this, t);
    }
    return !0;
  }
};
kd.default = Wpe;
var jC = { exports: {} };
jC.exports;
(function(r) {
  (function(e, t) {
    function n(H, p) {
      if (!H)
        throw new Error(p || "Assertion failed");
    }
    function i(H, p) {
      H.super_ = p;
      var w = function() {
      };
      w.prototype = p.prototype, H.prototype = new w(), H.prototype.constructor = H;
    }
    function s(H, p, w) {
      if (s.isBN(H))
        return H;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, H !== null && ((p === "le" || p === "be") && (w = p, p = 10), this._init(H || 0, p || 10, w || "be"));
    }
    typeof e == "object" ? e.exports = s : t.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = sy.Buffer;
    } catch {
    }
    s.isBN = function(p) {
      return p instanceof s ? !0 : p !== null && typeof p == "object" && p.constructor.wordSize === s.wordSize && Array.isArray(p.words);
    }, s.max = function(p, w) {
      return p.cmp(w) > 0 ? p : w;
    }, s.min = function(p, w) {
      return p.cmp(w) < 0 ? p : w;
    }, s.prototype._init = function(p, w, x) {
      if (typeof p == "number")
        return this._initNumber(p, w, x);
      if (typeof p == "object")
        return this._initArray(p, w, x);
      w === "hex" && (w = 16), n(w === (w | 0) && w >= 2 && w <= 36), p = p.toString().replace(/\s+/g, "");
      var N = 0;
      p[0] === "-" && (N++, this.negative = 1), N < p.length && (w === 16 ? this._parseHex(p, N, x) : (this._parseBase(p, w, N), x === "le" && this._initArray(this.toArray(), w, x)));
    }, s.prototype._initNumber = function(p, w, x) {
      p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [p & 67108863], this.length = 1) : p < 4503599627370496 ? (this.words = [
        p & 67108863,
        p / 67108864 & 67108863
      ], this.length = 2) : (n(p < 9007199254740992), this.words = [
        p & 67108863,
        p / 67108864 & 67108863,
        1
      ], this.length = 3), x === "le" && this._initArray(this.toArray(), w, x);
    }, s.prototype._initArray = function(p, w, x) {
      if (n(typeof p.length == "number"), p.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var O, U, q = 0;
      if (x === "be")
        for (N = p.length - 1, O = 0; N >= 0; N -= 3)
          U = p[N] | p[N - 1] << 8 | p[N - 2] << 16, this.words[O] |= U << q & 67108863, this.words[O + 1] = U >>> 26 - q & 67108863, q += 24, q >= 26 && (q -= 26, O++);
      else if (x === "le")
        for (N = 0, O = 0; N < p.length; N += 3)
          U = p[N] | p[N + 1] << 8 | p[N + 2] << 16, this.words[O] |= U << q & 67108863, this.words[O + 1] = U >>> 26 - q & 67108863, q += 24, q >= 26 && (q -= 26, O++);
      return this._strip();
    };
    function a(H, p) {
      var w = H.charCodeAt(p);
      if (w >= 48 && w <= 57)
        return w - 48;
      if (w >= 65 && w <= 70)
        return w - 55;
      if (w >= 97 && w <= 102)
        return w - 87;
      n(!1, "Invalid character in " + H);
    }
    function c(H, p, w) {
      var x = a(H, w);
      return w - 1 >= p && (x |= a(H, w - 1) << 4), x;
    }
    s.prototype._parseHex = function(p, w, x) {
      this.length = Math.ceil((p.length - w) / 6), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++)
        this.words[N] = 0;
      var O = 0, U = 0, q;
      if (x === "be")
        for (N = p.length - 1; N >= w; N -= 2)
          q = c(p, w, N) << O, this.words[U] |= q & 67108863, O >= 18 ? (O -= 18, U += 1, this.words[U] |= q >>> 26) : O += 8;
      else {
        var B = p.length - w;
        for (N = B % 2 === 0 ? w + 1 : w; N < p.length; N += 2)
          q = c(p, w, N) << O, this.words[U] |= q & 67108863, O >= 18 ? (O -= 18, U += 1, this.words[U] |= q >>> 26) : O += 8;
      }
      this._strip();
    };
    function u(H, p, w, x) {
      for (var N = 0, O = 0, U = Math.min(H.length, w), q = p; q < U; q++) {
        var B = H.charCodeAt(q) - 48;
        N *= x, B >= 49 ? O = B - 49 + 10 : B >= 17 ? O = B - 17 + 10 : O = B, n(B >= 0 && O < x, "Invalid character"), N += O;
      }
      return N;
    }
    s.prototype._parseBase = function(p, w, x) {
      this.words = [0], this.length = 1;
      for (var N = 0, O = 1; O <= 67108863; O *= w)
        N++;
      N--, O = O / w | 0;
      for (var U = p.length - x, q = U % N, B = Math.min(U, U - q) + x, E = 0, V = x; V < B; V += N)
        E = u(p, V, V + N, w), this.imuln(O), this.words[0] + E < 67108864 ? this.words[0] += E : this._iaddn(E);
      if (q !== 0) {
        var be = 1;
        for (E = u(p, V, p.length, w), V = 0; V < q; V++)
          be *= w;
        this.imuln(be), this.words[0] + E < 67108864 ? this.words[0] += E : this._iaddn(E);
      }
      this._strip();
    }, s.prototype.copy = function(p) {
      p.words = new Array(this.length);
      for (var w = 0; w < this.length; w++)
        p.words[w] = this.words[w];
      p.length = this.length, p.negative = this.negative, p.red = this.red;
    };
    function f(H, p) {
      H.words = p.words, H.length = p.length, H.negative = p.negative, H.red = p.red;
    }
    if (s.prototype._move = function(p) {
      f(p, this);
    }, s.prototype.clone = function() {
      var p = new s(null);
      return this.copy(p), p;
    }, s.prototype._expand = function(p) {
      for (; this.length < p; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = d;
      } catch {
        s.prototype.inspect = d;
      }
    else
      s.prototype.inspect = d;
    function d() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var m = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], y = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], b = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(p, w) {
      p = p || 10, w = w | 0 || 1;
      var x;
      if (p === 16 || p === "hex") {
        x = "";
        for (var N = 0, O = 0, U = 0; U < this.length; U++) {
          var q = this.words[U], B = ((q << N | O) & 16777215).toString(16);
          O = q >>> 24 - N & 16777215, N += 2, N >= 26 && (N -= 26, U--), O !== 0 || U !== this.length - 1 ? x = m[6 - B.length] + B + x : x = B + x;
        }
        for (O !== 0 && (x = O.toString(16) + x); x.length % w !== 0; )
          x = "0" + x;
        return this.negative !== 0 && (x = "-" + x), x;
      }
      if (p === (p | 0) && p >= 2 && p <= 36) {
        var E = y[p], V = b[p];
        x = "";
        var be = this.clone();
        for (be.negative = 0; !be.isZero(); ) {
          var ve = be.modrn(V).toString(p);
          be = be.idivn(V), be.isZero() ? x = ve + x : x = m[E - ve.length] + ve + x;
        }
        for (this.isZero() && (x = "0" + x); x.length % w !== 0; )
          x = "0" + x;
        return this.negative !== 0 && (x = "-" + x), x;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var p = this.words[0];
      return this.length === 2 ? p += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (s.prototype.toBuffer = function(p, w) {
      return this.toArrayLike(o, p, w);
    }), s.prototype.toArray = function(p, w) {
      return this.toArrayLike(Array, p, w);
    };
    var I = function(p, w) {
      return p.allocUnsafe ? p.allocUnsafe(w) : new p(w);
    };
    s.prototype.toArrayLike = function(p, w, x) {
      this._strip();
      var N = this.byteLength(), O = x || Math.max(1, N);
      n(N <= O, "byte array longer than desired length"), n(O > 0, "Requested array length <= 0");
      var U = I(p, O), q = w === "le" ? "LE" : "BE";
      return this["_toArrayLike" + q](U, N), U;
    }, s.prototype._toArrayLikeLE = function(p, w) {
      for (var x = 0, N = 0, O = 0, U = 0; O < this.length; O++) {
        var q = this.words[O] << U | N;
        p[x++] = q & 255, x < p.length && (p[x++] = q >> 8 & 255), x < p.length && (p[x++] = q >> 16 & 255), U === 6 ? (x < p.length && (p[x++] = q >> 24 & 255), N = 0, U = 0) : (N = q >>> 24, U += 2);
      }
      if (x < p.length)
        for (p[x++] = N; x < p.length; )
          p[x++] = 0;
    }, s.prototype._toArrayLikeBE = function(p, w) {
      for (var x = p.length - 1, N = 0, O = 0, U = 0; O < this.length; O++) {
        var q = this.words[O] << U | N;
        p[x--] = q & 255, x >= 0 && (p[x--] = q >> 8 & 255), x >= 0 && (p[x--] = q >> 16 & 255), U === 6 ? (x >= 0 && (p[x--] = q >> 24 & 255), N = 0, U = 0) : (N = q >>> 24, U += 2);
      }
      if (x >= 0)
        for (p[x--] = N; x >= 0; )
          p[x--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(p) {
      return 32 - Math.clz32(p);
    } : s.prototype._countBits = function(p) {
      var w = p, x = 0;
      return w >= 4096 && (x += 13, w >>>= 13), w >= 64 && (x += 7, w >>>= 7), w >= 8 && (x += 4, w >>>= 4), w >= 2 && (x += 2, w >>>= 2), x + w;
    }, s.prototype._zeroBits = function(p) {
      if (p === 0)
        return 26;
      var w = p, x = 0;
      return w & 8191 || (x += 13, w >>>= 13), w & 127 || (x += 7, w >>>= 7), w & 15 || (x += 4, w >>>= 4), w & 3 || (x += 2, w >>>= 2), w & 1 || x++, x;
    }, s.prototype.bitLength = function() {
      var p = this.words[this.length - 1], w = this._countBits(p);
      return (this.length - 1) * 26 + w;
    };
    function k(H) {
      for (var p = new Array(H.bitLength()), w = 0; w < p.length; w++) {
        var x = w / 26 | 0, N = w % 26;
        p[w] = H.words[x] >>> N & 1;
      }
      return p;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var p = 0, w = 0; w < this.length; w++) {
        var x = this._zeroBits(this.words[w]);
        if (p += x, x !== 26)
          break;
      }
      return p;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(p) {
      return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(p) {
      return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(p) {
      for (; this.length < p.length; )
        this.words[this.length++] = 0;
      for (var w = 0; w < p.length; w++)
        this.words[w] = this.words[w] | p.words[w];
      return this._strip();
    }, s.prototype.ior = function(p) {
      return n((this.negative | p.negative) === 0), this.iuor(p);
    }, s.prototype.or = function(p) {
      return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
    }, s.prototype.uor = function(p) {
      return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
    }, s.prototype.iuand = function(p) {
      var w;
      this.length > p.length ? w = p : w = this;
      for (var x = 0; x < w.length; x++)
        this.words[x] = this.words[x] & p.words[x];
      return this.length = w.length, this._strip();
    }, s.prototype.iand = function(p) {
      return n((this.negative | p.negative) === 0), this.iuand(p);
    }, s.prototype.and = function(p) {
      return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
    }, s.prototype.uand = function(p) {
      return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
    }, s.prototype.iuxor = function(p) {
      var w, x;
      this.length > p.length ? (w = this, x = p) : (w = p, x = this);
      for (var N = 0; N < x.length; N++)
        this.words[N] = w.words[N] ^ x.words[N];
      if (this !== w)
        for (; N < w.length; N++)
          this.words[N] = w.words[N];
      return this.length = w.length, this._strip();
    }, s.prototype.ixor = function(p) {
      return n((this.negative | p.negative) === 0), this.iuxor(p);
    }, s.prototype.xor = function(p) {
      return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
    }, s.prototype.uxor = function(p) {
      return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
    }, s.prototype.inotn = function(p) {
      n(typeof p == "number" && p >= 0);
      var w = Math.ceil(p / 26) | 0, x = p % 26;
      this._expand(w), x > 0 && w--;
      for (var N = 0; N < w; N++)
        this.words[N] = ~this.words[N] & 67108863;
      return x > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - x), this._strip();
    }, s.prototype.notn = function(p) {
      return this.clone().inotn(p);
    }, s.prototype.setn = function(p, w) {
      n(typeof p == "number" && p >= 0);
      var x = p / 26 | 0, N = p % 26;
      return this._expand(x + 1), w ? this.words[x] = this.words[x] | 1 << N : this.words[x] = this.words[x] & ~(1 << N), this._strip();
    }, s.prototype.iadd = function(p) {
      var w;
      if (this.negative !== 0 && p.negative === 0)
        return this.negative = 0, w = this.isub(p), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && p.negative !== 0)
        return p.negative = 0, w = this.isub(p), p.negative = 1, w._normSign();
      var x, N;
      this.length > p.length ? (x = this, N = p) : (x = p, N = this);
      for (var O = 0, U = 0; U < N.length; U++)
        w = (x.words[U] | 0) + (N.words[U] | 0) + O, this.words[U] = w & 67108863, O = w >>> 26;
      for (; O !== 0 && U < x.length; U++)
        w = (x.words[U] | 0) + O, this.words[U] = w & 67108863, O = w >>> 26;
      if (this.length = x.length, O !== 0)
        this.words[this.length] = O, this.length++;
      else if (x !== this)
        for (; U < x.length; U++)
          this.words[U] = x.words[U];
      return this;
    }, s.prototype.add = function(p) {
      var w;
      return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, w = this.sub(p), p.negative ^= 1, w) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, w = p.sub(this), this.negative = 1, w) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
    }, s.prototype.isub = function(p) {
      if (p.negative !== 0) {
        p.negative = 0;
        var w = this.iadd(p);
        return p.negative = 1, w._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
      var x = this.cmp(p);
      if (x === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var N, O;
      x > 0 ? (N = this, O = p) : (N = p, O = this);
      for (var U = 0, q = 0; q < O.length; q++)
        w = (N.words[q] | 0) - (O.words[q] | 0) + U, U = w >> 26, this.words[q] = w & 67108863;
      for (; U !== 0 && q < N.length; q++)
        w = (N.words[q] | 0) + U, U = w >> 26, this.words[q] = w & 67108863;
      if (U === 0 && q < N.length && N !== this)
        for (; q < N.length; q++)
          this.words[q] = N.words[q];
      return this.length = Math.max(this.length, q), N !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(p) {
      return this.clone().isub(p);
    };
    function R(H, p, w) {
      w.negative = p.negative ^ H.negative;
      var x = H.length + p.length | 0;
      w.length = x, x = x - 1 | 0;
      var N = H.words[0] | 0, O = p.words[0] | 0, U = N * O, q = U & 67108863, B = U / 67108864 | 0;
      w.words[0] = q;
      for (var E = 1; E < x; E++) {
        for (var V = B >>> 26, be = B & 67108863, ve = Math.min(E, p.length - 1), ne = Math.max(0, E - H.length + 1); ne <= ve; ne++) {
          var K = E - ne | 0;
          N = H.words[K] | 0, O = p.words[ne] | 0, U = N * O + be, V += U / 67108864 | 0, be = U & 67108863;
        }
        w.words[E] = be | 0, B = V | 0;
      }
      return B !== 0 ? w.words[E] = B | 0 : w.length--, w._strip();
    }
    var T = function(p, w, x) {
      var N = p.words, O = w.words, U = x.words, q = 0, B, E, V, be = N[0] | 0, ve = be & 8191, ne = be >>> 13, K = N[1] | 0, Y = K & 8191, ee = K >>> 13, S = N[2] | 0, M = S & 8191, G = S >>> 13, ue = N[3] | 0, Ee = ue & 8191, Le = ue >>> 13, Fe = N[4] | 0, De = Fe & 8191, dt = Fe >>> 13, or = N[5] | 0, Qe = or & 8191, We = or >>> 13, lt = N[6] | 0, qe = lt & 8191, Ye = lt >>> 13, st = N[7] | 0, Ge = st & 8191, W = st >>> 13, _ = N[8] | 0, A = _ & 8191, J = _ >>> 13, ae = N[9] | 0, le = ae & 8191, ge = ae >>> 13, je = O[0] | 0, Ue = je & 8191, it = je >>> 13, jt = O[1] | 0, at = jt & 8191, Jt = jt >>> 13, _i = O[2] | 0, yr = _i & 8191, _r = _i >>> 13, Pr = O[3] | 0, It = Pr & 8191, Mt = Pr >>> 13, Mr = O[4] | 0, Nt = Mr & 8191, Rt = Mr >>> 13, Hr = O[5] | 0, Bt = Hr & 8191, Dt = Hr >>> 13, zr = O[6] | 0, kt = zr & 8191, $t = zr >>> 13, Dr = O[7] | 0, xt = Dr & 8191, Ft = Dr >>> 13, Vr = O[8] | 0, $r = Vr & 8191, Lr = Vr >>> 13, za = O[9] | 0, ar = za & 8191, Br = za >>> 13;
      x.negative = p.negative ^ w.negative, x.length = 19, B = Math.imul(ve, Ue), E = Math.imul(ve, it), E = E + Math.imul(ne, Ue) | 0, V = Math.imul(ne, it);
      var qo = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (qo >>> 26) | 0, qo &= 67108863, B = Math.imul(Y, Ue), E = Math.imul(Y, it), E = E + Math.imul(ee, Ue) | 0, V = Math.imul(ee, it), B = B + Math.imul(ve, at) | 0, E = E + Math.imul(ve, Jt) | 0, E = E + Math.imul(ne, at) | 0, V = V + Math.imul(ne, Jt) | 0;
      var Go = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (Go >>> 26) | 0, Go &= 67108863, B = Math.imul(M, Ue), E = Math.imul(M, it), E = E + Math.imul(G, Ue) | 0, V = Math.imul(G, it), B = B + Math.imul(Y, at) | 0, E = E + Math.imul(Y, Jt) | 0, E = E + Math.imul(ee, at) | 0, V = V + Math.imul(ee, Jt) | 0, B = B + Math.imul(ve, yr) | 0, E = E + Math.imul(ve, _r) | 0, E = E + Math.imul(ne, yr) | 0, V = V + Math.imul(ne, _r) | 0;
      var Ko = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (Ko >>> 26) | 0, Ko &= 67108863, B = Math.imul(Ee, Ue), E = Math.imul(Ee, it), E = E + Math.imul(Le, Ue) | 0, V = Math.imul(Le, it), B = B + Math.imul(M, at) | 0, E = E + Math.imul(M, Jt) | 0, E = E + Math.imul(G, at) | 0, V = V + Math.imul(G, Jt) | 0, B = B + Math.imul(Y, yr) | 0, E = E + Math.imul(Y, _r) | 0, E = E + Math.imul(ee, yr) | 0, V = V + Math.imul(ee, _r) | 0, B = B + Math.imul(ve, It) | 0, E = E + Math.imul(ve, Mt) | 0, E = E + Math.imul(ne, It) | 0, V = V + Math.imul(ne, Mt) | 0;
      var Zo = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (Zo >>> 26) | 0, Zo &= 67108863, B = Math.imul(De, Ue), E = Math.imul(De, it), E = E + Math.imul(dt, Ue) | 0, V = Math.imul(dt, it), B = B + Math.imul(Ee, at) | 0, E = E + Math.imul(Ee, Jt) | 0, E = E + Math.imul(Le, at) | 0, V = V + Math.imul(Le, Jt) | 0, B = B + Math.imul(M, yr) | 0, E = E + Math.imul(M, _r) | 0, E = E + Math.imul(G, yr) | 0, V = V + Math.imul(G, _r) | 0, B = B + Math.imul(Y, It) | 0, E = E + Math.imul(Y, Mt) | 0, E = E + Math.imul(ee, It) | 0, V = V + Math.imul(ee, Mt) | 0, B = B + Math.imul(ve, Nt) | 0, E = E + Math.imul(ve, Rt) | 0, E = E + Math.imul(ne, Nt) | 0, V = V + Math.imul(ne, Rt) | 0;
      var hi = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, B = Math.imul(Qe, Ue), E = Math.imul(Qe, it), E = E + Math.imul(We, Ue) | 0, V = Math.imul(We, it), B = B + Math.imul(De, at) | 0, E = E + Math.imul(De, Jt) | 0, E = E + Math.imul(dt, at) | 0, V = V + Math.imul(dt, Jt) | 0, B = B + Math.imul(Ee, yr) | 0, E = E + Math.imul(Ee, _r) | 0, E = E + Math.imul(Le, yr) | 0, V = V + Math.imul(Le, _r) | 0, B = B + Math.imul(M, It) | 0, E = E + Math.imul(M, Mt) | 0, E = E + Math.imul(G, It) | 0, V = V + Math.imul(G, Mt) | 0, B = B + Math.imul(Y, Nt) | 0, E = E + Math.imul(Y, Rt) | 0, E = E + Math.imul(ee, Nt) | 0, V = V + Math.imul(ee, Rt) | 0, B = B + Math.imul(ve, Bt) | 0, E = E + Math.imul(ve, Dt) | 0, E = E + Math.imul(ne, Bt) | 0, V = V + Math.imul(ne, Dt) | 0;
      var ps = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (ps >>> 26) | 0, ps &= 67108863, B = Math.imul(qe, Ue), E = Math.imul(qe, it), E = E + Math.imul(Ye, Ue) | 0, V = Math.imul(Ye, it), B = B + Math.imul(Qe, at) | 0, E = E + Math.imul(Qe, Jt) | 0, E = E + Math.imul(We, at) | 0, V = V + Math.imul(We, Jt) | 0, B = B + Math.imul(De, yr) | 0, E = E + Math.imul(De, _r) | 0, E = E + Math.imul(dt, yr) | 0, V = V + Math.imul(dt, _r) | 0, B = B + Math.imul(Ee, It) | 0, E = E + Math.imul(Ee, Mt) | 0, E = E + Math.imul(Le, It) | 0, V = V + Math.imul(Le, Mt) | 0, B = B + Math.imul(M, Nt) | 0, E = E + Math.imul(M, Rt) | 0, E = E + Math.imul(G, Nt) | 0, V = V + Math.imul(G, Rt) | 0, B = B + Math.imul(Y, Bt) | 0, E = E + Math.imul(Y, Dt) | 0, E = E + Math.imul(ee, Bt) | 0, V = V + Math.imul(ee, Dt) | 0, B = B + Math.imul(ve, kt) | 0, E = E + Math.imul(ve, $t) | 0, E = E + Math.imul(ne, kt) | 0, V = V + Math.imul(ne, $t) | 0;
      var Jo = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (Jo >>> 26) | 0, Jo &= 67108863, B = Math.imul(Ge, Ue), E = Math.imul(Ge, it), E = E + Math.imul(W, Ue) | 0, V = Math.imul(W, it), B = B + Math.imul(qe, at) | 0, E = E + Math.imul(qe, Jt) | 0, E = E + Math.imul(Ye, at) | 0, V = V + Math.imul(Ye, Jt) | 0, B = B + Math.imul(Qe, yr) | 0, E = E + Math.imul(Qe, _r) | 0, E = E + Math.imul(We, yr) | 0, V = V + Math.imul(We, _r) | 0, B = B + Math.imul(De, It) | 0, E = E + Math.imul(De, Mt) | 0, E = E + Math.imul(dt, It) | 0, V = V + Math.imul(dt, Mt) | 0, B = B + Math.imul(Ee, Nt) | 0, E = E + Math.imul(Ee, Rt) | 0, E = E + Math.imul(Le, Nt) | 0, V = V + Math.imul(Le, Rt) | 0, B = B + Math.imul(M, Bt) | 0, E = E + Math.imul(M, Dt) | 0, E = E + Math.imul(G, Bt) | 0, V = V + Math.imul(G, Dt) | 0, B = B + Math.imul(Y, kt) | 0, E = E + Math.imul(Y, $t) | 0, E = E + Math.imul(ee, kt) | 0, V = V + Math.imul(ee, $t) | 0, B = B + Math.imul(ve, xt) | 0, E = E + Math.imul(ve, Ft) | 0, E = E + Math.imul(ne, xt) | 0, V = V + Math.imul(ne, Ft) | 0;
      var gs = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (gs >>> 26) | 0, gs &= 67108863, B = Math.imul(A, Ue), E = Math.imul(A, it), E = E + Math.imul(J, Ue) | 0, V = Math.imul(J, it), B = B + Math.imul(Ge, at) | 0, E = E + Math.imul(Ge, Jt) | 0, E = E + Math.imul(W, at) | 0, V = V + Math.imul(W, Jt) | 0, B = B + Math.imul(qe, yr) | 0, E = E + Math.imul(qe, _r) | 0, E = E + Math.imul(Ye, yr) | 0, V = V + Math.imul(Ye, _r) | 0, B = B + Math.imul(Qe, It) | 0, E = E + Math.imul(Qe, Mt) | 0, E = E + Math.imul(We, It) | 0, V = V + Math.imul(We, Mt) | 0, B = B + Math.imul(De, Nt) | 0, E = E + Math.imul(De, Rt) | 0, E = E + Math.imul(dt, Nt) | 0, V = V + Math.imul(dt, Rt) | 0, B = B + Math.imul(Ee, Bt) | 0, E = E + Math.imul(Ee, Dt) | 0, E = E + Math.imul(Le, Bt) | 0, V = V + Math.imul(Le, Dt) | 0, B = B + Math.imul(M, kt) | 0, E = E + Math.imul(M, $t) | 0, E = E + Math.imul(G, kt) | 0, V = V + Math.imul(G, $t) | 0, B = B + Math.imul(Y, xt) | 0, E = E + Math.imul(Y, Ft) | 0, E = E + Math.imul(ee, xt) | 0, V = V + Math.imul(ee, Ft) | 0, B = B + Math.imul(ve, $r) | 0, E = E + Math.imul(ve, Lr) | 0, E = E + Math.imul(ne, $r) | 0, V = V + Math.imul(ne, Lr) | 0;
      var Qo = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (Qo >>> 26) | 0, Qo &= 67108863, B = Math.imul(le, Ue), E = Math.imul(le, it), E = E + Math.imul(ge, Ue) | 0, V = Math.imul(ge, it), B = B + Math.imul(A, at) | 0, E = E + Math.imul(A, Jt) | 0, E = E + Math.imul(J, at) | 0, V = V + Math.imul(J, Jt) | 0, B = B + Math.imul(Ge, yr) | 0, E = E + Math.imul(Ge, _r) | 0, E = E + Math.imul(W, yr) | 0, V = V + Math.imul(W, _r) | 0, B = B + Math.imul(qe, It) | 0, E = E + Math.imul(qe, Mt) | 0, E = E + Math.imul(Ye, It) | 0, V = V + Math.imul(Ye, Mt) | 0, B = B + Math.imul(Qe, Nt) | 0, E = E + Math.imul(Qe, Rt) | 0, E = E + Math.imul(We, Nt) | 0, V = V + Math.imul(We, Rt) | 0, B = B + Math.imul(De, Bt) | 0, E = E + Math.imul(De, Dt) | 0, E = E + Math.imul(dt, Bt) | 0, V = V + Math.imul(dt, Dt) | 0, B = B + Math.imul(Ee, kt) | 0, E = E + Math.imul(Ee, $t) | 0, E = E + Math.imul(Le, kt) | 0, V = V + Math.imul(Le, $t) | 0, B = B + Math.imul(M, xt) | 0, E = E + Math.imul(M, Ft) | 0, E = E + Math.imul(G, xt) | 0, V = V + Math.imul(G, Ft) | 0, B = B + Math.imul(Y, $r) | 0, E = E + Math.imul(Y, Lr) | 0, E = E + Math.imul(ee, $r) | 0, V = V + Math.imul(ee, Lr) | 0, B = B + Math.imul(ve, ar) | 0, E = E + Math.imul(ve, Br) | 0, E = E + Math.imul(ne, ar) | 0, V = V + Math.imul(ne, Br) | 0;
      var Yo = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (Yo >>> 26) | 0, Yo &= 67108863, B = Math.imul(le, at), E = Math.imul(le, Jt), E = E + Math.imul(ge, at) | 0, V = Math.imul(ge, Jt), B = B + Math.imul(A, yr) | 0, E = E + Math.imul(A, _r) | 0, E = E + Math.imul(J, yr) | 0, V = V + Math.imul(J, _r) | 0, B = B + Math.imul(Ge, It) | 0, E = E + Math.imul(Ge, Mt) | 0, E = E + Math.imul(W, It) | 0, V = V + Math.imul(W, Mt) | 0, B = B + Math.imul(qe, Nt) | 0, E = E + Math.imul(qe, Rt) | 0, E = E + Math.imul(Ye, Nt) | 0, V = V + Math.imul(Ye, Rt) | 0, B = B + Math.imul(Qe, Bt) | 0, E = E + Math.imul(Qe, Dt) | 0, E = E + Math.imul(We, Bt) | 0, V = V + Math.imul(We, Dt) | 0, B = B + Math.imul(De, kt) | 0, E = E + Math.imul(De, $t) | 0, E = E + Math.imul(dt, kt) | 0, V = V + Math.imul(dt, $t) | 0, B = B + Math.imul(Ee, xt) | 0, E = E + Math.imul(Ee, Ft) | 0, E = E + Math.imul(Le, xt) | 0, V = V + Math.imul(Le, Ft) | 0, B = B + Math.imul(M, $r) | 0, E = E + Math.imul(M, Lr) | 0, E = E + Math.imul(G, $r) | 0, V = V + Math.imul(G, Lr) | 0, B = B + Math.imul(Y, ar) | 0, E = E + Math.imul(Y, Br) | 0, E = E + Math.imul(ee, ar) | 0, V = V + Math.imul(ee, Br) | 0;
      var ms = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (ms >>> 26) | 0, ms &= 67108863, B = Math.imul(le, yr), E = Math.imul(le, _r), E = E + Math.imul(ge, yr) | 0, V = Math.imul(ge, _r), B = B + Math.imul(A, It) | 0, E = E + Math.imul(A, Mt) | 0, E = E + Math.imul(J, It) | 0, V = V + Math.imul(J, Mt) | 0, B = B + Math.imul(Ge, Nt) | 0, E = E + Math.imul(Ge, Rt) | 0, E = E + Math.imul(W, Nt) | 0, V = V + Math.imul(W, Rt) | 0, B = B + Math.imul(qe, Bt) | 0, E = E + Math.imul(qe, Dt) | 0, E = E + Math.imul(Ye, Bt) | 0, V = V + Math.imul(Ye, Dt) | 0, B = B + Math.imul(Qe, kt) | 0, E = E + Math.imul(Qe, $t) | 0, E = E + Math.imul(We, kt) | 0, V = V + Math.imul(We, $t) | 0, B = B + Math.imul(De, xt) | 0, E = E + Math.imul(De, Ft) | 0, E = E + Math.imul(dt, xt) | 0, V = V + Math.imul(dt, Ft) | 0, B = B + Math.imul(Ee, $r) | 0, E = E + Math.imul(Ee, Lr) | 0, E = E + Math.imul(Le, $r) | 0, V = V + Math.imul(Le, Lr) | 0, B = B + Math.imul(M, ar) | 0, E = E + Math.imul(M, Br) | 0, E = E + Math.imul(G, ar) | 0, V = V + Math.imul(G, Br) | 0;
      var lo = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (lo >>> 26) | 0, lo &= 67108863, B = Math.imul(le, It), E = Math.imul(le, Mt), E = E + Math.imul(ge, It) | 0, V = Math.imul(ge, Mt), B = B + Math.imul(A, Nt) | 0, E = E + Math.imul(A, Rt) | 0, E = E + Math.imul(J, Nt) | 0, V = V + Math.imul(J, Rt) | 0, B = B + Math.imul(Ge, Bt) | 0, E = E + Math.imul(Ge, Dt) | 0, E = E + Math.imul(W, Bt) | 0, V = V + Math.imul(W, Dt) | 0, B = B + Math.imul(qe, kt) | 0, E = E + Math.imul(qe, $t) | 0, E = E + Math.imul(Ye, kt) | 0, V = V + Math.imul(Ye, $t) | 0, B = B + Math.imul(Qe, xt) | 0, E = E + Math.imul(Qe, Ft) | 0, E = E + Math.imul(We, xt) | 0, V = V + Math.imul(We, Ft) | 0, B = B + Math.imul(De, $r) | 0, E = E + Math.imul(De, Lr) | 0, E = E + Math.imul(dt, $r) | 0, V = V + Math.imul(dt, Lr) | 0, B = B + Math.imul(Ee, ar) | 0, E = E + Math.imul(Ee, Br) | 0, E = E + Math.imul(Le, ar) | 0, V = V + Math.imul(Le, Br) | 0;
      var uo = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (uo >>> 26) | 0, uo &= 67108863, B = Math.imul(le, Nt), E = Math.imul(le, Rt), E = E + Math.imul(ge, Nt) | 0, V = Math.imul(ge, Rt), B = B + Math.imul(A, Bt) | 0, E = E + Math.imul(A, Dt) | 0, E = E + Math.imul(J, Bt) | 0, V = V + Math.imul(J, Dt) | 0, B = B + Math.imul(Ge, kt) | 0, E = E + Math.imul(Ge, $t) | 0, E = E + Math.imul(W, kt) | 0, V = V + Math.imul(W, $t) | 0, B = B + Math.imul(qe, xt) | 0, E = E + Math.imul(qe, Ft) | 0, E = E + Math.imul(Ye, xt) | 0, V = V + Math.imul(Ye, Ft) | 0, B = B + Math.imul(Qe, $r) | 0, E = E + Math.imul(Qe, Lr) | 0, E = E + Math.imul(We, $r) | 0, V = V + Math.imul(We, Lr) | 0, B = B + Math.imul(De, ar) | 0, E = E + Math.imul(De, Br) | 0, E = E + Math.imul(dt, ar) | 0, V = V + Math.imul(dt, Br) | 0;
      var Vn = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (Vn >>> 26) | 0, Vn &= 67108863, B = Math.imul(le, Bt), E = Math.imul(le, Dt), E = E + Math.imul(ge, Bt) | 0, V = Math.imul(ge, Dt), B = B + Math.imul(A, kt) | 0, E = E + Math.imul(A, $t) | 0, E = E + Math.imul(J, kt) | 0, V = V + Math.imul(J, $t) | 0, B = B + Math.imul(Ge, xt) | 0, E = E + Math.imul(Ge, Ft) | 0, E = E + Math.imul(W, xt) | 0, V = V + Math.imul(W, Ft) | 0, B = B + Math.imul(qe, $r) | 0, E = E + Math.imul(qe, Lr) | 0, E = E + Math.imul(Ye, $r) | 0, V = V + Math.imul(Ye, Lr) | 0, B = B + Math.imul(Qe, ar) | 0, E = E + Math.imul(Qe, Br) | 0, E = E + Math.imul(We, ar) | 0, V = V + Math.imul(We, Br) | 0;
      var vh = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (vh >>> 26) | 0, vh &= 67108863, B = Math.imul(le, kt), E = Math.imul(le, $t), E = E + Math.imul(ge, kt) | 0, V = Math.imul(ge, $t), B = B + Math.imul(A, xt) | 0, E = E + Math.imul(A, Ft) | 0, E = E + Math.imul(J, xt) | 0, V = V + Math.imul(J, Ft) | 0, B = B + Math.imul(Ge, $r) | 0, E = E + Math.imul(Ge, Lr) | 0, E = E + Math.imul(W, $r) | 0, V = V + Math.imul(W, Lr) | 0, B = B + Math.imul(qe, ar) | 0, E = E + Math.imul(qe, Br) | 0, E = E + Math.imul(Ye, ar) | 0, V = V + Math.imul(Ye, Br) | 0;
      var bh = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (bh >>> 26) | 0, bh &= 67108863, B = Math.imul(le, xt), E = Math.imul(le, Ft), E = E + Math.imul(ge, xt) | 0, V = Math.imul(ge, Ft), B = B + Math.imul(A, $r) | 0, E = E + Math.imul(A, Lr) | 0, E = E + Math.imul(J, $r) | 0, V = V + Math.imul(J, Lr) | 0, B = B + Math.imul(Ge, ar) | 0, E = E + Math.imul(Ge, Br) | 0, E = E + Math.imul(W, ar) | 0, V = V + Math.imul(W, Br) | 0;
      var _h = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (_h >>> 26) | 0, _h &= 67108863, B = Math.imul(le, $r), E = Math.imul(le, Lr), E = E + Math.imul(ge, $r) | 0, V = Math.imul(ge, Lr), B = B + Math.imul(A, ar) | 0, E = E + Math.imul(A, Br) | 0, E = E + Math.imul(J, ar) | 0, V = V + Math.imul(J, Br) | 0;
      var Eh = (q + B | 0) + ((E & 8191) << 13) | 0;
      q = (V + (E >>> 13) | 0) + (Eh >>> 26) | 0, Eh &= 67108863, B = Math.imul(le, ar), E = Math.imul(le, Br), E = E + Math.imul(ge, ar) | 0, V = Math.imul(ge, Br);
      var ql = (q + B | 0) + ((E & 8191) << 13) | 0;
      return q = (V + (E >>> 13) | 0) + (ql >>> 26) | 0, ql &= 67108863, U[0] = qo, U[1] = Go, U[2] = Ko, U[3] = Zo, U[4] = hi, U[5] = ps, U[6] = Jo, U[7] = gs, U[8] = Qo, U[9] = Yo, U[10] = ms, U[11] = lo, U[12] = uo, U[13] = Vn, U[14] = vh, U[15] = bh, U[16] = _h, U[17] = Eh, U[18] = ql, q !== 0 && (U[19] = q, x.length++), x;
    };
    Math.imul || (T = R);
    function $(H, p, w) {
      w.negative = p.negative ^ H.negative, w.length = H.length + p.length;
      for (var x = 0, N = 0, O = 0; O < w.length - 1; O++) {
        var U = N;
        N = 0;
        for (var q = x & 67108863, B = Math.min(O, p.length - 1), E = Math.max(0, O - H.length + 1); E <= B; E++) {
          var V = O - E, be = H.words[V] | 0, ve = p.words[E] | 0, ne = be * ve, K = ne & 67108863;
          U = U + (ne / 67108864 | 0) | 0, K = K + q | 0, q = K & 67108863, U = U + (K >>> 26) | 0, N += U >>> 26, U &= 67108863;
        }
        w.words[O] = q, x = U, U = N;
      }
      return x !== 0 ? w.words[O] = x : w.length--, w._strip();
    }
    function D(H, p, w) {
      return $(H, p, w);
    }
    s.prototype.mulTo = function(p, w) {
      var x, N = this.length + p.length;
      return this.length === 10 && p.length === 10 ? x = T(this, p, w) : N < 63 ? x = R(this, p, w) : N < 1024 ? x = $(this, p, w) : x = D(this, p, w), x;
    }, s.prototype.mul = function(p) {
      var w = new s(null);
      return w.words = new Array(this.length + p.length), this.mulTo(p, w);
    }, s.prototype.mulf = function(p) {
      var w = new s(null);
      return w.words = new Array(this.length + p.length), D(this, p, w);
    }, s.prototype.imul = function(p) {
      return this.clone().mulTo(p, this);
    }, s.prototype.imuln = function(p) {
      var w = p < 0;
      w && (p = -p), n(typeof p == "number"), n(p < 67108864);
      for (var x = 0, N = 0; N < this.length; N++) {
        var O = (this.words[N] | 0) * p, U = (O & 67108863) + (x & 67108863);
        x >>= 26, x += O / 67108864 | 0, x += U >>> 26, this.words[N] = U & 67108863;
      }
      return x !== 0 && (this.words[N] = x, this.length++), w ? this.ineg() : this;
    }, s.prototype.muln = function(p) {
      return this.clone().imuln(p);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(p) {
      var w = k(p);
      if (w.length === 0)
        return new s(1);
      for (var x = this, N = 0; N < w.length && w[N] === 0; N++, x = x.sqr())
        ;
      if (++N < w.length)
        for (var O = x.sqr(); N < w.length; N++, O = O.sqr())
          w[N] !== 0 && (x = x.mul(O));
      return x;
    }, s.prototype.iushln = function(p) {
      n(typeof p == "number" && p >= 0);
      var w = p % 26, x = (p - w) / 26, N = 67108863 >>> 26 - w << 26 - w, O;
      if (w !== 0) {
        var U = 0;
        for (O = 0; O < this.length; O++) {
          var q = this.words[O] & N, B = (this.words[O] | 0) - q << w;
          this.words[O] = B | U, U = q >>> 26 - w;
        }
        U && (this.words[O] = U, this.length++);
      }
      if (x !== 0) {
        for (O = this.length - 1; O >= 0; O--)
          this.words[O + x] = this.words[O];
        for (O = 0; O < x; O++)
          this.words[O] = 0;
        this.length += x;
      }
      return this._strip();
    }, s.prototype.ishln = function(p) {
      return n(this.negative === 0), this.iushln(p);
    }, s.prototype.iushrn = function(p, w, x) {
      n(typeof p == "number" && p >= 0);
      var N;
      w ? N = (w - w % 26) / 26 : N = 0;
      var O = p % 26, U = Math.min((p - O) / 26, this.length), q = 67108863 ^ 67108863 >>> O << O, B = x;
      if (N -= U, N = Math.max(0, N), B) {
        for (var E = 0; E < U; E++)
          B.words[E] = this.words[E];
        B.length = U;
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, E = 0; E < this.length; E++)
            this.words[E] = this.words[E + U];
        else
          this.words[0] = 0, this.length = 1;
      var V = 0;
      for (E = this.length - 1; E >= 0 && (V !== 0 || E >= N); E--) {
        var be = this.words[E] | 0;
        this.words[E] = V << 26 - O | be >>> O, V = be & q;
      }
      return B && V !== 0 && (B.words[B.length++] = V), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(p, w, x) {
      return n(this.negative === 0), this.iushrn(p, w, x);
    }, s.prototype.shln = function(p) {
      return this.clone().ishln(p);
    }, s.prototype.ushln = function(p) {
      return this.clone().iushln(p);
    }, s.prototype.shrn = function(p) {
      return this.clone().ishrn(p);
    }, s.prototype.ushrn = function(p) {
      return this.clone().iushrn(p);
    }, s.prototype.testn = function(p) {
      n(typeof p == "number" && p >= 0);
      var w = p % 26, x = (p - w) / 26, N = 1 << w;
      if (this.length <= x)
        return !1;
      var O = this.words[x];
      return !!(O & N);
    }, s.prototype.imaskn = function(p) {
      n(typeof p == "number" && p >= 0);
      var w = p % 26, x = (p - w) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= x)
        return this;
      if (w !== 0 && x++, this.length = Math.min(x, this.length), w !== 0) {
        var N = 67108863 ^ 67108863 >>> w << w;
        this.words[this.length - 1] &= N;
      }
      return this._strip();
    }, s.prototype.maskn = function(p) {
      return this.clone().imaskn(p);
    }, s.prototype.iaddn = function(p) {
      return n(typeof p == "number"), n(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= p ? (this.words[0] = p - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
    }, s.prototype._iaddn = function(p) {
      this.words[0] += p;
      for (var w = 0; w < this.length && this.words[w] >= 67108864; w++)
        this.words[w] -= 67108864, w === this.length - 1 ? this.words[w + 1] = 1 : this.words[w + 1]++;
      return this.length = Math.max(this.length, w + 1), this;
    }, s.prototype.isubn = function(p) {
      if (n(typeof p == "number"), n(p < 67108864), p < 0)
        return this.iaddn(-p);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(p), this.negative = 1, this;
      if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var w = 0; w < this.length && this.words[w] < 0; w++)
          this.words[w] += 67108864, this.words[w + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(p) {
      return this.clone().iaddn(p);
    }, s.prototype.subn = function(p) {
      return this.clone().isubn(p);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(p, w, x) {
      var N = p.length + x, O;
      this._expand(N);
      var U, q = 0;
      for (O = 0; O < p.length; O++) {
        U = (this.words[O + x] | 0) + q;
        var B = (p.words[O] | 0) * w;
        U -= B & 67108863, q = (U >> 26) - (B / 67108864 | 0), this.words[O + x] = U & 67108863;
      }
      for (; O < this.length - x; O++)
        U = (this.words[O + x] | 0) + q, q = U >> 26, this.words[O + x] = U & 67108863;
      if (q === 0)
        return this._strip();
      for (n(q === -1), q = 0, O = 0; O < this.length; O++)
        U = -(this.words[O] | 0) + q, q = U >> 26, this.words[O] = U & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(p, w) {
      var x = this.length - p.length, N = this.clone(), O = p, U = O.words[O.length - 1] | 0, q = this._countBits(U);
      x = 26 - q, x !== 0 && (O = O.ushln(x), N.iushln(x), U = O.words[O.length - 1] | 0);
      var B = N.length - O.length, E;
      if (w !== "mod") {
        E = new s(null), E.length = B + 1, E.words = new Array(E.length);
        for (var V = 0; V < E.length; V++)
          E.words[V] = 0;
      }
      var be = N.clone()._ishlnsubmul(O, 1, B);
      be.negative === 0 && (N = be, E && (E.words[B] = 1));
      for (var ve = B - 1; ve >= 0; ve--) {
        var ne = (N.words[O.length + ve] | 0) * 67108864 + (N.words[O.length + ve - 1] | 0);
        for (ne = Math.min(ne / U | 0, 67108863), N._ishlnsubmul(O, ne, ve); N.negative !== 0; )
          ne--, N.negative = 0, N._ishlnsubmul(O, 1, ve), N.isZero() || (N.negative ^= 1);
        E && (E.words[ve] = ne);
      }
      return E && E._strip(), N._strip(), w !== "div" && x !== 0 && N.iushrn(x), {
        div: E || null,
        mod: N
      };
    }, s.prototype.divmod = function(p, w, x) {
      if (n(!p.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var N, O, U;
      return this.negative !== 0 && p.negative === 0 ? (U = this.neg().divmod(p, w), w !== "mod" && (N = U.div.neg()), w !== "div" && (O = U.mod.neg(), x && O.negative !== 0 && O.iadd(p)), {
        div: N,
        mod: O
      }) : this.negative === 0 && p.negative !== 0 ? (U = this.divmod(p.neg(), w), w !== "mod" && (N = U.div.neg()), {
        div: N,
        mod: U.mod
      }) : this.negative & p.negative ? (U = this.neg().divmod(p.neg(), w), w !== "div" && (O = U.mod.neg(), x && O.negative !== 0 && O.isub(p)), {
        div: U.div,
        mod: O
      }) : p.length > this.length || this.cmp(p) < 0 ? {
        div: new s(0),
        mod: this
      } : p.length === 1 ? w === "div" ? {
        div: this.divn(p.words[0]),
        mod: null
      } : w === "mod" ? {
        div: null,
        mod: new s(this.modrn(p.words[0]))
      } : {
        div: this.divn(p.words[0]),
        mod: new s(this.modrn(p.words[0]))
      } : this._wordDiv(p, w);
    }, s.prototype.div = function(p) {
      return this.divmod(p, "div", !1).div;
    }, s.prototype.mod = function(p) {
      return this.divmod(p, "mod", !1).mod;
    }, s.prototype.umod = function(p) {
      return this.divmod(p, "mod", !0).mod;
    }, s.prototype.divRound = function(p) {
      var w = this.divmod(p);
      if (w.mod.isZero())
        return w.div;
      var x = w.div.negative !== 0 ? w.mod.isub(p) : w.mod, N = p.ushrn(1), O = p.andln(1), U = x.cmp(N);
      return U < 0 || O === 1 && U === 0 ? w.div : w.div.negative !== 0 ? w.div.isubn(1) : w.div.iaddn(1);
    }, s.prototype.modrn = function(p) {
      var w = p < 0;
      w && (p = -p), n(p <= 67108863);
      for (var x = (1 << 26) % p, N = 0, O = this.length - 1; O >= 0; O--)
        N = (x * N + (this.words[O] | 0)) % p;
      return w ? -N : N;
    }, s.prototype.modn = function(p) {
      return this.modrn(p);
    }, s.prototype.idivn = function(p) {
      var w = p < 0;
      w && (p = -p), n(p <= 67108863);
      for (var x = 0, N = this.length - 1; N >= 0; N--) {
        var O = (this.words[N] | 0) + x * 67108864;
        this.words[N] = O / p | 0, x = O % p;
      }
      return this._strip(), w ? this.ineg() : this;
    }, s.prototype.divn = function(p) {
      return this.clone().idivn(p);
    }, s.prototype.egcd = function(p) {
      n(p.negative === 0), n(!p.isZero());
      var w = this, x = p.clone();
      w.negative !== 0 ? w = w.umod(p) : w = w.clone();
      for (var N = new s(1), O = new s(0), U = new s(0), q = new s(1), B = 0; w.isEven() && x.isEven(); )
        w.iushrn(1), x.iushrn(1), ++B;
      for (var E = x.clone(), V = w.clone(); !w.isZero(); ) {
        for (var be = 0, ve = 1; !(w.words[0] & ve) && be < 26; ++be, ve <<= 1)
          ;
        if (be > 0)
          for (w.iushrn(be); be-- > 0; )
            (N.isOdd() || O.isOdd()) && (N.iadd(E), O.isub(V)), N.iushrn(1), O.iushrn(1);
        for (var ne = 0, K = 1; !(x.words[0] & K) && ne < 26; ++ne, K <<= 1)
          ;
        if (ne > 0)
          for (x.iushrn(ne); ne-- > 0; )
            (U.isOdd() || q.isOdd()) && (U.iadd(E), q.isub(V)), U.iushrn(1), q.iushrn(1);
        w.cmp(x) >= 0 ? (w.isub(x), N.isub(U), O.isub(q)) : (x.isub(w), U.isub(N), q.isub(O));
      }
      return {
        a: U,
        b: q,
        gcd: x.iushln(B)
      };
    }, s.prototype._invmp = function(p) {
      n(p.negative === 0), n(!p.isZero());
      var w = this, x = p.clone();
      w.negative !== 0 ? w = w.umod(p) : w = w.clone();
      for (var N = new s(1), O = new s(0), U = x.clone(); w.cmpn(1) > 0 && x.cmpn(1) > 0; ) {
        for (var q = 0, B = 1; !(w.words[0] & B) && q < 26; ++q, B <<= 1)
          ;
        if (q > 0)
          for (w.iushrn(q); q-- > 0; )
            N.isOdd() && N.iadd(U), N.iushrn(1);
        for (var E = 0, V = 1; !(x.words[0] & V) && E < 26; ++E, V <<= 1)
          ;
        if (E > 0)
          for (x.iushrn(E); E-- > 0; )
            O.isOdd() && O.iadd(U), O.iushrn(1);
        w.cmp(x) >= 0 ? (w.isub(x), N.isub(O)) : (x.isub(w), O.isub(N));
      }
      var be;
      return w.cmpn(1) === 0 ? be = N : be = O, be.cmpn(0) < 0 && be.iadd(p), be;
    }, s.prototype.gcd = function(p) {
      if (this.isZero())
        return p.abs();
      if (p.isZero())
        return this.abs();
      var w = this.clone(), x = p.clone();
      w.negative = 0, x.negative = 0;
      for (var N = 0; w.isEven() && x.isEven(); N++)
        w.iushrn(1), x.iushrn(1);
      do {
        for (; w.isEven(); )
          w.iushrn(1);
        for (; x.isEven(); )
          x.iushrn(1);
        var O = w.cmp(x);
        if (O < 0) {
          var U = w;
          w = x, x = U;
        } else if (O === 0 || x.cmpn(1) === 0)
          break;
        w.isub(x);
      } while (!0);
      return x.iushln(N);
    }, s.prototype.invm = function(p) {
      return this.egcd(p).a.umod(p);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(p) {
      return this.words[0] & p;
    }, s.prototype.bincn = function(p) {
      n(typeof p == "number");
      var w = p % 26, x = (p - w) / 26, N = 1 << w;
      if (this.length <= x)
        return this._expand(x + 1), this.words[x] |= N, this;
      for (var O = N, U = x; O !== 0 && U < this.length; U++) {
        var q = this.words[U] | 0;
        q += O, O = q >>> 26, q &= 67108863, this.words[U] = q;
      }
      return O !== 0 && (this.words[U] = O, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(p) {
      var w = p < 0;
      if (this.negative !== 0 && !w)
        return -1;
      if (this.negative === 0 && w)
        return 1;
      this._strip();
      var x;
      if (this.length > 1)
        x = 1;
      else {
        w && (p = -p), n(p <= 67108863, "Number is too big");
        var N = this.words[0] | 0;
        x = N === p ? 0 : N < p ? -1 : 1;
      }
      return this.negative !== 0 ? -x | 0 : x;
    }, s.prototype.cmp = function(p) {
      if (this.negative !== 0 && p.negative === 0)
        return -1;
      if (this.negative === 0 && p.negative !== 0)
        return 1;
      var w = this.ucmp(p);
      return this.negative !== 0 ? -w | 0 : w;
    }, s.prototype.ucmp = function(p) {
      if (this.length > p.length)
        return 1;
      if (this.length < p.length)
        return -1;
      for (var w = 0, x = this.length - 1; x >= 0; x--) {
        var N = this.words[x] | 0, O = p.words[x] | 0;
        if (N !== O) {
          N < O ? w = -1 : N > O && (w = 1);
          break;
        }
      }
      return w;
    }, s.prototype.gtn = function(p) {
      return this.cmpn(p) === 1;
    }, s.prototype.gt = function(p) {
      return this.cmp(p) === 1;
    }, s.prototype.gten = function(p) {
      return this.cmpn(p) >= 0;
    }, s.prototype.gte = function(p) {
      return this.cmp(p) >= 0;
    }, s.prototype.ltn = function(p) {
      return this.cmpn(p) === -1;
    }, s.prototype.lt = function(p) {
      return this.cmp(p) === -1;
    }, s.prototype.lten = function(p) {
      return this.cmpn(p) <= 0;
    }, s.prototype.lte = function(p) {
      return this.cmp(p) <= 0;
    }, s.prototype.eqn = function(p) {
      return this.cmpn(p) === 0;
    }, s.prototype.eq = function(p) {
      return this.cmp(p) === 0;
    }, s.red = function(p) {
      return new se(p);
    }, s.prototype.toRed = function(p) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(p) {
      return this.red = p, this;
    }, s.prototype.forceRed = function(p) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(p);
    }, s.prototype.redAdd = function(p) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
    }, s.prototype.redIAdd = function(p) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
    }, s.prototype.redSub = function(p) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
    }, s.prototype.redISub = function(p) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
    }, s.prototype.redShl = function(p) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
    }, s.prototype.redMul = function(p) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
    }, s.prototype.redIMul = function(p) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(p) {
      return n(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
    };
    var L = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function P(H, p) {
      this.name = H, this.p = new s(p, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    P.prototype._tmp = function() {
      var p = new s(null);
      return p.words = new Array(Math.ceil(this.n / 13)), p;
    }, P.prototype.ireduce = function(p) {
      var w = p, x;
      do
        this.split(w, this.tmp), w = this.imulK(w), w = w.iadd(this.tmp), x = w.bitLength();
      while (x > this.n);
      var N = x < this.n ? -1 : w.ucmp(this.p);
      return N === 0 ? (w.words[0] = 0, w.length = 1) : N > 0 ? w.isub(this.p) : w.strip !== void 0 ? w.strip() : w._strip(), w;
    }, P.prototype.split = function(p, w) {
      p.iushrn(this.n, 0, w);
    }, P.prototype.imulK = function(p) {
      return p.imul(this.k);
    };
    function v() {
      P.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(v, P), v.prototype.split = function(p, w) {
      for (var x = 4194303, N = Math.min(p.length, 9), O = 0; O < N; O++)
        w.words[O] = p.words[O];
      if (w.length = N, p.length <= 9) {
        p.words[0] = 0, p.length = 1;
        return;
      }
      var U = p.words[9];
      for (w.words[w.length++] = U & x, O = 10; O < p.length; O++) {
        var q = p.words[O] | 0;
        p.words[O - 10] = (q & x) << 4 | U >>> 22, U = q;
      }
      U >>>= 22, p.words[O - 10] = U, U === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
    }, v.prototype.imulK = function(p) {
      p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
      for (var w = 0, x = 0; x < p.length; x++) {
        var N = p.words[x] | 0;
        w += N * 977, p.words[x] = w & 67108863, w = N * 64 + (w / 67108864 | 0);
      }
      return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
    };
    function F() {
      P.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(F, P);
    function X() {
      P.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(X, P);
    function te() {
      P.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(te, P), te.prototype.imulK = function(p) {
      for (var w = 0, x = 0; x < p.length; x++) {
        var N = (p.words[x] | 0) * 19 + w, O = N & 67108863;
        N >>>= 26, p.words[x] = O, w = N;
      }
      return w !== 0 && (p.words[p.length++] = w), p;
    }, s._prime = function(p) {
      if (L[p])
        return L[p];
      var w;
      if (p === "k256")
        w = new v();
      else if (p === "p224")
        w = new F();
      else if (p === "p192")
        w = new X();
      else if (p === "p25519")
        w = new te();
      else
        throw new Error("Unknown prime " + p);
      return L[p] = w, w;
    };
    function se(H) {
      if (typeof H == "string") {
        var p = s._prime(H);
        this.m = p.p, this.prime = p;
      } else
        n(H.gtn(1), "modulus must be greater than 1"), this.m = H, this.prime = null;
    }
    se.prototype._verify1 = function(p) {
      n(p.negative === 0, "red works only with positives"), n(p.red, "red works only with red numbers");
    }, se.prototype._verify2 = function(p, w) {
      n((p.negative | w.negative) === 0, "red works only with positives"), n(
        p.red && p.red === w.red,
        "red works only with red numbers"
      );
    }, se.prototype.imod = function(p) {
      return this.prime ? this.prime.ireduce(p)._forceRed(this) : (f(p, p.umod(this.m)._forceRed(this)), p);
    }, se.prototype.neg = function(p) {
      return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
    }, se.prototype.add = function(p, w) {
      this._verify2(p, w);
      var x = p.add(w);
      return x.cmp(this.m) >= 0 && x.isub(this.m), x._forceRed(this);
    }, se.prototype.iadd = function(p, w) {
      this._verify2(p, w);
      var x = p.iadd(w);
      return x.cmp(this.m) >= 0 && x.isub(this.m), x;
    }, se.prototype.sub = function(p, w) {
      this._verify2(p, w);
      var x = p.sub(w);
      return x.cmpn(0) < 0 && x.iadd(this.m), x._forceRed(this);
    }, se.prototype.isub = function(p, w) {
      this._verify2(p, w);
      var x = p.isub(w);
      return x.cmpn(0) < 0 && x.iadd(this.m), x;
    }, se.prototype.shl = function(p, w) {
      return this._verify1(p), this.imod(p.ushln(w));
    }, se.prototype.imul = function(p, w) {
      return this._verify2(p, w), this.imod(p.imul(w));
    }, se.prototype.mul = function(p, w) {
      return this._verify2(p, w), this.imod(p.mul(w));
    }, se.prototype.isqr = function(p) {
      return this.imul(p, p.clone());
    }, se.prototype.sqr = function(p) {
      return this.mul(p, p);
    }, se.prototype.sqrt = function(p) {
      if (p.isZero())
        return p.clone();
      var w = this.m.andln(3);
      if (n(w % 2 === 1), w === 3) {
        var x = this.m.add(new s(1)).iushrn(2);
        return this.pow(p, x);
      }
      for (var N = this.m.subn(1), O = 0; !N.isZero() && N.andln(1) === 0; )
        O++, N.iushrn(1);
      n(!N.isZero());
      var U = new s(1).toRed(this), q = U.redNeg(), B = this.m.subn(1).iushrn(1), E = this.m.bitLength();
      for (E = new s(2 * E * E).toRed(this); this.pow(E, B).cmp(q) !== 0; )
        E.redIAdd(q);
      for (var V = this.pow(E, N), be = this.pow(p, N.addn(1).iushrn(1)), ve = this.pow(p, N), ne = O; ve.cmp(U) !== 0; ) {
        for (var K = ve, Y = 0; K.cmp(U) !== 0; Y++)
          K = K.redSqr();
        n(Y < ne);
        var ee = this.pow(V, new s(1).iushln(ne - Y - 1));
        be = be.redMul(ee), V = ee.redSqr(), ve = ve.redMul(V), ne = Y;
      }
      return be;
    }, se.prototype.invm = function(p) {
      var w = p._invmp(this.m);
      return w.negative !== 0 ? (w.negative = 0, this.imod(w).redNeg()) : this.imod(w);
    }, se.prototype.pow = function(p, w) {
      if (w.isZero())
        return new s(1).toRed(this);
      if (w.cmpn(1) === 0)
        return p.clone();
      var x = 4, N = new Array(1 << x);
      N[0] = new s(1).toRed(this), N[1] = p;
      for (var O = 2; O < N.length; O++)
        N[O] = this.mul(N[O - 1], p);
      var U = N[0], q = 0, B = 0, E = w.bitLength() % 26;
      for (E === 0 && (E = 26), O = w.length - 1; O >= 0; O--) {
        for (var V = w.words[O], be = E - 1; be >= 0; be--) {
          var ve = V >> be & 1;
          if (U !== N[0] && (U = this.sqr(U)), ve === 0 && q === 0) {
            B = 0;
            continue;
          }
          q <<= 1, q |= ve, B++, !(B !== x && (O !== 0 || be !== 0)) && (U = this.mul(U, N[q]), B = 0, q = 0);
        }
        E = 26;
      }
      return U;
    }, se.prototype.convertTo = function(p) {
      var w = p.umod(this.m);
      return w === p ? w.clone() : w;
    }, se.prototype.convertFrom = function(p) {
      var w = p.clone();
      return w.red = null, w;
    }, s.mont = function(p) {
      return new we(p);
    };
    function we(H) {
      se.call(this, H), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(we, se), we.prototype.convertTo = function(p) {
      return this.imod(p.ushln(this.shift));
    }, we.prototype.convertFrom = function(p) {
      var w = this.imod(p.mul(this.rinv));
      return w.red = null, w;
    }, we.prototype.imul = function(p, w) {
      if (p.isZero() || w.isZero())
        return p.words[0] = 0, p.length = 1, p;
      var x = p.imul(w), N = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = x.isub(N).iushrn(this.shift), U = O;
      return O.cmp(this.m) >= 0 ? U = O.isub(this.m) : O.cmpn(0) < 0 && (U = O.iadd(this.m)), U._forceRed(this);
    }, we.prototype.mul = function(p, w) {
      if (p.isZero() || w.isZero())
        return new s(0)._forceRed(this);
      var x = p.mul(w), N = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = x.isub(N).iushrn(this.shift), U = O;
      return O.cmp(this.m) >= 0 ? U = O.isub(this.m) : O.cmpn(0) < 0 && (U = O.iadd(this.m)), U._forceRed(this);
    }, we.prototype.invm = function(p) {
      var w = this.imod(p._invmp(this.m).mul(this.r2));
      return w._forceRed(this);
    };
  })(r, ze);
})(jC);
var p3 = jC.exports, qg = {};
Object.defineProperty(qg, "__esModule", { value: !0 });
qg.EVENTS = void 0;
qg.EVENTS = {
  STARTED_CONNECTING: "walletlink_sdk.started.connecting",
  CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
  DISCONNECTED: "walletlink_sdk.disconnected",
  METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
  LINKED: "walletlink_sdk.linked",
  FAILURE: "walletlink_sdk.generic_failure",
  SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
  ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
  SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
  UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
  SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
  GENERAL_ERROR: "walletlink_sdk.general_error",
  WEB3_REQUEST: "walletlink_sdk.web3.request",
  WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
  WEB3_RESPONSE: "walletlink_sdk.web3.response",
  UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
};
var wy = {}, WC = {}, nh = {}, Hpe = ww;
ww.default = ww;
ww.stable = hL;
ww.stableStringify = hL;
var G2 = "[...]", lL = "[Circular]", wd = [], ff = [];
function uL() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function ww(r, e, t, n) {
  typeof n > "u" && (n = uL()), Vx(r, "", 0, [], void 0, 0, n);
  var i;
  try {
    ff.length === 0 ? i = JSON.stringify(r, e, t) : i = JSON.stringify(r, fL(e), t);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; wd.length !== 0; ) {
      var s = wd.pop();
      s.length === 4 ? Object.defineProperty(s[0], s[1], s[3]) : s[0][s[1]] = s[2];
    }
  }
  return i;
}
function Yp(r, e, t, n) {
  var i = Object.getOwnPropertyDescriptor(n, t);
  i.get !== void 0 ? i.configurable ? (Object.defineProperty(n, t, { value: r }), wd.push([n, t, e, i])) : ff.push([e, t, r]) : (n[t] = r, wd.push([n, t, e]));
}
function Vx(r, e, t, n, i, s, o) {
  s += 1;
  var a;
  if (typeof r == "object" && r !== null) {
    for (a = 0; a < n.length; a++)
      if (n[a] === r) {
        Yp(lL, r, e, i);
        return;
      }
    if (typeof o.depthLimit < "u" && s > o.depthLimit) {
      Yp(G2, r, e, i);
      return;
    }
    if (typeof o.edgesLimit < "u" && t + 1 > o.edgesLimit) {
      Yp(G2, r, e, i);
      return;
    }
    if (n.push(r), Array.isArray(r))
      for (a = 0; a < r.length; a++)
        Vx(r[a], a, a, n, r, s, o);
    else {
      var c = Object.keys(r);
      for (a = 0; a < c.length; a++) {
        var u = c[a];
        Vx(r[u], u, a, n, r, s, o);
      }
    }
    n.pop();
  }
}
function zpe(r, e) {
  return r < e ? -1 : r > e ? 1 : 0;
}
function hL(r, e, t, n) {
  typeof n > "u" && (n = uL());
  var i = qx(r, "", 0, [], void 0, 0, n) || r, s;
  try {
    ff.length === 0 ? s = JSON.stringify(i, e, t) : s = JSON.stringify(i, fL(e), t);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; wd.length !== 0; ) {
      var o = wd.pop();
      o.length === 4 ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2];
    }
  }
  return s;
}
function qx(r, e, t, n, i, s, o) {
  s += 1;
  var a;
  if (typeof r == "object" && r !== null) {
    for (a = 0; a < n.length; a++)
      if (n[a] === r) {
        Yp(lL, r, e, i);
        return;
      }
    try {
      if (typeof r.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof o.depthLimit < "u" && s > o.depthLimit) {
      Yp(G2, r, e, i);
      return;
    }
    if (typeof o.edgesLimit < "u" && t + 1 > o.edgesLimit) {
      Yp(G2, r, e, i);
      return;
    }
    if (n.push(r), Array.isArray(r))
      for (a = 0; a < r.length; a++)
        qx(r[a], a, a, n, r, s, o);
    else {
      var c = {}, u = Object.keys(r).sort(zpe);
      for (a = 0; a < u.length; a++) {
        var f = u[a];
        qx(r[f], f, a, n, r, s, o), c[f] = r[f];
      }
      if (typeof i < "u")
        wd.push([i, e, r]), i[e] = c;
      else
        return c;
    }
    n.pop();
  }
}
function fL(r) {
  return r = typeof r < "u" ? r : function(e, t) {
    return t;
  }, function(e, t) {
    if (ff.length > 0)
      for (var n = 0; n < ff.length; n++) {
        var i = ff[n];
        if (i[1] === e && i[0] === t) {
          t = i[2], ff.splice(n, 1);
          break;
        }
      }
    return r.call(this, e, t);
  };
}
Object.defineProperty(nh, "__esModule", { value: !0 });
nh.EthereumProviderError = nh.EthereumRpcError = void 0;
const Vpe = Hpe;
class dL extends Error {
  constructor(e, t, n) {
    if (!Number.isInteger(e))
      throw new Error('"code" must be an integer.');
    if (!t || typeof t != "string")
      throw new Error('"message" must be a nonempty string.');
    super(t), this.code = e, n !== void 0 && (this.data = n);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const e = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (e.data = this.data), this.stack && (e.stack = this.stack), e;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return Vpe.default(this.serialize(), Kpe, 2);
  }
}
nh.EthereumRpcError = dL;
class qpe extends dL {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(e, t, n) {
    if (!Gpe(e))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e, t, n);
  }
}
nh.EthereumProviderError = qpe;
function Gpe(r) {
  return Number.isInteger(r) && r >= 1e3 && r <= 4999;
}
function Kpe(r, e) {
  if (e !== "[Circular]")
    return e;
}
var HC = {}, ih = {};
Object.defineProperty(ih, "__esModule", { value: !0 });
ih.errorValues = ih.errorCodes = void 0;
ih.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
ih.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.serializeError = r.isValidCode = r.getMessageFromCode = r.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const e = ih, t = nh, n = e.errorCodes.rpc.internal, i = "Unspecified error message. This is a bug, please report it.", s = {
    code: n,
    message: o(n)
  };
  r.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function o(m, y = i) {
    if (Number.isInteger(m)) {
      const b = m.toString();
      if (d(e.errorValues, b))
        return e.errorValues[b].message;
      if (u(m))
        return r.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return y;
  }
  r.getMessageFromCode = o;
  function a(m) {
    if (!Number.isInteger(m))
      return !1;
    const y = m.toString();
    return !!(e.errorValues[y] || u(m));
  }
  r.isValidCode = a;
  function c(m, { fallbackError: y = s, shouldIncludeStack: b = !1 } = {}) {
    var I, k;
    if (!y || !Number.isInteger(y.code) || typeof y.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (m instanceof t.EthereumRpcError)
      return m.serialize();
    const R = {};
    if (m && typeof m == "object" && !Array.isArray(m) && d(m, "code") && a(m.code)) {
      const $ = m;
      R.code = $.code, $.message && typeof $.message == "string" ? (R.message = $.message, d($, "data") && (R.data = $.data)) : (R.message = o(R.code), R.data = { originalError: f(m) });
    } else {
      R.code = y.code;
      const $ = (I = m) === null || I === void 0 ? void 0 : I.message;
      R.message = $ && typeof $ == "string" ? $ : y.message, R.data = { originalError: f(m) };
    }
    const T = (k = m) === null || k === void 0 ? void 0 : k.stack;
    return b && m && T && typeof T == "string" && (R.stack = T), R;
  }
  r.serializeError = c;
  function u(m) {
    return m >= -32099 && m <= -32e3;
  }
  function f(m) {
    return m && typeof m == "object" && !Array.isArray(m) ? Object.assign({}, m) : m;
  }
  function d(m, y) {
    return Object.prototype.hasOwnProperty.call(m, y);
  }
})(HC);
var g3 = {};
Object.defineProperty(g3, "__esModule", { value: !0 });
g3.ethErrors = void 0;
const zC = nh, pL = HC, Ii = ih;
g3.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (r) => _o(Ii.errorCodes.rpc.parse, r),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (r) => _o(Ii.errorCodes.rpc.invalidRequest, r),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (r) => _o(Ii.errorCodes.rpc.invalidParams, r),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (r) => _o(Ii.errorCodes.rpc.methodNotFound, r),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (r) => _o(Ii.errorCodes.rpc.internal, r),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (r) => {
      if (!r || typeof r != "object" || Array.isArray(r))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: e } = r;
      if (!Number.isInteger(e) || e > -32005 || e < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return _o(e, r);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (r) => _o(Ii.errorCodes.rpc.invalidInput, r),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (r) => _o(Ii.errorCodes.rpc.resourceNotFound, r),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (r) => _o(Ii.errorCodes.rpc.resourceUnavailable, r),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (r) => _o(Ii.errorCodes.rpc.transactionRejected, r),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (r) => _o(Ii.errorCodes.rpc.methodNotSupported, r),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (r) => _o(Ii.errorCodes.rpc.limitExceeded, r)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (r) => U1(Ii.errorCodes.provider.userRejectedRequest, r),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (r) => U1(Ii.errorCodes.provider.unauthorized, r),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (r) => U1(Ii.errorCodes.provider.unsupportedMethod, r),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (r) => U1(Ii.errorCodes.provider.disconnected, r),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (r) => U1(Ii.errorCodes.provider.chainDisconnected, r),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (r) => {
      if (!r || typeof r != "object" || Array.isArray(r))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: e, message: t, data: n } = r;
      if (!t || typeof t != "string")
        throw new Error('"message" must be a nonempty string');
      return new zC.EthereumProviderError(e, t, n);
    }
  }
};
function _o(r, e) {
  const [t, n] = gL(e);
  return new zC.EthereumRpcError(r, t || pL.getMessageFromCode(r), n);
}
function U1(r, e) {
  const [t, n] = gL(e);
  return new zC.EthereumProviderError(r, t || pL.getMessageFromCode(r), n);
}
function gL(r) {
  if (r) {
    if (typeof r == "string")
      return [r];
    if (typeof r == "object" && !Array.isArray(r)) {
      const { message: e, data: t } = r;
      if (e && typeof e != "string")
        throw new Error("Must specify string message.");
      return [e || void 0, t];
    }
  }
  return [];
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.getMessageFromCode = r.serializeError = r.EthereumProviderError = r.EthereumRpcError = r.ethErrors = r.errorCodes = void 0;
  const e = nh;
  Object.defineProperty(r, "EthereumRpcError", { enumerable: !0, get: function() {
    return e.EthereumRpcError;
  } }), Object.defineProperty(r, "EthereumProviderError", { enumerable: !0, get: function() {
    return e.EthereumProviderError;
  } });
  const t = HC;
  Object.defineProperty(r, "serializeError", { enumerable: !0, get: function() {
    return t.serializeError;
  } }), Object.defineProperty(r, "getMessageFromCode", { enumerable: !0, get: function() {
    return t.getMessageFromCode;
  } });
  const n = g3;
  Object.defineProperty(r, "ethErrors", { enumerable: !0, get: function() {
    return n.ethErrors;
  } });
  const i = ih;
  Object.defineProperty(r, "errorCodes", { enumerable: !0, get: function() {
    return i.errorCodes;
  } });
})(WC);
var tn = {}, m3 = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.Web3Method = void 0, function(e) {
    e.requestEthereumAccounts = "requestEthereumAccounts", e.signEthereumMessage = "signEthereumMessage", e.signEthereumTransaction = "signEthereumTransaction", e.submitEthereumTransaction = "submitEthereumTransaction", e.ethereumAddressFromSignedMessage = "ethereumAddressFromSignedMessage", e.scanQRCode = "scanQRCode", e.generic = "generic", e.childRequestEthereumAccounts = "childRequestEthereumAccounts", e.addEthereumChain = "addEthereumChain", e.switchEthereumChain = "switchEthereumChain", e.makeEthereumJSONRPCRequest = "makeEthereumJSONRPCRequest", e.watchAsset = "watchAsset", e.selectProvider = "selectProvider";
  }(r.Web3Method || (r.Web3Method = {}));
})(m3);
Object.defineProperty(tn, "__esModule", { value: !0 });
tn.EthereumAddressFromSignedMessageResponse = tn.SubmitEthereumTransactionResponse = tn.SignEthereumTransactionResponse = tn.SignEthereumMessageResponse = tn.isRequestEthereumAccountsResponse = tn.SelectProviderResponse = tn.WatchAssetReponse = tn.RequestEthereumAccountsResponse = tn.SwitchEthereumChainResponse = tn.AddEthereumChainResponse = tn.isErrorResponse = void 0;
const Lc = m3;
function Zpe(r) {
  var e, t;
  return ((e = r) === null || e === void 0 ? void 0 : e.method) !== void 0 && ((t = r) === null || t === void 0 ? void 0 : t.errorMessage) !== void 0;
}
tn.isErrorResponse = Zpe;
function Jpe(r) {
  return {
    method: Lc.Web3Method.addEthereumChain,
    result: r
  };
}
tn.AddEthereumChainResponse = Jpe;
function Qpe(r) {
  return {
    method: Lc.Web3Method.switchEthereumChain,
    result: r
  };
}
tn.SwitchEthereumChainResponse = Qpe;
function Ype(r) {
  return { method: Lc.Web3Method.requestEthereumAccounts, result: r };
}
tn.RequestEthereumAccountsResponse = Ype;
function Xpe(r) {
  return { method: Lc.Web3Method.watchAsset, result: r };
}
tn.WatchAssetReponse = Xpe;
function e0e(r) {
  return { method: Lc.Web3Method.selectProvider, result: r };
}
tn.SelectProviderResponse = e0e;
function t0e(r) {
  return r && r.method === Lc.Web3Method.requestEthereumAccounts;
}
tn.isRequestEthereumAccountsResponse = t0e;
function r0e(r) {
  return { method: Lc.Web3Method.signEthereumMessage, result: r };
}
tn.SignEthereumMessageResponse = r0e;
function n0e(r) {
  return { method: Lc.Web3Method.signEthereumTransaction, result: r };
}
tn.SignEthereumTransactionResponse = n0e;
function i0e(r) {
  return { method: Lc.Web3Method.submitEthereumTransaction, result: r };
}
tn.SubmitEthereumTransactionResponse = i0e;
function s0e(r) {
  return {
    method: Lc.Web3Method.ethereumAddressFromSignedMessage,
    result: r
  };
}
tn.EthereumAddressFromSignedMessageResponse = s0e;
var Gg = {};
Object.defineProperty(Gg, "__esModule", { value: !0 });
Gg.LIB_VERSION = void 0;
Gg.LIB_VERSION = "3.7.2";
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.getErrorCode = r.serializeError = r.standardErrors = r.standardErrorMessage = r.standardErrorCodes = void 0;
  const e = WC, t = tn, n = Gg;
  r.standardErrorCodes = Object.freeze(Object.assign(Object.assign({}, e.errorCodes), { provider: Object.freeze(Object.assign(Object.assign({}, e.errorCodes.provider), { unsupportedChain: 4902 })) }));
  function i(f) {
    return f !== void 0 ? (0, e.getMessageFromCode)(f) : "Unknown error";
  }
  r.standardErrorMessage = i, r.standardErrors = Object.freeze(Object.assign(Object.assign({}, e.ethErrors), { provider: Object.freeze(Object.assign(Object.assign({}, e.ethErrors.provider), { unsupportedChain: (f = "") => e.ethErrors.provider.custom({
    code: r.standardErrorCodes.provider.unsupportedChain,
    message: `Unrecognized chain ID ${f}. Try adding the chain using wallet_addEthereumChain first.`
  }) })) }));
  function s(f, d) {
    const m = (0, e.serializeError)(o(f), {
      shouldIncludeStack: !0
    }), y = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
    y.searchParams.set("version", n.LIB_VERSION), y.searchParams.set("code", m.code.toString());
    const b = a(m.data, d);
    return b && y.searchParams.set("method", b), y.searchParams.set("message", m.message), Object.assign(Object.assign({}, m), { docUrl: y.href });
  }
  r.serializeError = s;
  function o(f) {
    return typeof f == "string" ? {
      message: f,
      code: r.standardErrorCodes.rpc.internal
    } : (0, t.isErrorResponse)(f) ? Object.assign(Object.assign({}, f), { message: f.errorMessage, code: f.errorCode, data: { method: f.method, result: f.result } }) : f;
  }
  function a(f, d) {
    var m;
    const y = (m = f) === null || m === void 0 ? void 0 : m.method;
    if (y)
      return y;
    if (d !== void 0)
      return typeof d == "string" ? d : Array.isArray(d) ? d.length > 0 ? d[0].method : void 0 : d.method;
  }
  function c(f) {
    var d;
    if (typeof f == "number")
      return f;
    if (u(f))
      return (d = f.code) !== null && d !== void 0 ? d : f.errorCode;
  }
  r.getErrorCode = c;
  function u(f) {
    return typeof f == "object" && f !== null && (typeof f.code == "number" || typeof f.errorCode == "number");
  }
})(wy);
var Kg = {}, mL = { exports: {} }, Gx = { exports: {} };
typeof Object.create == "function" ? Gx.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Gx.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var n = function() {
    };
    n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e;
  }
};
var ja = Gx.exports, Kx = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(r, e) {
  var t = Vg, n = t.Buffer;
  function i(o, a) {
    for (var c in o)
      a[c] = o[c];
  }
  n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? r.exports = t : (i(t, e), e.Buffer = s);
  function s(o, a, c) {
    return n(o, a, c);
  }
  s.prototype = Object.create(n.prototype), i(n, s), s.from = function(o, a, c) {
    if (typeof o == "number")
      throw new TypeError("Argument must not be a number");
    return n(o, a, c);
  }, s.alloc = function(o, a, c) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    var u = n(o);
    return a !== void 0 ? typeof c == "string" ? u.fill(a, c) : u.fill(a) : u.fill(0), u;
  }, s.allocUnsafe = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return n(o);
  }, s.allocUnsafeSlow = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return t.SlowBuffer(o);
  };
})(Kx, Kx.exports);
var wh = Kx.exports, wL = wh.Buffer;
function w3(r, e) {
  this._block = wL.alloc(r), this._finalSize = e, this._blockSize = r, this._len = 0;
}
w3.prototype.update = function(r, e) {
  typeof r == "string" && (e = e || "utf8", r = wL.from(r, e));
  for (var t = this._block, n = this._blockSize, i = r.length, s = this._len, o = 0; o < i; ) {
    for (var a = s % n, c = Math.min(i - o, n - a), u = 0; u < c; u++)
      t[a + u] = r[o + u];
    s += c, o += c, s % n === 0 && this._update(t);
  }
  return this._len += i, this;
};
w3.prototype.digest = function(r) {
  var e = this._len % this._blockSize;
  this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var t = this._len * 8;
  if (t <= 4294967295)
    this._block.writeUInt32BE(t, this._blockSize - 4);
  else {
    var n = (t & 4294967295) >>> 0, i = (t - n) / 4294967296;
    this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
  }
  this._update(this._block);
  var s = this._hash();
  return r ? s.toString(r) : s;
};
w3.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var Zg = w3, o0e = ja, yL = Zg, a0e = wh.Buffer, c0e = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], l0e = new Array(80);
function yy() {
  this.init(), this._w = l0e, yL.call(this, 64, 56);
}
o0e(yy, yL);
yy.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function u0e(r) {
  return r << 5 | r >>> 27;
}
function h0e(r) {
  return r << 30 | r >>> 2;
}
function f0e(r, e, t, n) {
  return r === 0 ? e & t | ~e & n : r === 2 ? e & t | e & n | t & n : e ^ t ^ n;
}
yy.prototype._update = function(r) {
  for (var e = this._w, t = this._a | 0, n = this._b | 0, i = this._c | 0, s = this._d | 0, o = this._e | 0, a = 0; a < 16; ++a)
    e[a] = r.readInt32BE(a * 4);
  for (; a < 80; ++a)
    e[a] = e[a - 3] ^ e[a - 8] ^ e[a - 14] ^ e[a - 16];
  for (var c = 0; c < 80; ++c) {
    var u = ~~(c / 20), f = u0e(t) + f0e(u, n, i, s) + o + e[c] + c0e[u] | 0;
    o = s, s = i, i = h0e(n), n = t, t = f;
  }
  this._a = t + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0;
};
yy.prototype._hash = function() {
  var r = a0e.allocUnsafe(20);
  return r.writeInt32BE(this._a | 0, 0), r.writeInt32BE(this._b | 0, 4), r.writeInt32BE(this._c | 0, 8), r.writeInt32BE(this._d | 0, 12), r.writeInt32BE(this._e | 0, 16), r;
};
var d0e = yy, p0e = ja, vL = Zg, g0e = wh.Buffer, m0e = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], w0e = new Array(80);
function vy() {
  this.init(), this._w = w0e, vL.call(this, 64, 56);
}
p0e(vy, vL);
vy.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function y0e(r) {
  return r << 1 | r >>> 31;
}
function v0e(r) {
  return r << 5 | r >>> 27;
}
function b0e(r) {
  return r << 30 | r >>> 2;
}
function _0e(r, e, t, n) {
  return r === 0 ? e & t | ~e & n : r === 2 ? e & t | e & n | t & n : e ^ t ^ n;
}
vy.prototype._update = function(r) {
  for (var e = this._w, t = this._a | 0, n = this._b | 0, i = this._c | 0, s = this._d | 0, o = this._e | 0, a = 0; a < 16; ++a)
    e[a] = r.readInt32BE(a * 4);
  for (; a < 80; ++a)
    e[a] = y0e(e[a - 3] ^ e[a - 8] ^ e[a - 14] ^ e[a - 16]);
  for (var c = 0; c < 80; ++c) {
    var u = ~~(c / 20), f = v0e(t) + _0e(u, n, i, s) + o + e[c] + m0e[u] | 0;
    o = s, s = i, i = b0e(n), n = t, t = f;
  }
  this._a = t + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0;
};
vy.prototype._hash = function() {
  var r = g0e.allocUnsafe(20);
  return r.writeInt32BE(this._a | 0, 0), r.writeInt32BE(this._b | 0, 4), r.writeInt32BE(this._c | 0, 8), r.writeInt32BE(this._d | 0, 12), r.writeInt32BE(this._e | 0, 16), r;
};
var E0e = vy, x0e = ja, bL = Zg, S0e = wh.Buffer, C0e = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], A0e = new Array(64);
function by() {
  this.init(), this._w = A0e, bL.call(this, 64, 56);
}
x0e(by, bL);
by.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function I0e(r, e, t) {
  return t ^ r & (e ^ t);
}
function R0e(r, e, t) {
  return r & e | t & (r | e);
}
function T0e(r) {
  return (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10);
}
function O0e(r) {
  return (r >>> 6 | r << 26) ^ (r >>> 11 | r << 21) ^ (r >>> 25 | r << 7);
}
function N0e(r) {
  return (r >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3;
}
function P0e(r) {
  return (r >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10;
}
by.prototype._update = function(r) {
  for (var e = this._w, t = this._a | 0, n = this._b | 0, i = this._c | 0, s = this._d | 0, o = this._e | 0, a = this._f | 0, c = this._g | 0, u = this._h | 0, f = 0; f < 16; ++f)
    e[f] = r.readInt32BE(f * 4);
  for (; f < 64; ++f)
    e[f] = P0e(e[f - 2]) + e[f - 7] + N0e(e[f - 15]) + e[f - 16] | 0;
  for (var d = 0; d < 64; ++d) {
    var m = u + O0e(o) + I0e(o, a, c) + C0e[d] + e[d] | 0, y = T0e(t) + R0e(t, n, i) | 0;
    u = c, c = a, a = o, o = s + m | 0, s = i, i = n, n = t, t = m + y | 0;
  }
  this._a = t + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0, this._f = a + this._f | 0, this._g = c + this._g | 0, this._h = u + this._h | 0;
};
by.prototype._hash = function() {
  var r = S0e.allocUnsafe(32);
  return r.writeInt32BE(this._a, 0), r.writeInt32BE(this._b, 4), r.writeInt32BE(this._c, 8), r.writeInt32BE(this._d, 12), r.writeInt32BE(this._e, 16), r.writeInt32BE(this._f, 20), r.writeInt32BE(this._g, 24), r.writeInt32BE(this._h, 28), r;
};
var _L = by, M0e = ja, D0e = _L, k0e = Zg, $0e = wh.Buffer, L0e = new Array(64);
function y3() {
  this.init(), this._w = L0e, k0e.call(this, 64, 56);
}
M0e(y3, D0e);
y3.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
y3.prototype._hash = function() {
  var r = $0e.allocUnsafe(28);
  return r.writeInt32BE(this._a, 0), r.writeInt32BE(this._b, 4), r.writeInt32BE(this._c, 8), r.writeInt32BE(this._d, 12), r.writeInt32BE(this._e, 16), r.writeInt32BE(this._f, 20), r.writeInt32BE(this._g, 24), r;
};
var B0e = y3, F0e = ja, EL = Zg, U0e = wh.Buffer, Q7 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], j0e = new Array(160);
function _y() {
  this.init(), this._w = j0e, EL.call(this, 128, 112);
}
F0e(_y, EL);
_y.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Y7(r, e, t) {
  return t ^ r & (e ^ t);
}
function X7(r, e, t) {
  return r & e | t & (r | e);
}
function eO(r, e) {
  return (r >>> 28 | e << 4) ^ (e >>> 2 | r << 30) ^ (e >>> 7 | r << 25);
}
function tO(r, e) {
  return (r >>> 14 | e << 18) ^ (r >>> 18 | e << 14) ^ (e >>> 9 | r << 23);
}
function W0e(r, e) {
  return (r >>> 1 | e << 31) ^ (r >>> 8 | e << 24) ^ r >>> 7;
}
function H0e(r, e) {
  return (r >>> 1 | e << 31) ^ (r >>> 8 | e << 24) ^ (r >>> 7 | e << 25);
}
function z0e(r, e) {
  return (r >>> 19 | e << 13) ^ (e >>> 29 | r << 3) ^ r >>> 6;
}
function V0e(r, e) {
  return (r >>> 19 | e << 13) ^ (e >>> 29 | r << 3) ^ (r >>> 6 | e << 26);
}
function ei(r, e) {
  return r >>> 0 < e >>> 0 ? 1 : 0;
}
_y.prototype._update = function(r) {
  for (var e = this._w, t = this._ah | 0, n = this._bh | 0, i = this._ch | 0, s = this._dh | 0, o = this._eh | 0, a = this._fh | 0, c = this._gh | 0, u = this._hh | 0, f = this._al | 0, d = this._bl | 0, m = this._cl | 0, y = this._dl | 0, b = this._el | 0, I = this._fl | 0, k = this._gl | 0, R = this._hl | 0, T = 0; T < 32; T += 2)
    e[T] = r.readInt32BE(T * 4), e[T + 1] = r.readInt32BE(T * 4 + 4);
  for (; T < 160; T += 2) {
    var $ = e[T - 30], D = e[T - 15 * 2 + 1], L = W0e($, D), P = H0e(D, $);
    $ = e[T - 2 * 2], D = e[T - 2 * 2 + 1];
    var v = z0e($, D), F = V0e(D, $), X = e[T - 7 * 2], te = e[T - 7 * 2 + 1], se = e[T - 16 * 2], we = e[T - 16 * 2 + 1], H = P + te | 0, p = L + X + ei(H, P) | 0;
    H = H + F | 0, p = p + v + ei(H, F) | 0, H = H + we | 0, p = p + se + ei(H, we) | 0, e[T] = p, e[T + 1] = H;
  }
  for (var w = 0; w < 160; w += 2) {
    p = e[w], H = e[w + 1];
    var x = X7(t, n, i), N = X7(f, d, m), O = eO(t, f), U = eO(f, t), q = tO(o, b), B = tO(b, o), E = Q7[w], V = Q7[w + 1], be = Y7(o, a, c), ve = Y7(b, I, k), ne = R + B | 0, K = u + q + ei(ne, R) | 0;
    ne = ne + ve | 0, K = K + be + ei(ne, ve) | 0, ne = ne + V | 0, K = K + E + ei(ne, V) | 0, ne = ne + H | 0, K = K + p + ei(ne, H) | 0;
    var Y = U + N | 0, ee = O + x + ei(Y, U) | 0;
    u = c, R = k, c = a, k = I, a = o, I = b, b = y + ne | 0, o = s + K + ei(b, y) | 0, s = i, y = m, i = n, m = d, n = t, d = f, f = ne + Y | 0, t = K + ee + ei(f, ne) | 0;
  }
  this._al = this._al + f | 0, this._bl = this._bl + d | 0, this._cl = this._cl + m | 0, this._dl = this._dl + y | 0, this._el = this._el + b | 0, this._fl = this._fl + I | 0, this._gl = this._gl + k | 0, this._hl = this._hl + R | 0, this._ah = this._ah + t + ei(this._al, f) | 0, this._bh = this._bh + n + ei(this._bl, d) | 0, this._ch = this._ch + i + ei(this._cl, m) | 0, this._dh = this._dh + s + ei(this._dl, y) | 0, this._eh = this._eh + o + ei(this._el, b) | 0, this._fh = this._fh + a + ei(this._fl, I) | 0, this._gh = this._gh + c + ei(this._gl, k) | 0, this._hh = this._hh + u + ei(this._hl, R) | 0;
};
_y.prototype._hash = function() {
  var r = U0e.allocUnsafe(64);
  function e(t, n, i) {
    r.writeInt32BE(t, i), r.writeInt32BE(n, i + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), r;
};
var xL = _y, q0e = ja, G0e = xL, K0e = Zg, Z0e = wh.Buffer, J0e = new Array(160);
function v3() {
  this.init(), this._w = J0e, K0e.call(this, 128, 112);
}
q0e(v3, G0e);
v3.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
v3.prototype._hash = function() {
  var r = Z0e.allocUnsafe(48);
  function e(t, n, i) {
    r.writeInt32BE(t, i), r.writeInt32BE(n, i + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), r;
};
var Q0e = v3, $d = mL.exports = function(e) {
  e = e.toLowerCase();
  var t = $d[e];
  if (!t)
    throw new Error(e + " is not supported (we accept pull requests)");
  return new t();
};
$d.sha = d0e;
$d.sha1 = E0e;
$d.sha224 = B0e;
$d.sha256 = _L;
$d.sha384 = Q0e;
$d.sha512 = xL;
var Y0e = mL.exports, pt = {}, X0e = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, t = Symbol("test"), n = Object(t);
  if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
    return !1;
  var i = 42;
  e[t] = i;
  for (t in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var s = Object.getOwnPropertySymbols(e);
  if (s.length !== 1 || s[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var o = Object.getOwnPropertyDescriptor(e, t);
    if (o.value !== i || o.enumerable !== !0)
      return !1;
  }
  return !0;
}, rO = typeof Symbol < "u" && Symbol, ege = X0e, tge = function() {
  return typeof rO != "function" || typeof Symbol != "function" || typeof rO("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : ege();
}, nO = {
  foo: {}
}, rge = Object, nge = function() {
  return { __proto__: nO }.foo === nO.foo && !({ __proto__: null } instanceof rge);
}, ige = "Function.prototype.bind called on incompatible ", sge = Object.prototype.toString, oge = Math.max, age = "[object Function]", iO = function(e, t) {
  for (var n = [], i = 0; i < e.length; i += 1)
    n[i] = e[i];
  for (var s = 0; s < t.length; s += 1)
    n[s + e.length] = t[s];
  return n;
}, cge = function(e, t) {
  for (var n = [], i = t || 0, s = 0; i < e.length; i += 1, s += 1)
    n[s] = e[i];
  return n;
}, lge = function(r, e) {
  for (var t = "", n = 0; n < r.length; n += 1)
    t += r[n], n + 1 < r.length && (t += e);
  return t;
}, uge = function(e) {
  var t = this;
  if (typeof t != "function" || sge.apply(t) !== age)
    throw new TypeError(ige + t);
  for (var n = cge(arguments, 1), i, s = function() {
    if (this instanceof i) {
      var f = t.apply(
        this,
        iO(n, arguments)
      );
      return Object(f) === f ? f : this;
    }
    return t.apply(
      e,
      iO(n, arguments)
    );
  }, o = oge(0, t.length - n.length), a = [], c = 0; c < o; c++)
    a[c] = "$" + c;
  if (i = Function("binder", "return function (" + lge(a, ",") + "){ return binder.apply(this,arguments); }")(s), t.prototype) {
    var u = function() {
    };
    u.prototype = t.prototype, i.prototype = new u(), u.prototype = null;
  }
  return i;
}, hge = uge, VC = Function.prototype.bind || hge, fge = Function.prototype.call, dge = Object.prototype.hasOwnProperty, pge = VC, gge = pge.call(fge, dge), hr, _g = SyntaxError, SL = Function, Xp = TypeError, D4 = function(r) {
  try {
    return SL('"use strict"; return (' + r + ").constructor;")();
  } catch {
  }
}, Wf = Object.getOwnPropertyDescriptor;
if (Wf)
  try {
    Wf({}, "");
  } catch {
    Wf = null;
  }
var k4 = function() {
  throw new Xp();
}, mge = Wf ? function() {
  try {
    return arguments.callee, k4;
  } catch {
    try {
      return Wf(arguments, "callee").get;
    } catch {
      return k4;
    }
  }
}() : k4, pp = tge(), wge = nge(), oi = Object.getPrototypeOf || (wge ? function(r) {
  return r.__proto__;
} : null), Rp = {}, yge = typeof Uint8Array > "u" || !oi ? hr : oi(Uint8Array), Hf = {
  "%AggregateError%": typeof AggregateError > "u" ? hr : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? hr : ArrayBuffer,
  "%ArrayIteratorPrototype%": pp && oi ? oi([][Symbol.iterator]()) : hr,
  "%AsyncFromSyncIteratorPrototype%": hr,
  "%AsyncFunction%": Rp,
  "%AsyncGenerator%": Rp,
  "%AsyncGeneratorFunction%": Rp,
  "%AsyncIteratorPrototype%": Rp,
  "%Atomics%": typeof Atomics > "u" ? hr : Atomics,
  "%BigInt%": typeof BigInt > "u" ? hr : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? hr : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? hr : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? hr : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? hr : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? hr : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? hr : FinalizationRegistry,
  "%Function%": SL,
  "%GeneratorFunction%": Rp,
  "%Int8Array%": typeof Int8Array > "u" ? hr : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? hr : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? hr : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": pp && oi ? oi(oi([][Symbol.iterator]())) : hr,
  "%JSON%": typeof JSON == "object" ? JSON : hr,
  "%Map%": typeof Map > "u" ? hr : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !pp || !oi ? hr : oi((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? hr : Promise,
  "%Proxy%": typeof Proxy > "u" ? hr : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? hr : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? hr : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !pp || !oi ? hr : oi((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? hr : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": pp && oi ? oi(""[Symbol.iterator]()) : hr,
  "%Symbol%": pp ? Symbol : hr,
  "%SyntaxError%": _g,
  "%ThrowTypeError%": mge,
  "%TypedArray%": yge,
  "%TypeError%": Xp,
  "%Uint8Array%": typeof Uint8Array > "u" ? hr : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? hr : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? hr : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? hr : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? hr : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? hr : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? hr : WeakSet
};
if (oi)
  try {
    null.error;
  } catch (r) {
    var vge = oi(oi(r));
    Hf["%Error.prototype%"] = vge;
  }
var bge = function r(e) {
  var t;
  if (e === "%AsyncFunction%")
    t = D4("async function () {}");
  else if (e === "%GeneratorFunction%")
    t = D4("function* () {}");
  else if (e === "%AsyncGeneratorFunction%")
    t = D4("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var n = r("%AsyncGeneratorFunction%");
    n && (t = n.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var i = r("%AsyncGenerator%");
    i && oi && (t = oi(i.prototype));
  }
  return Hf[e] = t, t;
}, sO = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Ey = VC, K2 = gge, _ge = Ey.call(Function.call, Array.prototype.concat), Ege = Ey.call(Function.apply, Array.prototype.splice), oO = Ey.call(Function.call, String.prototype.replace), Z2 = Ey.call(Function.call, String.prototype.slice), xge = Ey.call(Function.call, RegExp.prototype.exec), Sge = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Cge = /\\(\\)?/g, Age = function(e) {
  var t = Z2(e, 0, 1), n = Z2(e, -1);
  if (t === "%" && n !== "%")
    throw new _g("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && t !== "%")
    throw new _g("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return oO(e, Sge, function(s, o, a, c) {
    i[i.length] = a ? oO(c, Cge, "$1") : o || s;
  }), i;
}, Ige = function(e, t) {
  var n = e, i;
  if (K2(sO, n) && (i = sO[n], n = "%" + i[0] + "%"), K2(Hf, n)) {
    var s = Hf[n];
    if (s === Rp && (s = bge(n)), typeof s > "u" && !t)
      throw new Xp("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: n,
      value: s
    };
  }
  throw new _g("intrinsic " + e + " does not exist!");
}, Ld = function(e, t) {
  if (typeof e != "string" || e.length === 0)
    throw new Xp("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof t != "boolean")
    throw new Xp('"allowMissing" argument must be a boolean');
  if (xge(/^%?[^%]*%?$/, e) === null)
    throw new _g("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = Age(e), i = n.length > 0 ? n[0] : "", s = Ige("%" + i + "%", t), o = s.name, a = s.value, c = !1, u = s.alias;
  u && (i = u[0], Ege(n, _ge([0, 1], u)));
  for (var f = 1, d = !0; f < n.length; f += 1) {
    var m = n[f], y = Z2(m, 0, 1), b = Z2(m, -1);
    if ((y === '"' || y === "'" || y === "`" || b === '"' || b === "'" || b === "`") && y !== b)
      throw new _g("property names with quotes must have matching quotes");
    if ((m === "constructor" || !d) && (c = !0), i += "." + m, o = "%" + i + "%", K2(Hf, o))
      a = Hf[o];
    else if (a != null) {
      if (!(m in a)) {
        if (!t)
          throw new Xp("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if (Wf && f + 1 >= n.length) {
        var I = Wf(a, m);
        d = !!I, d && "get" in I && !("originalValue" in I.get) ? a = I.get : a = a[m];
      } else
        d = K2(a, m), a = a[m];
      d && !c && (Hf[o] = a);
    }
  }
  return a;
}, CL = { exports: {} }, Rge = Ld, Zx = Rge("%Object.defineProperty%", !0), Jx = function() {
  if (Zx)
    try {
      return Zx({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
Jx.hasArrayLengthDefineBug = function() {
  if (!Jx())
    return null;
  try {
    return Zx([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var AL = Jx, Tge = Ld, Hb = Tge("%Object.getOwnPropertyDescriptor%", !0);
if (Hb)
  try {
    Hb([], "length");
  } catch {
    Hb = null;
  }
var IL = Hb, Oge = AL(), qC = Ld, gm = Oge && qC("%Object.defineProperty%", !0);
if (gm)
  try {
    gm({}, "a", { value: 1 });
  } catch {
    gm = !1;
  }
var Nge = qC("%SyntaxError%"), gp = qC("%TypeError%"), aO = IL, Pge = function(e, t, n) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new gp("`obj` must be an object or a function`");
  if (typeof t != "string" && typeof t != "symbol")
    throw new gp("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new gp("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new gp("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new gp("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new gp("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, s = arguments.length > 4 ? arguments[4] : null, o = arguments.length > 5 ? arguments[5] : null, a = arguments.length > 6 ? arguments[6] : !1, c = !!aO && aO(e, t);
  if (gm)
    gm(e, t, {
      configurable: o === null && c ? c.configurable : !o,
      enumerable: i === null && c ? c.enumerable : !i,
      value: n,
      writable: s === null && c ? c.writable : !s
    });
  else if (a || !i && !s && !o)
    e[t] = n;
  else
    throw new Nge("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, RL = Ld, cO = Pge, Mge = AL(), lO = IL, uO = RL("%TypeError%"), Dge = RL("%Math.floor%"), kge = function(e, t) {
  if (typeof e != "function")
    throw new uO("`fn` is not a function");
  if (typeof t != "number" || t < 0 || t > 4294967295 || Dge(t) !== t)
    throw new uO("`length` must be a positive 32-bit integer");
  var n = arguments.length > 2 && !!arguments[2], i = !0, s = !0;
  if ("length" in e && lO) {
    var o = lO(e, "length");
    o && !o.configurable && (i = !1), o && !o.writable && (s = !1);
  }
  return (i || s || !n) && (Mge ? cO(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    t,
    !0,
    !0
  ) : cO(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    t
  )), e;
};
(function(r) {
  var e = VC, t = Ld, n = kge, i = t("%TypeError%"), s = t("%Function.prototype.apply%"), o = t("%Function.prototype.call%"), a = t("%Reflect.apply%", !0) || e.call(o, s), c = t("%Object.defineProperty%", !0), u = t("%Math.max%");
  if (c)
    try {
      c({}, "a", { value: 1 });
    } catch {
      c = null;
    }
  r.exports = function(m) {
    if (typeof m != "function")
      throw new i("a function is required");
    var y = a(e, o, arguments);
    return n(
      y,
      1 + u(0, m.length - (arguments.length - 1)),
      !0
    );
  };
  var f = function() {
    return a(e, s, arguments);
  };
  c ? c(r.exports, "apply", { value: f }) : r.exports.apply = f;
})(CL);
var $ge = CL.exports, TL = Ld, OL = $ge, Lge = OL(TL("String.prototype.indexOf")), Bge = function(e, t) {
  var n = TL(e, !!t);
  return typeof n == "function" && Lge(e, ".prototype.") > -1 ? OL(n) : n;
}, GC = typeof Map == "function" && Map.prototype, $4 = Object.getOwnPropertyDescriptor && GC ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, J2 = GC && $4 && typeof $4.get == "function" ? $4.get : null, hO = GC && Map.prototype.forEach, KC = typeof Set == "function" && Set.prototype, L4 = Object.getOwnPropertyDescriptor && KC ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Q2 = KC && L4 && typeof L4.get == "function" ? L4.get : null, fO = KC && Set.prototype.forEach, Fge = typeof WeakMap == "function" && WeakMap.prototype, mm = Fge ? WeakMap.prototype.has : null, Uge = typeof WeakSet == "function" && WeakSet.prototype, wm = Uge ? WeakSet.prototype.has : null, jge = typeof WeakRef == "function" && WeakRef.prototype, dO = jge ? WeakRef.prototype.deref : null, Wge = Boolean.prototype.valueOf, Hge = Object.prototype.toString, zge = Function.prototype.toString, Vge = String.prototype.match, ZC = String.prototype.slice, Uu = String.prototype.replace, qge = String.prototype.toUpperCase, pO = String.prototype.toLowerCase, NL = RegExp.prototype.test, gO = Array.prototype.concat, pc = Array.prototype.join, Gge = Array.prototype.slice, mO = Math.floor, Qx = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, B4 = Object.getOwnPropertySymbols, Yx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, Eg = typeof Symbol == "function" && typeof Symbol.iterator == "object", Ui = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Eg || !0) ? Symbol.toStringTag : null, PL = Object.prototype.propertyIsEnumerable, wO = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(r) {
  return r.__proto__;
} : null);
function yO(r, e) {
  if (r === 1 / 0 || r === -1 / 0 || r !== r || r && r > -1e3 && r < 1e3 || NL.call(/e/, e))
    return e;
  var t = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof r == "number") {
    var n = r < 0 ? -mO(-r) : mO(r);
    if (n !== r) {
      var i = String(n), s = ZC.call(e, i.length + 1);
      return Uu.call(i, t, "$&_") + "." + Uu.call(Uu.call(s, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return Uu.call(e, t, "$&_");
}
var Xx = sy, vO = Xx.custom, bO = DL(vO) ? vO : null, Kge = function r(e, t, n, i) {
  var s = t || {};
  if (fu(s, "quoteStyle") && s.quoteStyle !== "single" && s.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (fu(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var o = fu(s, "customInspect") ? s.customInspect : !0;
  if (typeof o != "boolean" && o !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (fu(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (fu(s, "numericSeparator") && typeof s.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var a = s.numericSeparator;
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  if (typeof e == "boolean")
    return e ? "true" : "false";
  if (typeof e == "string")
    return $L(e, s);
  if (typeof e == "number") {
    if (e === 0)
      return 1 / 0 / e > 0 ? "0" : "-0";
    var c = String(e);
    return a ? yO(e, c) : c;
  }
  if (typeof e == "bigint") {
    var u = String(e) + "n";
    return a ? yO(e, u) : u;
  }
  var f = typeof s.depth > "u" ? 5 : s.depth;
  if (typeof n > "u" && (n = 0), n >= f && f > 0 && typeof e == "object")
    return eS(e) ? "[Array]" : "[Object]";
  var d = f1e(s, n);
  if (typeof i > "u")
    i = [];
  else if (kL(i, e) >= 0)
    return "[Circular]";
  function m(H, p, w) {
    if (p && (i = Gge.call(i), i.push(p)), w) {
      var x = {
        depth: s.depth
      };
      return fu(s, "quoteStyle") && (x.quoteStyle = s.quoteStyle), r(H, x, n + 1, i);
    }
    return r(H, s, n + 1, i);
  }
  if (typeof e == "function" && !_O(e)) {
    var y = n1e(e), b = ub(e, m);
    return "[Function" + (y ? ": " + y : " (anonymous)") + "]" + (b.length > 0 ? " { " + pc.call(b, ", ") + " }" : "");
  }
  if (DL(e)) {
    var I = Eg ? Uu.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : Yx.call(e);
    return typeof e == "object" && !Eg ? j1(I) : I;
  }
  if (l1e(e)) {
    for (var k = "<" + pO.call(String(e.nodeName)), R = e.attributes || [], T = 0; T < R.length; T++)
      k += " " + R[T].name + "=" + ML(Zge(R[T].value), "double", s);
    return k += ">", e.childNodes && e.childNodes.length && (k += "..."), k += "</" + pO.call(String(e.nodeName)) + ">", k;
  }
  if (eS(e)) {
    if (e.length === 0)
      return "[]";
    var $ = ub(e, m);
    return d && !h1e($) ? "[" + tS($, d) + "]" : "[ " + pc.call($, ", ") + " ]";
  }
  if (Qge(e)) {
    var D = ub(e, m);
    return !("cause" in Error.prototype) && "cause" in e && !PL.call(e, "cause") ? "{ [" + String(e) + "] " + pc.call(gO.call("[cause]: " + m(e.cause), D), ", ") + " }" : D.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + pc.call(D, ", ") + " }";
  }
  if (typeof e == "object" && o) {
    if (bO && typeof e[bO] == "function" && Xx)
      return Xx(e, { depth: f - n });
    if (o !== "symbol" && typeof e.inspect == "function")
      return e.inspect();
  }
  if (i1e(e)) {
    var L = [];
    return hO && hO.call(e, function(H, p) {
      L.push(m(p, e, !0) + " => " + m(H, e));
    }), EO("Map", J2.call(e), L, d);
  }
  if (a1e(e)) {
    var P = [];
    return fO && fO.call(e, function(H) {
      P.push(m(H, e));
    }), EO("Set", Q2.call(e), P, d);
  }
  if (s1e(e))
    return F4("WeakMap");
  if (c1e(e))
    return F4("WeakSet");
  if (o1e(e))
    return F4("WeakRef");
  if (Xge(e))
    return j1(m(Number(e)));
  if (t1e(e))
    return j1(m(Qx.call(e)));
  if (e1e(e))
    return j1(Wge.call(e));
  if (Yge(e))
    return j1(m(String(e)));
  if (typeof window < "u" && e === window)
    return "{ [object Window] }";
  if (e === ze)
    return "{ [object globalThis] }";
  if (!Jge(e) && !_O(e)) {
    var v = ub(e, m), F = wO ? wO(e) === Object.prototype : e instanceof Object || e.constructor === Object, X = e instanceof Object ? "" : "null prototype", te = !F && Ui && Object(e) === e && Ui in e ? ZC.call(yh(e), 8, -1) : X ? "Object" : "", se = F || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", we = se + (te || X ? "[" + pc.call(gO.call([], te || [], X || []), ": ") + "] " : "");
    return v.length === 0 ? we + "{}" : d ? we + "{" + tS(v, d) + "}" : we + "{ " + pc.call(v, ", ") + " }";
  }
  return String(e);
};
function ML(r, e, t) {
  var n = (t.quoteStyle || e) === "double" ? '"' : "'";
  return n + r + n;
}
function Zge(r) {
  return Uu.call(String(r), /"/g, "&quot;");
}
function eS(r) {
  return yh(r) === "[object Array]" && (!Ui || !(typeof r == "object" && Ui in r));
}
function Jge(r) {
  return yh(r) === "[object Date]" && (!Ui || !(typeof r == "object" && Ui in r));
}
function _O(r) {
  return yh(r) === "[object RegExp]" && (!Ui || !(typeof r == "object" && Ui in r));
}
function Qge(r) {
  return yh(r) === "[object Error]" && (!Ui || !(typeof r == "object" && Ui in r));
}
function Yge(r) {
  return yh(r) === "[object String]" && (!Ui || !(typeof r == "object" && Ui in r));
}
function Xge(r) {
  return yh(r) === "[object Number]" && (!Ui || !(typeof r == "object" && Ui in r));
}
function e1e(r) {
  return yh(r) === "[object Boolean]" && (!Ui || !(typeof r == "object" && Ui in r));
}
function DL(r) {
  if (Eg)
    return r && typeof r == "object" && r instanceof Symbol;
  if (typeof r == "symbol")
    return !0;
  if (!r || typeof r != "object" || !Yx)
    return !1;
  try {
    return Yx.call(r), !0;
  } catch {
  }
  return !1;
}
function t1e(r) {
  if (!r || typeof r != "object" || !Qx)
    return !1;
  try {
    return Qx.call(r), !0;
  } catch {
  }
  return !1;
}
var r1e = Object.prototype.hasOwnProperty || function(r) {
  return r in this;
};
function fu(r, e) {
  return r1e.call(r, e);
}
function yh(r) {
  return Hge.call(r);
}
function n1e(r) {
  if (r.name)
    return r.name;
  var e = Vge.call(zge.call(r), /^function\s*([\w$]+)/);
  return e ? e[1] : null;
}
function kL(r, e) {
  if (r.indexOf)
    return r.indexOf(e);
  for (var t = 0, n = r.length; t < n; t++)
    if (r[t] === e)
      return t;
  return -1;
}
function i1e(r) {
  if (!J2 || !r || typeof r != "object")
    return !1;
  try {
    J2.call(r);
    try {
      Q2.call(r);
    } catch {
      return !0;
    }
    return r instanceof Map;
  } catch {
  }
  return !1;
}
function s1e(r) {
  if (!mm || !r || typeof r != "object")
    return !1;
  try {
    mm.call(r, mm);
    try {
      wm.call(r, wm);
    } catch {
      return !0;
    }
    return r instanceof WeakMap;
  } catch {
  }
  return !1;
}
function o1e(r) {
  if (!dO || !r || typeof r != "object")
    return !1;
  try {
    return dO.call(r), !0;
  } catch {
  }
  return !1;
}
function a1e(r) {
  if (!Q2 || !r || typeof r != "object")
    return !1;
  try {
    Q2.call(r);
    try {
      J2.call(r);
    } catch {
      return !0;
    }
    return r instanceof Set;
  } catch {
  }
  return !1;
}
function c1e(r) {
  if (!wm || !r || typeof r != "object")
    return !1;
  try {
    wm.call(r, wm);
    try {
      mm.call(r, mm);
    } catch {
      return !0;
    }
    return r instanceof WeakSet;
  } catch {
  }
  return !1;
}
function l1e(r) {
  return !r || typeof r != "object" ? !1 : typeof HTMLElement < "u" && r instanceof HTMLElement ? !0 : typeof r.nodeName == "string" && typeof r.getAttribute == "function";
}
function $L(r, e) {
  if (r.length > e.maxStringLength) {
    var t = r.length - e.maxStringLength, n = "... " + t + " more character" + (t > 1 ? "s" : "");
    return $L(ZC.call(r, 0, e.maxStringLength), e) + n;
  }
  var i = Uu.call(Uu.call(r, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, u1e);
  return ML(i, "single", e);
}
function u1e(r) {
  var e = r.charCodeAt(0), t = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[e];
  return t ? "\\" + t : "\\x" + (e < 16 ? "0" : "") + qge.call(e.toString(16));
}
function j1(r) {
  return "Object(" + r + ")";
}
function F4(r) {
  return r + " { ? }";
}
function EO(r, e, t, n) {
  var i = n ? tS(t, n) : pc.call(t, ", ");
  return r + " (" + e + ") {" + i + "}";
}
function h1e(r) {
  for (var e = 0; e < r.length; e++)
    if (kL(r[e], `
`) >= 0)
      return !1;
  return !0;
}
function f1e(r, e) {
  var t;
  if (r.indent === "	")
    t = "	";
  else if (typeof r.indent == "number" && r.indent > 0)
    t = pc.call(Array(r.indent + 1), " ");
  else
    return null;
  return {
    base: t,
    prev: pc.call(Array(e + 1), t)
  };
}
function tS(r, e) {
  if (r.length === 0)
    return "";
  var t = `
` + e.prev + e.base;
  return t + pc.call(r, "," + t) + `
` + e.prev;
}
function ub(r, e) {
  var t = eS(r), n = [];
  if (t) {
    n.length = r.length;
    for (var i = 0; i < r.length; i++)
      n[i] = fu(r, i) ? e(r[i], r) : "";
  }
  var s = typeof B4 == "function" ? B4(r) : [], o;
  if (Eg) {
    o = {};
    for (var a = 0; a < s.length; a++)
      o["$" + s[a]] = s[a];
  }
  for (var c in r)
    fu(r, c) && (t && String(Number(c)) === c && c < r.length || Eg && o["$" + c] instanceof Symbol || (NL.call(/[^\w$]/, c) ? n.push(e(c, r) + ": " + e(r[c], r)) : n.push(c + ": " + e(r[c], r))));
  if (typeof B4 == "function")
    for (var u = 0; u < s.length; u++)
      PL.call(r, s[u]) && n.push("[" + e(s[u]) + "]: " + e(r[s[u]], r));
  return n;
}
var JC = Ld, Jg = Bge, d1e = Kge, p1e = JC("%TypeError%"), hb = JC("%WeakMap%", !0), fb = JC("%Map%", !0), g1e = Jg("WeakMap.prototype.get", !0), m1e = Jg("WeakMap.prototype.set", !0), w1e = Jg("WeakMap.prototype.has", !0), y1e = Jg("Map.prototype.get", !0), v1e = Jg("Map.prototype.set", !0), b1e = Jg("Map.prototype.has", !0), QC = function(r, e) {
  for (var t = r, n; (n = t.next) !== null; t = n)
    if (n.key === e)
      return t.next = n.next, n.next = r.next, r.next = n, n;
}, _1e = function(r, e) {
  var t = QC(r, e);
  return t && t.value;
}, E1e = function(r, e, t) {
  var n = QC(r, e);
  n ? n.value = t : r.next = {
    // eslint-disable-line no-param-reassign
    key: e,
    next: r.next,
    value: t
  };
}, x1e = function(r, e) {
  return !!QC(r, e);
}, S1e = function() {
  var e, t, n, i = {
    assert: function(s) {
      if (!i.has(s))
        throw new p1e("Side channel does not contain " + d1e(s));
    },
    get: function(s) {
      if (hb && s && (typeof s == "object" || typeof s == "function")) {
        if (e)
          return g1e(e, s);
      } else if (fb) {
        if (t)
          return y1e(t, s);
      } else if (n)
        return _1e(n, s);
    },
    has: function(s) {
      if (hb && s && (typeof s == "object" || typeof s == "function")) {
        if (e)
          return w1e(e, s);
      } else if (fb) {
        if (t)
          return b1e(t, s);
      } else if (n)
        return x1e(n, s);
      return !1;
    },
    set: function(s, o) {
      hb && s && (typeof s == "object" || typeof s == "function") ? (e || (e = new hb()), m1e(e, s, o)) : fb ? (t || (t = new fb()), v1e(t, s, o)) : (n || (n = { key: {}, next: null }), E1e(n, s, o));
    }
  };
  return i;
}, C1e = String.prototype.replace, A1e = /%20/g, U4 = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, YC = {
  default: U4.RFC3986,
  formatters: {
    RFC1738: function(r) {
      return C1e.call(r, A1e, "+");
    },
    RFC3986: function(r) {
      return String(r);
    }
  },
  RFC1738: U4.RFC1738,
  RFC3986: U4.RFC3986
}, I1e = YC, j4 = Object.prototype.hasOwnProperty, Qh = Array.isArray, ec = function() {
  for (var r = [], e = 0; e < 256; ++e)
    r.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return r;
}(), R1e = function(e) {
  for (; e.length > 1; ) {
    var t = e.pop(), n = t.obj[t.prop];
    if (Qh(n)) {
      for (var i = [], s = 0; s < n.length; ++s)
        typeof n[s] < "u" && i.push(n[s]);
      t.obj[t.prop] = i;
    }
  }
}, LL = function(e, t) {
  for (var n = t && t.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i = 0; i < e.length; ++i)
    typeof e[i] < "u" && (n[i] = e[i]);
  return n;
}, T1e = function r(e, t, n) {
  if (!t)
    return e;
  if (typeof t != "object") {
    if (Qh(e))
      e.push(t);
    else if (e && typeof e == "object")
      (n && (n.plainObjects || n.allowPrototypes) || !j4.call(Object.prototype, t)) && (e[t] = !0);
    else
      return [e, t];
    return e;
  }
  if (!e || typeof e != "object")
    return [e].concat(t);
  var i = e;
  return Qh(e) && !Qh(t) && (i = LL(e, n)), Qh(e) && Qh(t) ? (t.forEach(function(s, o) {
    if (j4.call(e, o)) {
      var a = e[o];
      a && typeof a == "object" && s && typeof s == "object" ? e[o] = r(a, s, n) : e.push(s);
    } else
      e[o] = s;
  }), e) : Object.keys(t).reduce(function(s, o) {
    var a = t[o];
    return j4.call(s, o) ? s[o] = r(s[o], a, n) : s[o] = a, s;
  }, i);
}, O1e = function(e, t) {
  return Object.keys(t).reduce(function(n, i) {
    return n[i] = t[i], n;
  }, e);
}, N1e = function(r, e, t) {
  var n = r.replace(/\+/g, " ");
  if (t === "iso-8859-1")
    return n.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(n);
  } catch {
    return n;
  }
}, P1e = function(e, t, n, i, s) {
  if (e.length === 0)
    return e;
  var o = e;
  if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), n === "iso-8859-1")
    return escape(o).replace(/%u[0-9a-f]{4}/gi, function(f) {
      return "%26%23" + parseInt(f.slice(2), 16) + "%3B";
    });
  for (var a = "", c = 0; c < o.length; ++c) {
    var u = o.charCodeAt(c);
    if (u === 45 || u === 46 || u === 95 || u === 126 || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || s === I1e.RFC1738 && (u === 40 || u === 41)) {
      a += o.charAt(c);
      continue;
    }
    if (u < 128) {
      a = a + ec[u];
      continue;
    }
    if (u < 2048) {
      a = a + (ec[192 | u >> 6] + ec[128 | u & 63]);
      continue;
    }
    if (u < 55296 || u >= 57344) {
      a = a + (ec[224 | u >> 12] + ec[128 | u >> 6 & 63] + ec[128 | u & 63]);
      continue;
    }
    c += 1, u = 65536 + ((u & 1023) << 10 | o.charCodeAt(c) & 1023), a += ec[240 | u >> 18] + ec[128 | u >> 12 & 63] + ec[128 | u >> 6 & 63] + ec[128 | u & 63];
  }
  return a;
}, M1e = function(e) {
  for (var t = [{ obj: { o: e }, prop: "o" }], n = [], i = 0; i < t.length; ++i)
    for (var s = t[i], o = s.obj[s.prop], a = Object.keys(o), c = 0; c < a.length; ++c) {
      var u = a[c], f = o[u];
      typeof f == "object" && f !== null && n.indexOf(f) === -1 && (t.push({ obj: o, prop: u }), n.push(f));
    }
  return R1e(t), e;
}, D1e = function(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}, k1e = function(e) {
  return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
}, $1e = function(e, t) {
  return [].concat(e, t);
}, L1e = function(e, t) {
  if (Qh(e)) {
    for (var n = [], i = 0; i < e.length; i += 1)
      n.push(t(e[i]));
    return n;
  }
  return t(e);
}, BL = {
  arrayToObject: LL,
  assign: O1e,
  combine: $1e,
  compact: M1e,
  decode: N1e,
  encode: P1e,
  isBuffer: k1e,
  isRegExp: D1e,
  maybeMap: L1e,
  merge: T1e
}, FL = S1e, zb = BL, ym = YC, B1e = Object.prototype.hasOwnProperty, xO = {
  brackets: function(e) {
    return e + "[]";
  },
  comma: "comma",
  indices: function(e, t) {
    return e + "[" + t + "]";
  },
  repeat: function(e) {
    return e;
  }
}, al = Array.isArray, F1e = Array.prototype.push, UL = function(r, e) {
  F1e.apply(r, al(e) ? e : [e]);
}, U1e = Date.prototype.toISOString, SO = ym.default, Oi = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: zb.encode,
  encodeValuesOnly: !1,
  format: SO,
  formatter: ym.formatters[SO],
  // deprecated
  indices: !1,
  serializeDate: function(e) {
    return U1e.call(e);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, j1e = function(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
}, W4 = {}, W1e = function r(e, t, n, i, s, o, a, c, u, f, d, m, y, b, I, k) {
  for (var R = e, T = k, $ = 0, D = !1; (T = T.get(W4)) !== void 0 && !D; ) {
    var L = T.get(e);
    if ($ += 1, typeof L < "u") {
      if (L === $)
        throw new RangeError("Cyclic object value");
      D = !0;
    }
    typeof T.get(W4) > "u" && ($ = 0);
  }
  if (typeof c == "function" ? R = c(t, R) : R instanceof Date ? R = d(R) : n === "comma" && al(R) && (R = zb.maybeMap(R, function(x) {
    return x instanceof Date ? d(x) : x;
  })), R === null) {
    if (s)
      return a && !b ? a(t, Oi.encoder, I, "key", m) : t;
    R = "";
  }
  if (j1e(R) || zb.isBuffer(R)) {
    if (a) {
      var P = b ? t : a(t, Oi.encoder, I, "key", m);
      return [y(P) + "=" + y(a(R, Oi.encoder, I, "value", m))];
    }
    return [y(t) + "=" + y(String(R))];
  }
  var v = [];
  if (typeof R > "u")
    return v;
  var F;
  if (n === "comma" && al(R))
    b && a && (R = zb.maybeMap(R, a)), F = [{ value: R.length > 0 ? R.join(",") || null : void 0 }];
  else if (al(c))
    F = c;
  else {
    var X = Object.keys(R);
    F = u ? X.sort(u) : X;
  }
  for (var te = i && al(R) && R.length === 1 ? t + "[]" : t, se = 0; se < F.length; ++se) {
    var we = F[se], H = typeof we == "object" && typeof we.value < "u" ? we.value : R[we];
    if (!(o && H === null)) {
      var p = al(R) ? typeof n == "function" ? n(te, we) : te : te + (f ? "." + we : "[" + we + "]");
      k.set(e, $);
      var w = FL();
      w.set(W4, k), UL(v, r(
        H,
        p,
        n,
        i,
        s,
        o,
        n === "comma" && b && al(R) ? null : a,
        c,
        u,
        f,
        d,
        m,
        y,
        b,
        I,
        w
      ));
    }
  }
  return v;
}, H1e = function(e) {
  if (!e)
    return Oi;
  if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var t = e.charset || Oi.charset;
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var n = ym.default;
  if (typeof e.format < "u") {
    if (!B1e.call(ym.formatters, e.format))
      throw new TypeError("Unknown format option provided.");
    n = e.format;
  }
  var i = ym.formatters[n], s = Oi.filter;
  return (typeof e.filter == "function" || al(e.filter)) && (s = e.filter), {
    addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : Oi.addQueryPrefix,
    allowDots: typeof e.allowDots > "u" ? Oi.allowDots : !!e.allowDots,
    charset: t,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Oi.charsetSentinel,
    delimiter: typeof e.delimiter > "u" ? Oi.delimiter : e.delimiter,
    encode: typeof e.encode == "boolean" ? e.encode : Oi.encode,
    encoder: typeof e.encoder == "function" ? e.encoder : Oi.encoder,
    encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : Oi.encodeValuesOnly,
    filter: s,
    format: n,
    formatter: i,
    serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : Oi.serializeDate,
    skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Oi.skipNulls,
    sort: typeof e.sort == "function" ? e.sort : null,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Oi.strictNullHandling
  };
}, z1e = function(r, e) {
  var t = r, n = H1e(e), i, s;
  typeof n.filter == "function" ? (s = n.filter, t = s("", t)) : al(n.filter) && (s = n.filter, i = s);
  var o = [];
  if (typeof t != "object" || t === null)
    return "";
  var a;
  e && e.arrayFormat in xO ? a = e.arrayFormat : e && "indices" in e ? a = e.indices ? "indices" : "repeat" : a = "indices";
  var c = xO[a];
  if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var u = c === "comma" && e && e.commaRoundTrip;
  i || (i = Object.keys(t)), n.sort && i.sort(n.sort);
  for (var f = FL(), d = 0; d < i.length; ++d) {
    var m = i[d];
    n.skipNulls && t[m] === null || UL(o, W1e(
      t[m],
      m,
      c,
      u,
      n.strictNullHandling,
      n.skipNulls,
      n.encode ? n.encoder : null,
      n.filter,
      n.sort,
      n.allowDots,
      n.serializeDate,
      n.format,
      n.formatter,
      n.encodeValuesOnly,
      n.charset,
      f
    ));
  }
  var y = o.join(n.delimiter), b = n.addQueryPrefix === !0 ? "?" : "";
  return n.charsetSentinel && (n.charset === "iso-8859-1" ? b += "utf8=%26%2310003%3B&" : b += "utf8=%E2%9C%93&"), y.length > 0 ? b + y : "";
}, xg = BL, rS = Object.prototype.hasOwnProperty, V1e = Array.isArray, ni = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: xg.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, q1e = function(r) {
  return r.replace(/&#(\d+);/g, function(e, t) {
    return String.fromCharCode(parseInt(t, 10));
  });
}, jL = function(r, e) {
  return r && typeof r == "string" && e.comma && r.indexOf(",") > -1 ? r.split(",") : r;
}, G1e = "utf8=%26%2310003%3B", K1e = "utf8=%E2%9C%93", Z1e = function(e, t) {
  var n = { __proto__: null }, i = t.ignoreQueryPrefix ? e.replace(/^\?/, "") : e, s = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit, o = i.split(t.delimiter, s), a = -1, c, u = t.charset;
  if (t.charsetSentinel)
    for (c = 0; c < o.length; ++c)
      o[c].indexOf("utf8=") === 0 && (o[c] === K1e ? u = "utf-8" : o[c] === G1e && (u = "iso-8859-1"), a = c, c = o.length);
  for (c = 0; c < o.length; ++c)
    if (c !== a) {
      var f = o[c], d = f.indexOf("]="), m = d === -1 ? f.indexOf("=") : d + 1, y, b;
      m === -1 ? (y = t.decoder(f, ni.decoder, u, "key"), b = t.strictNullHandling ? null : "") : (y = t.decoder(f.slice(0, m), ni.decoder, u, "key"), b = xg.maybeMap(
        jL(f.slice(m + 1), t),
        function(I) {
          return t.decoder(I, ni.decoder, u, "value");
        }
      )), b && t.interpretNumericEntities && u === "iso-8859-1" && (b = q1e(b)), f.indexOf("[]=") > -1 && (b = V1e(b) ? [b] : b), rS.call(n, y) ? n[y] = xg.combine(n[y], b) : n[y] = b;
    }
  return n;
}, J1e = function(r, e, t, n) {
  for (var i = n ? e : jL(e, t), s = r.length - 1; s >= 0; --s) {
    var o, a = r[s];
    if (a === "[]" && t.parseArrays)
      o = [].concat(i);
    else {
      o = t.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var c = a.charAt(0) === "[" && a.charAt(a.length - 1) === "]" ? a.slice(1, -1) : a, u = parseInt(c, 10);
      !t.parseArrays && c === "" ? o = { 0: i } : !isNaN(u) && a !== c && String(u) === c && u >= 0 && t.parseArrays && u <= t.arrayLimit ? (o = [], o[u] = i) : c !== "__proto__" && (o[c] = i);
    }
    i = o;
  }
  return i;
}, Q1e = function(e, t, n, i) {
  if (e) {
    var s = n.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, o = /(\[[^[\]]*])/, a = /(\[[^[\]]*])/g, c = n.depth > 0 && o.exec(s), u = c ? s.slice(0, c.index) : s, f = [];
    if (u) {
      if (!n.plainObjects && rS.call(Object.prototype, u) && !n.allowPrototypes)
        return;
      f.push(u);
    }
    for (var d = 0; n.depth > 0 && (c = a.exec(s)) !== null && d < n.depth; ) {
      if (d += 1, !n.plainObjects && rS.call(Object.prototype, c[1].slice(1, -1)) && !n.allowPrototypes)
        return;
      f.push(c[1]);
    }
    return c && f.push("[" + s.slice(c.index) + "]"), J1e(f, t, n, i);
  }
}, Y1e = function(e) {
  if (!e)
    return ni;
  if (e.decoder !== null && e.decoder !== void 0 && typeof e.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var t = typeof e.charset > "u" ? ni.charset : e.charset;
  return {
    allowDots: typeof e.allowDots > "u" ? ni.allowDots : !!e.allowDots,
    allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : ni.allowPrototypes,
    allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : ni.allowSparse,
    arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : ni.arrayLimit,
    charset: t,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : ni.charsetSentinel,
    comma: typeof e.comma == "boolean" ? e.comma : ni.comma,
    decoder: typeof e.decoder == "function" ? e.decoder : ni.decoder,
    delimiter: typeof e.delimiter == "string" || xg.isRegExp(e.delimiter) ? e.delimiter : ni.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : ni.depth,
    ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : ni.interpretNumericEntities,
    parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : ni.parameterLimit,
    parseArrays: e.parseArrays !== !1,
    plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : ni.plainObjects,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : ni.strictNullHandling
  };
}, X1e = function(r, e) {
  var t = Y1e(e);
  if (r === "" || r === null || typeof r > "u")
    return t.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var n = typeof r == "string" ? Z1e(r, t) : r, i = t.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, s = Object.keys(n), o = 0; o < s.length; ++o) {
    var a = s[o], c = Q1e(a, n[a], t, typeof r == "string");
    i = xg.merge(i, c, t);
  }
  return t.allowSparse === !0 ? i : xg.compact(i);
}, eme = z1e, tme = X1e, rme = YC, nme = {
  formats: rme,
  parse: tme,
  stringify: eme
}, xy = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.ProviderType = r.RegExpString = r.IntNumber = r.BigIntString = r.AddressString = r.HexString = r.OpaqueType = void 0;
  function e() {
    return (n) => n;
  }
  r.OpaqueType = e, r.HexString = e(), r.AddressString = e(), r.BigIntString = e();
  function t(n) {
    return Math.floor(n);
  }
  r.IntNumber = t, r.RegExpString = e(), function(n) {
    n.CoinbaseWallet = "CoinbaseWallet", n.MetaMask = "MetaMask", n.Unselected = "";
  }(r.ProviderType || (r.ProviderType = {}));
})(xy);
var ime = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(pt, "__esModule", { value: !0 });
pt.isInIFrame = pt.createQrUrl = pt.getFavicon = pt.range = pt.isBigNumber = pt.ensureParsedJSONObject = pt.ensureBN = pt.ensureRegExpString = pt.ensureIntNumber = pt.ensureBuffer = pt.ensureAddressString = pt.ensureEvenLengthHexString = pt.ensureHexString = pt.isHexString = pt.prepend0x = pt.strip0x = pt.has0xPrefix = pt.hexStringFromIntNumber = pt.intNumberFromHexString = pt.bigIntStringFromBN = pt.hexStringFromBuffer = pt.hexStringToUint8Array = pt.uint8ArrayToHex = pt.randomBytesHex = void 0;
const yu = ime(p3), sme = nme, Bd = wy, Lo = xy, WL = /^[0-9]*$/, HL = /^[a-f0-9]*$/;
function ome(r) {
  return zL(crypto.getRandomValues(new Uint8Array(r)));
}
pt.randomBytesHex = ome;
function zL(r) {
  return [...r].map((e) => e.toString(16).padStart(2, "0")).join("");
}
pt.uint8ArrayToHex = zL;
function ame(r) {
  return new Uint8Array(r.match(/.{1,2}/g).map((e) => parseInt(e, 16)));
}
pt.hexStringToUint8Array = ame;
function cme(r, e = !1) {
  const t = r.toString("hex");
  return (0, Lo.HexString)(e ? "0x" + t : t);
}
pt.hexStringFromBuffer = cme;
function lme(r) {
  return (0, Lo.BigIntString)(r.toString(10));
}
pt.bigIntStringFromBN = lme;
function ume(r) {
  return (0, Lo.IntNumber)(new yu.default(Cy(r, !1), 16).toNumber());
}
pt.intNumberFromHexString = ume;
function hme(r) {
  return (0, Lo.HexString)("0x" + new yu.default(r).toString(16));
}
pt.hexStringFromIntNumber = hme;
function XC(r) {
  return r.startsWith("0x") || r.startsWith("0X");
}
pt.has0xPrefix = XC;
function b3(r) {
  return XC(r) ? r.slice(2) : r;
}
pt.strip0x = b3;
function VL(r) {
  return XC(r) ? "0x" + r.slice(2) : "0x" + r;
}
pt.prepend0x = VL;
function Sy(r) {
  if (typeof r != "string")
    return !1;
  const e = b3(r).toLowerCase();
  return HL.test(e);
}
pt.isHexString = Sy;
function qL(r, e = !1) {
  if (typeof r == "string") {
    const t = b3(r).toLowerCase();
    if (HL.test(t))
      return (0, Lo.HexString)(e ? "0x" + t : t);
  }
  throw Bd.standardErrors.rpc.invalidParams(`"${String(r)}" is not a hexadecimal string`);
}
pt.ensureHexString = qL;
function Cy(r, e = !1) {
  let t = qL(r, !1);
  return t.length % 2 === 1 && (t = (0, Lo.HexString)("0" + t)), e ? (0, Lo.HexString)("0x" + t) : t;
}
pt.ensureEvenLengthHexString = Cy;
function fme(r) {
  if (typeof r == "string") {
    const e = b3(r).toLowerCase();
    if (Sy(e) && e.length === 40)
      return (0, Lo.AddressString)(VL(e));
  }
  throw Bd.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(r)}`);
}
pt.ensureAddressString = fme;
function dme(r) {
  if (Buffer.isBuffer(r))
    return r;
  if (typeof r == "string")
    if (Sy(r)) {
      const e = Cy(r, !1);
      return Buffer.from(e, "hex");
    } else
      return Buffer.from(r, "utf8");
  throw Bd.standardErrors.rpc.invalidParams(`Not binary data: ${String(r)}`);
}
pt.ensureBuffer = dme;
function GL(r) {
  if (typeof r == "number" && Number.isInteger(r))
    return (0, Lo.IntNumber)(r);
  if (typeof r == "string") {
    if (WL.test(r))
      return (0, Lo.IntNumber)(Number(r));
    if (Sy(r))
      return (0, Lo.IntNumber)(new yu.default(Cy(r, !1), 16).toNumber());
  }
  throw Bd.standardErrors.rpc.invalidParams(`Not an integer: ${String(r)}`);
}
pt.ensureIntNumber = GL;
function pme(r) {
  if (r instanceof RegExp)
    return (0, Lo.RegExpString)(r.toString());
  throw Bd.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(r)}`);
}
pt.ensureRegExpString = pme;
function gme(r) {
  if (r !== null && (yu.default.isBN(r) || KL(r)))
    return new yu.default(r.toString(10), 10);
  if (typeof r == "number")
    return new yu.default(GL(r));
  if (typeof r == "string") {
    if (WL.test(r))
      return new yu.default(r, 10);
    if (Sy(r))
      return new yu.default(Cy(r, !1), 16);
  }
  throw Bd.standardErrors.rpc.invalidParams(`Not an integer: ${String(r)}`);
}
pt.ensureBN = gme;
function mme(r) {
  if (typeof r == "string")
    return JSON.parse(r);
  if (typeof r == "object")
    return r;
  throw Bd.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(r)}`);
}
pt.ensureParsedJSONObject = mme;
function KL(r) {
  if (r == null || typeof r.constructor != "function")
    return !1;
  const { constructor: e } = r;
  return typeof e.config == "function" && typeof e.EUCLID == "number";
}
pt.isBigNumber = KL;
function wme(r, e) {
  return Array.from({ length: e - r }, (t, n) => r + n);
}
pt.range = wme;
function yme() {
  const r = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]'), { protocol: e, host: t } = document.location, n = r ? r.getAttribute("href") : null;
  return !n || n.startsWith("javascript:") ? null : n.startsWith("http://") || n.startsWith("https://") || n.startsWith("data:") ? n : n.startsWith("//") ? e + n : `${e}//${t}${n}`;
}
pt.getFavicon = yme;
function vme(r, e, t, n, i, s) {
  const o = n ? "parent-id" : "id", a = (0, sme.stringify)({
    [o]: r,
    secret: e,
    server: t,
    v: i,
    chainId: s
  });
  return `${t}/#/link?${a}`;
}
pt.createQrUrl = vme;
function bme() {
  try {
    return window.frameElement !== null;
  } catch {
    return !1;
  }
}
pt.isInIFrame = bme;
Object.defineProperty(Kg, "__esModule", { value: !0 });
Kg.Session = void 0;
const CO = Y0e, AO = pt, IO = "session:id", RO = "session:secret", TO = "session:linked";
class eA {
  constructor(e, t, n, i) {
    this._storage = e, this._id = t || (0, AO.randomBytesHex)(16), this._secret = n || (0, AO.randomBytesHex)(32), this._key = new CO.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex"), this._linked = !!i;
  }
  static load(e) {
    const t = e.getItem(IO), n = e.getItem(TO), i = e.getItem(RO);
    return t && i ? new eA(e, t, i, n === "1") : null;
  }
  /**
   * Takes in a session ID and returns the sha256 hash of it.
   * @param sessionId session ID
   */
  static hash(e) {
    return new CO.sha256().update(e).digest("hex");
  }
  get id() {
    return this._id;
  }
  get secret() {
    return this._secret;
  }
  get key() {
    return this._key;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    this._linked = e, this.persistLinked();
  }
  save() {
    return this._storage.setItem(IO, this._id), this._storage.setItem(RO, this._secret), this.persistLinked(), this;
  }
  persistLinked() {
    this._storage.setItem(TO, this._linked ? "1" : "0");
  }
}
Kg.Session = eA;
var Aa = {};
Object.defineProperty(Aa, "__esModule", { value: !0 });
Aa.WalletSDKRelayAbstract = Aa.APP_VERSION_KEY = Aa.LOCAL_STORAGE_ADDRESSES_KEY = Aa.WALLET_USER_NAME_KEY = void 0;
const OO = wy;
Aa.WALLET_USER_NAME_KEY = "walletUsername";
Aa.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
Aa.APP_VERSION_KEY = "AppVersion";
class _me {
  async makeEthereumJSONRPCRequest(e, t) {
    if (!t)
      throw new Error("Error: No jsonRpcUrl provided");
    return window.fetch(t, {
      method: "POST",
      body: JSON.stringify(e),
      mode: "cors",
      headers: { "Content-Type": "application/json" }
    }).then((n) => n.json()).then((n) => {
      if (!n)
        throw OO.standardErrors.rpc.parse({});
      const i = n, { error: s } = i;
      if (s)
        throw (0, OO.serializeError)(s, e.method);
      return i;
    });
  }
}
Aa.WalletSDKRelayAbstract = _me;
var nS = { exports: {} }, ZL = Wi.EventEmitter, H4, NO;
function Eme() {
  if (NO)
    return H4;
  NO = 1;
  function r(b, I) {
    var k = Object.keys(b);
    if (Object.getOwnPropertySymbols) {
      var R = Object.getOwnPropertySymbols(b);
      I && (R = R.filter(function(T) {
        return Object.getOwnPropertyDescriptor(b, T).enumerable;
      })), k.push.apply(k, R);
    }
    return k;
  }
  function e(b) {
    for (var I = 1; I < arguments.length; I++) {
      var k = arguments[I] != null ? arguments[I] : {};
      I % 2 ? r(Object(k), !0).forEach(function(R) {
        t(b, R, k[R]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(k)) : r(Object(k)).forEach(function(R) {
        Object.defineProperty(b, R, Object.getOwnPropertyDescriptor(k, R));
      });
    }
    return b;
  }
  function t(b, I, k) {
    return I = o(I), I in b ? Object.defineProperty(b, I, { value: k, enumerable: !0, configurable: !0, writable: !0 }) : b[I] = k, b;
  }
  function n(b, I) {
    if (!(b instanceof I))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(b, I) {
    for (var k = 0; k < I.length; k++) {
      var R = I[k];
      R.enumerable = R.enumerable || !1, R.configurable = !0, "value" in R && (R.writable = !0), Object.defineProperty(b, o(R.key), R);
    }
  }
  function s(b, I, k) {
    return I && i(b.prototype, I), k && i(b, k), Object.defineProperty(b, "prototype", { writable: !1 }), b;
  }
  function o(b) {
    var I = a(b, "string");
    return typeof I == "symbol" ? I : String(I);
  }
  function a(b, I) {
    if (typeof b != "object" || b === null)
      return b;
    var k = b[Symbol.toPrimitive];
    if (k !== void 0) {
      var R = k.call(b, I || "default");
      if (typeof R != "object")
        return R;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (I === "string" ? String : Number)(b);
  }
  var c = Vg, u = c.Buffer, f = sy, d = f.inspect, m = d && d.custom || "inspect";
  function y(b, I, k) {
    u.prototype.copy.call(b, I, k);
  }
  return H4 = /* @__PURE__ */ function() {
    function b() {
      n(this, b), this.head = null, this.tail = null, this.length = 0;
    }
    return s(b, [{
      key: "push",
      value: function(k) {
        var R = {
          data: k,
          next: null
        };
        this.length > 0 ? this.tail.next = R : this.head = R, this.tail = R, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(k) {
        var R = {
          data: k,
          next: this.head
        };
        this.length === 0 && (this.tail = R), this.head = R, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var k = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, k;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(k) {
        if (this.length === 0)
          return "";
        for (var R = this.head, T = "" + R.data; R = R.next; )
          T += k + R.data;
        return T;
      }
    }, {
      key: "concat",
      value: function(k) {
        if (this.length === 0)
          return u.alloc(0);
        for (var R = u.allocUnsafe(k >>> 0), T = this.head, $ = 0; T; )
          y(T.data, R, $), $ += T.data.length, T = T.next;
        return R;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(k, R) {
        var T;
        return k < this.head.data.length ? (T = this.head.data.slice(0, k), this.head.data = this.head.data.slice(k)) : k === this.head.data.length ? T = this.shift() : T = R ? this._getString(k) : this._getBuffer(k), T;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(k) {
        var R = this.head, T = 1, $ = R.data;
        for (k -= $.length; R = R.next; ) {
          var D = R.data, L = k > D.length ? D.length : k;
          if (L === D.length ? $ += D : $ += D.slice(0, k), k -= L, k === 0) {
            L === D.length ? (++T, R.next ? this.head = R.next : this.head = this.tail = null) : (this.head = R, R.data = D.slice(L));
            break;
          }
          ++T;
        }
        return this.length -= T, $;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(k) {
        var R = u.allocUnsafe(k), T = this.head, $ = 1;
        for (T.data.copy(R), k -= T.data.length; T = T.next; ) {
          var D = T.data, L = k > D.length ? D.length : k;
          if (D.copy(R, R.length - k, 0, L), k -= L, k === 0) {
            L === D.length ? (++$, T.next ? this.head = T.next : this.head = this.tail = null) : (this.head = T, T.data = D.slice(L));
            break;
          }
          ++$;
        }
        return this.length -= $, R;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: m,
      value: function(k, R) {
        return d(this, e(e({}, R), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), b;
  }(), H4;
}
function xme(r, e) {
  var t = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
  return n || i ? (e ? e(r) : r && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(iS, this, r)) : process.nextTick(iS, this, r)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(r || null, function(s) {
    !e && s ? t._writableState ? t._writableState.errorEmitted ? process.nextTick(Vb, t) : (t._writableState.errorEmitted = !0, process.nextTick(PO, t, s)) : process.nextTick(PO, t, s) : e ? (process.nextTick(Vb, t), e(s)) : process.nextTick(Vb, t);
  }), this);
}
function PO(r, e) {
  iS(r, e), Vb(r);
}
function Vb(r) {
  r._writableState && !r._writableState.emitClose || r._readableState && !r._readableState.emitClose || r.emit("close");
}
function Sme() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function iS(r, e) {
  r.emit("error", e);
}
function Cme(r, e) {
  var t = r._readableState, n = r._writableState;
  t && t.autoDestroy || n && n.autoDestroy ? r.destroy(e) : r.emit("error", e);
}
var JL = {
  destroy: xme,
  undestroy: Sme,
  errorOrDestroy: Cme
}, Fd = {};
function Ame(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e;
}
var QL = {};
function zo(r, e, t) {
  t || (t = Error);
  function n(s, o, a) {
    return typeof e == "string" ? e : e(s, o, a);
  }
  var i = /* @__PURE__ */ function(s) {
    Ame(o, s);
    function o(a, c, u) {
      return s.call(this, n(a, c, u)) || this;
    }
    return o;
  }(t);
  i.prototype.name = t.name, i.prototype.code = r, QL[r] = i;
}
function MO(r, e) {
  if (Array.isArray(r)) {
    var t = r.length;
    return r = r.map(function(n) {
      return String(n);
    }), t > 2 ? "one of ".concat(e, " ").concat(r.slice(0, t - 1).join(", "), ", or ") + r[t - 1] : t === 2 ? "one of ".concat(e, " ").concat(r[0], " or ").concat(r[1]) : "of ".concat(e, " ").concat(r[0]);
  } else
    return "of ".concat(e, " ").concat(String(r));
}
function Ime(r, e, t) {
  return r.substr(!t || t < 0 ? 0 : +t, e.length) === e;
}
function Rme(r, e, t) {
  return (t === void 0 || t > r.length) && (t = r.length), r.substring(t - e.length, t) === e;
}
function Tme(r, e, t) {
  return typeof t != "number" && (t = 0), t + e.length > r.length ? !1 : r.indexOf(e, t) !== -1;
}
zo("ERR_INVALID_OPT_VALUE", function(r, e) {
  return 'The value "' + e + '" is invalid for option "' + r + '"';
}, TypeError);
zo("ERR_INVALID_ARG_TYPE", function(r, e, t) {
  var n;
  typeof e == "string" && Ime(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
  var i;
  if (Rme(r, " argument"))
    i = "The ".concat(r, " ").concat(n, " ").concat(MO(e, "type"));
  else {
    var s = Tme(r, ".") ? "property" : "argument";
    i = 'The "'.concat(r, '" ').concat(s, " ").concat(n, " ").concat(MO(e, "type"));
  }
  return i += ". Received type ".concat(typeof t), i;
}, TypeError);
zo("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
zo("ERR_METHOD_NOT_IMPLEMENTED", function(r) {
  return "The " + r + " method is not implemented";
});
zo("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
zo("ERR_STREAM_DESTROYED", function(r) {
  return "Cannot call " + r + " after a stream was destroyed";
});
zo("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
zo("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
zo("ERR_STREAM_WRITE_AFTER_END", "write after end");
zo("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
zo("ERR_UNKNOWN_ENCODING", function(r) {
  return "Unknown encoding: " + r;
}, TypeError);
zo("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Fd.codes = QL;
var Ome = Fd.codes.ERR_INVALID_OPT_VALUE;
function Nme(r, e, t) {
  return r.highWaterMark != null ? r.highWaterMark : e ? r[t] : null;
}
function Pme(r, e, t, n) {
  var i = Nme(e, n, t);
  if (i != null) {
    if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
      var s = n ? t : "highWaterMark";
      throw new Ome(s, i);
    }
    return Math.floor(i);
  }
  return r.objectMode ? 16 : 16 * 1024;
}
var YL = {
  getHighWaterMark: Pme
}, Mme = Dme;
function Dme(r, e) {
  if (z4("noDeprecation"))
    return r;
  var t = !1;
  function n() {
    if (!t) {
      if (z4("throwDeprecation"))
        throw new Error(e);
      z4("traceDeprecation") ? console.trace(e) : console.warn(e), t = !0;
    }
    return r.apply(this, arguments);
  }
  return n;
}
function z4(r) {
  try {
    if (!ze.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var e = ze.localStorage[r];
  return e == null ? !1 : String(e).toLowerCase() === "true";
}
var V4, DO;
function XL() {
  if (DO)
    return V4;
  DO = 1, V4 = F;
  function r(ne) {
    var K = this;
    this.next = null, this.entry = null, this.finish = function() {
      ve(K, ne);
    };
  }
  var e;
  F.WritableState = P;
  var t = {
    deprecate: Mme
  }, n = ZL, i = Vg.Buffer, s = (typeof ze < "u" ? ze : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(ne) {
    return i.from(ne);
  }
  function a(ne) {
    return i.isBuffer(ne) || ne instanceof s;
  }
  var c = JL, u = YL, f = u.getHighWaterMark, d = Fd.codes, m = d.ERR_INVALID_ARG_TYPE, y = d.ERR_METHOD_NOT_IMPLEMENTED, b = d.ERR_MULTIPLE_CALLBACK, I = d.ERR_STREAM_CANNOT_PIPE, k = d.ERR_STREAM_DESTROYED, R = d.ERR_STREAM_NULL_VALUES, T = d.ERR_STREAM_WRITE_AFTER_END, $ = d.ERR_UNKNOWN_ENCODING, D = c.errorOrDestroy;
  ja(F, n);
  function L() {
  }
  function P(ne, K, Y) {
    e = e || Sg(), ne = ne || {}, typeof Y != "boolean" && (Y = K instanceof e), this.objectMode = !!ne.objectMode, Y && (this.objectMode = this.objectMode || !!ne.writableObjectMode), this.highWaterMark = f(this, ne, "writableHighWaterMark", Y), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ee = ne.decodeStrings === !1;
    this.decodeStrings = !ee, this.defaultEncoding = ne.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(S) {
      x(K, S);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ne.emitClose !== !1, this.autoDestroy = !!ne.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new r(this);
  }
  P.prototype.getBuffer = function() {
    for (var K = this.bufferedRequest, Y = []; K; )
      Y.push(K), K = K.next;
    return Y;
  }, function() {
    try {
      Object.defineProperty(P.prototype, "buffer", {
        get: t.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var v;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (v = Function.prototype[Symbol.hasInstance], Object.defineProperty(F, Symbol.hasInstance, {
    value: function(K) {
      return v.call(this, K) ? !0 : this !== F ? !1 : K && K._writableState instanceof P;
    }
  })) : v = function(K) {
    return K instanceof this;
  };
  function F(ne) {
    e = e || Sg();
    var K = this instanceof e;
    if (!K && !v.call(F, this))
      return new F(ne);
    this._writableState = new P(ne, this, K), this.writable = !0, ne && (typeof ne.write == "function" && (this._write = ne.write), typeof ne.writev == "function" && (this._writev = ne.writev), typeof ne.destroy == "function" && (this._destroy = ne.destroy), typeof ne.final == "function" && (this._final = ne.final)), n.call(this);
  }
  F.prototype.pipe = function() {
    D(this, new I());
  };
  function X(ne, K) {
    var Y = new T();
    D(ne, Y), process.nextTick(K, Y);
  }
  function te(ne, K, Y, ee) {
    var S;
    return Y === null ? S = new R() : typeof Y != "string" && !K.objectMode && (S = new m("chunk", ["string", "Buffer"], Y)), S ? (D(ne, S), process.nextTick(ee, S), !1) : !0;
  }
  F.prototype.write = function(ne, K, Y) {
    var ee = this._writableState, S = !1, M = !ee.objectMode && a(ne);
    return M && !i.isBuffer(ne) && (ne = o(ne)), typeof K == "function" && (Y = K, K = null), M ? K = "buffer" : K || (K = ee.defaultEncoding), typeof Y != "function" && (Y = L), ee.ending ? X(this, Y) : (M || te(this, ee, ne, Y)) && (ee.pendingcb++, S = we(this, ee, M, ne, K, Y)), S;
  }, F.prototype.cork = function() {
    this._writableState.corked++;
  }, F.prototype.uncork = function() {
    var ne = this._writableState;
    ne.corked && (ne.corked--, !ne.writing && !ne.corked && !ne.bufferProcessing && ne.bufferedRequest && U(this, ne));
  }, F.prototype.setDefaultEncoding = function(K) {
    if (typeof K == "string" && (K = K.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((K + "").toLowerCase()) > -1))
      throw new $(K);
    return this._writableState.defaultEncoding = K, this;
  }, Object.defineProperty(F.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function se(ne, K, Y) {
    return !ne.objectMode && ne.decodeStrings !== !1 && typeof K == "string" && (K = i.from(K, Y)), K;
  }
  Object.defineProperty(F.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function we(ne, K, Y, ee, S, M) {
    if (!Y) {
      var G = se(K, ee, S);
      ee !== G && (Y = !0, S = "buffer", ee = G);
    }
    var ue = K.objectMode ? 1 : ee.length;
    K.length += ue;
    var Ee = K.length < K.highWaterMark;
    if (Ee || (K.needDrain = !0), K.writing || K.corked) {
      var Le = K.lastBufferedRequest;
      K.lastBufferedRequest = {
        chunk: ee,
        encoding: S,
        isBuf: Y,
        callback: M,
        next: null
      }, Le ? Le.next = K.lastBufferedRequest : K.bufferedRequest = K.lastBufferedRequest, K.bufferedRequestCount += 1;
    } else
      H(ne, K, !1, ue, ee, S, M);
    return Ee;
  }
  function H(ne, K, Y, ee, S, M, G) {
    K.writelen = ee, K.writecb = G, K.writing = !0, K.sync = !0, K.destroyed ? K.onwrite(new k("write")) : Y ? ne._writev(S, K.onwrite) : ne._write(S, M, K.onwrite), K.sync = !1;
  }
  function p(ne, K, Y, ee, S) {
    --K.pendingcb, Y ? (process.nextTick(S, ee), process.nextTick(V, ne, K), ne._writableState.errorEmitted = !0, D(ne, ee)) : (S(ee), ne._writableState.errorEmitted = !0, D(ne, ee), V(ne, K));
  }
  function w(ne) {
    ne.writing = !1, ne.writecb = null, ne.length -= ne.writelen, ne.writelen = 0;
  }
  function x(ne, K) {
    var Y = ne._writableState, ee = Y.sync, S = Y.writecb;
    if (typeof S != "function")
      throw new b();
    if (w(Y), K)
      p(ne, Y, ee, K, S);
    else {
      var M = q(Y) || ne.destroyed;
      !M && !Y.corked && !Y.bufferProcessing && Y.bufferedRequest && U(ne, Y), ee ? process.nextTick(N, ne, Y, M, S) : N(ne, Y, M, S);
    }
  }
  function N(ne, K, Y, ee) {
    Y || O(ne, K), K.pendingcb--, ee(), V(ne, K);
  }
  function O(ne, K) {
    K.length === 0 && K.needDrain && (K.needDrain = !1, ne.emit("drain"));
  }
  function U(ne, K) {
    K.bufferProcessing = !0;
    var Y = K.bufferedRequest;
    if (ne._writev && Y && Y.next) {
      var ee = K.bufferedRequestCount, S = new Array(ee), M = K.corkedRequestsFree;
      M.entry = Y;
      for (var G = 0, ue = !0; Y; )
        S[G] = Y, Y.isBuf || (ue = !1), Y = Y.next, G += 1;
      S.allBuffers = ue, H(ne, K, !0, K.length, S, "", M.finish), K.pendingcb++, K.lastBufferedRequest = null, M.next ? (K.corkedRequestsFree = M.next, M.next = null) : K.corkedRequestsFree = new r(K), K.bufferedRequestCount = 0;
    } else {
      for (; Y; ) {
        var Ee = Y.chunk, Le = Y.encoding, Fe = Y.callback, De = K.objectMode ? 1 : Ee.length;
        if (H(ne, K, !1, De, Ee, Le, Fe), Y = Y.next, K.bufferedRequestCount--, K.writing)
          break;
      }
      Y === null && (K.lastBufferedRequest = null);
    }
    K.bufferedRequest = Y, K.bufferProcessing = !1;
  }
  F.prototype._write = function(ne, K, Y) {
    Y(new y("_write()"));
  }, F.prototype._writev = null, F.prototype.end = function(ne, K, Y) {
    var ee = this._writableState;
    return typeof ne == "function" ? (Y = ne, ne = null, K = null) : typeof K == "function" && (Y = K, K = null), ne != null && this.write(ne, K), ee.corked && (ee.corked = 1, this.uncork()), ee.ending || be(this, ee, Y), this;
  }, Object.defineProperty(F.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function q(ne) {
    return ne.ending && ne.length === 0 && ne.bufferedRequest === null && !ne.finished && !ne.writing;
  }
  function B(ne, K) {
    ne._final(function(Y) {
      K.pendingcb--, Y && D(ne, Y), K.prefinished = !0, ne.emit("prefinish"), V(ne, K);
    });
  }
  function E(ne, K) {
    !K.prefinished && !K.finalCalled && (typeof ne._final == "function" && !K.destroyed ? (K.pendingcb++, K.finalCalled = !0, process.nextTick(B, ne, K)) : (K.prefinished = !0, ne.emit("prefinish")));
  }
  function V(ne, K) {
    var Y = q(K);
    if (Y && (E(ne, K), K.pendingcb === 0 && (K.finished = !0, ne.emit("finish"), K.autoDestroy))) {
      var ee = ne._readableState;
      (!ee || ee.autoDestroy && ee.endEmitted) && ne.destroy();
    }
    return Y;
  }
  function be(ne, K, Y) {
    K.ending = !0, V(ne, K), Y && (K.finished ? process.nextTick(Y) : ne.once("finish", Y)), K.ended = !0, ne.writable = !1;
  }
  function ve(ne, K, Y) {
    var ee = ne.entry;
    for (ne.entry = null; ee; ) {
      var S = ee.callback;
      K.pendingcb--, S(Y), ee = ee.next;
    }
    K.corkedRequestsFree.next = ne;
  }
  return Object.defineProperty(F.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(K) {
      this._writableState && (this._writableState.destroyed = K);
    }
  }), F.prototype.destroy = c.destroy, F.prototype._undestroy = c.undestroy, F.prototype._destroy = function(ne, K) {
    K(ne);
  }, V4;
}
var q4, kO;
function Sg() {
  if (kO)
    return q4;
  kO = 1;
  var r = Object.keys || function(u) {
    var f = [];
    for (var d in u)
      f.push(d);
    return f;
  };
  q4 = o;
  var e = tB(), t = XL();
  ja(o, e);
  for (var n = r(t.prototype), i = 0; i < n.length; i++) {
    var s = n[i];
    o.prototype[s] || (o.prototype[s] = t.prototype[s]);
  }
  function o(u) {
    if (!(this instanceof o))
      return new o(u);
    e.call(this, u), t.call(this, u), this.allowHalfOpen = !0, u && (u.readable === !1 && (this.readable = !1), u.writable === !1 && (this.writable = !1), u.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function a() {
    this._writableState.ended || process.nextTick(c, this);
  }
  function c(u) {
    u.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(f) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = f, this._writableState.destroyed = f);
    }
  }), q4;
}
var G4 = {}, $O;
function LO() {
  if ($O)
    return G4;
  $O = 1;
  var r = wh.Buffer, e = r.isEncoding || function(R) {
    switch (R = "" + R, R && R.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function t(R) {
    if (!R)
      return "utf8";
    for (var T; ; )
      switch (R) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return R;
        default:
          if (T)
            return;
          R = ("" + R).toLowerCase(), T = !0;
      }
  }
  function n(R) {
    var T = t(R);
    if (typeof T != "string" && (r.isEncoding === e || !e(R)))
      throw new Error("Unknown encoding: " + R);
    return T || R;
  }
  G4.StringDecoder = i;
  function i(R) {
    this.encoding = n(R);
    var T;
    switch (this.encoding) {
      case "utf16le":
        this.text = d, this.end = m, T = 4;
        break;
      case "utf8":
        this.fillLast = c, T = 4;
        break;
      case "base64":
        this.text = y, this.end = b, T = 3;
        break;
      default:
        this.write = I, this.end = k;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(T);
  }
  i.prototype.write = function(R) {
    if (R.length === 0)
      return "";
    var T, $;
    if (this.lastNeed) {
      if (T = this.fillLast(R), T === void 0)
        return "";
      $ = this.lastNeed, this.lastNeed = 0;
    } else
      $ = 0;
    return $ < R.length ? T ? T + this.text(R, $) : this.text(R, $) : T || "";
  }, i.prototype.end = f, i.prototype.text = u, i.prototype.fillLast = function(R) {
    if (this.lastNeed <= R.length)
      return R.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    R.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, R.length), this.lastNeed -= R.length;
  };
  function s(R) {
    return R <= 127 ? 0 : R >> 5 === 6 ? 2 : R >> 4 === 14 ? 3 : R >> 3 === 30 ? 4 : R >> 6 === 2 ? -1 : -2;
  }
  function o(R, T, $) {
    var D = T.length - 1;
    if (D < $)
      return 0;
    var L = s(T[D]);
    return L >= 0 ? (L > 0 && (R.lastNeed = L - 1), L) : --D < $ || L === -2 ? 0 : (L = s(T[D]), L >= 0 ? (L > 0 && (R.lastNeed = L - 2), L) : --D < $ || L === -2 ? 0 : (L = s(T[D]), L >= 0 ? (L > 0 && (L === 2 ? L = 0 : R.lastNeed = L - 3), L) : 0));
  }
  function a(R, T, $) {
    if ((T[0] & 192) !== 128)
      return R.lastNeed = 0, "";
    if (R.lastNeed > 1 && T.length > 1) {
      if ((T[1] & 192) !== 128)
        return R.lastNeed = 1, "";
      if (R.lastNeed > 2 && T.length > 2 && (T[2] & 192) !== 128)
        return R.lastNeed = 2, "";
    }
  }
  function c(R) {
    var T = this.lastTotal - this.lastNeed, $ = a(this, R);
    if ($ !== void 0)
      return $;
    if (this.lastNeed <= R.length)
      return R.copy(this.lastChar, T, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    R.copy(this.lastChar, T, 0, R.length), this.lastNeed -= R.length;
  }
  function u(R, T) {
    var $ = o(this, R, T);
    if (!this.lastNeed)
      return R.toString("utf8", T);
    this.lastTotal = $;
    var D = R.length - ($ - this.lastNeed);
    return R.copy(this.lastChar, 0, D), R.toString("utf8", T, D);
  }
  function f(R) {
    var T = R && R.length ? this.write(R) : "";
    return this.lastNeed ? T + "" : T;
  }
  function d(R, T) {
    if ((R.length - T) % 2 === 0) {
      var $ = R.toString("utf16le", T);
      if ($) {
        var D = $.charCodeAt($.length - 1);
        if (D >= 55296 && D <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = R[R.length - 2], this.lastChar[1] = R[R.length - 1], $.slice(0, -1);
      }
      return $;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = R[R.length - 1], R.toString("utf16le", T, R.length - 1);
  }
  function m(R) {
    var T = R && R.length ? this.write(R) : "";
    if (this.lastNeed) {
      var $ = this.lastTotal - this.lastNeed;
      return T + this.lastChar.toString("utf16le", 0, $);
    }
    return T;
  }
  function y(R, T) {
    var $ = (R.length - T) % 3;
    return $ === 0 ? R.toString("base64", T) : (this.lastNeed = 3 - $, this.lastTotal = 3, $ === 1 ? this.lastChar[0] = R[R.length - 1] : (this.lastChar[0] = R[R.length - 2], this.lastChar[1] = R[R.length - 1]), R.toString("base64", T, R.length - $));
  }
  function b(R) {
    var T = R && R.length ? this.write(R) : "";
    return this.lastNeed ? T + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : T;
  }
  function I(R) {
    return R.toString(this.encoding);
  }
  function k(R) {
    return R && R.length ? this.write(R) : "";
  }
  return G4;
}
var BO = Fd.codes.ERR_STREAM_PREMATURE_CLOSE;
function kme(r) {
  var e = !1;
  return function() {
    if (!e) {
      e = !0;
      for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
        n[i] = arguments[i];
      r.apply(this, n);
    }
  };
}
function $me() {
}
function Lme(r) {
  return r.setHeader && typeof r.abort == "function";
}
function eB(r, e, t) {
  if (typeof e == "function")
    return eB(r, null, e);
  e || (e = {}), t = kme(t || $me);
  var n = e.readable || e.readable !== !1 && r.readable, i = e.writable || e.writable !== !1 && r.writable, s = function() {
    r.writable || a();
  }, o = r._writableState && r._writableState.finished, a = function() {
    i = !1, o = !0, n || t.call(r);
  }, c = r._readableState && r._readableState.endEmitted, u = function() {
    n = !1, c = !0, i || t.call(r);
  }, f = function(b) {
    t.call(r, b);
  }, d = function() {
    var b;
    if (n && !c)
      return (!r._readableState || !r._readableState.ended) && (b = new BO()), t.call(r, b);
    if (i && !o)
      return (!r._writableState || !r._writableState.ended) && (b = new BO()), t.call(r, b);
  }, m = function() {
    r.req.on("finish", a);
  };
  return Lme(r) ? (r.on("complete", a), r.on("abort", d), r.req ? m() : r.on("request", m)) : i && !r._writableState && (r.on("end", s), r.on("close", s)), r.on("end", u), r.on("finish", a), e.error !== !1 && r.on("error", f), r.on("close", d), function() {
    r.removeListener("complete", a), r.removeListener("abort", d), r.removeListener("request", m), r.req && r.req.removeListener("finish", a), r.removeListener("end", s), r.removeListener("close", s), r.removeListener("finish", a), r.removeListener("end", u), r.removeListener("error", f), r.removeListener("close", d);
  };
}
var tA = eB, K4, FO;
function Bme() {
  if (FO)
    return K4;
  FO = 1;
  var r;
  function e($, D, L) {
    return D = t(D), D in $ ? Object.defineProperty($, D, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : $[D] = L, $;
  }
  function t($) {
    var D = n($, "string");
    return typeof D == "symbol" ? D : String(D);
  }
  function n($, D) {
    if (typeof $ != "object" || $ === null)
      return $;
    var L = $[Symbol.toPrimitive];
    if (L !== void 0) {
      var P = L.call($, D || "default");
      if (typeof P != "object")
        return P;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (D === "string" ? String : Number)($);
  }
  var i = tA, s = Symbol("lastResolve"), o = Symbol("lastReject"), a = Symbol("error"), c = Symbol("ended"), u = Symbol("lastPromise"), f = Symbol("handlePromise"), d = Symbol("stream");
  function m($, D) {
    return {
      value: $,
      done: D
    };
  }
  function y($) {
    var D = $[s];
    if (D !== null) {
      var L = $[d].read();
      L !== null && ($[u] = null, $[s] = null, $[o] = null, D(m(L, !1)));
    }
  }
  function b($) {
    process.nextTick(y, $);
  }
  function I($, D) {
    return function(L, P) {
      $.then(function() {
        if (D[c]) {
          L(m(void 0, !0));
          return;
        }
        D[f](L, P);
      }, P);
    };
  }
  var k = Object.getPrototypeOf(function() {
  }), R = Object.setPrototypeOf((r = {
    get stream() {
      return this[d];
    },
    next: function() {
      var D = this, L = this[a];
      if (L !== null)
        return Promise.reject(L);
      if (this[c])
        return Promise.resolve(m(void 0, !0));
      if (this[d].destroyed)
        return new Promise(function(X, te) {
          process.nextTick(function() {
            D[a] ? te(D[a]) : X(m(void 0, !0));
          });
        });
      var P = this[u], v;
      if (P)
        v = new Promise(I(P, this));
      else {
        var F = this[d].read();
        if (F !== null)
          return Promise.resolve(m(F, !1));
        v = new Promise(this[f]);
      }
      return this[u] = v, v;
    }
  }, e(r, Symbol.asyncIterator, function() {
    return this;
  }), e(r, "return", function() {
    var D = this;
    return new Promise(function(L, P) {
      D[d].destroy(null, function(v) {
        if (v) {
          P(v);
          return;
        }
        L(m(void 0, !0));
      });
    });
  }), r), k), T = function(D) {
    var L, P = Object.create(R, (L = {}, e(L, d, {
      value: D,
      writable: !0
    }), e(L, s, {
      value: null,
      writable: !0
    }), e(L, o, {
      value: null,
      writable: !0
    }), e(L, a, {
      value: null,
      writable: !0
    }), e(L, c, {
      value: D._readableState.endEmitted,
      writable: !0
    }), e(L, f, {
      value: function(F, X) {
        var te = P[d].read();
        te ? (P[u] = null, P[s] = null, P[o] = null, F(m(te, !1))) : (P[s] = F, P[o] = X);
      },
      writable: !0
    }), L));
    return P[u] = null, i(D, function(v) {
      if (v && v.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var F = P[o];
        F !== null && (P[u] = null, P[s] = null, P[o] = null, F(v)), P[a] = v;
        return;
      }
      var X = P[s];
      X !== null && (P[u] = null, P[s] = null, P[o] = null, X(m(void 0, !0))), P[c] = !0;
    }), D.on("readable", b.bind(null, P)), P;
  };
  return K4 = T, K4;
}
var Z4, UO;
function Fme() {
  return UO || (UO = 1, Z4 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Z4;
}
var J4, jO;
function tB() {
  if (jO)
    return J4;
  jO = 1, J4 = X;
  var r;
  X.ReadableState = F, Wi.EventEmitter;
  var e = function(G, ue) {
    return G.listeners(ue).length;
  }, t = ZL, n = Vg.Buffer, i = (typeof ze < "u" ? ze : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(M) {
    return n.from(M);
  }
  function o(M) {
    return n.isBuffer(M) || M instanceof i;
  }
  var a = sy, c;
  a && a.debuglog ? c = a.debuglog("stream") : c = function() {
  };
  var u = Eme(), f = JL, d = YL, m = d.getHighWaterMark, y = Fd.codes, b = y.ERR_INVALID_ARG_TYPE, I = y.ERR_STREAM_PUSH_AFTER_EOF, k = y.ERR_METHOD_NOT_IMPLEMENTED, R = y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, T, $, D;
  ja(X, t);
  var L = f.errorOrDestroy, P = ["error", "close", "destroy", "pause", "resume"];
  function v(M, G, ue) {
    if (typeof M.prependListener == "function")
      return M.prependListener(G, ue);
    !M._events || !M._events[G] ? M.on(G, ue) : Array.isArray(M._events[G]) ? M._events[G].unshift(ue) : M._events[G] = [ue, M._events[G]];
  }
  function F(M, G, ue) {
    r = r || Sg(), M = M || {}, typeof ue != "boolean" && (ue = G instanceof r), this.objectMode = !!M.objectMode, ue && (this.objectMode = this.objectMode || !!M.readableObjectMode), this.highWaterMark = m(this, M, "readableHighWaterMark", ue), this.buffer = new u(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = M.emitClose !== !1, this.autoDestroy = !!M.autoDestroy, this.destroyed = !1, this.defaultEncoding = M.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, M.encoding && (T || (T = LO().StringDecoder), this.decoder = new T(M.encoding), this.encoding = M.encoding);
  }
  function X(M) {
    if (r = r || Sg(), !(this instanceof X))
      return new X(M);
    var G = this instanceof r;
    this._readableState = new F(M, this, G), this.readable = !0, M && (typeof M.read == "function" && (this._read = M.read), typeof M.destroy == "function" && (this._destroy = M.destroy)), t.call(this);
  }
  Object.defineProperty(X.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(G) {
      this._readableState && (this._readableState.destroyed = G);
    }
  }), X.prototype.destroy = f.destroy, X.prototype._undestroy = f.undestroy, X.prototype._destroy = function(M, G) {
    G(M);
  }, X.prototype.push = function(M, G) {
    var ue = this._readableState, Ee;
    return ue.objectMode ? Ee = !0 : typeof M == "string" && (G = G || ue.defaultEncoding, G !== ue.encoding && (M = n.from(M, G), G = ""), Ee = !0), te(this, M, G, !1, Ee);
  }, X.prototype.unshift = function(M) {
    return te(this, M, null, !0, !1);
  };
  function te(M, G, ue, Ee, Le) {
    c("readableAddChunk", G);
    var Fe = M._readableState;
    if (G === null)
      Fe.reading = !1, x(M, Fe);
    else {
      var De;
      if (Le || (De = we(Fe, G)), De)
        L(M, De);
      else if (Fe.objectMode || G && G.length > 0)
        if (typeof G != "string" && !Fe.objectMode && Object.getPrototypeOf(G) !== n.prototype && (G = s(G)), Ee)
          Fe.endEmitted ? L(M, new R()) : se(M, Fe, G, !0);
        else if (Fe.ended)
          L(M, new I());
        else {
          if (Fe.destroyed)
            return !1;
          Fe.reading = !1, Fe.decoder && !ue ? (G = Fe.decoder.write(G), Fe.objectMode || G.length !== 0 ? se(M, Fe, G, !1) : U(M, Fe)) : se(M, Fe, G, !1);
        }
      else
        Ee || (Fe.reading = !1, U(M, Fe));
    }
    return !Fe.ended && (Fe.length < Fe.highWaterMark || Fe.length === 0);
  }
  function se(M, G, ue, Ee) {
    G.flowing && G.length === 0 && !G.sync ? (G.awaitDrain = 0, M.emit("data", ue)) : (G.length += G.objectMode ? 1 : ue.length, Ee ? G.buffer.unshift(ue) : G.buffer.push(ue), G.needReadable && N(M)), U(M, G);
  }
  function we(M, G) {
    var ue;
    return !o(G) && typeof G != "string" && G !== void 0 && !M.objectMode && (ue = new b("chunk", ["string", "Buffer", "Uint8Array"], G)), ue;
  }
  X.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, X.prototype.setEncoding = function(M) {
    T || (T = LO().StringDecoder);
    var G = new T(M);
    this._readableState.decoder = G, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ue = this._readableState.buffer.head, Ee = ""; ue !== null; )
      Ee += G.write(ue.data), ue = ue.next;
    return this._readableState.buffer.clear(), Ee !== "" && this._readableState.buffer.push(Ee), this._readableState.length = Ee.length, this;
  };
  var H = 1073741824;
  function p(M) {
    return M >= H ? M = H : (M--, M |= M >>> 1, M |= M >>> 2, M |= M >>> 4, M |= M >>> 8, M |= M >>> 16, M++), M;
  }
  function w(M, G) {
    return M <= 0 || G.length === 0 && G.ended ? 0 : G.objectMode ? 1 : M !== M ? G.flowing && G.length ? G.buffer.head.data.length : G.length : (M > G.highWaterMark && (G.highWaterMark = p(M)), M <= G.length ? M : G.ended ? G.length : (G.needReadable = !0, 0));
  }
  X.prototype.read = function(M) {
    c("read", M), M = parseInt(M, 10);
    var G = this._readableState, ue = M;
    if (M !== 0 && (G.emittedReadable = !1), M === 0 && G.needReadable && ((G.highWaterMark !== 0 ? G.length >= G.highWaterMark : G.length > 0) || G.ended))
      return c("read: emitReadable", G.length, G.ended), G.length === 0 && G.ended ? Y(this) : N(this), null;
    if (M = w(M, G), M === 0 && G.ended)
      return G.length === 0 && Y(this), null;
    var Ee = G.needReadable;
    c("need readable", Ee), (G.length === 0 || G.length - M < G.highWaterMark) && (Ee = !0, c("length less than watermark", Ee)), G.ended || G.reading ? (Ee = !1, c("reading or ended", Ee)) : Ee && (c("do read"), G.reading = !0, G.sync = !0, G.length === 0 && (G.needReadable = !0), this._read(G.highWaterMark), G.sync = !1, G.reading || (M = w(ue, G)));
    var Le;
    return M > 0 ? Le = K(M, G) : Le = null, Le === null ? (G.needReadable = G.length <= G.highWaterMark, M = 0) : (G.length -= M, G.awaitDrain = 0), G.length === 0 && (G.ended || (G.needReadable = !0), ue !== M && G.ended && Y(this)), Le !== null && this.emit("data", Le), Le;
  };
  function x(M, G) {
    if (c("onEofChunk"), !G.ended) {
      if (G.decoder) {
        var ue = G.decoder.end();
        ue && ue.length && (G.buffer.push(ue), G.length += G.objectMode ? 1 : ue.length);
      }
      G.ended = !0, G.sync ? N(M) : (G.needReadable = !1, G.emittedReadable || (G.emittedReadable = !0, O(M)));
    }
  }
  function N(M) {
    var G = M._readableState;
    c("emitReadable", G.needReadable, G.emittedReadable), G.needReadable = !1, G.emittedReadable || (c("emitReadable", G.flowing), G.emittedReadable = !0, process.nextTick(O, M));
  }
  function O(M) {
    var G = M._readableState;
    c("emitReadable_", G.destroyed, G.length, G.ended), !G.destroyed && (G.length || G.ended) && (M.emit("readable"), G.emittedReadable = !1), G.needReadable = !G.flowing && !G.ended && G.length <= G.highWaterMark, ne(M);
  }
  function U(M, G) {
    G.readingMore || (G.readingMore = !0, process.nextTick(q, M, G));
  }
  function q(M, G) {
    for (; !G.reading && !G.ended && (G.length < G.highWaterMark || G.flowing && G.length === 0); ) {
      var ue = G.length;
      if (c("maybeReadMore read 0"), M.read(0), ue === G.length)
        break;
    }
    G.readingMore = !1;
  }
  X.prototype._read = function(M) {
    L(this, new k("_read()"));
  }, X.prototype.pipe = function(M, G) {
    var ue = this, Ee = this._readableState;
    switch (Ee.pipesCount) {
      case 0:
        Ee.pipes = M;
        break;
      case 1:
        Ee.pipes = [Ee.pipes, M];
        break;
      default:
        Ee.pipes.push(M);
        break;
    }
    Ee.pipesCount += 1, c("pipe count=%d opts=%j", Ee.pipesCount, G);
    var Le = (!G || G.end !== !1) && M !== process.stdout && M !== process.stderr, Fe = Le ? dt : Ge;
    Ee.endEmitted ? process.nextTick(Fe) : ue.once("end", Fe), M.on("unpipe", De);
    function De(W, _) {
      c("onunpipe"), W === ue && _ && _.hasUnpiped === !1 && (_.hasUnpiped = !0, We());
    }
    function dt() {
      c("onend"), M.end();
    }
    var or = B(ue);
    M.on("drain", or);
    var Qe = !1;
    function We() {
      c("cleanup"), M.removeListener("close", Ye), M.removeListener("finish", st), M.removeListener("drain", or), M.removeListener("error", qe), M.removeListener("unpipe", De), ue.removeListener("end", dt), ue.removeListener("end", Ge), ue.removeListener("data", lt), Qe = !0, Ee.awaitDrain && (!M._writableState || M._writableState.needDrain) && or();
    }
    ue.on("data", lt);
    function lt(W) {
      c("ondata");
      var _ = M.write(W);
      c("dest.write", _), _ === !1 && ((Ee.pipesCount === 1 && Ee.pipes === M || Ee.pipesCount > 1 && S(Ee.pipes, M) !== -1) && !Qe && (c("false write response, pause", Ee.awaitDrain), Ee.awaitDrain++), ue.pause());
    }
    function qe(W) {
      c("onerror", W), Ge(), M.removeListener("error", qe), e(M, "error") === 0 && L(M, W);
    }
    v(M, "error", qe);
    function Ye() {
      M.removeListener("finish", st), Ge();
    }
    M.once("close", Ye);
    function st() {
      c("onfinish"), M.removeListener("close", Ye), Ge();
    }
    M.once("finish", st);
    function Ge() {
      c("unpipe"), ue.unpipe(M);
    }
    return M.emit("pipe", ue), Ee.flowing || (c("pipe resume"), ue.resume()), M;
  };
  function B(M) {
    return function() {
      var ue = M._readableState;
      c("pipeOnDrain", ue.awaitDrain), ue.awaitDrain && ue.awaitDrain--, ue.awaitDrain === 0 && e(M, "data") && (ue.flowing = !0, ne(M));
    };
  }
  X.prototype.unpipe = function(M) {
    var G = this._readableState, ue = {
      hasUnpiped: !1
    };
    if (G.pipesCount === 0)
      return this;
    if (G.pipesCount === 1)
      return M && M !== G.pipes ? this : (M || (M = G.pipes), G.pipes = null, G.pipesCount = 0, G.flowing = !1, M && M.emit("unpipe", this, ue), this);
    if (!M) {
      var Ee = G.pipes, Le = G.pipesCount;
      G.pipes = null, G.pipesCount = 0, G.flowing = !1;
      for (var Fe = 0; Fe < Le; Fe++)
        Ee[Fe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var De = S(G.pipes, M);
    return De === -1 ? this : (G.pipes.splice(De, 1), G.pipesCount -= 1, G.pipesCount === 1 && (G.pipes = G.pipes[0]), M.emit("unpipe", this, ue), this);
  }, X.prototype.on = function(M, G) {
    var ue = t.prototype.on.call(this, M, G), Ee = this._readableState;
    return M === "data" ? (Ee.readableListening = this.listenerCount("readable") > 0, Ee.flowing !== !1 && this.resume()) : M === "readable" && !Ee.endEmitted && !Ee.readableListening && (Ee.readableListening = Ee.needReadable = !0, Ee.flowing = !1, Ee.emittedReadable = !1, c("on readable", Ee.length, Ee.reading), Ee.length ? N(this) : Ee.reading || process.nextTick(V, this)), ue;
  }, X.prototype.addListener = X.prototype.on, X.prototype.removeListener = function(M, G) {
    var ue = t.prototype.removeListener.call(this, M, G);
    return M === "readable" && process.nextTick(E, this), ue;
  }, X.prototype.removeAllListeners = function(M) {
    var G = t.prototype.removeAllListeners.apply(this, arguments);
    return (M === "readable" || M === void 0) && process.nextTick(E, this), G;
  };
  function E(M) {
    var G = M._readableState;
    G.readableListening = M.listenerCount("readable") > 0, G.resumeScheduled && !G.paused ? G.flowing = !0 : M.listenerCount("data") > 0 && M.resume();
  }
  function V(M) {
    c("readable nexttick read 0"), M.read(0);
  }
  X.prototype.resume = function() {
    var M = this._readableState;
    return M.flowing || (c("resume"), M.flowing = !M.readableListening, be(this, M)), M.paused = !1, this;
  };
  function be(M, G) {
    G.resumeScheduled || (G.resumeScheduled = !0, process.nextTick(ve, M, G));
  }
  function ve(M, G) {
    c("resume", G.reading), G.reading || M.read(0), G.resumeScheduled = !1, M.emit("resume"), ne(M), G.flowing && !G.reading && M.read(0);
  }
  X.prototype.pause = function() {
    return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ne(M) {
    var G = M._readableState;
    for (c("flow", G.flowing); G.flowing && M.read() !== null; )
      ;
  }
  X.prototype.wrap = function(M) {
    var G = this, ue = this._readableState, Ee = !1;
    M.on("end", function() {
      if (c("wrapped end"), ue.decoder && !ue.ended) {
        var De = ue.decoder.end();
        De && De.length && G.push(De);
      }
      G.push(null);
    }), M.on("data", function(De) {
      if (c("wrapped data"), ue.decoder && (De = ue.decoder.write(De)), !(ue.objectMode && De == null) && !(!ue.objectMode && (!De || !De.length))) {
        var dt = G.push(De);
        dt || (Ee = !0, M.pause());
      }
    });
    for (var Le in M)
      this[Le] === void 0 && typeof M[Le] == "function" && (this[Le] = /* @__PURE__ */ function(dt) {
        return function() {
          return M[dt].apply(M, arguments);
        };
      }(Le));
    for (var Fe = 0; Fe < P.length; Fe++)
      M.on(P[Fe], this.emit.bind(this, P[Fe]));
    return this._read = function(De) {
      c("wrapped _read", De), Ee && (Ee = !1, M.resume());
    }, this;
  }, typeof Symbol == "function" && (X.prototype[Symbol.asyncIterator] = function() {
    return $ === void 0 && ($ = Bme()), $(this);
  }), Object.defineProperty(X.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(X.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(X.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(G) {
      this._readableState && (this._readableState.flowing = G);
    }
  }), X._fromList = K, Object.defineProperty(X.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function K(M, G) {
    if (G.length === 0)
      return null;
    var ue;
    return G.objectMode ? ue = G.buffer.shift() : !M || M >= G.length ? (G.decoder ? ue = G.buffer.join("") : G.buffer.length === 1 ? ue = G.buffer.first() : ue = G.buffer.concat(G.length), G.buffer.clear()) : ue = G.buffer.consume(M, G.decoder), ue;
  }
  function Y(M) {
    var G = M._readableState;
    c("endReadable", G.endEmitted), G.endEmitted || (G.ended = !0, process.nextTick(ee, G, M));
  }
  function ee(M, G) {
    if (c("endReadableNT", M.endEmitted, M.length), !M.endEmitted && M.length === 0 && (M.endEmitted = !0, G.readable = !1, G.emit("end"), M.autoDestroy)) {
      var ue = G._writableState;
      (!ue || ue.autoDestroy && ue.finished) && G.destroy();
    }
  }
  typeof Symbol == "function" && (X.from = function(M, G) {
    return D === void 0 && (D = Fme()), D(X, M, G);
  });
  function S(M, G) {
    for (var ue = 0, Ee = M.length; ue < Ee; ue++)
      if (M[ue] === G)
        return ue;
    return -1;
  }
  return J4;
}
var rB = $l, _3 = Fd.codes, Ume = _3.ERR_METHOD_NOT_IMPLEMENTED, jme = _3.ERR_MULTIPLE_CALLBACK, Wme = _3.ERR_TRANSFORM_ALREADY_TRANSFORMING, Hme = _3.ERR_TRANSFORM_WITH_LENGTH_0, E3 = Sg();
ja($l, E3);
function zme(r, e) {
  var t = this._transformState;
  t.transforming = !1;
  var n = t.writecb;
  if (n === null)
    return this.emit("error", new jme());
  t.writechunk = null, t.writecb = null, e != null && this.push(e), n(r);
  var i = this._readableState;
  i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
}
function $l(r) {
  if (!(this instanceof $l))
    return new $l(r);
  E3.call(this, r), this._transformState = {
    afterTransform: zme.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, r && (typeof r.transform == "function" && (this._transform = r.transform), typeof r.flush == "function" && (this._flush = r.flush)), this.on("prefinish", Vme);
}
function Vme() {
  var r = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, t) {
    WO(r, e, t);
  }) : WO(this, null, null);
}
$l.prototype.push = function(r, e) {
  return this._transformState.needTransform = !1, E3.prototype.push.call(this, r, e);
};
$l.prototype._transform = function(r, e, t) {
  t(new Ume("_transform()"));
};
$l.prototype._write = function(r, e, t) {
  var n = this._transformState;
  if (n.writecb = t, n.writechunk = r, n.writeencoding = e, !n.transforming) {
    var i = this._readableState;
    (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
};
$l.prototype._read = function(r) {
  var e = this._transformState;
  e.writechunk !== null && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0;
};
$l.prototype._destroy = function(r, e) {
  E3.prototype._destroy.call(this, r, function(t) {
    e(t);
  });
};
function WO(r, e, t) {
  if (e)
    return r.emit("error", e);
  if (t != null && r.push(t), r._writableState.length)
    throw new Hme();
  if (r._transformState.transforming)
    throw new Wme();
  return r.push(null);
}
var qme = yw, nB = rB;
ja(yw, nB);
function yw(r) {
  if (!(this instanceof yw))
    return new yw(r);
  nB.call(this, r);
}
yw.prototype._transform = function(r, e, t) {
  t(null, r);
};
var Q4;
function Gme(r) {
  var e = !1;
  return function() {
    e || (e = !0, r.apply(void 0, arguments));
  };
}
var iB = Fd.codes, Kme = iB.ERR_MISSING_ARGS, Zme = iB.ERR_STREAM_DESTROYED;
function HO(r) {
  if (r)
    throw r;
}
function Jme(r) {
  return r.setHeader && typeof r.abort == "function";
}
function Qme(r, e, t, n) {
  n = Gme(n);
  var i = !1;
  r.on("close", function() {
    i = !0;
  }), Q4 === void 0 && (Q4 = tA), Q4(r, {
    readable: e,
    writable: t
  }, function(o) {
    if (o)
      return n(o);
    i = !0, n();
  });
  var s = !1;
  return function(o) {
    if (!i && !s) {
      if (s = !0, Jme(r))
        return r.abort();
      if (typeof r.destroy == "function")
        return r.destroy();
      n(o || new Zme("pipe"));
    }
  };
}
function zO(r) {
  r();
}
function Yme(r, e) {
  return r.pipe(e);
}
function Xme(r) {
  return !r.length || typeof r[r.length - 1] != "function" ? HO : r.pop();
}
function ewe() {
  for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)
    e[t] = arguments[t];
  var n = Xme(e);
  if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
    throw new Kme("streams");
  var i, s = e.map(function(o, a) {
    var c = a < e.length - 1, u = a > 0;
    return Qme(o, c, u, function(f) {
      i || (i = f), f && s.forEach(zO), !c && (s.forEach(zO), n(i));
    });
  });
  return e.reduce(Yme);
}
var twe = ewe;
(function(r, e) {
  e = r.exports = tB(), e.Stream = e, e.Readable = e, e.Writable = XL(), e.Duplex = Sg(), e.Transform = rB, e.PassThrough = qme, e.finished = tA, e.pipeline = twe;
})(nS, nS.exports);
var sB = nS.exports;
const { Transform: rwe } = sB;
var nwe = (r) => class oB extends rwe {
  constructor(t, n, i, s, o) {
    super(o), this._rate = t, this._capacity = n, this._delimitedSuffix = i, this._hashBitLength = s, this._options = o, this._state = new r(), this._state.initialize(t, n), this._finalized = !1;
  }
  _transform(t, n, i) {
    let s = null;
    try {
      this.update(t, n);
    } catch (o) {
      s = o;
    }
    i(s);
  }
  _flush(t) {
    let n = null;
    try {
      this.push(this.digest());
    } catch (i) {
      n = i;
    }
    t(n);
  }
  update(t, n) {
    if (!Buffer.isBuffer(t) && typeof t != "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Digest already called");
    return Buffer.isBuffer(t) || (t = Buffer.from(t, n)), this._state.absorb(t), this;
  }
  digest(t) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
    let n = this._state.squeeze(this._hashBitLength / 8);
    return t !== void 0 && (n = n.toString(t)), this._resetState(), n;
  }
  // remove result from memory
  _resetState() {
    return this._state.initialize(this._rate, this._capacity), this;
  }
  // because sometimes we need hash right now and little later
  _clone() {
    const t = new oB(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    return this._state.copy(t._state), t._finalized = this._finalized, t;
  }
};
const { Transform: iwe } = sB;
var swe = (r) => class aB extends iwe {
  constructor(t, n, i, s) {
    super(s), this._rate = t, this._capacity = n, this._delimitedSuffix = i, this._options = s, this._state = new r(), this._state.initialize(t, n), this._finalized = !1;
  }
  _transform(t, n, i) {
    let s = null;
    try {
      this.update(t, n);
    } catch (o) {
      s = o;
    }
    i(s);
  }
  _flush() {
  }
  _read(t) {
    this.push(this.squeeze(t));
  }
  update(t, n) {
    if (!Buffer.isBuffer(t) && typeof t != "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Squeeze already called");
    return Buffer.isBuffer(t) || (t = Buffer.from(t, n)), this._state.absorb(t), this;
  }
  squeeze(t, n) {
    this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
    let i = this._state.squeeze(t);
    return n !== void 0 && (i = i.toString(n)), i;
  }
  _resetState() {
    return this._state.initialize(this._rate, this._capacity), this;
  }
  _clone() {
    const t = new aB(this._rate, this._capacity, this._delimitedSuffix, this._options);
    return this._state.copy(t._state), t._finalized = this._finalized, t;
  }
};
const owe = nwe, awe = swe;
var cwe = function(r) {
  const e = owe(r), t = awe(r);
  return function(n, i) {
    switch (typeof n == "string" ? n.toLowerCase() : n) {
      case "keccak224":
        return new e(1152, 448, null, 224, i);
      case "keccak256":
        return new e(1088, 512, null, 256, i);
      case "keccak384":
        return new e(832, 768, null, 384, i);
      case "keccak512":
        return new e(576, 1024, null, 512, i);
      case "sha3-224":
        return new e(1152, 448, 6, 224, i);
      case "sha3-256":
        return new e(1088, 512, 6, 256, i);
      case "sha3-384":
        return new e(832, 768, 6, 384, i);
      case "sha3-512":
        return new e(576, 1024, 6, 512, i);
      case "shake128":
        return new t(1344, 256, 31, i);
      case "shake256":
        return new t(1088, 512, 31, i);
      default:
        throw new Error("Invald algorithm: " + n);
    }
  };
}, cB = {};
const VO = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
cB.p1600 = function(r) {
  for (let e = 0; e < 24; ++e) {
    const t = r[0] ^ r[10] ^ r[20] ^ r[30] ^ r[40], n = r[1] ^ r[11] ^ r[21] ^ r[31] ^ r[41], i = r[2] ^ r[12] ^ r[22] ^ r[32] ^ r[42], s = r[3] ^ r[13] ^ r[23] ^ r[33] ^ r[43], o = r[4] ^ r[14] ^ r[24] ^ r[34] ^ r[44], a = r[5] ^ r[15] ^ r[25] ^ r[35] ^ r[45], c = r[6] ^ r[16] ^ r[26] ^ r[36] ^ r[46], u = r[7] ^ r[17] ^ r[27] ^ r[37] ^ r[47], f = r[8] ^ r[18] ^ r[28] ^ r[38] ^ r[48], d = r[9] ^ r[19] ^ r[29] ^ r[39] ^ r[49];
    let m = f ^ (i << 1 | s >>> 31), y = d ^ (s << 1 | i >>> 31);
    const b = r[0] ^ m, I = r[1] ^ y, k = r[10] ^ m, R = r[11] ^ y, T = r[20] ^ m, $ = r[21] ^ y, D = r[30] ^ m, L = r[31] ^ y, P = r[40] ^ m, v = r[41] ^ y;
    m = t ^ (o << 1 | a >>> 31), y = n ^ (a << 1 | o >>> 31);
    const F = r[2] ^ m, X = r[3] ^ y, te = r[12] ^ m, se = r[13] ^ y, we = r[22] ^ m, H = r[23] ^ y, p = r[32] ^ m, w = r[33] ^ y, x = r[42] ^ m, N = r[43] ^ y;
    m = i ^ (c << 1 | u >>> 31), y = s ^ (u << 1 | c >>> 31);
    const O = r[4] ^ m, U = r[5] ^ y, q = r[14] ^ m, B = r[15] ^ y, E = r[24] ^ m, V = r[25] ^ y, be = r[34] ^ m, ve = r[35] ^ y, ne = r[44] ^ m, K = r[45] ^ y;
    m = o ^ (f << 1 | d >>> 31), y = a ^ (d << 1 | f >>> 31);
    const Y = r[6] ^ m, ee = r[7] ^ y, S = r[16] ^ m, M = r[17] ^ y, G = r[26] ^ m, ue = r[27] ^ y, Ee = r[36] ^ m, Le = r[37] ^ y, Fe = r[46] ^ m, De = r[47] ^ y;
    m = c ^ (t << 1 | n >>> 31), y = u ^ (n << 1 | t >>> 31);
    const dt = r[8] ^ m, or = r[9] ^ y, Qe = r[18] ^ m, We = r[19] ^ y, lt = r[28] ^ m, qe = r[29] ^ y, Ye = r[38] ^ m, st = r[39] ^ y, Ge = r[48] ^ m, W = r[49] ^ y, _ = b, A = I, J = R << 4 | k >>> 28, ae = k << 4 | R >>> 28, le = T << 3 | $ >>> 29, ge = $ << 3 | T >>> 29, je = L << 9 | D >>> 23, Ue = D << 9 | L >>> 23, it = P << 18 | v >>> 14, jt = v << 18 | P >>> 14, at = F << 1 | X >>> 31, Jt = X << 1 | F >>> 31, _i = se << 12 | te >>> 20, yr = te << 12 | se >>> 20, _r = we << 10 | H >>> 22, Pr = H << 10 | we >>> 22, It = w << 13 | p >>> 19, Mt = p << 13 | w >>> 19, Mr = x << 2 | N >>> 30, Nt = N << 2 | x >>> 30, Rt = U << 30 | O >>> 2, Hr = O << 30 | U >>> 2, Bt = q << 6 | B >>> 26, Dt = B << 6 | q >>> 26, zr = V << 11 | E >>> 21, kt = E << 11 | V >>> 21, $t = be << 15 | ve >>> 17, Dr = ve << 15 | be >>> 17, xt = K << 29 | ne >>> 3, Ft = ne << 29 | K >>> 3, Vr = Y << 28 | ee >>> 4, $r = ee << 28 | Y >>> 4, Lr = M << 23 | S >>> 9, za = S << 23 | M >>> 9, ar = G << 25 | ue >>> 7, Br = ue << 25 | G >>> 7, qo = Ee << 21 | Le >>> 11, Go = Le << 21 | Ee >>> 11, Ko = De << 24 | Fe >>> 8, Zo = Fe << 24 | De >>> 8, hi = dt << 27 | or >>> 5, ps = or << 27 | dt >>> 5, Jo = Qe << 20 | We >>> 12, gs = We << 20 | Qe >>> 12, Qo = qe << 7 | lt >>> 25, Yo = lt << 7 | qe >>> 25, ms = Ye << 8 | st >>> 24, lo = st << 8 | Ye >>> 24, uo = Ge << 14 | W >>> 18, Vn = W << 14 | Ge >>> 18;
    r[0] = _ ^ ~_i & zr, r[1] = A ^ ~yr & kt, r[10] = Vr ^ ~Jo & le, r[11] = $r ^ ~gs & ge, r[20] = at ^ ~Bt & ar, r[21] = Jt ^ ~Dt & Br, r[30] = hi ^ ~J & _r, r[31] = ps ^ ~ae & Pr, r[40] = Rt ^ ~Lr & Qo, r[41] = Hr ^ ~za & Yo, r[2] = _i ^ ~zr & qo, r[3] = yr ^ ~kt & Go, r[12] = Jo ^ ~le & It, r[13] = gs ^ ~ge & Mt, r[22] = Bt ^ ~ar & ms, r[23] = Dt ^ ~Br & lo, r[32] = J ^ ~_r & $t, r[33] = ae ^ ~Pr & Dr, r[42] = Lr ^ ~Qo & je, r[43] = za ^ ~Yo & Ue, r[4] = zr ^ ~qo & uo, r[5] = kt ^ ~Go & Vn, r[14] = le ^ ~It & xt, r[15] = ge ^ ~Mt & Ft, r[24] = ar ^ ~ms & it, r[25] = Br ^ ~lo & jt, r[34] = _r ^ ~$t & Ko, r[35] = Pr ^ ~Dr & Zo, r[44] = Qo ^ ~je & Mr, r[45] = Yo ^ ~Ue & Nt, r[6] = qo ^ ~uo & _, r[7] = Go ^ ~Vn & A, r[16] = It ^ ~xt & Vr, r[17] = Mt ^ ~Ft & $r, r[26] = ms ^ ~it & at, r[27] = lo ^ ~jt & Jt, r[36] = $t ^ ~Ko & hi, r[37] = Dr ^ ~Zo & ps, r[46] = je ^ ~Mr & Rt, r[47] = Ue ^ ~Nt & Hr, r[8] = uo ^ ~_ & _i, r[9] = Vn ^ ~A & yr, r[18] = xt ^ ~Vr & Jo, r[19] = Ft ^ ~$r & gs, r[28] = it ^ ~at & Bt, r[29] = jt ^ ~Jt & Dt, r[38] = Ko ^ ~hi & J, r[39] = Zo ^ ~ps & ae, r[48] = Mr ^ ~Rt & Lr, r[49] = Nt ^ ~Hr & za, r[0] ^= VO[e * 2], r[1] ^= VO[e * 2 + 1];
  }
};
const Y2 = cB;
function Qg() {
  this.state = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], this.blockSize = null, this.count = 0, this.squeezing = !1;
}
Qg.prototype.initialize = function(r, e) {
  for (let t = 0; t < 50; ++t)
    this.state[t] = 0;
  this.blockSize = r / 8, this.count = 0, this.squeezing = !1;
};
Qg.prototype.absorb = function(r) {
  for (let e = 0; e < r.length; ++e)
    this.state[~~(this.count / 4)] ^= r[e] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (Y2.p1600(this.state), this.count = 0);
};
Qg.prototype.absorbLastFewBits = function(r) {
  this.state[~~(this.count / 4)] ^= r << 8 * (this.count % 4), r & 128 && this.count === this.blockSize - 1 && Y2.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), Y2.p1600(this.state), this.count = 0, this.squeezing = !0;
};
Qg.prototype.squeeze = function(r) {
  this.squeezing || this.absorbLastFewBits(1);
  const e = Buffer.alloc(r);
  for (let t = 0; t < r; ++t)
    e[t] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (Y2.p1600(this.state), this.count = 0);
  return e;
};
Qg.prototype.copy = function(r) {
  for (let e = 0; e < 50; ++e)
    r.state[e] = this.state[e];
  r.blockSize = this.blockSize, r.count = this.count, r.squeezing = this.squeezing;
};
var lwe = Qg, uwe = cwe(lwe);
const hwe = uwe, fwe = p3;
function lB(r) {
  return Buffer.allocUnsafe(r).fill(0);
}
function uB(r, e, t) {
  const n = lB(e);
  return r = x3(r), t ? r.length < e ? (r.copy(n), n) : r.slice(0, e) : r.length < e ? (r.copy(n, e - r.length), n) : r.slice(-e);
}
function dwe(r, e) {
  return uB(r, e, !0);
}
function x3(r) {
  if (!Buffer.isBuffer(r))
    if (Array.isArray(r))
      r = Buffer.from(r);
    else if (typeof r == "string")
      hB(r) ? r = Buffer.from(mwe(fB(r)), "hex") : r = Buffer.from(r);
    else if (typeof r == "number")
      r = intToBuffer(r);
    else if (r == null)
      r = Buffer.allocUnsafe(0);
    else if (fwe.isBN(r))
      r = r.toArrayLike(Buffer);
    else if (r.toArray)
      r = Buffer.from(r.toArray());
    else
      throw new Error("invalid type");
  return r;
}
function pwe(r) {
  return r = x3(r), "0x" + r.toString("hex");
}
function gwe(r, e) {
  return r = x3(r), e || (e = 256), hwe("keccak" + e).update(r).digest();
}
function mwe(r) {
  return r.length % 2 ? "0" + r : r;
}
function hB(r) {
  return typeof r == "string" && r.match(/^0x[0-9A-Fa-f]*$/);
}
function fB(r) {
  return typeof r == "string" && r.startsWith("0x") ? r.slice(2) : r;
}
var dB = {
  zeros: lB,
  setLength: uB,
  setLengthRight: dwe,
  isHexString: hB,
  stripHexPrefix: fB,
  toBuffer: x3,
  bufferToHex: pwe,
  keccak: gwe
};
const yd = dB, df = p3;
function pB(r) {
  return r.startsWith("int[") ? "int256" + r.slice(3) : r === "int" ? "int256" : r.startsWith("uint[") ? "uint256" + r.slice(4) : r === "uint" ? "uint256" : r.startsWith("fixed[") ? "fixed128x128" + r.slice(5) : r === "fixed" ? "fixed128x128" : r.startsWith("ufixed[") ? "ufixed128x128" + r.slice(6) : r === "ufixed" ? "ufixed128x128" : r;
}
function e0(r) {
  return parseInt(/^\D+(\d+)$/.exec(r)[1], 10);
}
function qO(r) {
  var e = /^\D+(\d+)x(\d+)$/.exec(r);
  return [parseInt(e[1], 10), parseInt(e[2], 10)];
}
function gB(r) {
  var e = r.match(/(.*)\[(.*?)\]$/);
  return e ? e[2] === "" ? "dynamic" : parseInt(e[2], 10) : null;
}
function Yh(r) {
  var e = typeof r;
  if (e === "string")
    return yd.isHexString(r) ? new df(yd.stripHexPrefix(r), 16) : new df(r, 10);
  if (e === "number")
    return new df(r);
  if (r.toArray)
    return r;
  throw new Error("Argument is not a number");
}
function sc(r, e) {
  var t, n, i, s;
  if (r === "address")
    return sc("uint160", Yh(e));
  if (r === "bool")
    return sc("uint8", e ? 1 : 0);
  if (r === "string")
    return sc("bytes", new Buffer(e, "utf8"));
  if (ywe(r)) {
    if (typeof e.length > "u")
      throw new Error("Not an array?");
    if (t = gB(r), t !== "dynamic" && t !== 0 && e.length > t)
      throw new Error("Elements exceed array size: " + t);
    i = [], r = r.slice(0, r.lastIndexOf("[")), typeof e == "string" && (e = JSON.parse(e));
    for (s in e)
      i.push(sc(r, e[s]));
    if (t === "dynamic") {
      var o = sc("uint256", e.length);
      i.unshift(o);
    }
    return Buffer.concat(i);
  } else {
    if (r === "bytes")
      return e = new Buffer(e), i = Buffer.concat([sc("uint256", e.length), e]), e.length % 32 !== 0 && (i = Buffer.concat([i, yd.zeros(32 - e.length % 32)])), i;
    if (r.startsWith("bytes")) {
      if (t = e0(r), t < 1 || t > 32)
        throw new Error("Invalid bytes<N> width: " + t);
      return yd.setLengthRight(e, 32);
    } else if (r.startsWith("uint")) {
      if (t = e0(r), t % 8 || t < 8 || t > 256)
        throw new Error("Invalid uint<N> width: " + t);
      if (n = Yh(e), n.bitLength() > t)
        throw new Error("Supplied uint exceeds width: " + t + " vs " + n.bitLength());
      if (n < 0)
        throw new Error("Supplied uint is negative");
      return n.toArrayLike(Buffer, "be", 32);
    } else if (r.startsWith("int")) {
      if (t = e0(r), t % 8 || t < 8 || t > 256)
        throw new Error("Invalid int<N> width: " + t);
      if (n = Yh(e), n.bitLength() > t)
        throw new Error("Supplied int exceeds width: " + t + " vs " + n.bitLength());
      return n.toTwos(256).toArrayLike(Buffer, "be", 32);
    } else if (r.startsWith("ufixed")) {
      if (t = qO(r), n = Yh(e), n < 0)
        throw new Error("Supplied ufixed is negative");
      return sc("uint256", n.mul(new df(2).pow(new df(t[1]))));
    } else if (r.startsWith("fixed"))
      return t = qO(r), sc("int256", Yh(e).mul(new df(2).pow(new df(t[1]))));
  }
  throw new Error("Unsupported or invalid type: " + r);
}
function wwe(r) {
  return r === "string" || r === "bytes" || gB(r) === "dynamic";
}
function ywe(r) {
  return r.lastIndexOf("]") === r.length - 1;
}
function vwe(r, e) {
  var t = [], n = [], i = 32 * r.length;
  for (var s in r) {
    var o = pB(r[s]), a = e[s], c = sc(o, a);
    wwe(o) ? (t.push(sc("uint256", i)), n.push(c), i += c.length) : t.push(c);
  }
  return Buffer.concat(t.concat(n));
}
function mB(r, e) {
  if (r.length !== e.length)
    throw new Error("Number of types are not matching the values");
  for (var t, n, i = [], s = 0; s < r.length; s++) {
    var o = pB(r[s]), a = e[s];
    if (o === "bytes")
      i.push(a);
    else if (o === "string")
      i.push(new Buffer(a, "utf8"));
    else if (o === "bool")
      i.push(new Buffer(a ? "01" : "00", "hex"));
    else if (o === "address")
      i.push(yd.setLength(a, 20));
    else if (o.startsWith("bytes")) {
      if (t = e0(o), t < 1 || t > 32)
        throw new Error("Invalid bytes<N> width: " + t);
      i.push(yd.setLengthRight(a, t));
    } else if (o.startsWith("uint")) {
      if (t = e0(o), t % 8 || t < 8 || t > 256)
        throw new Error("Invalid uint<N> width: " + t);
      if (n = Yh(a), n.bitLength() > t)
        throw new Error("Supplied uint exceeds width: " + t + " vs " + n.bitLength());
      i.push(n.toArrayLike(Buffer, "be", t / 8));
    } else if (o.startsWith("int")) {
      if (t = e0(o), t % 8 || t < 8 || t > 256)
        throw new Error("Invalid int<N> width: " + t);
      if (n = Yh(a), n.bitLength() > t)
        throw new Error("Supplied int exceeds width: " + t + " vs " + n.bitLength());
      i.push(n.toTwos(t).toArrayLike(Buffer, "be", t / 8));
    } else
      throw new Error("Unsupported or invalid type: " + o);
  }
  return Buffer.concat(i);
}
function bwe(r, e) {
  return yd.keccak(mB(r, e));
}
var _we = {
  rawEncode: vwe,
  solidityPack: mB,
  soliditySHA3: bwe
};
const aa = dB, vm = _we, wB = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            type: { type: "string" }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: { type: "string" },
    domain: { type: "object" },
    message: { type: "object" }
  },
  required: ["types", "primaryType", "domain", "message"]
}, Y4 = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData(r, e, t, n = !0) {
    const i = ["bytes32"], s = [this.hashType(r, t)];
    if (n) {
      const o = (a, c, u) => {
        if (t[c] !== void 0)
          return ["bytes32", u == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : aa.keccak(this.encodeData(c, u, t, n))];
        if (u === void 0)
          throw new Error(`missing value for field ${a} of type ${c}`);
        if (c === "bytes")
          return ["bytes32", aa.keccak(u)];
        if (c === "string")
          return typeof u == "string" && (u = Buffer.from(u, "utf8")), ["bytes32", aa.keccak(u)];
        if (c.lastIndexOf("]") === c.length - 1) {
          const f = c.slice(0, c.lastIndexOf("[")), d = u.map((m) => o(a, f, m));
          return ["bytes32", aa.keccak(vm.rawEncode(
            d.map(([m]) => m),
            d.map(([, m]) => m)
          ))];
        }
        return [c, u];
      };
      for (const a of t[r]) {
        const [c, u] = o(a.name, a.type, e[a.name]);
        i.push(c), s.push(u);
      }
    } else
      for (const o of t[r]) {
        let a = e[o.name];
        if (a !== void 0)
          if (o.type === "bytes")
            i.push("bytes32"), a = aa.keccak(a), s.push(a);
          else if (o.type === "string")
            i.push("bytes32"), typeof a == "string" && (a = Buffer.from(a, "utf8")), a = aa.keccak(a), s.push(a);
          else if (t[o.type] !== void 0)
            i.push("bytes32"), a = aa.keccak(this.encodeData(o.type, a, t, n)), s.push(a);
          else {
            if (o.type.lastIndexOf("]") === o.type.length - 1)
              throw new Error("Arrays currently unimplemented in encodeData");
            i.push(o.type), s.push(a);
          }
      }
    return vm.rawEncode(i, s);
  },
  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType(r, e) {
    let t = "", n = this.findTypeDependencies(r, e).filter((i) => i !== r);
    n = [r].concat(n.sort());
    for (const i of n) {
      if (!e[i])
        throw new Error("No type definition specified: " + i);
      t += i + "(" + e[i].map(({ name: o, type: a }) => a + " " + o).join(",") + ")";
    }
    return t;
  },
  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies(r, e, t = []) {
    if (r = r.match(/^\w*/)[0], t.includes(r) || e[r] === void 0)
      return t;
    t.push(r);
    for (const n of e[r])
      for (const i of this.findTypeDependencies(n.type, e, t))
        !t.includes(i) && t.push(i);
    return t;
  },
  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {Buffer} - Hash of an object
   */
  hashStruct(r, e, t, n = !0) {
    return aa.keccak(this.encodeData(r, e, t, n));
  },
  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType(r, e) {
    return aa.keccak(this.encodeType(r, e));
  },
  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData(r) {
    const e = {};
    for (const t in wB.properties)
      r[t] && (e[t] = r[t]);
    return e.types && (e.types = Object.assign({ EIP712Domain: [] }, e.types)), e;
  },
  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash(r, e = !0) {
    const t = this.sanitizeData(r), n = [Buffer.from("1901", "hex")];
    return n.push(this.hashStruct("EIP712Domain", t.domain, t.types, e)), t.primaryType !== "EIP712Domain" && n.push(this.hashStruct(t.primaryType, t.message, t.types, e)), aa.keccak(Buffer.concat(n));
  }
};
var Ewe = {
  TYPED_MESSAGE_SCHEMA: wB,
  TypedDataUtils: Y4,
  hashForSignTypedDataLegacy: function(r) {
    return xwe(r.data);
  },
  hashForSignTypedData_v3: function(r) {
    return Y4.hash(r.data, !1);
  },
  hashForSignTypedData_v4: function(r) {
    return Y4.hash(r.data);
  }
};
function xwe(r) {
  const e = new Error("Expect argument to be non-empty array");
  if (typeof r != "object" || !r.length)
    throw e;
  const t = r.map(function(s) {
    return s.type === "bytes" ? aa.toBuffer(s.value) : s.value;
  }), n = r.map(function(s) {
    return s.type;
  }), i = r.map(function(s) {
    if (!s.name)
      throw e;
    return s.type + " " + s.name;
  });
  return vm.soliditySHA3(
    ["bytes32", "bytes32"],
    [
      vm.soliditySHA3(new Array(r.length).fill("string"), i),
      vm.soliditySHA3(n, t)
    ]
  );
}
var Cg = {};
Object.defineProperty(Cg, "__esModule", { value: !0 });
Cg.filterFromParam = Cg.FilterPolyfill = void 0;
const Tp = xy, Zi = pt, Swe = 5 * 60 * 1e3, Xh = {
  jsonrpc: "2.0",
  id: 0
};
class Cwe {
  constructor(e) {
    this.logFilters = /* @__PURE__ */ new Map(), this.blockFilters = /* @__PURE__ */ new Set(), this.pendingTransactionFilters = /* @__PURE__ */ new Set(), this.cursors = /* @__PURE__ */ new Map(), this.timeouts = /* @__PURE__ */ new Map(), this.nextFilterId = (0, Tp.IntNumber)(1), this.provider = e;
  }
  async newFilter(e) {
    const t = yB(e), n = this.makeFilterId(), i = await this.setInitialCursorPosition(n, t.fromBlock);
    return console.log(`Installing new log filter(${n}):`, t, "initial cursor position:", i), this.logFilters.set(n, t), this.setFilterTimeout(n), (0, Zi.hexStringFromIntNumber)(n);
  }
  async newBlockFilter() {
    const e = this.makeFilterId(), t = await this.setInitialCursorPosition(e, "latest");
    return console.log(`Installing new block filter (${e}) with initial cursor position:`, t), this.blockFilters.add(e), this.setFilterTimeout(e), (0, Zi.hexStringFromIntNumber)(e);
  }
  async newPendingTransactionFilter() {
    const e = this.makeFilterId(), t = await this.setInitialCursorPosition(e, "latest");
    return console.log(`Installing new block filter (${e}) with initial cursor position:`, t), this.pendingTransactionFilters.add(e), this.setFilterTimeout(e), (0, Zi.hexStringFromIntNumber)(e);
  }
  uninstallFilter(e) {
    const t = (0, Zi.intNumberFromHexString)(e);
    return console.log(`Uninstalling filter (${t})`), this.deleteFilter(t), !0;
  }
  getFilterChanges(e) {
    const t = (0, Zi.intNumberFromHexString)(e);
    return this.timeouts.has(t) && this.setFilterTimeout(t), this.logFilters.has(t) ? this.getLogFilterChanges(t) : this.blockFilters.has(t) ? this.getBlockFilterChanges(t) : this.pendingTransactionFilters.has(t) ? this.getPendingTransactionFilterChanges(t) : Promise.resolve(db());
  }
  async getFilterLogs(e) {
    const t = (0, Zi.intNumberFromHexString)(e), n = this.logFilters.get(t);
    return n ? this.sendAsyncPromise(Object.assign(Object.assign({}, Xh), { method: "eth_getLogs", params: [GO(n)] })) : db();
  }
  makeFilterId() {
    return (0, Tp.IntNumber)(++this.nextFilterId);
  }
  sendAsyncPromise(e) {
    return new Promise((t, n) => {
      this.provider.sendAsync(e, (i, s) => {
        if (i)
          return n(i);
        if (Array.isArray(s) || s == null)
          return n(new Error(`unexpected response received: ${JSON.stringify(s)}`));
        t(s);
      });
    });
  }
  deleteFilter(e) {
    console.log(`Deleting filter (${e})`), this.logFilters.delete(e), this.blockFilters.delete(e), this.pendingTransactionFilters.delete(e), this.cursors.delete(e), this.timeouts.delete(e);
  }
  async getLogFilterChanges(e) {
    const t = this.logFilters.get(e), n = this.cursors.get(e);
    if (!n || !t)
      return db();
    const i = await this.getCurrentBlockHeight(), s = t.toBlock === "latest" ? i : t.toBlock;
    if (n > i || n > t.toBlock)
      return pb();
    console.log(`Fetching logs from ${n} to ${s} for filter ${e}`);
    const o = await this.sendAsyncPromise(Object.assign(Object.assign({}, Xh), { method: "eth_getLogs", params: [
      GO(Object.assign(Object.assign({}, t), { fromBlock: n, toBlock: s }))
    ] }));
    if (Array.isArray(o.result)) {
      const a = o.result.map((u) => (0, Zi.intNumberFromHexString)(u.blockNumber || "0x0")), c = Math.max(...a);
      if (c && c > n) {
        const u = (0, Tp.IntNumber)(c + 1);
        console.log(`Moving cursor position for filter (${e}) from ${n} to ${u}`), this.cursors.set(e, u);
      }
    }
    return o;
  }
  async getBlockFilterChanges(e) {
    const t = this.cursors.get(e);
    if (!t)
      return db();
    const n = await this.getCurrentBlockHeight();
    if (t > n)
      return pb();
    console.log(`Fetching blocks from ${t} to ${n} for filter (${e})`);
    const i = (await Promise.all(
      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
      (0, Zi.range)(t, n + 1).map((o) => this.getBlockHashByNumber((0, Tp.IntNumber)(o)))
    )).filter((o) => !!o), s = (0, Tp.IntNumber)(t + i.length);
    return console.log(`Moving cursor position for filter (${e}) from ${t} to ${s}`), this.cursors.set(e, s), Object.assign(Object.assign({}, Xh), { result: i });
  }
  async getPendingTransactionFilterChanges(e) {
    return Promise.resolve(pb());
  }
  async setInitialCursorPosition(e, t) {
    const n = await this.getCurrentBlockHeight(), i = typeof t == "number" && t > n ? t : n;
    return this.cursors.set(e, i), i;
  }
  setFilterTimeout(e) {
    const t = this.timeouts.get(e);
    t && window.clearTimeout(t);
    const n = window.setTimeout(() => {
      console.log(`Filter (${e}) timed out`), this.deleteFilter(e);
    }, Swe);
    this.timeouts.set(e, n);
  }
  async getCurrentBlockHeight() {
    const { result: e } = await this.sendAsyncPromise(Object.assign(Object.assign({}, Xh), { method: "eth_blockNumber", params: [] }));
    return (0, Zi.intNumberFromHexString)((0, Zi.ensureHexString)(e));
  }
  async getBlockHashByNumber(e) {
    const t = await this.sendAsyncPromise(Object.assign(Object.assign({}, Xh), { method: "eth_getBlockByNumber", params: [(0, Zi.hexStringFromIntNumber)(e), !1] }));
    return t.result && typeof t.result.hash == "string" ? (0, Zi.ensureHexString)(t.result.hash) : null;
  }
}
Cg.FilterPolyfill = Cwe;
function yB(r) {
  return {
    fromBlock: KO(r.fromBlock),
    toBlock: KO(r.toBlock),
    addresses: r.address === void 0 ? null : Array.isArray(r.address) ? r.address : [r.address],
    topics: r.topics || []
  };
}
Cg.filterFromParam = yB;
function GO(r) {
  const e = {
    fromBlock: ZO(r.fromBlock),
    toBlock: ZO(r.toBlock),
    topics: r.topics
  };
  return r.addresses !== null && (e.address = r.addresses), e;
}
function KO(r) {
  if (r === void 0 || r === "latest" || r === "pending")
    return "latest";
  if (r === "earliest")
    return (0, Tp.IntNumber)(0);
  if ((0, Zi.isHexString)(r))
    return (0, Zi.intNumberFromHexString)(r);
  throw new Error(`Invalid block option: ${String(r)}`);
}
function ZO(r) {
  return r === "latest" ? r : (0, Zi.hexStringFromIntNumber)(r);
}
function db() {
  return Object.assign(Object.assign({}, Xh), { error: { code: -32e3, message: "filter not found" } });
}
function pb() {
  return Object.assign(Object.assign({}, Xh), { result: [] });
}
var vB = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.JSONRPCMethod = void 0, function(e) {
    e.eth_accounts = "eth_accounts", e.eth_coinbase = "eth_coinbase", e.net_version = "net_version", e.eth_chainId = "eth_chainId", e.eth_uninstallFilter = "eth_uninstallFilter", e.eth_requestAccounts = "eth_requestAccounts", e.eth_sign = "eth_sign", e.eth_ecRecover = "eth_ecRecover", e.personal_sign = "personal_sign", e.personal_ecRecover = "personal_ecRecover", e.eth_signTransaction = "eth_signTransaction", e.eth_sendRawTransaction = "eth_sendRawTransaction", e.eth_sendTransaction = "eth_sendTransaction", e.eth_signTypedData_v1 = "eth_signTypedData_v1", e.eth_signTypedData_v2 = "eth_signTypedData_v2", e.eth_signTypedData_v3 = "eth_signTypedData_v3", e.eth_signTypedData_v4 = "eth_signTypedData_v4", e.eth_signTypedData = "eth_signTypedData", e.cbWallet_arbitrary = "walletlink_arbitrary", e.wallet_addEthereumChain = "wallet_addEthereumChain", e.wallet_switchEthereumChain = "wallet_switchEthereumChain", e.wallet_watchAsset = "wallet_watchAsset", e.eth_subscribe = "eth_subscribe", e.eth_unsubscribe = "eth_unsubscribe", e.eth_newFilter = "eth_newFilter", e.eth_newBlockFilter = "eth_newBlockFilter", e.eth_newPendingTransactionFilter = "eth_newPendingTransactionFilter", e.eth_getFilterChanges = "eth_getFilterChanges", e.eth_getFilterLogs = "eth_getFilterLogs";
  }(r.JSONRPCMethod || (r.JSONRPCMethod = {}));
})(vB);
var S3 = {}, bB = {}, C3 = {}, rA = Awe;
function Awe(r) {
  r = r || {};
  var e = r.max || Number.MAX_SAFE_INTEGER, t = typeof r.start < "u" ? r.start : Math.floor(Math.random() * e);
  return function() {
    return t = t % e, t++;
  };
}
const JO = (r, e) => function() {
  const t = e.promiseModule, n = new Array(arguments.length);
  for (let i = 0; i < arguments.length; i++)
    n[i] = arguments[i];
  return new t((i, s) => {
    e.errorFirst ? n.push(function(o, a) {
      if (e.multiArgs) {
        const c = new Array(arguments.length - 1);
        for (let u = 1; u < arguments.length; u++)
          c[u - 1] = arguments[u];
        o ? (c.unshift(o), s(c)) : i(c);
      } else
        o ? s(o) : i(a);
    }) : n.push(function(o) {
      if (e.multiArgs) {
        const a = new Array(arguments.length - 1);
        for (let c = 0; c < arguments.length; c++)
          a[c] = arguments[c];
        i(a);
      } else
        i(o);
    }), r.apply(this, n);
  });
};
var Iwe = (r, e) => {
  e = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise
  }, e);
  const t = (i) => {
    const s = (o) => typeof o == "string" ? i === o : o.test(i);
    return e.include ? e.include.some(s) : !e.exclude.some(s);
  };
  let n;
  typeof r == "function" ? n = function() {
    return e.excludeMain ? r.apply(this, arguments) : JO(r, e).apply(this, arguments);
  } : n = Object.create(Object.getPrototypeOf(r));
  for (const i in r) {
    const s = r[i];
    n[i] = typeof s == "function" && t(i) ? JO(s, e) : s;
  }
  return n;
}, Ay = {}, Rwe = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Ay, "__esModule", { value: !0 });
Ay.BaseBlockTracker = void 0;
const Twe = Rwe(kd), Owe = 1e3, Nwe = (r, e) => r + e, QO = ["sync", "latest"];
class Pwe extends Twe.default {
  constructor(e) {
    super(), this._blockResetDuration = e.blockResetDuration || 20 * Owe, this._currentBlock = null, this._isRunning = !1, this._onNewListener = this._onNewListener.bind(this), this._onRemoveListener = this._onRemoveListener.bind(this), this._resetCurrentBlock = this._resetCurrentBlock.bind(this), this._setupInternalEvents();
  }
  async destroy() {
    this._cancelBlockResetTimeout(), await this._maybeEnd(), super.removeAllListeners();
  }
  isRunning() {
    return this._isRunning;
  }
  getCurrentBlock() {
    return this._currentBlock;
  }
  async getLatestBlock() {
    return this._currentBlock ? this._currentBlock : await new Promise((t) => this.once("latest", t));
  }
  // dont allow module consumer to remove our internal event listeners
  removeAllListeners(e) {
    return e ? super.removeAllListeners(e) : super.removeAllListeners(), this._setupInternalEvents(), this._onRemoveListener(), this;
  }
  _setupInternalEvents() {
    this.removeListener("newListener", this._onNewListener), this.removeListener("removeListener", this._onRemoveListener), this.on("newListener", this._onNewListener), this.on("removeListener", this._onRemoveListener);
  }
  _onNewListener(e) {
    QO.includes(e) && this._maybeStart();
  }
  _onRemoveListener() {
    this._getBlockTrackerEventCount() > 0 || this._maybeEnd();
  }
  async _maybeStart() {
    this._isRunning || (this._isRunning = !0, this._cancelBlockResetTimeout(), await this._start(), this.emit("_started"));
  }
  async _maybeEnd() {
    this._isRunning && (this._isRunning = !1, this._setupBlockResetTimeout(), await this._end(), this.emit("_ended"));
  }
  _getBlockTrackerEventCount() {
    return QO.map((e) => this.listenerCount(e)).reduce(Nwe);
  }
  _newPotentialLatest(e) {
    const t = this._currentBlock;
    t && YO(e) <= YO(t) || this._setCurrentBlock(e);
  }
  _setCurrentBlock(e) {
    const t = this._currentBlock;
    this._currentBlock = e, this.emit("latest", e), this.emit("sync", { oldBlock: t, newBlock: e });
  }
  _setupBlockResetTimeout() {
    this._cancelBlockResetTimeout(), this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration), this._blockResetTimeout.unref && this._blockResetTimeout.unref();
  }
  _cancelBlockResetTimeout() {
    this._blockResetTimeout && clearTimeout(this._blockResetTimeout);
  }
  _resetCurrentBlock() {
    this._currentBlock = null;
  }
}
Ay.BaseBlockTracker = Pwe;
function YO(r) {
  return Number.parseInt(r, 16);
}
var _B = {}, EB = {}, wi = {};
class xB extends TypeError {
  constructor(e, t) {
    let n;
    const { message: i, explanation: s, ...o } = e, { path: a } = e, c = a.length === 0 ? i : `At path: ${a.join(".")} -- ${i}`;
    super(s ?? c), s != null && (this.cause = c), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => n ?? (n = [e, ...t()]);
  }
}
function Mwe(r) {
  return Bo(r) && typeof r[Symbol.iterator] == "function";
}
function Bo(r) {
  return typeof r == "object" && r != null;
}
function XO(r) {
  if (Object.prototype.toString.call(r) !== "[object Object]")
    return !1;
  const e = Object.getPrototypeOf(r);
  return e === null || e === Object.prototype;
}
function Jn(r) {
  return typeof r == "symbol" ? r.toString() : typeof r == "string" ? JSON.stringify(r) : `${r}`;
}
function Dwe(r) {
  const { done: e, value: t } = r.next();
  return e ? void 0 : t;
}
function kwe(r, e, t, n) {
  if (r === !0)
    return;
  r === !1 ? r = {} : typeof r == "string" && (r = { message: r });
  const { path: i, branch: s } = e, { type: o } = t, { refinement: a, message: c = `Expected a value of type \`${o}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${Jn(n)}\`` } = r;
  return {
    value: n,
    type: o,
    refinement: a,
    key: i[i.length - 1],
    path: i,
    branch: s,
    ...r,
    message: c
  };
}
function* sS(r, e, t, n) {
  Mwe(r) || (r = [r]);
  for (const i of r) {
    const s = kwe(i, e, t, n);
    s && (yield s);
  }
}
function* nA(r, e, t = {}) {
  const { path: n = [], branch: i = [r], coerce: s = !1, mask: o = !1 } = t, a = { path: n, branch: i };
  if (s && (r = e.coercer(r, a), o && e.type !== "type" && Bo(e.schema) && Bo(r) && !Array.isArray(r)))
    for (const u in r)
      e.schema[u] === void 0 && delete r[u];
  let c = "valid";
  for (const u of e.validator(r, a))
    u.explanation = t.message, c = "not_valid", yield [u, void 0];
  for (let [u, f, d] of e.entries(r, a)) {
    const m = nA(f, d, {
      path: u === void 0 ? n : [...n, u],
      branch: u === void 0 ? i : [...i, f],
      coerce: s,
      mask: o,
      message: t.message
    });
    for (const y of m)
      y[0] ? (c = y[0].refinement != null ? "not_refined" : "not_valid", yield [y[0], void 0]) : s && (f = y[1], u === void 0 ? r = f : r instanceof Map ? r.set(u, f) : r instanceof Set ? r.add(f) : Bo(r) && (f !== void 0 || u in r) && (r[u] = f));
  }
  if (c !== "not_valid")
    for (const u of e.refiner(r, a))
      u.explanation = t.message, c = "not_refined", yield [u, void 0];
  c === "valid" && (yield [void 0, r]);
}
class Bn {
  constructor(e) {
    const { type: t, schema: n, validator: i, refiner: s, coercer: o = (c) => c, entries: a = function* () {
    } } = e;
    this.type = t, this.schema = n, this.entries = a, this.coercer = o, i ? this.validator = (c, u) => {
      const f = i(c, u);
      return sS(f, u, this, c);
    } : this.validator = () => [], s ? this.refiner = (c, u) => {
      const f = s(c, u);
      return sS(f, u, this, c);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(e, t) {
    return SB(e, this, t);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(e, t) {
    return CB(e, this, t);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(e) {
    return iA(e, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(e, t) {
    return AB(e, this, t);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(e, t = {}) {
    return Yg(e, this, t);
  }
}
function SB(r, e, t) {
  const n = Yg(r, e, { message: t });
  if (n[0])
    throw n[0];
}
function CB(r, e, t) {
  const n = Yg(r, e, { coerce: !0, message: t });
  if (n[0])
    throw n[0];
  return n[1];
}
function AB(r, e, t) {
  const n = Yg(r, e, { coerce: !0, mask: !0, message: t });
  if (n[0])
    throw n[0];
  return n[1];
}
function iA(r, e) {
  return !Yg(r, e)[0];
}
function Yg(r, e, t = {}) {
  const n = nA(r, e, t), i = Dwe(n);
  return i[0] ? [new xB(i[0], function* () {
    for (const o of n)
      o[0] && (yield o[0]);
  }), void 0] : [void 0, i[1]];
}
function $we(...r) {
  const e = r[0].type === "type", t = r.map((i) => i.schema), n = Object.assign({}, ...t);
  return e ? oA(n) : Iy(n);
}
function Ls(r, e) {
  return new Bn({ type: r, schema: null, validator: e });
}
function Lwe(r, e) {
  return new Bn({
    ...r,
    refiner: (t, n) => t === void 0 || r.refiner(t, n),
    validator(t, n) {
      return t === void 0 ? !0 : (e(t, n), r.validator(t, n));
    }
  });
}
function Bwe(r) {
  return new Bn({
    type: "dynamic",
    schema: null,
    *entries(e, t) {
      yield* r(e, t).entries(e, t);
    },
    validator(e, t) {
      return r(e, t).validator(e, t);
    },
    coercer(e, t) {
      return r(e, t).coercer(e, t);
    },
    refiner(e, t) {
      return r(e, t).refiner(e, t);
    }
  });
}
function Fwe(r) {
  let e;
  return new Bn({
    type: "lazy",
    schema: null,
    *entries(t, n) {
      e ?? (e = r()), yield* e.entries(t, n);
    },
    validator(t, n) {
      return e ?? (e = r()), e.validator(t, n);
    },
    coercer(t, n) {
      return e ?? (e = r()), e.coercer(t, n);
    },
    refiner(t, n) {
      return e ?? (e = r()), e.refiner(t, n);
    }
  });
}
function Uwe(r, e) {
  const { schema: t } = r, n = { ...t };
  for (const i of e)
    delete n[i];
  switch (r.type) {
    case "type":
      return oA(n);
    default:
      return Iy(n);
  }
}
function jwe(r) {
  const e = r instanceof Bn ? { ...r.schema } : { ...r };
  for (const t in e)
    e[t] = IB(e[t]);
  return Iy(e);
}
function Wwe(r, e) {
  const { schema: t } = r, n = {};
  for (const i of e)
    n[i] = t[i];
  return Iy(n);
}
function Hwe(r, e) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), Ls(r, e);
}
function zwe() {
  return Ls("any", () => !0);
}
function Vwe(r) {
  return new Bn({
    type: "array",
    schema: r,
    *entries(e) {
      if (r && Array.isArray(e))
        for (const [t, n] of e.entries())
          yield [t, n, r];
    },
    coercer(e) {
      return Array.isArray(e) ? e.slice() : e;
    },
    validator(e) {
      return Array.isArray(e) || `Expected an array value, but received: ${Jn(e)}`;
    }
  });
}
function qwe() {
  return Ls("bigint", (r) => typeof r == "bigint");
}
function Gwe() {
  return Ls("boolean", (r) => typeof r == "boolean");
}
function Kwe() {
  return Ls("date", (r) => r instanceof Date && !isNaN(r.getTime()) || `Expected a valid \`Date\` object, but received: ${Jn(r)}`);
}
function Zwe(r) {
  const e = {}, t = r.map((n) => Jn(n)).join();
  for (const n of r)
    e[n] = n;
  return new Bn({
    type: "enums",
    schema: e,
    validator(n) {
      return r.includes(n) || `Expected one of \`${t}\`, but received: ${Jn(n)}`;
    }
  });
}
function Jwe() {
  return Ls("func", (r) => typeof r == "function" || `Expected a function, but received: ${Jn(r)}`);
}
function Qwe(r) {
  return Ls("instance", (e) => e instanceof r || `Expected a \`${r.name}\` instance, but received: ${Jn(e)}`);
}
function Ywe() {
  return Ls("integer", (r) => typeof r == "number" && !isNaN(r) && Number.isInteger(r) || `Expected an integer, but received: ${Jn(r)}`);
}
function Xwe(r) {
  return new Bn({
    type: "intersection",
    schema: null,
    *entries(e, t) {
      for (const n of r)
        yield* n.entries(e, t);
    },
    *validator(e, t) {
      for (const n of r)
        yield* n.validator(e, t);
    },
    *refiner(e, t) {
      for (const n of r)
        yield* n.refiner(e, t);
    }
  });
}
function eye(r) {
  const e = Jn(r), t = typeof r;
  return new Bn({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? r : null,
    validator(n) {
      return n === r || `Expected the literal \`${e}\`, but received: ${Jn(n)}`;
    }
  });
}
function tye(r, e) {
  return new Bn({
    type: "map",
    schema: null,
    *entries(t) {
      if (r && e && t instanceof Map)
        for (const [n, i] of t.entries())
          yield [n, n, r], yield [n, i, e];
    },
    coercer(t) {
      return t instanceof Map ? new Map(t) : t;
    },
    validator(t) {
      return t instanceof Map || `Expected a \`Map\` object, but received: ${Jn(t)}`;
    }
  });
}
function sA() {
  return Ls("never", () => !1);
}
function rye(r) {
  return new Bn({
    ...r,
    validator: (e, t) => e === null || r.validator(e, t),
    refiner: (e, t) => e === null || r.refiner(e, t)
  });
}
function nye() {
  return Ls("number", (r) => typeof r == "number" && !isNaN(r) || `Expected a number, but received: ${Jn(r)}`);
}
function Iy(r) {
  const e = r ? Object.keys(r) : [], t = sA();
  return new Bn({
    type: "object",
    schema: r || null,
    *entries(n) {
      if (r && Bo(n)) {
        const i = new Set(Object.keys(n));
        for (const s of e)
          i.delete(s), yield [s, n[s], r[s]];
        for (const s of i)
          yield [s, n[s], t];
      }
    },
    validator(n) {
      return Bo(n) || `Expected an object, but received: ${Jn(n)}`;
    },
    coercer(n) {
      return Bo(n) ? { ...n } : n;
    }
  });
}
function IB(r) {
  return new Bn({
    ...r,
    validator: (e, t) => e === void 0 || r.validator(e, t),
    refiner: (e, t) => e === void 0 || r.refiner(e, t)
  });
}
function iye(r, e) {
  return new Bn({
    type: "record",
    schema: null,
    *entries(t) {
      if (Bo(t))
        for (const n in t) {
          const i = t[n];
          yield [n, n, r], yield [n, i, e];
        }
    },
    validator(t) {
      return Bo(t) || `Expected an object, but received: ${Jn(t)}`;
    }
  });
}
function sye() {
  return Ls("regexp", (r) => r instanceof RegExp);
}
function oye(r) {
  return new Bn({
    type: "set",
    schema: null,
    *entries(e) {
      if (r && e instanceof Set)
        for (const t of e)
          yield [t, t, r];
    },
    coercer(e) {
      return e instanceof Set ? new Set(e) : e;
    },
    validator(e) {
      return e instanceof Set || `Expected a \`Set\` object, but received: ${Jn(e)}`;
    }
  });
}
function RB() {
  return Ls("string", (r) => typeof r == "string" || `Expected a string, but received: ${Jn(r)}`);
}
function aye(r) {
  const e = sA();
  return new Bn({
    type: "tuple",
    schema: null,
    *entries(t) {
      if (Array.isArray(t)) {
        const n = Math.max(r.length, t.length);
        for (let i = 0; i < n; i++)
          yield [i, t[i], r[i] || e];
      }
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array, but received: ${Jn(t)}`;
    }
  });
}
function oA(r) {
  const e = Object.keys(r);
  return new Bn({
    type: "type",
    schema: r,
    *entries(t) {
      if (Bo(t))
        for (const n of e)
          yield [n, t[n], r[n]];
    },
    validator(t) {
      return Bo(t) || `Expected an object, but received: ${Jn(t)}`;
    },
    coercer(t) {
      return Bo(t) ? { ...t } : t;
    }
  });
}
function cye(r) {
  const e = r.map((t) => t.type).join(" | ");
  return new Bn({
    type: "union",
    schema: null,
    coercer(t) {
      for (const n of r) {
        const [i, s] = n.validate(t, { coerce: !0 });
        if (!i)
          return s;
      }
      return t;
    },
    validator(t, n) {
      const i = [];
      for (const s of r) {
        const [...o] = nA(t, s, n), [a] = o;
        if (a[0])
          for (const [c] of o)
            c && i.push(c);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${e}\`, but received: ${Jn(t)}`,
        ...i
      ];
    }
  });
}
function TB() {
  return Ls("unknown", () => !0);
}
function aA(r, e, t) {
  return new Bn({
    ...r,
    coercer: (n, i) => iA(n, e) ? r.coercer(t(n, i), i) : r.coercer(n, i)
  });
}
function lye(r, e, t = {}) {
  return aA(r, TB(), (n) => {
    const i = typeof e == "function" ? e() : e;
    if (n === void 0)
      return i;
    if (!t.strict && XO(n) && XO(i)) {
      const s = { ...n };
      let o = !1;
      for (const a in i)
        s[a] === void 0 && (s[a] = i[a], o = !0);
      if (o)
        return s;
    }
    return n;
  });
}
function uye(r) {
  return aA(r, RB(), (e) => e.trim());
}
function hye(r) {
  return Ud(r, "empty", (e) => {
    const t = OB(e);
    return t === 0 || `Expected an empty ${r.type} but received one with a size of \`${t}\``;
  });
}
function OB(r) {
  return r instanceof Map || r instanceof Set ? r.size : r.length;
}
function fye(r, e, t = {}) {
  const { exclusive: n } = t;
  return Ud(r, "max", (i) => n ? i < e : i <= e || `Expected a ${r.type} less than ${n ? "" : "or equal to "}${e} but received \`${i}\``);
}
function dye(r, e, t = {}) {
  const { exclusive: n } = t;
  return Ud(r, "min", (i) => n ? i > e : i >= e || `Expected a ${r.type} greater than ${n ? "" : "or equal to "}${e} but received \`${i}\``);
}
function pye(r) {
  return Ud(r, "nonempty", (e) => OB(e) > 0 || `Expected a nonempty ${r.type} but received an empty one`);
}
function gye(r, e) {
  return Ud(r, "pattern", (t) => e.test(t) || `Expected a ${r.type} matching \`/${e.source}/\` but received "${t}"`);
}
function mye(r, e, t = e) {
  const n = `Expected a ${r.type}`, i = e === t ? `of \`${e}\`` : `between \`${e}\` and \`${t}\``;
  return Ud(r, "size", (s) => {
    if (typeof s == "number" || s instanceof Date)
      return e <= s && s <= t || `${n} ${i} but received \`${s}\``;
    if (s instanceof Map || s instanceof Set) {
      const { size: o } = s;
      return e <= o && o <= t || `${n} with a size ${i} but received one with a size of \`${o}\``;
    } else {
      const { length: o } = s;
      return e <= o && o <= t || `${n} with a length ${i} but received one with a length of \`${o}\``;
    }
  });
}
function Ud(r, e, t) {
  return new Bn({
    ...r,
    *refiner(n, i) {
      yield* r.refiner(n, i);
      const s = t(n, i), o = sS(s, i, r, n);
      for (const a of o)
        yield { ...a, refinement: e };
    }
  });
}
const wye = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: Bn,
  StructError: xB,
  any: zwe,
  array: Vwe,
  assert: SB,
  assign: $we,
  bigint: qwe,
  boolean: Gwe,
  coerce: aA,
  create: CB,
  date: Kwe,
  defaulted: lye,
  define: Ls,
  deprecated: Lwe,
  dynamic: Bwe,
  empty: hye,
  enums: Zwe,
  func: Jwe,
  instance: Qwe,
  integer: Ywe,
  intersection: Xwe,
  is: iA,
  lazy: Fwe,
  literal: eye,
  map: tye,
  mask: AB,
  max: fye,
  min: dye,
  never: sA,
  nonempty: pye,
  nullable: rye,
  number: nye,
  object: Iy,
  omit: Uwe,
  optional: IB,
  partial: jwe,
  pattern: gye,
  pick: Wwe,
  record: iye,
  refine: Ud,
  regexp: sye,
  set: oye,
  size: mye,
  string: RB,
  struct: Hwe,
  trimmed: uye,
  tuple: aye,
  type: oA,
  union: cye,
  unknown: TB,
  validate: Yg
}, Symbol.toStringTag, { value: "Module" })), jd = /* @__PURE__ */ La(wye);
Object.defineProperty(wi, "__esModule", { value: !0 });
wi.assertExhaustive = wi.assertStruct = wi.assert = wi.AssertionError = void 0;
const yye = jd;
function vye(r) {
  return typeof r == "object" && r !== null && "message" in r;
}
function bye(r) {
  var e, t;
  return typeof ((t = (e = r == null ? void 0 : r.prototype) === null || e === void 0 ? void 0 : e.constructor) === null || t === void 0 ? void 0 : t.name) == "string";
}
function _ye(r) {
  const e = vye(r) ? r.message : String(r);
  return e.endsWith(".") ? e.slice(0, -1) : e;
}
function NB(r, e) {
  return bye(r) ? new r({
    message: e
  }) : r({
    message: e
  });
}
class cA extends Error {
  constructor(e) {
    super(e.message), this.code = "ERR_ASSERTION";
  }
}
wi.AssertionError = cA;
function Eye(r, e = "Assertion failed.", t = cA) {
  if (!r)
    throw e instanceof Error ? e : NB(t, e);
}
wi.assert = Eye;
function xye(r, e, t = "Assertion failed", n = cA) {
  try {
    (0, yye.assert)(r, e);
  } catch (i) {
    throw NB(n, `${t}: ${_ye(i)}.`);
  }
}
wi.assertStruct = xye;
function Sye(r) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
wi.assertExhaustive = Sye;
var Ry = {};
Object.defineProperty(Ry, "__esModule", { value: !0 });
Ry.base64 = void 0;
const Cye = jd, Aye = wi, Iye = (r, e = {}) => {
  var t, n;
  const i = (t = e.paddingRequired) !== null && t !== void 0 ? t : !1, s = (n = e.characterSet) !== null && n !== void 0 ? n : "base64";
  let o;
  s === "base64" ? o = String.raw`[A-Za-z0-9+\/]` : ((0, Aye.assert)(s === "base64url"), o = String.raw`[-_A-Za-z0-9]`);
  let a;
  return i ? a = new RegExp(`^(?:${o}{4})*(?:${o}{3}=|${o}{2}==)?$`, "u") : a = new RegExp(`^(?:${o}{4})*(?:${o}{2,3}|${o}{3}=|${o}{2}==)?$`, "u"), (0, Cye.pattern)(r, a);
};
Ry.base64 = Iye;
var br = {}, Ty = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.remove0x = r.add0x = r.assertIsStrictHexString = r.assertIsHexString = r.isStrictHexString = r.isHexString = r.StrictHexStruct = r.HexStruct = void 0;
  const e = jd, t = wi;
  r.HexStruct = (0, e.pattern)((0, e.string)(), /^(?:0x)?[0-9a-f]+$/iu), r.StrictHexStruct = (0, e.pattern)((0, e.string)(), /^0x[0-9a-f]+$/iu);
  function n(u) {
    return (0, e.is)(u, r.HexStruct);
  }
  r.isHexString = n;
  function i(u) {
    return (0, e.is)(u, r.StrictHexStruct);
  }
  r.isStrictHexString = i;
  function s(u) {
    (0, t.assert)(n(u), "Value must be a hexadecimal string.");
  }
  r.assertIsHexString = s;
  function o(u) {
    (0, t.assert)(i(u), 'Value must be a hexadecimal string, starting with "0x".');
  }
  r.assertIsStrictHexString = o;
  function a(u) {
    return u.startsWith("0x") ? u : u.startsWith("0X") ? `0x${u.substring(2)}` : `0x${u}`;
  }
  r.add0x = a;
  function c(u) {
    return u.startsWith("0x") || u.startsWith("0X") ? u.substring(2) : u;
  }
  r.remove0x = c;
})(Ty);
Object.defineProperty(br, "__esModule", { value: !0 });
br.createDataView = br.concatBytes = br.valueToBytes = br.stringToBytes = br.numberToBytes = br.signedBigIntToBytes = br.bigIntToBytes = br.hexToBytes = br.bytesToString = br.bytesToNumber = br.bytesToSignedBigInt = br.bytesToBigInt = br.bytesToHex = br.assertIsBytes = br.isBytes = void 0;
const ro = wi, oS = Ty, eN = 48, tN = 58, rN = 87;
function Rye() {
  const r = [];
  return () => {
    if (r.length === 0)
      for (let e = 0; e < 256; e++)
        r.push(e.toString(16).padStart(2, "0"));
    return r;
  };
}
const Tye = Rye();
function lA(r) {
  return r instanceof Uint8Array;
}
br.isBytes = lA;
function Xg(r) {
  (0, ro.assert)(lA(r), "Value must be a Uint8Array.");
}
br.assertIsBytes = Xg;
function PB(r) {
  if (Xg(r), r.length === 0)
    return "0x";
  const e = Tye(), t = new Array(r.length);
  for (let n = 0; n < r.length; n++)
    t[n] = e[r[n]];
  return (0, oS.add0x)(t.join(""));
}
br.bytesToHex = PB;
function MB(r) {
  Xg(r);
  const e = PB(r);
  return BigInt(e);
}
br.bytesToBigInt = MB;
function Oye(r) {
  Xg(r);
  let e = BigInt(0);
  for (const t of r)
    e = (e << BigInt(8)) + BigInt(t);
  return BigInt.asIntN(r.length * 8, e);
}
br.bytesToSignedBigInt = Oye;
function Nye(r) {
  Xg(r);
  const e = MB(r);
  return (0, ro.assert)(e <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(e);
}
br.bytesToNumber = Nye;
function Pye(r) {
  return Xg(r), new TextDecoder().decode(r);
}
br.bytesToString = Pye;
function A3(r) {
  var e;
  if (((e = r == null ? void 0 : r.toLowerCase) === null || e === void 0 ? void 0 : e.call(r)) === "0x")
    return new Uint8Array();
  (0, oS.assertIsHexString)(r);
  const t = (0, oS.remove0x)(r).toLowerCase(), n = t.length % 2 === 0 ? t : `0${t}`, i = new Uint8Array(n.length / 2);
  for (let s = 0; s < i.length; s++) {
    const o = n.charCodeAt(s * 2), a = n.charCodeAt(s * 2 + 1), c = o - (o < tN ? eN : rN), u = a - (a < tN ? eN : rN);
    i[s] = c * 16 + u;
  }
  return i;
}
br.hexToBytes = A3;
function DB(r) {
  (0, ro.assert)(typeof r == "bigint", "Value must be a bigint."), (0, ro.assert)(r >= BigInt(0), "Value must be a non-negative bigint.");
  const e = r.toString(16);
  return A3(e);
}
br.bigIntToBytes = DB;
function Mye(r, e) {
  (0, ro.assert)(e > 0);
  const t = r >> BigInt(31);
  return !((~r & t) + (r & ~t) >> BigInt(e * 8 + -1));
}
function Dye(r, e) {
  (0, ro.assert)(typeof r == "bigint", "Value must be a bigint."), (0, ro.assert)(typeof e == "number", "Byte length must be a number."), (0, ro.assert)(e > 0, "Byte length must be greater than 0."), (0, ro.assert)(Mye(r, e), "Byte length is too small to represent the given value.");
  let t = r;
  const n = new Uint8Array(e);
  for (let i = 0; i < n.length; i++)
    n[i] = Number(BigInt.asUintN(8, t)), t >>= BigInt(8);
  return n.reverse();
}
br.signedBigIntToBytes = Dye;
function kB(r) {
  (0, ro.assert)(typeof r == "number", "Value must be a number."), (0, ro.assert)(r >= 0, "Value must be a non-negative number."), (0, ro.assert)(Number.isSafeInteger(r), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const e = r.toString(16);
  return A3(e);
}
br.numberToBytes = kB;
function $B(r) {
  return (0, ro.assert)(typeof r == "string", "Value must be a string."), new TextEncoder().encode(r);
}
br.stringToBytes = $B;
function LB(r) {
  if (typeof r == "bigint")
    return DB(r);
  if (typeof r == "number")
    return kB(r);
  if (typeof r == "string")
    return r.startsWith("0x") ? A3(r) : $B(r);
  if (lA(r))
    return r;
  throw new TypeError(`Unsupported value type: "${typeof r}".`);
}
br.valueToBytes = LB;
function kye(r) {
  const e = new Array(r.length);
  let t = 0;
  for (let i = 0; i < r.length; i++) {
    const s = LB(r[i]);
    e[i] = s, t += s.length;
  }
  const n = new Uint8Array(t);
  for (let i = 0, s = 0; i < e.length; i++)
    n.set(e[i], s), s += e[i].length;
  return n;
}
br.concatBytes = kye;
function $ye(r) {
  if (typeof Buffer < "u" && r instanceof Buffer) {
    const e = r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
    return new DataView(e);
  }
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
br.createDataView = $ye;
var I3 = {};
Object.defineProperty(I3, "__esModule", { value: !0 });
I3.ChecksumStruct = void 0;
const nN = jd, Lye = Ry;
I3.ChecksumStruct = (0, nN.size)((0, Lye.base64)((0, nN.string)(), { paddingRequired: !0 }), 44, 44);
var vc = {};
Object.defineProperty(vc, "__esModule", { value: !0 });
vc.createHex = vc.createBytes = vc.createBigInt = vc.createNumber = void 0;
const wn = jd, Bye = wi, BB = br, R3 = Ty, FB = (0, wn.union)([(0, wn.number)(), (0, wn.bigint)(), (0, wn.string)(), R3.StrictHexStruct]), Fye = (0, wn.coerce)((0, wn.number)(), FB, Number), Uye = (0, wn.coerce)((0, wn.bigint)(), FB, BigInt);
(0, wn.union)([R3.StrictHexStruct, (0, wn.instance)(Uint8Array)]);
const jye = (0, wn.coerce)((0, wn.instance)(Uint8Array), (0, wn.union)([R3.StrictHexStruct]), BB.hexToBytes), Wye = (0, wn.coerce)(R3.StrictHexStruct, (0, wn.instance)(Uint8Array), BB.bytesToHex);
function Hye(r) {
  try {
    const e = (0, wn.create)(r, Fye);
    return (0, Bye.assert)(Number.isFinite(e), `Expected a number-like value, got "${r}".`), e;
  } catch (e) {
    throw e instanceof wn.StructError ? new Error(`Expected a number-like value, got "${r}".`) : e;
  }
}
vc.createNumber = Hye;
function zye(r) {
  try {
    return (0, wn.create)(r, Uye);
  } catch (e) {
    throw e instanceof wn.StructError ? new Error(`Expected a number-like value, got "${String(e.value)}".`) : e;
  }
}
vc.createBigInt = zye;
function Vye(r) {
  if (typeof r == "string" && r.toLowerCase() === "0x")
    return new Uint8Array();
  try {
    return (0, wn.create)(r, jye);
  } catch (e) {
    throw e instanceof wn.StructError ? new Error(`Expected a bytes-like value, got "${String(e.value)}".`) : e;
  }
}
vc.createBytes = Vye;
function qye(r) {
  if (r instanceof Uint8Array && r.length === 0 || typeof r == "string" && r.toLowerCase() === "0x")
    return "0x";
  try {
    return (0, wn.create)(r, Wye);
  } catch (e) {
    throw e instanceof wn.StructError ? new Error(`Expected a bytes-like value, got "${String(e.value)}".`) : e;
  }
}
vc.createHex = qye;
var Ag = {}, UB = ze && ze.__classPrivateFieldSet || function(r, e, t, n, i) {
  if (n === "m")
    throw new TypeError("Private method is not writable");
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? r !== e || !i : !e.has(r))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? i.call(r, t) : i ? i.value = t : e.set(r, t), t;
}, Xi = ze && ze.__classPrivateFieldGet || function(r, e, t, n) {
  if (t === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? r !== e || !n : !e.has(r))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
}, ia, tc;
Object.defineProperty(Ag, "__esModule", { value: !0 });
Ag.FrozenSet = Ag.FrozenMap = void 0;
class uA {
  constructor(e) {
    ia.set(this, void 0), UB(this, ia, new Map(e), "f"), Object.freeze(this);
  }
  get size() {
    return Xi(this, ia, "f").size;
  }
  [(ia = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return Xi(this, ia, "f")[Symbol.iterator]();
  }
  entries() {
    return Xi(this, ia, "f").entries();
  }
  forEach(e, t) {
    return Xi(this, ia, "f").forEach((n, i, s) => e.call(t, n, i, this));
  }
  get(e) {
    return Xi(this, ia, "f").get(e);
  }
  has(e) {
    return Xi(this, ia, "f").has(e);
  }
  keys() {
    return Xi(this, ia, "f").keys();
  }
  values() {
    return Xi(this, ia, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([e, t]) => `${String(e)} => ${String(t)}`).join(", ")} ` : ""}}`;
  }
}
Ag.FrozenMap = uA;
class hA {
  constructor(e) {
    tc.set(this, void 0), UB(this, tc, new Set(e), "f"), Object.freeze(this);
  }
  get size() {
    return Xi(this, tc, "f").size;
  }
  [(tc = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return Xi(this, tc, "f")[Symbol.iterator]();
  }
  entries() {
    return Xi(this, tc, "f").entries();
  }
  forEach(e, t) {
    return Xi(this, tc, "f").forEach((n, i, s) => e.call(t, n, i, this));
  }
  has(e) {
    return Xi(this, tc, "f").has(e);
  }
  keys() {
    return Xi(this, tc, "f").keys();
  }
  values() {
    return Xi(this, tc, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((e) => String(e)).join(", ")} ` : ""}}`;
  }
}
Ag.FrozenSet = hA;
Object.freeze(uA);
Object.freeze(uA.prototype);
Object.freeze(hA);
Object.freeze(hA.prototype);
var jB = {}, fA = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.calculateNumberSize = r.calculateStringSize = r.isASCII = r.isPlainObject = r.ESCAPE_CHARACTERS_REGEXP = r.JsonSize = r.hasProperty = r.isObject = r.isNullOrUndefined = r.isNonEmptyArray = void 0;
  function e(u) {
    return Array.isArray(u) && u.length > 0;
  }
  r.isNonEmptyArray = e;
  function t(u) {
    return u == null;
  }
  r.isNullOrUndefined = t;
  function n(u) {
    return !!u && typeof u == "object" && !Array.isArray(u);
  }
  r.isObject = n;
  const i = (u, f) => Object.hasOwnProperty.call(u, f);
  r.hasProperty = i, function(u) {
    u[u.Null = 4] = "Null", u[u.Comma = 1] = "Comma", u[u.Wrapper = 1] = "Wrapper", u[u.True = 4] = "True", u[u.False = 5] = "False", u[u.Quote = 1] = "Quote", u[u.Colon = 1] = "Colon", u[u.Date = 24] = "Date";
  }(r.JsonSize || (r.JsonSize = {})), r.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function s(u) {
    if (typeof u != "object" || u === null)
      return !1;
    try {
      let f = u;
      for (; Object.getPrototypeOf(f) !== null; )
        f = Object.getPrototypeOf(f);
      return Object.getPrototypeOf(u) === f;
    } catch {
      return !1;
    }
  }
  r.isPlainObject = s;
  function o(u) {
    return u.charCodeAt(0) <= 127;
  }
  r.isASCII = o;
  function a(u) {
    var f;
    return u.split("").reduce((m, y) => o(y) ? m + 1 : m + 2, 0) + ((f = u.match(r.ESCAPE_CHARACTERS_REGEXP)) !== null && f !== void 0 ? f : []).length;
  }
  r.calculateStringSize = a;
  function c(u) {
    return u.toString().length;
  }
  r.calculateNumberSize = c;
})(fA);
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.validateJsonAndGetSize = r.getJsonRpcIdValidator = r.assertIsJsonRpcError = r.isJsonRpcError = r.assertIsJsonRpcFailure = r.isJsonRpcFailure = r.assertIsJsonRpcSuccess = r.isJsonRpcSuccess = r.assertIsJsonRpcResponse = r.isJsonRpcResponse = r.assertIsPendingJsonRpcResponse = r.isPendingJsonRpcResponse = r.JsonRpcResponseStruct = r.JsonRpcFailureStruct = r.JsonRpcSuccessStruct = r.PendingJsonRpcResponseStruct = r.assertIsJsonRpcRequest = r.isJsonRpcRequest = r.assertIsJsonRpcNotification = r.isJsonRpcNotification = r.JsonRpcNotificationStruct = r.JsonRpcRequestStruct = r.JsonRpcParamsStruct = r.JsonRpcErrorStruct = r.JsonRpcIdStruct = r.JsonRpcVersionStruct = r.jsonrpc2 = r.isValidJson = r.JsonStruct = void 0;
  const e = jd, t = wi, n = fA;
  r.JsonStruct = (0, e.define)("Json", (L) => {
    const [P] = D(L, !0);
    return P ? !0 : "Expected a valid JSON-serializable value";
  });
  function i(L) {
    return (0, e.is)(L, r.JsonStruct);
  }
  r.isValidJson = i, r.jsonrpc2 = "2.0", r.JsonRpcVersionStruct = (0, e.literal)(r.jsonrpc2), r.JsonRpcIdStruct = (0, e.nullable)((0, e.union)([(0, e.number)(), (0, e.string)()])), r.JsonRpcErrorStruct = (0, e.object)({
    code: (0, e.integer)(),
    message: (0, e.string)(),
    data: (0, e.optional)(r.JsonStruct),
    stack: (0, e.optional)((0, e.string)())
  }), r.JsonRpcParamsStruct = (0, e.optional)((0, e.union)([(0, e.record)((0, e.string)(), r.JsonStruct), (0, e.array)(r.JsonStruct)])), r.JsonRpcRequestStruct = (0, e.object)({
    id: r.JsonRpcIdStruct,
    jsonrpc: r.JsonRpcVersionStruct,
    method: (0, e.string)(),
    params: r.JsonRpcParamsStruct
  }), r.JsonRpcNotificationStruct = (0, e.omit)(r.JsonRpcRequestStruct, ["id"]);
  function s(L) {
    return (0, e.is)(L, r.JsonRpcNotificationStruct);
  }
  r.isJsonRpcNotification = s;
  function o(L, P) {
    (0, t.assertStruct)(L, r.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", P);
  }
  r.assertIsJsonRpcNotification = o;
  function a(L) {
    return (0, e.is)(L, r.JsonRpcRequestStruct);
  }
  r.isJsonRpcRequest = a;
  function c(L, P) {
    (0, t.assertStruct)(L, r.JsonRpcRequestStruct, "Invalid JSON-RPC request", P);
  }
  r.assertIsJsonRpcRequest = c, r.PendingJsonRpcResponseStruct = (0, e.object)({
    id: r.JsonRpcIdStruct,
    jsonrpc: r.JsonRpcVersionStruct,
    result: (0, e.optional)((0, e.unknown)()),
    error: (0, e.optional)(r.JsonRpcErrorStruct)
  }), r.JsonRpcSuccessStruct = (0, e.object)({
    id: r.JsonRpcIdStruct,
    jsonrpc: r.JsonRpcVersionStruct,
    result: r.JsonStruct
  }), r.JsonRpcFailureStruct = (0, e.object)({
    id: r.JsonRpcIdStruct,
    jsonrpc: r.JsonRpcVersionStruct,
    error: r.JsonRpcErrorStruct
  }), r.JsonRpcResponseStruct = (0, e.union)([
    r.JsonRpcSuccessStruct,
    r.JsonRpcFailureStruct
  ]);
  function u(L) {
    return (0, e.is)(L, r.PendingJsonRpcResponseStruct);
  }
  r.isPendingJsonRpcResponse = u;
  function f(L, P) {
    (0, t.assertStruct)(L, r.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", P);
  }
  r.assertIsPendingJsonRpcResponse = f;
  function d(L) {
    return (0, e.is)(L, r.JsonRpcResponseStruct);
  }
  r.isJsonRpcResponse = d;
  function m(L, P) {
    (0, t.assertStruct)(L, r.JsonRpcResponseStruct, "Invalid JSON-RPC response", P);
  }
  r.assertIsJsonRpcResponse = m;
  function y(L) {
    return (0, e.is)(L, r.JsonRpcSuccessStruct);
  }
  r.isJsonRpcSuccess = y;
  function b(L, P) {
    (0, t.assertStruct)(L, r.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", P);
  }
  r.assertIsJsonRpcSuccess = b;
  function I(L) {
    return (0, e.is)(L, r.JsonRpcFailureStruct);
  }
  r.isJsonRpcFailure = I;
  function k(L, P) {
    (0, t.assertStruct)(L, r.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", P);
  }
  r.assertIsJsonRpcFailure = k;
  function R(L) {
    return (0, e.is)(L, r.JsonRpcErrorStruct);
  }
  r.isJsonRpcError = R;
  function T(L, P) {
    (0, t.assertStruct)(L, r.JsonRpcErrorStruct, "Invalid JSON-RPC error", P);
  }
  r.assertIsJsonRpcError = T;
  function $(L) {
    const { permitEmptyString: P, permitFractions: v, permitNull: F } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, L);
    return (te) => !!(typeof te == "number" && (v || Number.isInteger(te)) || typeof te == "string" && (P || te.length > 0) || F && te === null);
  }
  r.getJsonRpcIdValidator = $;
  function D(L, P = !1) {
    const v = /* @__PURE__ */ new Set();
    function F(X, te) {
      if (X === void 0)
        return [!1, 0];
      if (X === null)
        return [!0, te ? 0 : n.JsonSize.Null];
      const se = typeof X;
      try {
        if (se === "function")
          return [!1, 0];
        if (se === "string" || X instanceof String)
          return [
            !0,
            te ? 0 : (0, n.calculateStringSize)(X) + n.JsonSize.Quote * 2
          ];
        if (se === "boolean" || X instanceof Boolean)
          return te ? [!0, 0] : [!0, X == !0 ? n.JsonSize.True : n.JsonSize.False];
        if (se === "number" || X instanceof Number)
          return te ? [!0, 0] : [!0, (0, n.calculateNumberSize)(X)];
        if (X instanceof Date)
          return te ? [!0, 0] : [
            !0,
            // Note: Invalid dates will serialize to null
            isNaN(X.getDate()) ? n.JsonSize.Null : n.JsonSize.Date + n.JsonSize.Quote * 2
          ];
      } catch {
        return [!1, 0];
      }
      if (!(0, n.isPlainObject)(X) && !Array.isArray(X))
        return [!1, 0];
      if (v.has(X))
        return [!1, 0];
      v.add(X);
      try {
        return [
          !0,
          Object.entries(X).reduce(
            (we, [H, p], w, x) => {
              let [N, O] = F(p, te);
              if (!N)
                throw new Error("JSON validation did not pass. Validation process stopped.");
              if (v.delete(X), te)
                return 0;
              const U = Array.isArray(X) ? 0 : H.length + n.JsonSize.Comma + n.JsonSize.Colon * 2, q = w < x.length - 1 ? n.JsonSize.Comma : 0;
              return we + U + O + q;
            },
            // Starts at 2 because the serialized JSON string data (plain text)
            // will minimally contain {}/[]
            te ? 0 : n.JsonSize.Wrapper * 2
          )
        ];
      } catch {
        return [!1, 0];
      }
    }
    return F(L, P);
  }
  r.validateJsonAndGetSize = D;
})(jB);
var Ig = {}, aS = { exports: {} }, X4, iN;
function Gye() {
  if (iN)
    return X4;
  iN = 1;
  var r = 1e3, e = r * 60, t = e * 60, n = t * 24, i = n * 7, s = n * 365.25;
  X4 = function(f, d) {
    d = d || {};
    var m = typeof f;
    if (m === "string" && f.length > 0)
      return o(f);
    if (m === "number" && isFinite(f))
      return d.long ? c(f) : a(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(f)
    );
  };
  function o(f) {
    if (f = String(f), !(f.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        f
      );
      if (d) {
        var m = parseFloat(d[1]), y = (d[2] || "ms").toLowerCase();
        switch (y) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return m * s;
          case "weeks":
          case "week":
          case "w":
            return m * i;
          case "days":
          case "day":
          case "d":
            return m * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return m * t;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return m * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return m * r;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return m;
          default:
            return;
        }
      }
    }
  }
  function a(f) {
    var d = Math.abs(f);
    return d >= n ? Math.round(f / n) + "d" : d >= t ? Math.round(f / t) + "h" : d >= e ? Math.round(f / e) + "m" : d >= r ? Math.round(f / r) + "s" : f + "ms";
  }
  function c(f) {
    var d = Math.abs(f);
    return d >= n ? u(f, d, n, "day") : d >= t ? u(f, d, t, "hour") : d >= e ? u(f, d, e, "minute") : d >= r ? u(f, d, r, "second") : f + " ms";
  }
  function u(f, d, m, y) {
    var b = d >= m * 1.5;
    return Math.round(f / m) + " " + y + (b ? "s" : "");
  }
  return X4;
}
function Kye(r) {
  t.debug = t, t.default = t, t.coerce = c, t.disable = s, t.enable = i, t.enabled = o, t.humanize = Gye(), t.destroy = u, Object.keys(r).forEach((f) => {
    t[f] = r[f];
  }), t.names = [], t.skips = [], t.formatters = {};
  function e(f) {
    let d = 0;
    for (let m = 0; m < f.length; m++)
      d = (d << 5) - d + f.charCodeAt(m), d |= 0;
    return t.colors[Math.abs(d) % t.colors.length];
  }
  t.selectColor = e;
  function t(f) {
    let d, m = null, y, b;
    function I(...k) {
      if (!I.enabled)
        return;
      const R = I, T = Number(/* @__PURE__ */ new Date()), $ = T - (d || T);
      R.diff = $, R.prev = d, R.curr = T, d = T, k[0] = t.coerce(k[0]), typeof k[0] != "string" && k.unshift("%O");
      let D = 0;
      k[0] = k[0].replace(/%([a-zA-Z%])/g, (P, v) => {
        if (P === "%%")
          return "%";
        D++;
        const F = t.formatters[v];
        if (typeof F == "function") {
          const X = k[D];
          P = F.call(R, X), k.splice(D, 1), D--;
        }
        return P;
      }), t.formatArgs.call(R, k), (R.log || t.log).apply(R, k);
    }
    return I.namespace = f, I.useColors = t.useColors(), I.color = t.selectColor(f), I.extend = n, I.destroy = t.destroy, Object.defineProperty(I, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => m !== null ? m : (y !== t.namespaces && (y = t.namespaces, b = t.enabled(f)), b),
      set: (k) => {
        m = k;
      }
    }), typeof t.init == "function" && t.init(I), I;
  }
  function n(f, d) {
    const m = t(this.namespace + (typeof d > "u" ? ":" : d) + f);
    return m.log = this.log, m;
  }
  function i(f) {
    t.save(f), t.namespaces = f, t.names = [], t.skips = [];
    let d;
    const m = (typeof f == "string" ? f : "").split(/[\s,]+/), y = m.length;
    for (d = 0; d < y; d++)
      m[d] && (f = m[d].replace(/\*/g, ".*?"), f[0] === "-" ? t.skips.push(new RegExp("^" + f.slice(1) + "$")) : t.names.push(new RegExp("^" + f + "$")));
  }
  function s() {
    const f = [
      ...t.names.map(a),
      ...t.skips.map(a).map((d) => "-" + d)
    ].join(",");
    return t.enable(""), f;
  }
  function o(f) {
    if (f[f.length - 1] === "*")
      return !0;
    let d, m;
    for (d = 0, m = t.skips.length; d < m; d++)
      if (t.skips[d].test(f))
        return !1;
    for (d = 0, m = t.names.length; d < m; d++)
      if (t.names[d].test(f))
        return !0;
    return !1;
  }
  function a(f) {
    return f.toString().substring(2, f.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(f) {
    return f instanceof Error ? f.stack || f.message : f;
  }
  function u() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return t.enable(t.load()), t;
}
var Zye = Kye;
(function(r, e) {
  e.formatArgs = n, e.save = i, e.load = s, e.useColors = t, e.storage = o(), e.destroy = /* @__PURE__ */ (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function t() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + r.exports.humanize(this.diff), !this.useColors)
      return;
    const u = "color: " + this.color;
    c.splice(1, 0, u, "color: inherit");
    let f = 0, d = 0;
    c[0].replace(/%[a-zA-Z%]/g, (m) => {
      m !== "%%" && (f++, m === "%c" && (d = f));
    }), c.splice(d, 0, u);
  }
  e.log = console.debug || console.log || (() => {
  });
  function i(c) {
    try {
      c ? e.storage.setItem("debug", c) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let c;
    try {
      c = e.storage.getItem("debug");
    } catch {
    }
    return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  r.exports = Zye(e);
  const { formatters: a } = r.exports;
  a.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (u) {
      return "[UnexpectedJSONParseError]: " + u.message;
    }
  };
})(aS, aS.exports);
var Jye = aS.exports, Qye = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Ig, "__esModule", { value: !0 });
Ig.createModuleLogger = Ig.createProjectLogger = void 0;
const Yye = Qye(Jye), Xye = (0, Yye.default)("metamask");
function eve(r) {
  return Xye.extend(r);
}
Ig.createProjectLogger = eve;
function tve(r, e) {
  return r.extend(e);
}
Ig.createModuleLogger = tve;
var bc = {};
Object.defineProperty(bc, "__esModule", { value: !0 });
bc.hexToBigInt = bc.hexToNumber = bc.bigIntToHex = bc.numberToHex = void 0;
const t0 = wi, vw = Ty, rve = (r) => ((0, t0.assert)(typeof r == "number", "Value must be a number."), (0, t0.assert)(r >= 0, "Value must be a non-negative number."), (0, t0.assert)(Number.isSafeInteger(r), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, vw.add0x)(r.toString(16)));
bc.numberToHex = rve;
const nve = (r) => ((0, t0.assert)(typeof r == "bigint", "Value must be a bigint."), (0, t0.assert)(r >= 0, "Value must be a non-negative bigint."), (0, vw.add0x)(r.toString(16)));
bc.bigIntToHex = nve;
const ive = (r) => {
  (0, vw.assertIsHexString)(r);
  const e = parseInt(r, 16);
  return (0, t0.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `hexToBigInt` instead."), e;
};
bc.hexToNumber = ive;
const sve = (r) => ((0, vw.assertIsHexString)(r), BigInt((0, vw.add0x)(r)));
bc.hexToBigInt = sve;
var WB = {};
Object.defineProperty(WB, "__esModule", { value: !0 });
var HB = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.timeSince = r.inMilliseconds = r.Duration = void 0, function(s) {
    s[s.Millisecond = 1] = "Millisecond", s[s.Second = 1e3] = "Second", s[s.Minute = 6e4] = "Minute", s[s.Hour = 36e5] = "Hour", s[s.Day = 864e5] = "Day", s[s.Week = 6048e5] = "Week", s[s.Year = 31536e6] = "Year";
  }(r.Duration || (r.Duration = {}));
  const e = (s) => Number.isInteger(s) && s >= 0, t = (s, o) => {
    if (!e(s))
      throw new Error(`"${o}" must be a non-negative integer. Received: "${s}".`);
  };
  function n(s, o) {
    return t(s, "count"), s * o;
  }
  r.inMilliseconds = n;
  function i(s) {
    return t(s, "timestamp"), Date.now() - s;
  }
  r.timeSince = i;
})(HB);
var zB = {}, cS = { exports: {} };
const ove = "2.0.0", VB = 256, ave = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, cve = 16, lve = VB - 6, uve = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var T3 = {
  MAX_LENGTH: VB,
  MAX_SAFE_COMPONENT_LENGTH: cve,
  MAX_SAFE_BUILD_LENGTH: lve,
  MAX_SAFE_INTEGER: ave,
  RELEASE_TYPES: uve,
  SEMVER_SPEC_VERSION: ove,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const hve = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...r) => console.error("SEMVER", ...r) : () => {
};
var O3 = hve;
(function(r, e) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: t,
    MAX_SAFE_BUILD_LENGTH: n,
    MAX_LENGTH: i
  } = T3, s = O3;
  e = r.exports = {};
  const o = e.re = [], a = e.safeRe = [], c = e.src = [], u = e.t = {};
  let f = 0;
  const d = "[a-zA-Z0-9-]", m = [
    ["\\s", 1],
    ["\\d", i],
    [d, n]
  ], y = (I) => {
    for (const [k, R] of m)
      I = I.split(`${k}*`).join(`${k}{0,${R}}`).split(`${k}+`).join(`${k}{1,${R}}`);
    return I;
  }, b = (I, k, R) => {
    const T = y(k), $ = f++;
    s(I, $, k), u[I] = $, c[$] = k, o[$] = new RegExp(k, R ? "g" : void 0), a[$] = new RegExp(T, R ? "g" : void 0);
  };
  b("NUMERICIDENTIFIER", "0|[1-9]\\d*"), b("NUMERICIDENTIFIERLOOSE", "\\d+"), b("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${d}*`), b("MAINVERSION", `(${c[u.NUMERICIDENTIFIER]})\\.(${c[u.NUMERICIDENTIFIER]})\\.(${c[u.NUMERICIDENTIFIER]})`), b("MAINVERSIONLOOSE", `(${c[u.NUMERICIDENTIFIERLOOSE]})\\.(${c[u.NUMERICIDENTIFIERLOOSE]})\\.(${c[u.NUMERICIDENTIFIERLOOSE]})`), b("PRERELEASEIDENTIFIER", `(?:${c[u.NUMERICIDENTIFIER]}|${c[u.NONNUMERICIDENTIFIER]})`), b("PRERELEASEIDENTIFIERLOOSE", `(?:${c[u.NUMERICIDENTIFIERLOOSE]}|${c[u.NONNUMERICIDENTIFIER]})`), b("PRERELEASE", `(?:-(${c[u.PRERELEASEIDENTIFIER]}(?:\\.${c[u.PRERELEASEIDENTIFIER]})*))`), b("PRERELEASELOOSE", `(?:-?(${c[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[u.PRERELEASEIDENTIFIERLOOSE]})*))`), b("BUILDIDENTIFIER", `${d}+`), b("BUILD", `(?:\\+(${c[u.BUILDIDENTIFIER]}(?:\\.${c[u.BUILDIDENTIFIER]})*))`), b("FULLPLAIN", `v?${c[u.MAINVERSION]}${c[u.PRERELEASE]}?${c[u.BUILD]}?`), b("FULL", `^${c[u.FULLPLAIN]}$`), b("LOOSEPLAIN", `[v=\\s]*${c[u.MAINVERSIONLOOSE]}${c[u.PRERELEASELOOSE]}?${c[u.BUILD]}?`), b("LOOSE", `^${c[u.LOOSEPLAIN]}$`), b("GTLT", "((?:<|>)?=?)"), b("XRANGEIDENTIFIERLOOSE", `${c[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), b("XRANGEIDENTIFIER", `${c[u.NUMERICIDENTIFIER]}|x|X|\\*`), b("XRANGEPLAIN", `[v=\\s]*(${c[u.XRANGEIDENTIFIER]})(?:\\.(${c[u.XRANGEIDENTIFIER]})(?:\\.(${c[u.XRANGEIDENTIFIER]})(?:${c[u.PRERELEASE]})?${c[u.BUILD]}?)?)?`), b("XRANGEPLAINLOOSE", `[v=\\s]*(${c[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[u.XRANGEIDENTIFIERLOOSE]})(?:${c[u.PRERELEASELOOSE]})?${c[u.BUILD]}?)?)?`), b("XRANGE", `^${c[u.GTLT]}\\s*${c[u.XRANGEPLAIN]}$`), b("XRANGELOOSE", `^${c[u.GTLT]}\\s*${c[u.XRANGEPLAINLOOSE]}$`), b("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), b("COERCERTL", c[u.COERCE], !0), b("LONETILDE", "(?:~>?)"), b("TILDETRIM", `(\\s*)${c[u.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", b("TILDE", `^${c[u.LONETILDE]}${c[u.XRANGEPLAIN]}$`), b("TILDELOOSE", `^${c[u.LONETILDE]}${c[u.XRANGEPLAINLOOSE]}$`), b("LONECARET", "(?:\\^)"), b("CARETTRIM", `(\\s*)${c[u.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", b("CARET", `^${c[u.LONECARET]}${c[u.XRANGEPLAIN]}$`), b("CARETLOOSE", `^${c[u.LONECARET]}${c[u.XRANGEPLAINLOOSE]}$`), b("COMPARATORLOOSE", `^${c[u.GTLT]}\\s*(${c[u.LOOSEPLAIN]})$|^$`), b("COMPARATOR", `^${c[u.GTLT]}\\s*(${c[u.FULLPLAIN]})$|^$`), b("COMPARATORTRIM", `(\\s*)${c[u.GTLT]}\\s*(${c[u.LOOSEPLAIN]}|${c[u.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", b("HYPHENRANGE", `^\\s*(${c[u.XRANGEPLAIN]})\\s+-\\s+(${c[u.XRANGEPLAIN]})\\s*$`), b("HYPHENRANGELOOSE", `^\\s*(${c[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[u.XRANGEPLAINLOOSE]})\\s*$`), b("STAR", "(<|>)?=?\\s*\\*"), b("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), b("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(cS, cS.exports);
var Oy = cS.exports;
const fve = Object.freeze({ loose: !0 }), dve = Object.freeze({}), pve = (r) => r ? typeof r != "object" ? fve : r : dve;
var dA = pve;
const sN = /^[0-9]+$/, qB = (r, e) => {
  const t = sN.test(r), n = sN.test(e);
  return t && n && (r = +r, e = +e), r === e ? 0 : t && !n ? -1 : n && !t ? 1 : r < e ? -1 : 1;
}, gve = (r, e) => qB(e, r);
var GB = {
  compareIdentifiers: qB,
  rcompareIdentifiers: gve
};
const gb = O3, { MAX_LENGTH: oN, MAX_SAFE_INTEGER: mb } = T3, { safeRe: aN, t: cN } = Oy, mve = dA, { compareIdentifiers: mp } = GB;
let wve = class ic {
  constructor(e, t) {
    if (t = mve(t), e instanceof ic) {
      if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
    if (e.length > oN)
      throw new TypeError(
        `version is longer than ${oN} characters`
      );
    gb("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease;
    const n = e.trim().match(t.loose ? aN[cN.LOOSE] : aN[cN.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${e}`);
    if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > mb || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > mb || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > mb || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const s = +i;
        if (s >= 0 && s < mb)
          return s;
      }
      return i;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e) {
    if (gb("SemVer.compare", this.version, this.options, e), !(e instanceof ic)) {
      if (typeof e == "string" && e === this.version)
        return 0;
      e = new ic(e, this.options);
    }
    return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
  }
  compareMain(e) {
    return e instanceof ic || (e = new ic(e, this.options)), mp(this.major, e.major) || mp(this.minor, e.minor) || mp(this.patch, e.patch);
  }
  comparePre(e) {
    if (e instanceof ic || (e = new ic(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    let t = 0;
    do {
      const n = this.prerelease[t], i = e.prerelease[t];
      if (gb("prerelease compare", t, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return mp(n, i);
    } while (++t);
  }
  compareBuild(e) {
    e instanceof ic || (e = new ic(e, this.options));
    let t = 0;
    do {
      const n = this.build[t], i = e.build[t];
      if (gb("prerelease compare", t, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return mp(n, i);
    } while (++t);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(e, t, n) {
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t, n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t, n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t, n), this.inc("pre", t, n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t, n), this.inc("pre", t, n);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const i = Number(n) ? 1 : 0;
        if (!t && n === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [i];
        else {
          let s = this.prerelease.length;
          for (; --s >= 0; )
            typeof this.prerelease[s] == "number" && (this.prerelease[s]++, s = -2);
          if (s === -1) {
            if (t === this.prerelease.join(".") && n === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(i);
          }
        }
        if (t) {
          let s = [t, i];
          n === !1 && (s = [t]), mp(this.prerelease[0], t) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = s) : this.prerelease = s;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${e}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var ds = wve;
const lN = ds, yve = (r, e, t = !1) => {
  if (r instanceof lN)
    return r;
  try {
    return new lN(r, e);
  } catch (n) {
    if (!t)
      return null;
    throw n;
  }
};
var e1 = yve;
const vve = e1, bve = (r, e) => {
  const t = vve(r, e);
  return t ? t.version : null;
};
var _ve = bve;
const Eve = e1, xve = (r, e) => {
  const t = Eve(r.trim().replace(/^[=v]+/, ""), e);
  return t ? t.version : null;
};
var Sve = xve;
const uN = ds, Cve = (r, e, t, n, i) => {
  typeof t == "string" && (i = n, n = t, t = void 0);
  try {
    return new uN(
      r instanceof uN ? r.version : r,
      t
    ).inc(e, n, i).version;
  } catch {
    return null;
  }
};
var Ave = Cve;
const hN = e1, Ive = (r, e) => {
  const t = hN(r, null, !0), n = hN(e, null, !0), i = t.compare(n);
  if (i === 0)
    return null;
  const s = i > 0, o = s ? t : n, a = s ? n : t, c = !!o.prerelease.length;
  if (!!a.prerelease.length && !c)
    return !a.patch && !a.minor ? "major" : o.patch ? "patch" : o.minor ? "minor" : "major";
  const f = c ? "pre" : "";
  return t.major !== n.major ? f + "major" : t.minor !== n.minor ? f + "minor" : t.patch !== n.patch ? f + "patch" : "prerelease";
};
var Rve = Ive;
const Tve = ds, Ove = (r, e) => new Tve(r, e).major;
var Nve = Ove;
const Pve = ds, Mve = (r, e) => new Pve(r, e).minor;
var Dve = Mve;
const kve = ds, $ve = (r, e) => new kve(r, e).patch;
var Lve = $ve;
const Bve = e1, Fve = (r, e) => {
  const t = Bve(r, e);
  return t && t.prerelease.length ? t.prerelease : null;
};
var Uve = Fve;
const fN = ds, jve = (r, e, t) => new fN(r, t).compare(new fN(e, t));
var Wa = jve;
const Wve = Wa, Hve = (r, e, t) => Wve(e, r, t);
var zve = Hve;
const Vve = Wa, qve = (r, e) => Vve(r, e, !0);
var Gve = qve;
const dN = ds, Kve = (r, e, t) => {
  const n = new dN(r, t), i = new dN(e, t);
  return n.compare(i) || n.compareBuild(i);
};
var pA = Kve;
const Zve = pA, Jve = (r, e) => r.sort((t, n) => Zve(t, n, e));
var Qve = Jve;
const Yve = pA, Xve = (r, e) => r.sort((t, n) => Yve(n, t, e));
var ebe = Xve;
const tbe = Wa, rbe = (r, e, t) => tbe(r, e, t) > 0;
var N3 = rbe;
const nbe = Wa, ibe = (r, e, t) => nbe(r, e, t) < 0;
var gA = ibe;
const sbe = Wa, obe = (r, e, t) => sbe(r, e, t) === 0;
var KB = obe;
const abe = Wa, cbe = (r, e, t) => abe(r, e, t) !== 0;
var ZB = cbe;
const lbe = Wa, ube = (r, e, t) => lbe(r, e, t) >= 0;
var mA = ube;
const hbe = Wa, fbe = (r, e, t) => hbe(r, e, t) <= 0;
var wA = fbe;
const dbe = KB, pbe = ZB, gbe = N3, mbe = mA, wbe = gA, ybe = wA, vbe = (r, e, t, n) => {
  switch (e) {
    case "===":
      return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r === t;
    case "!==":
      return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r !== t;
    case "":
    case "=":
    case "==":
      return dbe(r, t, n);
    case "!=":
      return pbe(r, t, n);
    case ">":
      return gbe(r, t, n);
    case ">=":
      return mbe(r, t, n);
    case "<":
      return wbe(r, t, n);
    case "<=":
      return ybe(r, t, n);
    default:
      throw new TypeError(`Invalid operator: ${e}`);
  }
};
var JB = vbe;
const bbe = ds, _be = e1, { safeRe: wb, t: yb } = Oy, Ebe = (r, e) => {
  if (r instanceof bbe)
    return r;
  if (typeof r == "number" && (r = String(r)), typeof r != "string")
    return null;
  e = e || {};
  let t = null;
  if (!e.rtl)
    t = r.match(wb[yb.COERCE]);
  else {
    let n;
    for (; (n = wb[yb.COERCERTL].exec(r)) && (!t || t.index + t[0].length !== r.length); )
      (!t || n.index + n[0].length !== t.index + t[0].length) && (t = n), wb[yb.COERCERTL].lastIndex = n.index + n[1].length + n[2].length;
    wb[yb.COERCERTL].lastIndex = -1;
  }
  return t === null ? null : _be(`${t[2]}.${t[3] || "0"}.${t[4] || "0"}`, e);
};
var xbe = Ebe, e6, pN;
function Sbe() {
  return pN || (pN = 1, e6 = function(r) {
    r.prototype[Symbol.iterator] = function* () {
      for (let e = this.head; e; e = e.next)
        yield e.value;
    };
  }), e6;
}
var Cbe = Ar;
Ar.Node = vd;
Ar.create = Ar;
function Ar(r) {
  var e = this;
  if (e instanceof Ar || (e = new Ar()), e.tail = null, e.head = null, e.length = 0, r && typeof r.forEach == "function")
    r.forEach(function(i) {
      e.push(i);
    });
  else if (arguments.length > 0)
    for (var t = 0, n = arguments.length; t < n; t++)
      e.push(arguments[t]);
  return e;
}
Ar.prototype.removeNode = function(r) {
  if (r.list !== this)
    throw new Error("removing node which does not belong to this list");
  var e = r.next, t = r.prev;
  return e && (e.prev = t), t && (t.next = e), r === this.head && (this.head = e), r === this.tail && (this.tail = t), r.list.length--, r.next = null, r.prev = null, r.list = null, e;
};
Ar.prototype.unshiftNode = function(r) {
  if (r !== this.head) {
    r.list && r.list.removeNode(r);
    var e = this.head;
    r.list = this, r.next = e, e && (e.prev = r), this.head = r, this.tail || (this.tail = r), this.length++;
  }
};
Ar.prototype.pushNode = function(r) {
  if (r !== this.tail) {
    r.list && r.list.removeNode(r);
    var e = this.tail;
    r.list = this, r.prev = e, e && (e.next = r), this.tail = r, this.head || (this.head = r), this.length++;
  }
};
Ar.prototype.push = function() {
  for (var r = 0, e = arguments.length; r < e; r++)
    Ibe(this, arguments[r]);
  return this.length;
};
Ar.prototype.unshift = function() {
  for (var r = 0, e = arguments.length; r < e; r++)
    Rbe(this, arguments[r]);
  return this.length;
};
Ar.prototype.pop = function() {
  if (this.tail) {
    var r = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, r;
  }
};
Ar.prototype.shift = function() {
  if (this.head) {
    var r = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, r;
  }
};
Ar.prototype.forEach = function(r, e) {
  e = e || this;
  for (var t = this.head, n = 0; t !== null; n++)
    r.call(e, t.value, n, this), t = t.next;
};
Ar.prototype.forEachReverse = function(r, e) {
  e = e || this;
  for (var t = this.tail, n = this.length - 1; t !== null; n--)
    r.call(e, t.value, n, this), t = t.prev;
};
Ar.prototype.get = function(r) {
  for (var e = 0, t = this.head; t !== null && e < r; e++)
    t = t.next;
  if (e === r && t !== null)
    return t.value;
};
Ar.prototype.getReverse = function(r) {
  for (var e = 0, t = this.tail; t !== null && e < r; e++)
    t = t.prev;
  if (e === r && t !== null)
    return t.value;
};
Ar.prototype.map = function(r, e) {
  e = e || this;
  for (var t = new Ar(), n = this.head; n !== null; )
    t.push(r.call(e, n.value, this)), n = n.next;
  return t;
};
Ar.prototype.mapReverse = function(r, e) {
  e = e || this;
  for (var t = new Ar(), n = this.tail; n !== null; )
    t.push(r.call(e, n.value, this)), n = n.prev;
  return t;
};
Ar.prototype.reduce = function(r, e) {
  var t, n = this.head;
  if (arguments.length > 1)
    t = e;
  else if (this.head)
    n = this.head.next, t = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; n !== null; i++)
    t = r(t, n.value, i), n = n.next;
  return t;
};
Ar.prototype.reduceReverse = function(r, e) {
  var t, n = this.tail;
  if (arguments.length > 1)
    t = e;
  else if (this.tail)
    n = this.tail.prev, t = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; n !== null; i--)
    t = r(t, n.value, i), n = n.prev;
  return t;
};
Ar.prototype.toArray = function() {
  for (var r = new Array(this.length), e = 0, t = this.head; t !== null; e++)
    r[e] = t.value, t = t.next;
  return r;
};
Ar.prototype.toArrayReverse = function() {
  for (var r = new Array(this.length), e = 0, t = this.tail; t !== null; e++)
    r[e] = t.value, t = t.prev;
  return r;
};
Ar.prototype.slice = function(r, e) {
  e = e || this.length, e < 0 && (e += this.length), r = r || 0, r < 0 && (r += this.length);
  var t = new Ar();
  if (e < r || e < 0)
    return t;
  r < 0 && (r = 0), e > this.length && (e = this.length);
  for (var n = 0, i = this.head; i !== null && n < r; n++)
    i = i.next;
  for (; i !== null && n < e; n++, i = i.next)
    t.push(i.value);
  return t;
};
Ar.prototype.sliceReverse = function(r, e) {
  e = e || this.length, e < 0 && (e += this.length), r = r || 0, r < 0 && (r += this.length);
  var t = new Ar();
  if (e < r || e < 0)
    return t;
  r < 0 && (r = 0), e > this.length && (e = this.length);
  for (var n = this.length, i = this.tail; i !== null && n > e; n--)
    i = i.prev;
  for (; i !== null && n > r; n--, i = i.prev)
    t.push(i.value);
  return t;
};
Ar.prototype.splice = function(r, e, ...t) {
  r > this.length && (r = this.length - 1), r < 0 && (r = this.length + r);
  for (var n = 0, i = this.head; i !== null && n < r; n++)
    i = i.next;
  for (var s = [], n = 0; i && n < e; n++)
    s.push(i.value), i = this.removeNode(i);
  i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
  for (var n = 0; n < t.length; n++)
    i = Abe(this, i, t[n]);
  return s;
};
Ar.prototype.reverse = function() {
  for (var r = this.head, e = this.tail, t = r; t !== null; t = t.prev) {
    var n = t.prev;
    t.prev = t.next, t.next = n;
  }
  return this.head = e, this.tail = r, this;
};
function Abe(r, e, t) {
  var n = e === r.head ? new vd(t, null, e, r) : new vd(t, e, e.next, r);
  return n.next === null && (r.tail = n), n.prev === null && (r.head = n), r.length++, n;
}
function Ibe(r, e) {
  r.tail = new vd(e, r.tail, null, r), r.head || (r.head = r.tail), r.length++;
}
function Rbe(r, e) {
  r.head = new vd(e, null, r.head, r), r.tail || (r.tail = r.head), r.length++;
}
function vd(r, e, t, n) {
  if (!(this instanceof vd))
    return new vd(r, e, t, n);
  this.list = n, this.value = r, e ? (e.next = this, this.prev = e) : this.prev = null, t ? (t.prev = this, this.next = t) : this.next = null;
}
try {
  Sbe()(Ar);
} catch {
}
const Tbe = Cbe, ef = Symbol("max"), cl = Symbol("length"), wp = Symbol("lengthCalculator"), bm = Symbol("allowStale"), pf = Symbol("maxAge"), nl = Symbol("dispose"), gN = Symbol("noDisposeOnSet"), ii = Symbol("lruList"), la = Symbol("cache"), QB = Symbol("updateAgeOnGet"), t6 = () => 1;
class Obe {
  constructor(e) {
    if (typeof e == "number" && (e = { max: e }), e || (e = {}), e.max && (typeof e.max != "number" || e.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[ef] = e.max || 1 / 0;
    const t = e.length || t6;
    if (this[wp] = typeof t != "function" ? t6 : t, this[bm] = e.stale || !1, e.maxAge && typeof e.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[pf] = e.maxAge || 0, this[nl] = e.dispose, this[gN] = e.noDisposeOnSet || !1, this[QB] = e.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(e) {
    if (typeof e != "number" || e < 0)
      throw new TypeError("max must be a non-negative number");
    this[ef] = e || 1 / 0, W1(this);
  }
  get max() {
    return this[ef];
  }
  set allowStale(e) {
    this[bm] = !!e;
  }
  get allowStale() {
    return this[bm];
  }
  set maxAge(e) {
    if (typeof e != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[pf] = e, W1(this);
  }
  get maxAge() {
    return this[pf];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(e) {
    typeof e != "function" && (e = t6), e !== this[wp] && (this[wp] = e, this[cl] = 0, this[ii].forEach((t) => {
      t.length = this[wp](t.value, t.key), this[cl] += t.length;
    })), W1(this);
  }
  get lengthCalculator() {
    return this[wp];
  }
  get length() {
    return this[cl];
  }
  get itemCount() {
    return this[ii].length;
  }
  rforEach(e, t) {
    t = t || this;
    for (let n = this[ii].tail; n !== null; ) {
      const i = n.prev;
      mN(this, e, n, t), n = i;
    }
  }
  forEach(e, t) {
    t = t || this;
    for (let n = this[ii].head; n !== null; ) {
      const i = n.next;
      mN(this, e, n, t), n = i;
    }
  }
  keys() {
    return this[ii].toArray().map((e) => e.key);
  }
  values() {
    return this[ii].toArray().map((e) => e.value);
  }
  reset() {
    this[nl] && this[ii] && this[ii].length && this[ii].forEach((e) => this[nl](e.key, e.value)), this[la] = /* @__PURE__ */ new Map(), this[ii] = new Tbe(), this[cl] = 0;
  }
  dump() {
    return this[ii].map((e) => X2(this, e) ? !1 : {
      k: e.key,
      v: e.value,
      e: e.now + (e.maxAge || 0)
    }).toArray().filter((e) => e);
  }
  dumpLru() {
    return this[ii];
  }
  set(e, t, n) {
    if (n = n || this[pf], n && typeof n != "number")
      throw new TypeError("maxAge must be a number");
    const i = n ? Date.now() : 0, s = this[wp](t, e);
    if (this[la].has(e)) {
      if (s > this[ef])
        return r0(this, this[la].get(e)), !1;
      const c = this[la].get(e).value;
      return this[nl] && (this[gN] || this[nl](e, c.value)), c.now = i, c.maxAge = n, c.value = t, this[cl] += s - c.length, c.length = s, this.get(e), W1(this), !0;
    }
    const o = new Nbe(e, t, s, i, n);
    return o.length > this[ef] ? (this[nl] && this[nl](e, t), !1) : (this[cl] += o.length, this[ii].unshift(o), this[la].set(e, this[ii].head), W1(this), !0);
  }
  has(e) {
    if (!this[la].has(e))
      return !1;
    const t = this[la].get(e).value;
    return !X2(this, t);
  }
  get(e) {
    return r6(this, e, !0);
  }
  peek(e) {
    return r6(this, e, !1);
  }
  pop() {
    const e = this[ii].tail;
    return e ? (r0(this, e), e.value) : null;
  }
  del(e) {
    r0(this, this[la].get(e));
  }
  load(e) {
    this.reset();
    const t = Date.now();
    for (let n = e.length - 1; n >= 0; n--) {
      const i = e[n], s = i.e || 0;
      if (s === 0)
        this.set(i.k, i.v);
      else {
        const o = s - t;
        o > 0 && this.set(i.k, i.v, o);
      }
    }
  }
  prune() {
    this[la].forEach((e, t) => r6(this, t, !1));
  }
}
const r6 = (r, e, t) => {
  const n = r[la].get(e);
  if (n) {
    const i = n.value;
    if (X2(r, i)) {
      if (r0(r, n), !r[bm])
        return;
    } else
      t && (r[QB] && (n.value.now = Date.now()), r[ii].unshiftNode(n));
    return i.value;
  }
}, X2 = (r, e) => {
  if (!e || !e.maxAge && !r[pf])
    return !1;
  const t = Date.now() - e.now;
  return e.maxAge ? t > e.maxAge : r[pf] && t > r[pf];
}, W1 = (r) => {
  if (r[cl] > r[ef])
    for (let e = r[ii].tail; r[cl] > r[ef] && e !== null; ) {
      const t = e.prev;
      r0(r, e), e = t;
    }
}, r0 = (r, e) => {
  if (e) {
    const t = e.value;
    r[nl] && r[nl](t.key, t.value), r[cl] -= t.length, r[la].delete(t.key), r[ii].removeNode(e);
  }
};
class Nbe {
  constructor(e, t, n, i, s) {
    this.key = e, this.value = t, this.length = n, this.now = i, this.maxAge = s || 0;
  }
}
const mN = (r, e, t, n) => {
  let i = t.value;
  X2(r, i) && (r0(r, t), r[bm] || (i = void 0)), i && e.call(n, i.value, i.key, r);
};
var Pbe = Obe, n6, wN;
function Ha() {
  if (wN)
    return n6;
  wN = 1;
  class r {
    constructor(p, w) {
      if (w = n(w), p instanceof r)
        return p.loose === !!w.loose && p.includePrerelease === !!w.includePrerelease ? p : new r(p.raw, w);
      if (p instanceof i)
        return this.raw = p.value, this.set = [[p]], this.format(), this;
      if (this.options = w, this.loose = !!w.loose, this.includePrerelease = !!w.includePrerelease, this.raw = p.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((x) => this.parseRange(x.trim())).filter((x) => x.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const x = this.set[0];
        if (this.set = this.set.filter((N) => !b(N[0])), this.set.length === 0)
          this.set = [x];
        else if (this.set.length > 1) {
          for (const N of this.set)
            if (N.length === 1 && I(N[0])) {
              this.set = [N];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((p) => p.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(p) {
      const x = ((this.options.includePrerelease && m) | (this.options.loose && y)) + ":" + p, N = t.get(x);
      if (N)
        return N;
      const O = this.options.loose, U = O ? a[c.HYPHENRANGELOOSE] : a[c.HYPHENRANGE];
      p = p.replace(U, se(this.options.includePrerelease)), s("hyphen replace", p), p = p.replace(a[c.COMPARATORTRIM], u), s("comparator trim", p), p = p.replace(a[c.TILDETRIM], f), s("tilde trim", p), p = p.replace(a[c.CARETTRIM], d), s("caret trim", p);
      let q = p.split(" ").map((be) => R(be, this.options)).join(" ").split(/\s+/).map((be) => te(be, this.options));
      O && (q = q.filter((be) => (s("loose invalid filter", be, this.options), !!be.match(a[c.COMPARATORLOOSE])))), s("range list", q);
      const B = /* @__PURE__ */ new Map(), E = q.map((be) => new i(be, this.options));
      for (const be of E) {
        if (b(be))
          return [be];
        B.set(be.value, be);
      }
      B.size > 1 && B.has("") && B.delete("");
      const V = [...B.values()];
      return t.set(x, V), V;
    }
    intersects(p, w) {
      if (!(p instanceof r))
        throw new TypeError("a Range is required");
      return this.set.some((x) => k(x, w) && p.set.some((N) => k(N, w) && x.every((O) => N.every((U) => O.intersects(U, w)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(p) {
      if (!p)
        return !1;
      if (typeof p == "string")
        try {
          p = new o(p, this.options);
        } catch {
          return !1;
        }
      for (let w = 0; w < this.set.length; w++)
        if (we(this.set[w], p, this.options))
          return !0;
      return !1;
    }
  }
  n6 = r;
  const e = Pbe, t = new e({ max: 1e3 }), n = dA, i = P3(), s = O3, o = ds, {
    safeRe: a,
    t: c,
    comparatorTrimReplace: u,
    tildeTrimReplace: f,
    caretTrimReplace: d
  } = Oy, { FLAG_INCLUDE_PRERELEASE: m, FLAG_LOOSE: y } = T3, b = (H) => H.value === "<0.0.0-0", I = (H) => H.value === "", k = (H, p) => {
    let w = !0;
    const x = H.slice();
    let N = x.pop();
    for (; w && x.length; )
      w = x.every((O) => N.intersects(O, p)), N = x.pop();
    return w;
  }, R = (H, p) => (s("comp", H, p), H = L(H, p), s("caret", H), H = $(H, p), s("tildes", H), H = v(H, p), s("xrange", H), H = X(H, p), s("stars", H), H), T = (H) => !H || H.toLowerCase() === "x" || H === "*", $ = (H, p) => H.trim().split(/\s+/).map((w) => D(w, p)).join(" "), D = (H, p) => {
    const w = p.loose ? a[c.TILDELOOSE] : a[c.TILDE];
    return H.replace(w, (x, N, O, U, q) => {
      s("tilde", H, x, N, O, U, q);
      let B;
      return T(N) ? B = "" : T(O) ? B = `>=${N}.0.0 <${+N + 1}.0.0-0` : T(U) ? B = `>=${N}.${O}.0 <${N}.${+O + 1}.0-0` : q ? (s("replaceTilde pr", q), B = `>=${N}.${O}.${U}-${q} <${N}.${+O + 1}.0-0`) : B = `>=${N}.${O}.${U} <${N}.${+O + 1}.0-0`, s("tilde return", B), B;
    });
  }, L = (H, p) => H.trim().split(/\s+/).map((w) => P(w, p)).join(" "), P = (H, p) => {
    s("caret", H, p);
    const w = p.loose ? a[c.CARETLOOSE] : a[c.CARET], x = p.includePrerelease ? "-0" : "";
    return H.replace(w, (N, O, U, q, B) => {
      s("caret", H, N, O, U, q, B);
      let E;
      return T(O) ? E = "" : T(U) ? E = `>=${O}.0.0${x} <${+O + 1}.0.0-0` : T(q) ? O === "0" ? E = `>=${O}.${U}.0${x} <${O}.${+U + 1}.0-0` : E = `>=${O}.${U}.0${x} <${+O + 1}.0.0-0` : B ? (s("replaceCaret pr", B), O === "0" ? U === "0" ? E = `>=${O}.${U}.${q}-${B} <${O}.${U}.${+q + 1}-0` : E = `>=${O}.${U}.${q}-${B} <${O}.${+U + 1}.0-0` : E = `>=${O}.${U}.${q}-${B} <${+O + 1}.0.0-0`) : (s("no pr"), O === "0" ? U === "0" ? E = `>=${O}.${U}.${q}${x} <${O}.${U}.${+q + 1}-0` : E = `>=${O}.${U}.${q}${x} <${O}.${+U + 1}.0-0` : E = `>=${O}.${U}.${q} <${+O + 1}.0.0-0`), s("caret return", E), E;
    });
  }, v = (H, p) => (s("replaceXRanges", H, p), H.split(/\s+/).map((w) => F(w, p)).join(" ")), F = (H, p) => {
    H = H.trim();
    const w = p.loose ? a[c.XRANGELOOSE] : a[c.XRANGE];
    return H.replace(w, (x, N, O, U, q, B) => {
      s("xRange", H, x, N, O, U, q, B);
      const E = T(O), V = E || T(U), be = V || T(q), ve = be;
      return N === "=" && ve && (N = ""), B = p.includePrerelease ? "-0" : "", E ? N === ">" || N === "<" ? x = "<0.0.0-0" : x = "*" : N && ve ? (V && (U = 0), q = 0, N === ">" ? (N = ">=", V ? (O = +O + 1, U = 0, q = 0) : (U = +U + 1, q = 0)) : N === "<=" && (N = "<", V ? O = +O + 1 : U = +U + 1), N === "<" && (B = "-0"), x = `${N + O}.${U}.${q}${B}`) : V ? x = `>=${O}.0.0${B} <${+O + 1}.0.0-0` : be && (x = `>=${O}.${U}.0${B} <${O}.${+U + 1}.0-0`), s("xRange return", x), x;
    });
  }, X = (H, p) => (s("replaceStars", H, p), H.trim().replace(a[c.STAR], "")), te = (H, p) => (s("replaceGTE0", H, p), H.trim().replace(a[p.includePrerelease ? c.GTE0PRE : c.GTE0], "")), se = (H) => (p, w, x, N, O, U, q, B, E, V, be, ve, ne) => (T(x) ? w = "" : T(N) ? w = `>=${x}.0.0${H ? "-0" : ""}` : T(O) ? w = `>=${x}.${N}.0${H ? "-0" : ""}` : U ? w = `>=${w}` : w = `>=${w}${H ? "-0" : ""}`, T(E) ? B = "" : T(V) ? B = `<${+E + 1}.0.0-0` : T(be) ? B = `<${E}.${+V + 1}.0-0` : ve ? B = `<=${E}.${V}.${be}-${ve}` : H ? B = `<${E}.${V}.${+be + 1}-0` : B = `<=${B}`, `${w} ${B}`.trim()), we = (H, p, w) => {
    for (let x = 0; x < H.length; x++)
      if (!H[x].test(p))
        return !1;
    if (p.prerelease.length && !w.includePrerelease) {
      for (let x = 0; x < H.length; x++)
        if (s(H[x].semver), H[x].semver !== i.ANY && H[x].semver.prerelease.length > 0) {
          const N = H[x].semver;
          if (N.major === p.major && N.minor === p.minor && N.patch === p.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return n6;
}
var i6, yN;
function P3() {
  if (yN)
    return i6;
  yN = 1;
  const r = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return r;
    }
    constructor(f, d) {
      if (d = t(d), f instanceof e) {
        if (f.loose === !!d.loose)
          return f;
        f = f.value;
      }
      f = f.trim().split(/\s+/).join(" "), o("comparator", f, d), this.options = d, this.loose = !!d.loose, this.parse(f), this.semver === r ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(f) {
      const d = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], m = f.match(d);
      if (!m)
        throw new TypeError(`Invalid comparator: ${f}`);
      this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new a(m[2], this.options.loose) : this.semver = r;
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (o("Comparator.test", f, this.options.loose), this.semver === r || f === r)
        return !0;
      if (typeof f == "string")
        try {
          f = new a(f, this.options);
        } catch {
          return !1;
        }
      return s(f, this.operator, this.semver, this.options);
    }
    intersects(f, d) {
      if (!(f instanceof e))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(f.value, d).test(this.value) : f.operator === "" ? f.value === "" ? !0 : new c(this.value, d).test(f.semver) : (d = t(d), d.includePrerelease && (this.value === "<0.0.0-0" || f.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && f.operator.startsWith(">") || this.operator.startsWith("<") && f.operator.startsWith("<") || this.semver.version === f.semver.version && this.operator.includes("=") && f.operator.includes("=") || s(this.semver, "<", f.semver, d) && this.operator.startsWith(">") && f.operator.startsWith("<") || s(this.semver, ">", f.semver, d) && this.operator.startsWith("<") && f.operator.startsWith(">")));
    }
  }
  i6 = e;
  const t = dA, { safeRe: n, t: i } = Oy, s = JB, o = O3, a = ds, c = Ha();
  return i6;
}
const Mbe = Ha(), Dbe = (r, e, t) => {
  try {
    e = new Mbe(e, t);
  } catch {
    return !1;
  }
  return e.test(r);
};
var M3 = Dbe;
const kbe = Ha(), $be = (r, e) => new kbe(r, e).set.map((t) => t.map((n) => n.value).join(" ").trim().split(" "));
var Lbe = $be;
const Bbe = ds, Fbe = Ha(), Ube = (r, e, t) => {
  let n = null, i = null, s = null;
  try {
    s = new Fbe(e, t);
  } catch {
    return null;
  }
  return r.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === -1) && (n = o, i = new Bbe(n, t));
  }), n;
};
var jbe = Ube;
const Wbe = ds, Hbe = Ha(), zbe = (r, e, t) => {
  let n = null, i = null, s = null;
  try {
    s = new Hbe(e, t);
  } catch {
    return null;
  }
  return r.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === 1) && (n = o, i = new Wbe(n, t));
  }), n;
};
var Vbe = zbe;
const s6 = ds, qbe = Ha(), vN = N3, Gbe = (r, e) => {
  r = new qbe(r, e);
  let t = new s6("0.0.0");
  if (r.test(t) || (t = new s6("0.0.0-0"), r.test(t)))
    return t;
  t = null;
  for (let n = 0; n < r.set.length; ++n) {
    const i = r.set[n];
    let s = null;
    i.forEach((o) => {
      const a = new s6(o.semver.version);
      switch (o.operator) {
        case ">":
          a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
        case "":
        case ">=":
          (!s || vN(a, s)) && (s = a);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), s && (!t || vN(t, s)) && (t = s);
  }
  return t && r.test(t) ? t : null;
};
var Kbe = Gbe;
const Zbe = Ha(), Jbe = (r, e) => {
  try {
    return new Zbe(r, e).range || "*";
  } catch {
    return null;
  }
};
var Qbe = Jbe;
const Ybe = ds, YB = P3(), { ANY: Xbe } = YB, e2e = Ha(), t2e = M3, bN = N3, _N = gA, r2e = wA, n2e = mA, i2e = (r, e, t, n) => {
  r = new Ybe(r, n), e = new e2e(e, n);
  let i, s, o, a, c;
  switch (t) {
    case ">":
      i = bN, s = r2e, o = _N, a = ">", c = ">=";
      break;
    case "<":
      i = _N, s = n2e, o = bN, a = "<", c = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (t2e(r, e, n))
    return !1;
  for (let u = 0; u < e.set.length; ++u) {
    const f = e.set[u];
    let d = null, m = null;
    if (f.forEach((y) => {
      y.semver === Xbe && (y = new YB(">=0.0.0")), d = d || y, m = m || y, i(y.semver, d.semver, n) ? d = y : o(y.semver, m.semver, n) && (m = y);
    }), d.operator === a || d.operator === c || (!m.operator || m.operator === a) && s(r, m.semver))
      return !1;
    if (m.operator === c && o(r, m.semver))
      return !1;
  }
  return !0;
};
var yA = i2e;
const s2e = yA, o2e = (r, e, t) => s2e(r, e, ">", t);
var a2e = o2e;
const c2e = yA, l2e = (r, e, t) => c2e(r, e, "<", t);
var u2e = l2e;
const EN = Ha(), h2e = (r, e, t) => (r = new EN(r, t), e = new EN(e, t), r.intersects(e, t));
var f2e = h2e;
const d2e = M3, p2e = Wa;
var g2e = (r, e, t) => {
  const n = [];
  let i = null, s = null;
  const o = r.sort((f, d) => p2e(f, d, t));
  for (const f of o)
    d2e(f, e, t) ? (s = f, i || (i = f)) : (s && n.push([i, s]), s = null, i = null);
  i && n.push([i, null]);
  const a = [];
  for (const [f, d] of n)
    f === d ? a.push(f) : !d && f === o[0] ? a.push("*") : d ? f === o[0] ? a.push(`<=${d}`) : a.push(`${f} - ${d}`) : a.push(`>=${f}`);
  const c = a.join(" || "), u = typeof e.raw == "string" ? e.raw : String(e);
  return c.length < u.length ? c : e;
};
const xN = Ha(), vA = P3(), { ANY: o6 } = vA, H1 = M3, bA = Wa, m2e = (r, e, t = {}) => {
  if (r === e)
    return !0;
  r = new xN(r, t), e = new xN(e, t);
  let n = !1;
  e:
    for (const i of r.set) {
      for (const s of e.set) {
        const o = y2e(i, s, t);
        if (n = n || o !== null, o)
          continue e;
      }
      if (n)
        return !1;
    }
  return !0;
}, w2e = [new vA(">=0.0.0-0")], SN = [new vA(">=0.0.0")], y2e = (r, e, t) => {
  if (r === e)
    return !0;
  if (r.length === 1 && r[0].semver === o6) {
    if (e.length === 1 && e[0].semver === o6)
      return !0;
    t.includePrerelease ? r = w2e : r = SN;
  }
  if (e.length === 1 && e[0].semver === o6) {
    if (t.includePrerelease)
      return !0;
    e = SN;
  }
  const n = /* @__PURE__ */ new Set();
  let i, s;
  for (const y of r)
    y.operator === ">" || y.operator === ">=" ? i = CN(i, y, t) : y.operator === "<" || y.operator === "<=" ? s = AN(s, y, t) : n.add(y.semver);
  if (n.size > 1)
    return null;
  let o;
  if (i && s) {
    if (o = bA(i.semver, s.semver, t), o > 0)
      return null;
    if (o === 0 && (i.operator !== ">=" || s.operator !== "<="))
      return null;
  }
  for (const y of n) {
    if (i && !H1(y, String(i), t) || s && !H1(y, String(s), t))
      return null;
    for (const b of e)
      if (!H1(y, String(b), t))
        return !1;
    return !0;
  }
  let a, c, u, f, d = s && !t.includePrerelease && s.semver.prerelease.length ? s.semver : !1, m = i && !t.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  d && d.prerelease.length === 1 && s.operator === "<" && d.prerelease[0] === 0 && (d = !1);
  for (const y of e) {
    if (f = f || y.operator === ">" || y.operator === ">=", u = u || y.operator === "<" || y.operator === "<=", i) {
      if (m && y.semver.prerelease && y.semver.prerelease.length && y.semver.major === m.major && y.semver.minor === m.minor && y.semver.patch === m.patch && (m = !1), y.operator === ">" || y.operator === ">=") {
        if (a = CN(i, y, t), a === y && a !== i)
          return !1;
      } else if (i.operator === ">=" && !H1(i.semver, String(y), t))
        return !1;
    }
    if (s) {
      if (d && y.semver.prerelease && y.semver.prerelease.length && y.semver.major === d.major && y.semver.minor === d.minor && y.semver.patch === d.patch && (d = !1), y.operator === "<" || y.operator === "<=") {
        if (c = AN(s, y, t), c === y && c !== s)
          return !1;
      } else if (s.operator === "<=" && !H1(s.semver, String(y), t))
        return !1;
    }
    if (!y.operator && (s || i) && o !== 0)
      return !1;
  }
  return !(i && u && !s && o !== 0 || s && f && !i && o !== 0 || m || d);
}, CN = (r, e, t) => {
  if (!r)
    return e;
  const n = bA(r.semver, e.semver, t);
  return n > 0 ? r : n < 0 || e.operator === ">" && r.operator === ">=" ? e : r;
}, AN = (r, e, t) => {
  if (!r)
    return e;
  const n = bA(r.semver, e.semver, t);
  return n < 0 ? r : n > 0 || e.operator === "<" && r.operator === "<=" ? e : r;
};
var v2e = m2e;
const a6 = Oy, IN = T3, b2e = ds, RN = GB, _2e = e1, E2e = _ve, x2e = Sve, S2e = Ave, C2e = Rve, A2e = Nve, I2e = Dve, R2e = Lve, T2e = Uve, O2e = Wa, N2e = zve, P2e = Gve, M2e = pA, D2e = Qve, k2e = ebe, $2e = N3, L2e = gA, B2e = KB, F2e = ZB, U2e = mA, j2e = wA, W2e = JB, H2e = xbe, z2e = P3(), V2e = Ha(), q2e = M3, G2e = Lbe, K2e = jbe, Z2e = Vbe, J2e = Kbe, Q2e = Qbe, Y2e = yA, X2e = a2e, e_e = u2e, t_e = f2e, r_e = g2e, n_e = v2e;
var i_e = {
  parse: _2e,
  valid: E2e,
  clean: x2e,
  inc: S2e,
  diff: C2e,
  major: A2e,
  minor: I2e,
  patch: R2e,
  prerelease: T2e,
  compare: O2e,
  rcompare: N2e,
  compareLoose: P2e,
  compareBuild: M2e,
  sort: D2e,
  rsort: k2e,
  gt: $2e,
  lt: L2e,
  eq: B2e,
  neq: F2e,
  gte: U2e,
  lte: j2e,
  cmp: W2e,
  coerce: H2e,
  Comparator: z2e,
  Range: V2e,
  satisfies: q2e,
  toComparators: G2e,
  maxSatisfying: K2e,
  minSatisfying: Z2e,
  minVersion: J2e,
  validRange: Q2e,
  outside: Y2e,
  gtr: X2e,
  ltr: e_e,
  intersects: t_e,
  simplifyRange: r_e,
  subset: n_e,
  SemVer: b2e,
  re: a6.re,
  src: a6.src,
  tokens: a6.t,
  SEMVER_SPEC_VERSION: IN.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: IN.RELEASE_TYPES,
  compareIdentifiers: RN.compareIdentifiers,
  rcompareIdentifiers: RN.rcompareIdentifiers
};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.satisfiesVersionRange = r.gtRange = r.gtVersion = r.assertIsSemVerRange = r.assertIsSemVerVersion = r.isValidSemVerRange = r.isValidSemVerVersion = r.VersionRangeStruct = r.VersionStruct = void 0;
  const e = i_e, t = jd, n = wi;
  r.VersionStruct = (0, t.refine)((0, t.string)(), "Version", (d) => (0, e.valid)(d) === null ? `Expected SemVer version, got "${d}"` : !0), r.VersionRangeStruct = (0, t.refine)((0, t.string)(), "Version range", (d) => (0, e.validRange)(d) === null ? `Expected SemVer range, got "${d}"` : !0);
  function i(d) {
    return (0, t.is)(d, r.VersionStruct);
  }
  r.isValidSemVerVersion = i;
  function s(d) {
    return (0, t.is)(d, r.VersionRangeStruct);
  }
  r.isValidSemVerRange = s;
  function o(d) {
    (0, n.assertStruct)(d, r.VersionStruct);
  }
  r.assertIsSemVerVersion = o;
  function a(d) {
    (0, n.assertStruct)(d, r.VersionRangeStruct);
  }
  r.assertIsSemVerRange = a;
  function c(d, m) {
    return (0, e.gt)(d, m);
  }
  r.gtVersion = c;
  function u(d, m) {
    return (0, e.gtr)(d, m);
  }
  r.gtRange = u;
  function f(d, m) {
    return (0, e.satisfies)(d, m, {
      includePrerelease: !0
    });
  }
  r.satisfiesVersionRange = f;
})(zB);
(function(r) {
  var e = ze && ze.__createBinding || (Object.create ? function(n, i, s, o) {
    o === void 0 && (o = s);
    var a = Object.getOwnPropertyDescriptor(i, s);
    (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return i[s];
    } }), Object.defineProperty(n, o, a);
  } : function(n, i, s, o) {
    o === void 0 && (o = s), n[o] = i[s];
  }), t = ze && ze.__exportStar || function(n, i) {
    for (var s in n)
      s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, n, s);
  };
  Object.defineProperty(r, "__esModule", { value: !0 }), t(wi, r), t(Ry, r), t(br, r), t(I3, r), t(vc, r), t(Ag, r), t(Ty, r), t(jB, r), t(Ig, r), t(fA, r), t(bc, r), t(WB, r), t(HB, r), t(zB, r);
})(EB);
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.createModuleLogger = r.projectLogger = void 0;
  const e = EB;
  Object.defineProperty(r, "createModuleLogger", { enumerable: !0, get: function() {
    return e.createModuleLogger;
  } }), r.projectLogger = (0, e.createProjectLogger)("eth-block-tracker");
})(_B);
var XB = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(C3, "__esModule", { value: !0 });
C3.PollingBlockTracker = void 0;
const s_e = XB(rA), o_e = XB(Iwe), a_e = Ay, TN = _B, ON = (0, TN.createModuleLogger)(TN.projectLogger, "polling-block-tracker"), c_e = (0, s_e.default)(), l_e = 1e3;
class u_e extends a_e.BaseBlockTracker {
  constructor(e = {}) {
    var t;
    if (!e.provider)
      throw new Error("PollingBlockTracker - no provider specified.");
    super({
      blockResetDuration: (t = e.blockResetDuration) !== null && t !== void 0 ? t : e.pollingInterval
    }), this._provider = e.provider, this._pollingInterval = e.pollingInterval || 20 * l_e, this._retryTimeout = e.retryTimeout || this._pollingInterval / 10, this._keepEventLoopActive = e.keepEventLoopActive === void 0 ? !0 : e.keepEventLoopActive, this._setSkipCacheFlag = e.setSkipCacheFlag || !1;
  }
  // trigger block polling
  async checkForLatestBlock() {
    return await this._updateLatestBlock(), await this.getLatestBlock();
  }
  async _start() {
    this._synchronize();
  }
  async _end() {
  }
  async _synchronize() {
    for (var e; this._isRunning; )
      try {
        await this._updateLatestBlock();
        const t = NN(this._pollingInterval, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration"), await t;
      } catch (t) {
        const n = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(e = t.stack) !== null && e !== void 0 ? e : t}`);
        try {
          this.emit("error", n);
        } catch {
          console.error(n);
        }
        const i = NN(this._retryTimeout, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration"), await i;
      }
  }
  async _updateLatestBlock() {
    const e = await this._fetchLatestBlock();
    this._newPotentialLatest(e);
  }
  async _fetchLatestBlock() {
    const e = {
      jsonrpc: "2.0",
      id: c_e(),
      method: "eth_blockNumber",
      params: []
    };
    this._setSkipCacheFlag && (e.skipCache = !0), ON("Making request", e);
    const t = await (0, o_e.default)((n) => this._provider.sendAsync(e, n))();
    if (ON("Got response", t), t.error)
      throw new Error(`PollingBlockTracker - encountered error fetching block:
${t.error.message}`);
    return t.result;
  }
}
C3.PollingBlockTracker = u_e;
function NN(r, e) {
  return new Promise((t) => {
    const n = setTimeout(t, r);
    n.unref && e && n.unref();
  });
}
var D3 = {}, h_e = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(D3, "__esModule", { value: !0 });
D3.SubscribeBlockTracker = void 0;
const f_e = h_e(rA), d_e = Ay, p_e = (0, f_e.default)();
class g_e extends d_e.BaseBlockTracker {
  constructor(e = {}) {
    if (!e.provider)
      throw new Error("SubscribeBlockTracker - no provider specified.");
    super(e), this._provider = e.provider, this._subscriptionId = null;
  }
  async checkForLatestBlock() {
    return await this.getLatestBlock();
  }
  async _start() {
    if (this._subscriptionId === void 0 || this._subscriptionId === null)
      try {
        const e = await this._call("eth_blockNumber");
        this._subscriptionId = await this._call("eth_subscribe", "newHeads"), this._provider.on("data", this._handleSubData.bind(this)), this._newPotentialLatest(e);
      } catch (e) {
        this.emit("error", e);
      }
  }
  async _end() {
    if (this._subscriptionId !== null && this._subscriptionId !== void 0)
      try {
        await this._call("eth_unsubscribe", this._subscriptionId), this._subscriptionId = null;
      } catch (e) {
        this.emit("error", e);
      }
  }
  _call(e, ...t) {
    return new Promise((n, i) => {
      this._provider.sendAsync({
        id: p_e(),
        method: e,
        params: t,
        jsonrpc: "2.0"
      }, (s, o) => {
        s ? i(s) : n(o.result);
      });
    });
  }
  _handleSubData(e, t) {
    var n;
    t.method === "eth_subscription" && ((n = t.params) === null || n === void 0 ? void 0 : n.subscription) === this._subscriptionId && this._newPotentialLatest(t.params.result.number);
  }
}
D3.SubscribeBlockTracker = g_e;
var eF = {};
Object.defineProperty(eF, "__esModule", { value: !0 });
(function(r) {
  var e = ze && ze.__createBinding || (Object.create ? function(n, i, s, o) {
    o === void 0 && (o = s), Object.defineProperty(n, o, { enumerable: !0, get: function() {
      return i[s];
    } });
  } : function(n, i, s, o) {
    o === void 0 && (o = s), n[o] = i[s];
  }), t = ze && ze.__exportStar || function(n, i) {
    for (var s in n)
      s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, n, s);
  };
  Object.defineProperty(r, "__esModule", { value: !0 }), t(C3, r), t(D3, r), t(eF, r);
})(bB);
var _A = {}, k3 = {}, Ny = {};
Object.defineProperty(Ny, "__esModule", { value: !0 });
Ny.getUniqueId = void 0;
const tF = 4294967295;
let c6 = Math.floor(Math.random() * tF);
function m_e() {
  return c6 = (c6 + 1) % tF, c6;
}
Ny.getUniqueId = m_e;
Object.defineProperty(k3, "__esModule", { value: !0 });
k3.createIdRemapMiddleware = void 0;
const w_e = Ny;
function y_e() {
  return (r, e, t, n) => {
    const i = r.id, s = w_e.getUniqueId();
    r.id = s, e.id = s, t((o) => {
      r.id = i, e.id = i, o();
    });
  };
}
k3.createIdRemapMiddleware = y_e;
var $3 = {};
Object.defineProperty($3, "__esModule", { value: !0 });
$3.createAsyncMiddleware = void 0;
function v_e(r) {
  return async (e, t, n, i) => {
    let s;
    const o = new Promise((f) => {
      s = f;
    });
    let a = null, c = !1;
    const u = async () => {
      c = !0, n((f) => {
        a = f, s();
      }), await o;
    };
    try {
      await r(e, t, u), c ? (await o, a(null)) : i(null);
    } catch (f) {
      a ? a(f) : i(f);
    }
  };
}
$3.createAsyncMiddleware = v_e;
var L3 = {};
Object.defineProperty(L3, "__esModule", { value: !0 });
L3.createScaffoldMiddleware = void 0;
function b_e(r) {
  return (e, t, n, i) => {
    const s = r[e.method];
    return s === void 0 ? n() : typeof s == "function" ? s(e, t, n, i) : (t.result = s, i());
  };
}
L3.createScaffoldMiddleware = b_e;
var Py = {}, __e = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Py, "__esModule", { value: !0 });
Py.JsonRpcEngine = void 0;
const E_e = __e(kd), Eo = WC;
class il extends E_e.default {
  constructor() {
    super(), this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(e) {
    this._middleware.push(e);
  }
  handle(e, t) {
    if (t && typeof t != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(e) ? t ? this._handleBatch(e, t) : this._handleBatch(e) : t ? this._handle(e, t) : this._promiseHandle(e);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (e, t, n, i) => {
      try {
        const [s, o, a] = await il._runAllMiddleware(e, t, this._middleware);
        return o ? (await il._runReturnHandlers(a), i(s)) : n(async (c) => {
          try {
            await il._runReturnHandlers(a);
          } catch (u) {
            return c(u);
          }
          return c();
        });
      } catch (s) {
        return i(s);
      }
    };
  }
  async _handleBatch(e, t) {
    try {
      const n = await Promise.all(
        // 1. Begin executing each request in the order received
        e.map(this._promiseHandle.bind(this))
      );
      return t ? t(null, n) : n;
    } catch (n) {
      if (t)
        return t(n);
      throw n;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(e) {
    return new Promise((t) => {
      this._handle(e, (n, i) => {
        t(i);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(e, t) {
    if (!e || Array.isArray(e) || typeof e != "object") {
      const o = new Eo.EthereumRpcError(Eo.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof e}`, { request: e });
      return t(o, { id: void 0, jsonrpc: "2.0", error: o });
    }
    if (typeof e.method != "string") {
      const o = new Eo.EthereumRpcError(Eo.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof e.method}`, { request: e });
      return t(o, { id: e.id, jsonrpc: "2.0", error: o });
    }
    const n = Object.assign({}, e), i = {
      id: n.id,
      jsonrpc: n.jsonrpc
    };
    let s = null;
    try {
      await this._processRequest(n, i);
    } catch (o) {
      s = o;
    }
    return s && (delete i.result, i.error || (i.error = Eo.serializeError(s))), t(s, i);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(e, t) {
    const [n, i, s] = await il._runAllMiddleware(e, t, this._middleware);
    if (il._checkForCompletion(e, t, i), await il._runReturnHandlers(s), n)
      throw n;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(e, t, n) {
    const i = [];
    let s = null, o = !1;
    for (const a of n)
      if ([s, o] = await il._runMiddleware(e, t, a, i), o)
        break;
    return [s, o, i.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(e, t, n, i) {
    return new Promise((s) => {
      const o = (c) => {
        const u = c || t.error;
        u && (t.error = Eo.serializeError(u)), s([u, !0]);
      }, a = (c) => {
        t.error ? o(t.error) : (c && (typeof c != "function" && o(new Eo.EthereumRpcError(Eo.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof c}" for request:
${l6(e)}`, { request: e })), i.push(c)), s([null, !1]));
      };
      try {
        n(e, t, a, o);
      } catch (c) {
        o(c);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(e) {
    for (const t of e)
      await new Promise((n, i) => {
        t((s) => s ? i(s) : n());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(e, t, n) {
    if (!("result" in t) && !("error" in t))
      throw new Eo.EthereumRpcError(Eo.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${l6(e)}`, { request: e });
    if (!n)
      throw new Eo.EthereumRpcError(Eo.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${l6(e)}`, { request: e });
  }
}
Py.JsonRpcEngine = il;
function l6(r) {
  return JSON.stringify(r, null, 2);
}
var B3 = {};
Object.defineProperty(B3, "__esModule", { value: !0 });
B3.mergeMiddleware = void 0;
const x_e = Py;
function S_e(r) {
  const e = new x_e.JsonRpcEngine();
  return r.forEach((t) => e.push(t)), e.asMiddleware();
}
B3.mergeMiddleware = S_e;
(function(r) {
  var e = ze && ze.__createBinding || (Object.create ? function(n, i, s, o) {
    o === void 0 && (o = s), Object.defineProperty(n, o, { enumerable: !0, get: function() {
      return i[s];
    } });
  } : function(n, i, s, o) {
    o === void 0 && (o = s), n[o] = i[s];
  }), t = ze && ze.__exportStar || function(n, i) {
    for (var s in n)
      s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, n, s);
  };
  Object.defineProperty(r, "__esModule", { value: !0 }), t(k3, r), t($3, r), t(L3, r), t(Ny, r), t(Py, r), t(B3, r);
})(_A);
var rF = {}, EA = {}, lS = function(r, e) {
  return lS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, lS(r, e);
};
function nF(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  lS(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var e_ = function() {
  return e_ = Object.assign || function(e) {
    for (var t, n = 1, i = arguments.length; n < i; n++) {
      t = arguments[n];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, e_.apply(this, arguments);
};
function iF(r, e) {
  var t = {};
  for (var n in r)
    Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(r); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[i]) && (t[n[i]] = r[n[i]]);
  return t;
}
function sF(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function oF(r, e) {
  return function(t, n) {
    e(t, n, r);
  };
}
function C_e(r, e, t, n, i, s) {
  function o(R) {
    if (R !== void 0 && typeof R != "function")
      throw new TypeError("Function expected");
    return R;
  }
  for (var a = n.kind, c = a === "getter" ? "get" : a === "setter" ? "set" : "value", u = !e && r ? n.static ? r : r.prototype : null, f = e || (u ? Object.getOwnPropertyDescriptor(u, n.name) : {}), d, m = !1, y = t.length - 1; y >= 0; y--) {
    var b = {};
    for (var I in n)
      b[I] = I === "access" ? {} : n[I];
    for (var I in n.access)
      b.access[I] = n.access[I];
    b.addInitializer = function(R) {
      if (m)
        throw new TypeError("Cannot add initializers after decoration has completed");
      s.push(o(R || null));
    };
    var k = (0, t[y])(a === "accessor" ? { get: f.get, set: f.set } : f[c], b);
    if (a === "accessor") {
      if (k === void 0)
        continue;
      if (k === null || typeof k != "object")
        throw new TypeError("Object expected");
      (d = o(k.get)) && (f.get = d), (d = o(k.set)) && (f.set = d), (d = o(k.init)) && i.unshift(d);
    } else
      (d = o(k)) && (a === "field" ? i.unshift(d) : f[c] = d);
  }
  u && Object.defineProperty(u, n.name, f), m = !0;
}
function A_e(r, e, t) {
  for (var n = arguments.length > 2, i = 0; i < e.length; i++)
    t = n ? e[i].call(r, t) : e[i].call(r);
  return n ? t : void 0;
}
function I_e(r) {
  return typeof r == "symbol" ? r : "".concat(r);
}
function R_e(r, e, t) {
  return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(r, "name", { configurable: !0, value: t ? "".concat(t, " ", e) : e });
}
function aF(r, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(r, e);
}
function cF(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function a(f) {
      try {
        u(n.next(f));
      } catch (d) {
        o(d);
      }
    }
    function c(f) {
      try {
        u(n.throw(f));
      } catch (d) {
        o(d);
      }
    }
    function u(f) {
      f.done ? s(f.value) : i(f.value).then(a, c);
    }
    u((n = n.apply(r, e || [])).next());
  });
}
function lF(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(f) {
      return c([u, f]);
    };
  }
  function c(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, u[0] && (t = 0)), t; )
      try {
        if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done)
          return s;
        switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return t.label++, { value: u[1], done: !1 };
          case 5:
            t.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              t = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              t.label = u[1];
              break;
            }
            if (u[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = u;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(u);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        u = e.call(r, t);
      } catch (f) {
        u = [6, f], i = 0;
      } finally {
        n = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
var F3 = Object.create ? function(r, e, t, n) {
  n === void 0 && (n = t);
  var i = Object.getOwnPropertyDescriptor(e, t);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[t];
  } }), Object.defineProperty(r, n, i);
} : function(r, e, t, n) {
  n === void 0 && (n = t), r[n] = e[t];
};
function uF(r, e) {
  for (var t in r)
    t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && F3(e, r, t);
}
function t_(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t)
    return t.call(r);
  if (r && typeof r.length == "number")
    return {
      next: function() {
        return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function xA(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t)
    return r;
  var n = t.call(r), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function hF() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r = r.concat(xA(arguments[e]));
  return r;
}
function fF() {
  for (var r = 0, e = 0, t = arguments.length; e < t; e++)
    r += arguments[e].length;
  for (var n = Array(r), i = 0, e = 0; e < t; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      n[i] = s[o];
  return n;
}
function dF(r, e, t) {
  if (t || arguments.length === 2)
    for (var n = 0, i = e.length, s; n < i; n++)
      (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
function Rg(r) {
  return this instanceof Rg ? (this.v = r, this) : new Rg(r);
}
function pF(r, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), i, s = [];
  return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function o(m) {
    n[m] && (i[m] = function(y) {
      return new Promise(function(b, I) {
        s.push([m, y, b, I]) > 1 || a(m, y);
      });
    });
  }
  function a(m, y) {
    try {
      c(n[m](y));
    } catch (b) {
      d(s[0][3], b);
    }
  }
  function c(m) {
    m.value instanceof Rg ? Promise.resolve(m.value.v).then(u, f) : d(s[0][2], m);
  }
  function u(m) {
    a("next", m);
  }
  function f(m) {
    a("throw", m);
  }
  function d(m, y) {
    m(y), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function gF(r) {
  var e, t;
  return e = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(i, s) {
    e[i] = r[i] ? function(o) {
      return (t = !t) ? { value: Rg(r[i](o)), done: !1 } : s ? s(o) : o;
    } : s;
  }
}
function mF(r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof t_ == "function" ? t_(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function n(s) {
    t[s] = r[s] && function(o) {
      return new Promise(function(a, c) {
        o = r[s](o), i(a, c, o.done, o.value);
      });
    };
  }
  function i(s, o, a, c) {
    Promise.resolve(c).then(function(u) {
      s({ value: u, done: a });
    }, o);
  }
}
function wF(r, e) {
  return Object.defineProperty ? Object.defineProperty(r, "raw", { value: e }) : r.raw = e, r;
}
var T_e = Object.create ? function(r, e) {
  Object.defineProperty(r, "default", { enumerable: !0, value: e });
} : function(r, e) {
  r.default = e;
};
function yF(r) {
  if (r && r.__esModule)
    return r;
  var e = {};
  if (r != null)
    for (var t in r)
      t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && F3(e, r, t);
  return T_e(e, r), e;
}
function vF(r) {
  return r && r.__esModule ? r : { default: r };
}
function bF(r, e, t, n) {
  if (t === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? r !== e || !n : !e.has(r))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
}
function _F(r, e, t, n, i) {
  if (n === "m")
    throw new TypeError("Private method is not writable");
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? r !== e || !i : !e.has(r))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? i.call(r, t) : i ? i.value = t : e.set(r, t), t;
}
function EF(r, e) {
  if (e === null || typeof e != "object" && typeof e != "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof r == "function" ? e === r : r.has(e);
}
function xF(r, e, t) {
  if (e != null) {
    if (typeof e != "object" && typeof e != "function")
      throw new TypeError("Object expected.");
    var n;
    if (t) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      n = e[Symbol.asyncDispose];
    }
    if (n === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      n = e[Symbol.dispose];
    }
    if (typeof n != "function")
      throw new TypeError("Object not disposable.");
    r.stack.push({ value: e, dispose: n, async: t });
  } else
    t && r.stack.push({ async: !0 });
  return e;
}
var O_e = typeof SuppressedError == "function" ? SuppressedError : function(r, e, t) {
  var n = new Error(t);
  return n.name = "SuppressedError", n.error = r, n.suppressed = e, n;
};
function SF(r) {
  function e(n) {
    r.error = r.hasError ? new O_e(n, r.error, "An error was suppressed during disposal.") : n, r.hasError = !0;
  }
  function t() {
    for (; r.stack.length; ) {
      var n = r.stack.pop();
      try {
        var i = n.dispose && n.dispose.call(n.value);
        if (n.async)
          return Promise.resolve(i).then(t, function(s) {
            return e(s), t();
          });
      } catch (s) {
        e(s);
      }
    }
    if (r.hasError)
      throw r.error;
  }
  return t();
}
const N_e = {
  __extends: nF,
  __assign: e_,
  __rest: iF,
  __decorate: sF,
  __param: oF,
  __metadata: aF,
  __awaiter: cF,
  __generator: lF,
  __createBinding: F3,
  __exportStar: uF,
  __values: t_,
  __read: xA,
  __spread: hF,
  __spreadArrays: fF,
  __spreadArray: dF,
  __await: Rg,
  __asyncGenerator: pF,
  __asyncDelegator: gF,
  __asyncValues: mF,
  __makeTemplateObject: wF,
  __importStar: yF,
  __importDefault: vF,
  __classPrivateFieldGet: bF,
  __classPrivateFieldSet: _F,
  __classPrivateFieldIn: EF,
  __addDisposableResource: xF,
  __disposeResources: SF
}, P_e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource: xF,
  get __assign() {
    return e_;
  },
  __asyncDelegator: gF,
  __asyncGenerator: pF,
  __asyncValues: mF,
  __await: Rg,
  __awaiter: cF,
  __classPrivateFieldGet: bF,
  __classPrivateFieldIn: EF,
  __classPrivateFieldSet: _F,
  __createBinding: F3,
  __decorate: sF,
  __disposeResources: SF,
  __esDecorate: C_e,
  __exportStar: uF,
  __extends: nF,
  __generator: lF,
  __importDefault: vF,
  __importStar: yF,
  __makeTemplateObject: wF,
  __metadata: aF,
  __param: oF,
  __propKey: I_e,
  __read: xA,
  __rest: iF,
  __runInitializers: A_e,
  __setFunctionName: R_e,
  __spread: hF,
  __spreadArray: dF,
  __spreadArrays: fF,
  __values: t_,
  default: N_e
}, Symbol.toStringTag, { value: "Module" })), SA = /* @__PURE__ */ La(P_e);
var U3 = {};
Object.defineProperty(U3, "__esModule", { value: !0 });
var PN = SA, M_e = (
  /** @class */
  function() {
    function r(e) {
      if (this._maxConcurrency = e, this._queue = [], e <= 0)
        throw new Error("semaphore must be initialized to a positive value");
      this._value = e;
    }
    return r.prototype.acquire = function() {
      var e = this, t = this.isLocked(), n = new Promise(function(i) {
        return e._queue.push(i);
      });
      return t || this._dispatch(), n;
    }, r.prototype.runExclusive = function(e) {
      return PN.__awaiter(this, void 0, void 0, function() {
        var t, n, i;
        return PN.__generator(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, this.acquire()];
            case 1:
              t = s.sent(), n = t[0], i = t[1], s.label = 2;
            case 2:
              return s.trys.push([2, , 4, 5]), [4, e(n)];
            case 3:
              return [2, s.sent()];
            case 4:
              return i(), [
                7
                /*endfinally*/
              ];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, r.prototype.isLocked = function() {
      return this._value <= 0;
    }, r.prototype.release = function() {
      if (this._maxConcurrency > 1)
        throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
      if (this._currentReleaser) {
        var e = this._currentReleaser;
        this._currentReleaser = void 0, e();
      }
    }, r.prototype._dispatch = function() {
      var e = this, t = this._queue.shift();
      if (t) {
        var n = !1;
        this._currentReleaser = function() {
          n || (n = !0, e._value++, e._dispatch());
        }, t([this._value--, this._currentReleaser]);
      }
    }, r;
  }()
);
U3.default = M_e;
Object.defineProperty(EA, "__esModule", { value: !0 });
var MN = SA, D_e = U3, k_e = (
  /** @class */
  function() {
    function r() {
      this._semaphore = new D_e.default(1);
    }
    return r.prototype.acquire = function() {
      return MN.__awaiter(this, void 0, void 0, function() {
        var e, t;
        return MN.__generator(this, function(n) {
          switch (n.label) {
            case 0:
              return [4, this._semaphore.acquire()];
            case 1:
              return e = n.sent(), t = e[1], [2, t];
          }
        });
      });
    }, r.prototype.runExclusive = function(e) {
      return this._semaphore.runExclusive(function() {
        return e();
      });
    }, r.prototype.isLocked = function() {
      return this._semaphore.isLocked();
    }, r.prototype.release = function() {
      this._semaphore.release();
    }, r;
  }()
);
EA.default = k_e;
var j3 = {};
Object.defineProperty(j3, "__esModule", { value: !0 });
j3.withTimeout = void 0;
var vb = SA;
function $_e(r, e, t) {
  var n = this;
  return t === void 0 && (t = new Error("timeout")), {
    acquire: function() {
      return new Promise(function(i, s) {
        return vb.__awaiter(n, void 0, void 0, function() {
          var o, a, c;
          return vb.__generator(this, function(u) {
            switch (u.label) {
              case 0:
                return o = !1, setTimeout(function() {
                  o = !0, s(t);
                }, e), [4, r.acquire()];
              case 1:
                return a = u.sent(), o ? (c = Array.isArray(a) ? a[1] : a, c()) : i(a), [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    },
    runExclusive: function(i) {
      return vb.__awaiter(this, void 0, void 0, function() {
        var s, o;
        return vb.__generator(this, function(a) {
          switch (a.label) {
            case 0:
              s = function() {
              }, a.label = 1;
            case 1:
              return a.trys.push([1, , 7, 8]), [4, this.acquire()];
            case 2:
              return o = a.sent(), Array.isArray(o) ? (s = o[1], [4, i(o[0])]) : [3, 4];
            case 3:
              return [2, a.sent()];
            case 4:
              return s = o, [4, i()];
            case 5:
              return [2, a.sent()];
            case 6:
              return [3, 8];
            case 7:
              return s(), [
                7
                /*endfinally*/
              ];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    },
    release: function() {
      r.release();
    },
    isLocked: function() {
      return r.isLocked();
    }
  };
}
j3.withTimeout = $_e;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.withTimeout = r.Semaphore = r.Mutex = void 0;
  var e = EA;
  Object.defineProperty(r, "Mutex", { enumerable: !0, get: function() {
    return e.default;
  } });
  var t = U3;
  Object.defineProperty(r, "Semaphore", { enumerable: !0, get: function() {
    return t.default;
  } });
  var n = j3;
  Object.defineProperty(r, "withTimeout", { enumerable: !0, get: function() {
    return n.withTimeout;
  } });
})(rF);
var L_e = F_e, B_e = Object.prototype.hasOwnProperty;
function F_e() {
  for (var r = {}, e = 0; e < arguments.length; e++) {
    var t = arguments[e];
    for (var n in t)
      B_e.call(t, n) && (r[n] = t[n]);
  }
  return r;
}
const U_e = L_e, j_e = rA();
var W_e = Ut;
function Ut(r) {
  const e = this;
  e.currentProvider = r;
}
Ut.prototype.getBalance = My(2, "eth_getBalance");
Ut.prototype.getCode = My(2, "eth_getCode");
Ut.prototype.getTransactionCount = My(2, "eth_getTransactionCount");
Ut.prototype.getStorageAt = My(3, "eth_getStorageAt");
Ut.prototype.call = My(2, "eth_call");
Ut.prototype.protocolVersion = sr("eth_protocolVersion");
Ut.prototype.syncing = sr("eth_syncing");
Ut.prototype.coinbase = sr("eth_coinbase");
Ut.prototype.mining = sr("eth_mining");
Ut.prototype.hashrate = sr("eth_hashrate");
Ut.prototype.gasPrice = sr("eth_gasPrice");
Ut.prototype.accounts = sr("eth_accounts");
Ut.prototype.blockNumber = sr("eth_blockNumber");
Ut.prototype.getBlockTransactionCountByHash = sr("eth_getBlockTransactionCountByHash");
Ut.prototype.getBlockTransactionCountByNumber = sr("eth_getBlockTransactionCountByNumber");
Ut.prototype.getUncleCountByBlockHash = sr("eth_getUncleCountByBlockHash");
Ut.prototype.getUncleCountByBlockNumber = sr("eth_getUncleCountByBlockNumber");
Ut.prototype.sign = sr("eth_sign");
Ut.prototype.sendTransaction = sr("eth_sendTransaction");
Ut.prototype.sendRawTransaction = sr("eth_sendRawTransaction");
Ut.prototype.estimateGas = sr("eth_estimateGas");
Ut.prototype.getBlockByHash = sr("eth_getBlockByHash");
Ut.prototype.getBlockByNumber = sr("eth_getBlockByNumber");
Ut.prototype.getTransactionByHash = sr("eth_getTransactionByHash");
Ut.prototype.getTransactionByBlockHashAndIndex = sr("eth_getTransactionByBlockHashAndIndex");
Ut.prototype.getTransactionByBlockNumberAndIndex = sr("eth_getTransactionByBlockNumberAndIndex");
Ut.prototype.getTransactionReceipt = sr("eth_getTransactionReceipt");
Ut.prototype.getUncleByBlockHashAndIndex = sr("eth_getUncleByBlockHashAndIndex");
Ut.prototype.getUncleByBlockNumberAndIndex = sr("eth_getUncleByBlockNumberAndIndex");
Ut.prototype.getCompilers = sr("eth_getCompilers");
Ut.prototype.compileLLL = sr("eth_compileLLL");
Ut.prototype.compileSolidity = sr("eth_compileSolidity");
Ut.prototype.compileSerpent = sr("eth_compileSerpent");
Ut.prototype.newFilter = sr("eth_newFilter");
Ut.prototype.newBlockFilter = sr("eth_newBlockFilter");
Ut.prototype.newPendingTransactionFilter = sr("eth_newPendingTransactionFilter");
Ut.prototype.uninstallFilter = sr("eth_uninstallFilter");
Ut.prototype.getFilterChanges = sr("eth_getFilterChanges");
Ut.prototype.getFilterLogs = sr("eth_getFilterLogs");
Ut.prototype.getLogs = sr("eth_getLogs");
Ut.prototype.getWork = sr("eth_getWork");
Ut.prototype.submitWork = sr("eth_submitWork");
Ut.prototype.submitHashrate = sr("eth_submitHashrate");
Ut.prototype.sendAsync = function(r, e) {
  this.currentProvider.sendAsync(H_e(r), function(n, i) {
    if (!n && i.error && (n = new Error("EthQuery - RPC Error - " + i.error.message)), n)
      return e(n);
    e(null, i.result);
  });
};
function sr(r) {
  return function() {
    const e = this;
    var t = [].slice.call(arguments), n = t.pop();
    e.sendAsync({
      method: r,
      params: t
    }, n);
  };
}
function My(r, e) {
  return function() {
    const t = this;
    var n = [].slice.call(arguments), i = n.pop();
    n.length < r && n.push("latest"), t.sendAsync({
      method: e,
      params: n
    }, i);
  };
}
function H_e(r) {
  return U_e({
    // defaults
    id: j_e(),
    jsonrpc: "2.0",
    params: []
    // user-specified
  }, r);
}
const DN = (r, e, t, n) => function(...i) {
  const s = e.promiseModule;
  return new s((o, a) => {
    e.multiArgs ? i.push((...u) => {
      e.errorFirst ? u[0] ? a(u) : (u.shift(), o(u)) : o(u);
    }) : e.errorFirst ? i.push((u, f) => {
      u ? a(u) : o(f);
    }) : i.push(o), Reflect.apply(r, this === t ? n : this, i);
  });
}, kN = /* @__PURE__ */ new WeakMap();
var z_e = (r, e) => {
  e = {
    exclude: [/.+(?:Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise,
    ...e
  };
  const t = typeof r;
  if (!(r !== null && (t === "object" || t === "function")))
    throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${r === null ? "null" : t}\``);
  const n = (o, a) => {
    let c = kN.get(o);
    if (c || (c = {}, kN.set(o, c)), a in c)
      return c[a];
    const u = (b) => typeof b == "string" || typeof a == "symbol" ? a === b : b.test(a), f = Reflect.getOwnPropertyDescriptor(o, a), d = f === void 0 || f.writable || f.configurable, y = (e.include ? e.include.some(u) : !e.exclude.some(u)) && d;
    return c[a] = y, y;
  }, i = /* @__PURE__ */ new WeakMap(), s = new Proxy(r, {
    apply(o, a, c) {
      const u = i.get(o);
      if (u)
        return Reflect.apply(u, a, c);
      const f = e.excludeMain ? o : DN(o, e, s, o);
      return i.set(o, f), Reflect.apply(f, a, c);
    },
    get(o, a) {
      const c = o[a];
      if (!n(o, a) || c === Function.prototype[a])
        return c;
      const u = i.get(c);
      if (u)
        return u;
      if (typeof c == "function") {
        const f = DN(c, e, s, o);
        return i.set(c, f), f;
      }
      return c;
    }
  });
  return s;
};
const V_e = kd.default;
let q_e = class extends V_e {
  constructor() {
    super(), this.updates = [];
  }
  async initialize() {
  }
  async update() {
    throw new Error("BaseFilter - no update method specified");
  }
  addResults(e) {
    this.updates = this.updates.concat(e), e.forEach((t) => this.emit("update", t));
  }
  addInitialResults(e) {
  }
  getChangesAndClear() {
    const e = this.updates;
    return this.updates = [], e;
  }
};
var CA = q_e;
const G_e = CA;
let K_e = class extends G_e {
  constructor() {
    super(), this.allResults = [];
  }
  async update() {
    throw new Error("BaseFilterWithHistory - no update method specified");
  }
  addResults(e) {
    this.allResults = this.allResults.concat(e), super.addResults(e);
  }
  addInitialResults(e) {
    this.allResults = this.allResults.concat(e), super.addInitialResults(e);
  }
  getAllResults() {
    return this.allResults;
  }
};
var Z_e = K_e, Dy = {
  minBlockRef: J_e,
  maxBlockRef: Q_e,
  sortBlockRefs: AA,
  bnToHex: Y_e,
  blockRefIsNumber: X_e,
  hexToInt: r_,
  incrementHexInt: e3e,
  intToHex: CF,
  unsafeRandomBytes: t3e
};
function J_e(...r) {
  return AA(r)[0];
}
function Q_e(...r) {
  const e = AA(r);
  return e[e.length - 1];
}
function AA(r) {
  return r.sort((e, t) => e === "latest" || t === "earliest" ? 1 : t === "latest" || e === "earliest" ? -1 : r_(e) - r_(t));
}
function Y_e(r) {
  return "0x" + r.toString(16);
}
function X_e(r) {
  return r && !["earliest", "latest", "pending"].includes(r);
}
function r_(r) {
  return r == null ? r : Number.parseInt(r, 16);
}
function e3e(r) {
  if (r == null)
    return r;
  const e = r_(r);
  return CF(e + 1);
}
function CF(r) {
  if (r == null)
    return r;
  let e = r.toString(16);
  return e.length % 2 && (e = "0" + e), "0x" + e;
}
function t3e(r) {
  let e = "0x";
  for (let t = 0; t < r; t++)
    e += $N(), e += $N();
  return e;
}
function $N() {
  return Math.floor(Math.random() * 16).toString(16);
}
const r3e = W_e, n3e = z_e, i3e = Z_e, { bnToHex: eRe, hexToInt: bb, incrementHexInt: s3e, minBlockRef: o3e, blockRefIsNumber: a3e } = Dy;
let c3e = class extends i3e {
  constructor({ provider: e, params: t }) {
    super(), this.type = "log", this.ethQuery = new r3e(e), this.params = Object.assign({
      fromBlock: "latest",
      toBlock: "latest",
      address: void 0,
      topics: []
    }, t), this.params.address && (Array.isArray(this.params.address) || (this.params.address = [this.params.address]), this.params.address = this.params.address.map((n) => n.toLowerCase()));
  }
  async initialize({ currentBlock: e }) {
    let t = this.params.fromBlock;
    ["latest", "pending"].includes(t) && (t = e), t === "earliest" && (t = "0x0"), this.params.fromBlock = t;
    const n = o3e(this.params.toBlock, e), i = Object.assign({}, this.params, { toBlock: n }), s = await this._fetchLogs(i);
    this.addInitialResults(s);
  }
  async update({ oldBlock: e, newBlock: t }) {
    const n = t;
    let i;
    e ? i = s3e(e) : i = t;
    const s = Object.assign({}, this.params, { fromBlock: i, toBlock: n }), a = (await this._fetchLogs(s)).filter((c) => this.matchLog(c));
    this.addResults(a);
  }
  async _fetchLogs(e) {
    return await n3e((n) => this.ethQuery.getLogs(e, n))();
  }
  matchLog(e) {
    if (bb(this.params.fromBlock) >= bb(e.blockNumber) || a3e(this.params.toBlock) && bb(this.params.toBlock) <= bb(e.blockNumber))
      return !1;
    const t = e.address && e.address.toLowerCase();
    return this.params.address && t && !this.params.address.includes(t) ? !1 : this.params.topics.every((i, s) => {
      let o = e.topics[s];
      if (!o)
        return !1;
      o = o.toLowerCase();
      let a = Array.isArray(i) ? i : [i];
      return a.includes(null) ? !0 : (a = a.map((f) => f.toLowerCase()), a.includes(o));
    });
  }
};
var l3e = c3e, IA = u3e;
async function u3e({ provider: r, fromBlock: e, toBlock: t }) {
  e || (e = t);
  const n = LN(e), s = LN(t) - n + 1, o = Array(s).fill().map((c, u) => n + u).map(h3e);
  return await Promise.all(
    o.map((c) => d3e(r, "eth_getBlockByNumber", [c, !1]))
  );
}
function LN(r) {
  return r == null ? r : Number.parseInt(r, 16);
}
function h3e(r) {
  return r == null ? r : "0x" + r.toString(16);
}
function f3e(r, e) {
  return new Promise((t, n) => {
    r.sendAsync(e, (i, s) => {
      i ? n(i) : s.error ? n(s.error) : s.result ? t(s.result) : n(new Error("Result was empty"));
    });
  });
}
async function d3e(r, e, t) {
  for (let n = 0; n < 3; n++)
    try {
      return await f3e(r, {
        id: 1,
        jsonrpc: "2.0",
        method: e,
        params: t
      });
    } catch (i) {
      console.error(
        `provider.sendAsync failed: ${i.stack || i.message || i}`
      );
    }
  throw new Error(`Block not found for params: ${JSON.stringify(t)}`);
}
const p3e = CA, g3e = IA, { incrementHexInt: m3e } = Dy;
let w3e = class extends p3e {
  constructor({ provider: e, params: t }) {
    super(), this.type = "block", this.provider = e;
  }
  async update({ oldBlock: e, newBlock: t }) {
    const n = t, i = m3e(e), o = (await g3e({ provider: this.provider, fromBlock: i, toBlock: n })).map((a) => a.hash);
    this.addResults(o);
  }
};
var y3e = w3e;
const v3e = CA, b3e = IA, { incrementHexInt: _3e } = Dy;
let E3e = class extends v3e {
  constructor({ provider: e }) {
    super(), this.type = "tx", this.provider = e;
  }
  async update({ oldBlock: e }) {
    const t = e, n = _3e(e), i = await b3e({ provider: this.provider, fromBlock: n, toBlock: t }), s = [];
    for (const o of i)
      s.push(...o.transactions);
    this.addResults(s);
  }
};
var x3e = E3e;
const S3e = rF.Mutex, { createAsyncMiddleware: C3e, createScaffoldMiddleware: A3e } = _A, I3e = l3e, R3e = y3e, T3e = x3e, { intToHex: AF, hexToInt: u6 } = Dy;
var O3e = N3e;
function N3e({ blockTracker: r, provider: e }) {
  let t = 0, n = {};
  const i = new S3e(), s = P3e({ mutex: i }), o = A3e({
    // install filters
    eth_newFilter: s(h6(c)),
    eth_newBlockFilter: s(h6(u)),
    eth_newPendingTransactionFilter: s(h6(f)),
    // uninstall filters
    eth_uninstallFilter: s(qb(y)),
    // checking filter changes
    eth_getFilterChanges: s(qb(d)),
    eth_getFilterLogs: s(qb(m))
  }), a = async ({ oldBlock: T, newBlock: $ }) => {
    if (n.length === 0)
      return;
    const D = await i.acquire();
    try {
      await Promise.all(yp(n).map(async (L) => {
        try {
          await L.update({ oldBlock: T, newBlock: $ });
        } catch (P) {
          console.error(P);
        }
      }));
    } catch (L) {
      console.error(L);
    }
    D();
  };
  return o.newLogFilter = c, o.newBlockFilter = u, o.newPendingTransactionFilter = f, o.uninstallFilter = y, o.getFilterChanges = d, o.getFilterLogs = m, o.destroy = () => {
    k();
  }, o;
  async function c(T) {
    const $ = new I3e({ provider: e, params: T });
    return await b($), $;
  }
  async function u() {
    const T = new R3e({ provider: e });
    return await b(T), T;
  }
  async function f() {
    const T = new T3e({ provider: e });
    return await b(T), T;
  }
  async function d(T) {
    const $ = u6(T), D = n[$];
    if (!D)
      throw new Error(`No filter for index "${$}"`);
    return D.getChangesAndClear();
  }
  async function m(T) {
    const $ = u6(T), D = n[$];
    if (!D)
      throw new Error(`No filter for index "${$}"`);
    let L = [];
    return D.type === "log" && (L = D.getAllResults()), L;
  }
  async function y(T) {
    const $ = u6(T), L = !!n[$];
    return L && await I($), L;
  }
  async function b(T) {
    const $ = yp(n).length, D = await r.getLatestBlock();
    await T.initialize({ currentBlock: D }), t++, n[t] = T, T.id = t, T.idHex = AF(t);
    const L = yp(n).length;
    return R({ prevFilterCount: $, newFilterCount: L }), t;
  }
  async function I(T) {
    const $ = yp(n).length;
    delete n[T];
    const D = yp(n).length;
    R({ prevFilterCount: $, newFilterCount: D });
  }
  async function k() {
    const T = yp(n).length;
    n = {}, R({ prevFilterCount: T, newFilterCount: 0 });
  }
  function R({ prevFilterCount: T, newFilterCount: $ }) {
    if (T === 0 && $ > 0) {
      r.on("sync", a);
      return;
    }
    if (T > 0 && $ === 0) {
      r.removeListener("sync", a);
      return;
    }
  }
}
function h6(r) {
  return qb(async (...e) => {
    const t = await r(...e);
    return AF(t.id);
  });
}
function qb(r) {
  return C3e(async (e, t) => {
    const n = await r.apply(null, e.params);
    t.result = n;
  });
}
function P3e({ mutex: r }) {
  return (e) => async (t, n, i, s) => {
    (await r.acquire())(), e(t, n, i, s);
  };
}
function yp(r, e) {
  const t = [];
  for (let n in r)
    t.push(r[n]);
  return t;
}
const M3e = kd.default, { createAsyncMiddleware: BN, createScaffoldMiddleware: D3e } = _A, k3e = O3e, { unsafeRandomBytes: $3e, incrementHexInt: L3e } = Dy, B3e = IA;
var F3e = U3e;
function U3e({ blockTracker: r, provider: e }) {
  const t = {}, n = k3e({ blockTracker: r, provider: e });
  let i = !1;
  const s = new M3e(), o = D3e({
    eth_subscribe: BN(a),
    eth_unsubscribe: BN(c)
  });
  return o.destroy = f, { events: s, middleware: o };
  async function a(d, m) {
    if (i)
      throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
    const y = d.params[0], b = $3e(16);
    let I;
    switch (y) {
      case "newHeads":
        I = k({ subId: b });
        break;
      case "logs":
        const T = d.params[1], $ = await n.newLogFilter(T);
        I = R({ subId: b, filter: $ });
        break;
      default:
        throw new Error(`SubscriptionManager - unsupported subscription type "${y}"`);
    }
    t[b] = I, m.result = b;
    return;
    function k({ subId: T }) {
      const $ = {
        type: y,
        destroy: async () => {
          r.removeListener("sync", $.update);
        },
        update: async ({ oldBlock: D, newBlock: L }) => {
          const P = L, v = L3e(D);
          (await B3e({ provider: e, fromBlock: v, toBlock: P })).map(j3e).filter((te) => te !== null).forEach((te) => {
            u(T, te);
          });
        }
      };
      return r.on("sync", $.update), $;
    }
    function R({ subId: T, filter: $ }) {
      return $.on("update", (L) => u(T, L)), {
        type: y,
        destroy: async () => await n.uninstallFilter($.idHex)
      };
    }
  }
  async function c(d, m) {
    if (i)
      throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
    const y = d.params[0], b = t[y];
    if (!b) {
      m.result = !1;
      return;
    }
    delete t[y], await b.destroy(), m.result = !0;
  }
  function u(d, m) {
    s.emit("notification", {
      jsonrpc: "2.0",
      method: "eth_subscription",
      params: {
        subscription: d,
        result: m
      }
    });
  }
  function f() {
    s.removeAllListeners();
    for (const d in t)
      t[d].destroy(), delete t[d];
    i = !0;
  }
}
function j3e(r) {
  return r == null ? null : {
    hash: r.hash,
    parentHash: r.parentHash,
    sha3Uncles: r.sha3Uncles,
    miner: r.miner,
    stateRoot: r.stateRoot,
    transactionsRoot: r.transactionsRoot,
    receiptsRoot: r.receiptsRoot,
    logsBloom: r.logsBloom,
    difficulty: r.difficulty,
    number: r.number,
    gasLimit: r.gasLimit,
    gasUsed: r.gasUsed,
    nonce: r.nonce,
    mixHash: r.mixHash,
    timestamp: r.timestamp,
    extraData: r.extraData
  };
}
Object.defineProperty(S3, "__esModule", { value: !0 });
S3.SubscriptionManager = void 0;
const W3e = bB, H3e = F3e, FN = () => {
};
class z3e {
  constructor(e) {
    const t = new W3e.PollingBlockTracker({
      provider: e,
      pollingInterval: 15e3,
      setSkipCacheFlag: !0
    }), { events: n, middleware: i } = H3e({
      blockTracker: t,
      provider: e
    });
    this.events = n, this.subscriptionMiddleware = i;
  }
  async handleRequest(e) {
    const t = {};
    return await this.subscriptionMiddleware(e, t, FN, FN), t;
  }
  destroy() {
    this.subscriptionMiddleware.destroy();
  }
}
S3.SubscriptionManager = z3e;
var RA = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(bg, "__esModule", { value: !0 });
bg.CoinbaseWalletProvider = void 0;
const V3e = RA(kd), q3e = RA(p3), f6 = qg, Jr = wy, UN = Kg, jN = Aa, d6 = m3, G3e = tn, rr = pt, p6 = RA(Ewe), K3e = Cg, Nr = vB, Z3e = S3, WN = "DefaultChainId", HN = "DefaultJsonRpcUrl";
class J3e extends V3e.default {
  constructor(e) {
    var t, n;
    super(), this._filterPolyfill = new K3e.FilterPolyfill(this), this._subscriptionManager = new Z3e.SubscriptionManager(this), this._relay = null, this._addresses = [], this.hasMadeFirstChainChangedEmission = !1, this.setProviderInfo = this.setProviderInfo.bind(this), this.updateProviderInfo = this.updateProviderInfo.bind(this), this.getChainId = this.getChainId.bind(this), this.setAppInfo = this.setAppInfo.bind(this), this.enable = this.enable.bind(this), this.close = this.close.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this.request = this.request.bind(this), this._setAddresses = this._setAddresses.bind(this), this.scanQRCode = this.scanQRCode.bind(this), this.genericRequest = this.genericRequest.bind(this), this._chainIdFromOpts = e.chainId, this._jsonRpcUrlFromOpts = e.jsonRpcUrl, this._overrideIsMetaMask = e.overrideIsMetaMask, this._relayProvider = e.relayProvider, this._storage = e.storage, this._relayEventManager = e.relayEventManager, this.diagnostic = e.diagnosticLogger, this.reloadOnDisconnect = !0, this.isCoinbaseWallet = (t = e.overrideIsCoinbaseWallet) !== null && t !== void 0 ? t : !0, this.isCoinbaseBrowser = (n = e.overrideIsCoinbaseBrowser) !== null && n !== void 0 ? n : !1, this.qrUrl = e.qrUrl;
    const i = this.getChainId(), s = (0, rr.prepend0x)(i.toString(16));
    this.emit("connect", { chainIdStr: s });
    const o = this._storage.getItem(jN.LOCAL_STORAGE_ADDRESSES_KEY);
    if (o) {
      const a = o.split(" ");
      a[0] !== "" && (this._addresses = a.map((c) => (0, rr.ensureAddressString)(c)), this.emit("accountsChanged", a));
    }
    this._subscriptionManager.events.on("notification", (a) => {
      this.emit("message", {
        type: a.method,
        data: a.params
      });
    }), this._isAuthorized() && this.initializeRelay(), window.addEventListener("message", (a) => {
      var c;
      if (!(a.origin !== location.origin || a.source !== window) && a.data.type === "walletLinkMessage") {
        if (a.data.data.action === "dappChainSwitched") {
          const u = a.data.data.chainId, f = (c = a.data.data.jsonRpcUrl) !== null && c !== void 0 ? c : this.jsonRpcUrl;
          this.updateProviderInfo(f, Number(u));
        }
        a.data.data.action === "addressChanged" && this._setAddresses([a.data.data.address]);
      }
    });
  }
  /** @deprecated Use `.request({ method: 'eth_accounts' })` instead. */
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  /** @deprecated Use the chain ID. If you still need the network ID, use `.request({ method: 'net_version' })`. */
  get networkVersion() {
    return this.getChainId().toString(10);
  }
  /** @deprecated Use `.request({ method: 'eth_chainId' })` instead. */
  get chainId() {
    return (0, rr.prepend0x)(this.getChainId().toString(16));
  }
  get isWalletLink() {
    return !0;
  }
  /**
   * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return
   * true for this method.
   */
  get isMetaMask() {
    return this._overrideIsMetaMask;
  }
  get host() {
    return this.jsonRpcUrl;
  }
  get connected() {
    return !0;
  }
  isConnected() {
    return !0;
  }
  get jsonRpcUrl() {
    var e;
    return (e = this._storage.getItem(HN)) !== null && e !== void 0 ? e : this._jsonRpcUrlFromOpts;
  }
  set jsonRpcUrl(e) {
    this._storage.setItem(HN, e);
  }
  disableReloadOnDisconnect() {
    this.reloadOnDisconnect = !1;
  }
  setProviderInfo(e, t) {
    this.isCoinbaseBrowser || (this._chainIdFromOpts = t, this._jsonRpcUrlFromOpts = e), this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
  }
  updateProviderInfo(e, t) {
    this.jsonRpcUrl = e;
    const n = this.getChainId();
    this._storage.setItem(WN, t.toString(10)), ((0, rr.ensureIntNumber)(t) !== n || !this.hasMadeFirstChainChangedEmission) && (this.emit("chainChanged", this.getChainId()), this.hasMadeFirstChainChangedEmission = !0);
  }
  async watchAsset(e, t, n, i, s, o) {
    return !!(await (await this.initializeRelay()).watchAsset(e, t, n, i, s, o == null ? void 0 : o.toString()).promise).result;
  }
  async addEthereumChain(e, t, n, i, s, o) {
    var a, c;
    if ((0, rr.ensureIntNumber)(e) === this.getChainId())
      return !1;
    const u = await this.initializeRelay(), f = u.inlineAddEthereumChain(e.toString());
    !this._isAuthorized() && !f && await u.requestEthereumAccounts().promise;
    const d = await u.addEthereumChain(e.toString(), t, s, n, i, o).promise;
    return ((a = d.result) === null || a === void 0 ? void 0 : a.isApproved) === !0 && this.updateProviderInfo(t[0], e), ((c = d.result) === null || c === void 0 ? void 0 : c.isApproved) === !0;
  }
  async switchEthereumChain(e) {
    const n = await (await this.initializeRelay()).switchEthereumChain(e.toString(10), this.selectedAddress || void 0).promise;
    if ((0, G3e.isErrorResponse)(n) && n.errorCode)
      throw n.errorCode === Jr.standardErrorCodes.provider.unsupportedChain ? Jr.standardErrors.provider.unsupportedChain(e) : Jr.standardErrors.provider.custom({
        message: n.errorMessage,
        code: n.errorCode
      });
    const i = n.result;
    i.isApproved && i.rpcUrl.length > 0 && this.updateProviderInfo(i.rpcUrl, e);
  }
  setAppInfo(e, t) {
    this.initializeRelay().then((n) => n.setAppInfo(e, t));
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    var e;
    return (e = this.diagnostic) === null || e === void 0 || e.log(f6.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::enable",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? UN.Session.hash(this._relay.session.id) : void 0
    }), this._isAuthorized() ? [...this._addresses] : await this.send(Nr.JSONRPCMethod.eth_requestAccounts);
  }
  async close() {
    (await this.initializeRelay()).resetAndReload();
  }
  send(e, t) {
    try {
      const n = this._send(e, t);
      if (n instanceof Promise)
        return n.catch((i) => {
          throw (0, Jr.serializeError)(i, e);
        });
    } catch (n) {
      throw (0, Jr.serializeError)(n, e);
    }
  }
  _send(e, t) {
    if (typeof e == "string") {
      const i = e, s = Array.isArray(t) ? t : t !== void 0 ? [t] : [], o = {
        jsonrpc: "2.0",
        id: 0,
        method: i,
        params: s
      };
      return this._sendRequestAsync(o).then((a) => a.result);
    }
    if (typeof t == "function") {
      const i = e, s = t;
      return this._sendAsync(i, s);
    }
    if (Array.isArray(e))
      return e.map((s) => this._sendRequest(s));
    const n = e;
    return this._sendRequest(n);
  }
  async sendAsync(e, t) {
    try {
      return this._sendAsync(e, t).catch((n) => {
        throw (0, Jr.serializeError)(n, e);
      });
    } catch (n) {
      return Promise.reject((0, Jr.serializeError)(n, e));
    }
  }
  async _sendAsync(e, t) {
    if (typeof t != "function")
      throw new Error("callback is required");
    if (Array.isArray(e)) {
      const i = t;
      this._sendMultipleRequestsAsync(e).then((s) => i(null, s)).catch((s) => i(s, null));
      return;
    }
    const n = t;
    return this._sendRequestAsync(e).then((i) => n(null, i)).catch((i) => n(i, null));
  }
  async request(e) {
    try {
      return this._request(e).catch((t) => {
        throw (0, Jr.serializeError)(t, e.method);
      });
    } catch (t) {
      return Promise.reject((0, Jr.serializeError)(t, e.method));
    }
  }
  async _request(e) {
    if (!e || typeof e != "object" || Array.isArray(e))
      throw Jr.standardErrors.rpc.invalidRequest({
        message: "Expected a single, non-array, object argument.",
        data: e
      });
    const { method: t, params: n } = e;
    if (typeof t != "string" || t.length === 0)
      throw Jr.standardErrors.rpc.invalidRequest({
        message: "'args.method' must be a non-empty string.",
        data: e
      });
    if (n !== void 0 && !Array.isArray(n) && (typeof n != "object" || n === null))
      throw Jr.standardErrors.rpc.invalidRequest({
        message: "'args.params' must be an object or array if provided.",
        data: e
      });
    const i = n === void 0 ? [] : n, s = this._relayEventManager.makeRequestId();
    return (await this._sendRequestAsync({
      method: t,
      params: i,
      jsonrpc: "2.0",
      id: s
    })).result;
  }
  async scanQRCode(e) {
    var t;
    const i = await (await this.initializeRelay()).scanQRCode((0, rr.ensureRegExpString)(e)).promise;
    if (typeof i.result != "string")
      throw (0, Jr.serializeError)((t = i.errorMessage) !== null && t !== void 0 ? t : "result was not a string", d6.Web3Method.scanQRCode);
    return i.result;
  }
  async genericRequest(e, t) {
    var n;
    const s = await (await this.initializeRelay()).genericRequest(e, t).promise;
    if (typeof s.result != "string")
      throw (0, Jr.serializeError)((n = s.errorMessage) !== null && n !== void 0 ? n : "result was not a string", d6.Web3Method.generic);
    return s.result;
  }
  async selectProvider(e) {
    var t;
    const i = await (await this.initializeRelay()).selectProvider(e).promise;
    if (typeof i.result != "string")
      throw (0, Jr.serializeError)((t = i.errorMessage) !== null && t !== void 0 ? t : "result was not a string", d6.Web3Method.selectProvider);
    return i.result;
  }
  supportsSubscriptions() {
    return !1;
  }
  subscribe() {
    throw new Error("Subscriptions are not supported");
  }
  unsubscribe() {
    throw new Error("Subscriptions are not supported");
  }
  disconnect() {
    return !0;
  }
  _sendRequest(e) {
    const t = {
      jsonrpc: "2.0",
      id: e.id
    }, { method: n } = e;
    if (t.result = this._handleSynchronousMethods(e), t.result === void 0)
      throw new Error(`Coinbase Wallet does not support calling ${n} synchronously without a callback. Please provide a callback parameter to call ${n} asynchronously.`);
    return t;
  }
  _setAddresses(e, t) {
    if (!Array.isArray(e))
      throw new Error("addresses is not an array");
    const n = e.map((i) => (0, rr.ensureAddressString)(i));
    JSON.stringify(n) !== JSON.stringify(this._addresses) && (this._addresses = n, this.emit("accountsChanged", this._addresses), this._storage.setItem(jN.LOCAL_STORAGE_ADDRESSES_KEY, n.join(" ")));
  }
  _sendRequestAsync(e) {
    return new Promise((t, n) => {
      try {
        const i = this._handleSynchronousMethods(e);
        if (i !== void 0)
          return t({
            jsonrpc: "2.0",
            id: e.id,
            result: i
          });
        const s = this._handleAsynchronousFilterMethods(e);
        if (s !== void 0) {
          s.then((a) => t(Object.assign(Object.assign({}, a), { id: e.id }))).catch((a) => n(a));
          return;
        }
        const o = this._handleSubscriptionMethods(e);
        if (o !== void 0) {
          o.then((a) => t({
            jsonrpc: "2.0",
            id: e.id,
            result: a.result
          })).catch((a) => n(a));
          return;
        }
      } catch (i) {
        return n(i);
      }
      this._handleAsynchronousMethods(e).then((i) => i && t(Object.assign(Object.assign({}, i), { id: e.id }))).catch((i) => n(i));
    });
  }
  _sendMultipleRequestsAsync(e) {
    return Promise.all(e.map((t) => this._sendRequestAsync(t)));
  }
  _handleSynchronousMethods(e) {
    const { method: t } = e, n = e.params || [];
    switch (t) {
      case Nr.JSONRPCMethod.eth_accounts:
        return this._eth_accounts();
      case Nr.JSONRPCMethod.eth_coinbase:
        return this._eth_coinbase();
      case Nr.JSONRPCMethod.eth_uninstallFilter:
        return this._eth_uninstallFilter(n);
      case Nr.JSONRPCMethod.net_version:
        return this._net_version();
      case Nr.JSONRPCMethod.eth_chainId:
        return this._eth_chainId();
      default:
        return;
    }
  }
  async _handleAsynchronousMethods(e) {
    const { method: t } = e, n = e.params || [];
    switch (t) {
      case Nr.JSONRPCMethod.eth_requestAccounts:
        return this._eth_requestAccounts();
      case Nr.JSONRPCMethod.eth_sign:
        return this._eth_sign(n);
      case Nr.JSONRPCMethod.eth_ecRecover:
        return this._eth_ecRecover(n);
      case Nr.JSONRPCMethod.personal_sign:
        return this._personal_sign(n);
      case Nr.JSONRPCMethod.personal_ecRecover:
        return this._personal_ecRecover(n);
      case Nr.JSONRPCMethod.eth_signTransaction:
        return this._eth_signTransaction(n);
      case Nr.JSONRPCMethod.eth_sendRawTransaction:
        return this._eth_sendRawTransaction(n);
      case Nr.JSONRPCMethod.eth_sendTransaction:
        return this._eth_sendTransaction(n);
      case Nr.JSONRPCMethod.eth_signTypedData_v1:
        return this._eth_signTypedData_v1(n);
      case Nr.JSONRPCMethod.eth_signTypedData_v2:
        return this._throwUnsupportedMethodError();
      case Nr.JSONRPCMethod.eth_signTypedData_v3:
        return this._eth_signTypedData_v3(n);
      case Nr.JSONRPCMethod.eth_signTypedData_v4:
      case Nr.JSONRPCMethod.eth_signTypedData:
        return this._eth_signTypedData_v4(n);
      case Nr.JSONRPCMethod.cbWallet_arbitrary:
        return this._cbwallet_arbitrary(n);
      case Nr.JSONRPCMethod.wallet_addEthereumChain:
        return this._wallet_addEthereumChain(n);
      case Nr.JSONRPCMethod.wallet_switchEthereumChain:
        return this._wallet_switchEthereumChain(n);
      case Nr.JSONRPCMethod.wallet_watchAsset:
        return this._wallet_watchAsset(n);
    }
    return (await this.initializeRelay()).makeEthereumJSONRPCRequest(e, this.jsonRpcUrl);
  }
  _handleAsynchronousFilterMethods(e) {
    const { method: t } = e, n = e.params || [];
    switch (t) {
      case Nr.JSONRPCMethod.eth_newFilter:
        return this._eth_newFilter(n);
      case Nr.JSONRPCMethod.eth_newBlockFilter:
        return this._eth_newBlockFilter();
      case Nr.JSONRPCMethod.eth_newPendingTransactionFilter:
        return this._eth_newPendingTransactionFilter();
      case Nr.JSONRPCMethod.eth_getFilterChanges:
        return this._eth_getFilterChanges(n);
      case Nr.JSONRPCMethod.eth_getFilterLogs:
        return this._eth_getFilterLogs(n);
    }
  }
  _handleSubscriptionMethods(e) {
    switch (e.method) {
      case Nr.JSONRPCMethod.eth_subscribe:
      case Nr.JSONRPCMethod.eth_unsubscribe:
        return this._subscriptionManager.handleRequest(e);
    }
  }
  _isKnownAddress(e) {
    try {
      const t = (0, rr.ensureAddressString)(e);
      return this._addresses.map((i) => (0, rr.ensureAddressString)(i)).includes(t);
    } catch {
    }
    return !1;
  }
  _ensureKnownAddress(e) {
    var t;
    if (!this._isKnownAddress(e))
      throw (t = this.diagnostic) === null || t === void 0 || t.log(f6.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED), new Error("Unknown Ethereum address");
  }
  _prepareTransactionParams(e) {
    const t = e.from ? (0, rr.ensureAddressString)(e.from) : this.selectedAddress;
    if (!t)
      throw new Error("Ethereum address is unavailable");
    this._ensureKnownAddress(t);
    const n = e.to ? (0, rr.ensureAddressString)(e.to) : null, i = e.value != null ? (0, rr.ensureBN)(e.value) : new q3e.default(0), s = e.data ? (0, rr.ensureBuffer)(e.data) : Buffer.alloc(0), o = e.nonce != null ? (0, rr.ensureIntNumber)(e.nonce) : null, a = e.gasPrice != null ? (0, rr.ensureBN)(e.gasPrice) : null, c = e.maxFeePerGas != null ? (0, rr.ensureBN)(e.maxFeePerGas) : null, u = e.maxPriorityFeePerGas != null ? (0, rr.ensureBN)(e.maxPriorityFeePerGas) : null, f = e.gas != null ? (0, rr.ensureBN)(e.gas) : null, d = this.getChainId();
    return {
      fromAddress: t,
      toAddress: n,
      weiValue: i,
      data: s,
      nonce: o,
      gasPriceInWei: a,
      maxFeePerGas: c,
      maxPriorityFeePerGas: u,
      gasLimit: f,
      chainId: d
    };
  }
  _isAuthorized() {
    return this._addresses.length > 0;
  }
  _requireAuthorization() {
    if (!this._isAuthorized())
      throw Jr.standardErrors.provider.unauthorized({});
  }
  _throwUnsupportedMethodError() {
    throw Jr.standardErrors.provider.unsupportedMethod({});
  }
  async _signEthereumMessage(e, t, n, i) {
    this._ensureKnownAddress(t);
    try {
      return { jsonrpc: "2.0", id: 0, result: (await (await this.initializeRelay()).signEthereumMessage(e, t, n, i).promise).result };
    } catch (s) {
      throw typeof s.message == "string" && s.message.match(/(denied|rejected)/i) ? Jr.standardErrors.provider.userRejectedRequest("User denied message signature") : s;
    }
  }
  async _ethereumAddressFromSignedMessage(e, t, n) {
    return { jsonrpc: "2.0", id: 0, result: (await (await this.initializeRelay()).ethereumAddressFromSignedMessage(e, t, n).promise).result };
  }
  _eth_accounts() {
    return [...this._addresses];
  }
  _eth_coinbase() {
    return this.selectedAddress || null;
  }
  _net_version() {
    return this.getChainId().toString(10);
  }
  _eth_chainId() {
    return (0, rr.hexStringFromIntNumber)(this.getChainId());
  }
  getChainId() {
    const e = this._storage.getItem(WN);
    if (!e)
      return (0, rr.ensureIntNumber)(this._chainIdFromOpts);
    const t = parseInt(e, 10);
    return (0, rr.ensureIntNumber)(t);
  }
  async _eth_requestAccounts() {
    var e;
    if ((e = this.diagnostic) === null || e === void 0 || e.log(f6.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::_eth_requestAccounts",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? UN.Session.hash(this._relay.session.id) : void 0
    }), this._isAuthorized())
      return Promise.resolve({
        jsonrpc: "2.0",
        id: 0,
        result: this._addresses
      });
    let t;
    try {
      t = await (await this.initializeRelay()).requestEthereumAccounts().promise;
    } catch (n) {
      throw typeof n.message == "string" && n.message.match(/(denied|rejected)/i) ? Jr.standardErrors.provider.userRejectedRequest("User denied account authorization") : n;
    }
    if (!t.result)
      throw new Error("accounts received is empty");
    return this._setAddresses(t.result), this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()), { jsonrpc: "2.0", id: 0, result: this._addresses };
  }
  _eth_sign(e) {
    this._requireAuthorization();
    const t = (0, rr.ensureAddressString)(e[0]), n = (0, rr.ensureBuffer)(e[1]);
    return this._signEthereumMessage(n, t, !1);
  }
  _eth_ecRecover(e) {
    const t = (0, rr.ensureBuffer)(e[0]), n = (0, rr.ensureBuffer)(e[1]);
    return this._ethereumAddressFromSignedMessage(t, n, !1);
  }
  _personal_sign(e) {
    this._requireAuthorization();
    const t = (0, rr.ensureBuffer)(e[0]), n = (0, rr.ensureAddressString)(e[1]);
    return this._signEthereumMessage(t, n, !0);
  }
  _personal_ecRecover(e) {
    const t = (0, rr.ensureBuffer)(e[0]), n = (0, rr.ensureBuffer)(e[1]);
    return this._ethereumAddressFromSignedMessage(t, n, !0);
  }
  async _eth_signTransaction(e) {
    this._requireAuthorization();
    const t = this._prepareTransactionParams(e[0] || {});
    try {
      return { jsonrpc: "2.0", id: 0, result: (await (await this.initializeRelay()).signEthereumTransaction(t).promise).result };
    } catch (n) {
      throw typeof n.message == "string" && n.message.match(/(denied|rejected)/i) ? Jr.standardErrors.provider.userRejectedRequest("User denied transaction signature") : n;
    }
  }
  async _eth_sendRawTransaction(e) {
    const t = (0, rr.ensureBuffer)(e[0]);
    return { jsonrpc: "2.0", id: 0, result: (await (await this.initializeRelay()).submitEthereumTransaction(t, this.getChainId()).promise).result };
  }
  async _eth_sendTransaction(e) {
    this._requireAuthorization();
    const t = this._prepareTransactionParams(e[0] || {});
    try {
      return { jsonrpc: "2.0", id: 0, result: (await (await this.initializeRelay()).signAndSubmitEthereumTransaction(t).promise).result };
    } catch (n) {
      throw typeof n.message == "string" && n.message.match(/(denied|rejected)/i) ? Jr.standardErrors.provider.userRejectedRequest("User denied transaction signature") : n;
    }
  }
  async _eth_signTypedData_v1(e) {
    this._requireAuthorization();
    const t = (0, rr.ensureParsedJSONObject)(e[0]), n = (0, rr.ensureAddressString)(e[1]);
    this._ensureKnownAddress(n);
    const i = p6.default.hashForSignTypedDataLegacy({ data: t }), s = JSON.stringify(t, null, 2);
    return this._signEthereumMessage(i, n, !1, s);
  }
  async _eth_signTypedData_v3(e) {
    this._requireAuthorization();
    const t = (0, rr.ensureAddressString)(e[0]), n = (0, rr.ensureParsedJSONObject)(e[1]);
    this._ensureKnownAddress(t);
    const i = p6.default.hashForSignTypedData_v3({ data: n }), s = JSON.stringify(n, null, 2);
    return this._signEthereumMessage(i, t, !1, s);
  }
  async _eth_signTypedData_v4(e) {
    this._requireAuthorization();
    const t = (0, rr.ensureAddressString)(e[0]), n = (0, rr.ensureParsedJSONObject)(e[1]);
    this._ensureKnownAddress(t);
    const i = p6.default.hashForSignTypedData_v4({ data: n }), s = JSON.stringify(n, null, 2);
    return this._signEthereumMessage(i, t, !1, s);
  }
  /** @deprecated */
  async _cbwallet_arbitrary(e) {
    const t = e[0], n = e[1];
    if (typeof n != "string")
      throw new Error("parameter must be a string");
    if (typeof t != "object" || t === null)
      throw new Error("parameter must be an object");
    return { jsonrpc: "2.0", id: 0, result: await this.genericRequest(t, n) };
  }
  async _wallet_addEthereumChain(e) {
    var t, n, i, s;
    const o = e[0];
    if (((t = o.rpcUrls) === null || t === void 0 ? void 0 : t.length) === 0)
      return {
        jsonrpc: "2.0",
        id: 0,
        error: { code: 2, message: "please pass in at least 1 rpcUrl" }
      };
    if (!o.chainName || o.chainName.trim() === "")
      throw Jr.standardErrors.rpc.invalidParams("chainName is a required field");
    if (!o.nativeCurrency)
      throw Jr.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
    const a = parseInt(o.chainId, 16);
    return await this.addEthereumChain(a, (n = o.rpcUrls) !== null && n !== void 0 ? n : [], (i = o.blockExplorerUrls) !== null && i !== void 0 ? i : [], o.chainName, (s = o.iconUrls) !== null && s !== void 0 ? s : [], o.nativeCurrency) ? { jsonrpc: "2.0", id: 0, result: null } : {
      jsonrpc: "2.0",
      id: 0,
      error: { code: 2, message: "unable to add ethereum chain" }
    };
  }
  async _wallet_switchEthereumChain(e) {
    const t = e[0];
    return await this.switchEthereumChain(parseInt(t.chainId, 16)), { jsonrpc: "2.0", id: 0, result: null };
  }
  async _wallet_watchAsset(e) {
    const t = Array.isArray(e) ? e[0] : e;
    if (!t.type)
      throw Jr.standardErrors.rpc.invalidParams("Type is required");
    if ((t == null ? void 0 : t.type) !== "ERC20")
      throw Jr.standardErrors.rpc.invalidParams(`Asset of type '${t.type}' is not supported`);
    if (!(t != null && t.options))
      throw Jr.standardErrors.rpc.invalidParams("Options are required");
    if (!(t != null && t.options.address))
      throw Jr.standardErrors.rpc.invalidParams("Address is required");
    const n = this.getChainId(), { address: i, symbol: s, image: o, decimals: a } = t.options;
    return { jsonrpc: "2.0", id: 0, result: await this.watchAsset(t.type, i, s, a, o, n) };
  }
  _eth_uninstallFilter(e) {
    const t = (0, rr.ensureHexString)(e[0]);
    return this._filterPolyfill.uninstallFilter(t);
  }
  async _eth_newFilter(e) {
    const t = e[0];
    return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newFilter(t) };
  }
  async _eth_newBlockFilter() {
    return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newBlockFilter() };
  }
  async _eth_newPendingTransactionFilter() {
    return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newPendingTransactionFilter() };
  }
  _eth_getFilterChanges(e) {
    const t = (0, rr.ensureHexString)(e[0]);
    return this._filterPolyfill.getFilterChanges(t);
  }
  _eth_getFilterLogs(e) {
    const t = (0, rr.ensureHexString)(e[0]);
    return this._filterPolyfill.getFilterLogs(t);
  }
  initializeRelay() {
    return this._relay ? Promise.resolve(this._relay) : this._relayProvider().then((e) => (e.setAccountsCallback((t, n) => this._setAddresses(t, n)), e.setChainCallback((t, n) => {
      this.updateProviderInfo(n, parseInt(t, 10));
    }), e.setDappDefaultChainCallback(this._chainIdFromOpts), this._relay = e, e));
  }
}
bg.CoinbaseWalletProvider = J3e;
var W3 = {}, H3 = {}, ky, Lt, IF, RF, tf, zN, TF, uS, OF, bw = {}, NF = [], Q3e = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, z3 = Array.isArray;
function Il(r, e) {
  for (var t in e)
    r[t] = e[t];
  return r;
}
function PF(r) {
  var e = r.parentNode;
  e && e.removeChild(r);
}
function hS(r, e, t) {
  var n, i, s, o = {};
  for (s in e)
    s == "key" ? n = e[s] : s == "ref" ? i = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? ky.call(arguments, 2) : t), typeof r == "function" && r.defaultProps != null)
    for (s in r.defaultProps)
      o[s] === void 0 && (o[s] = r.defaultProps[s]);
  return _m(r, o, n, i, null);
}
function _m(r, e, t, n, i) {
  var s = { type: r, props: e, key: t, ref: n, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: i ?? ++IF, __i: -1, __u: 0 };
  return i == null && Lt.vnode != null && Lt.vnode(s), s;
}
function Y3e() {
  return { current: null };
}
function $y(r) {
  return r.children;
}
function Em(r, e) {
  this.props = r, this.context = e;
}
function Tg(r, e) {
  if (e == null)
    return r.__ ? Tg(r.__, r.__i + 1) : null;
  for (var t; e < r.__k.length; e++)
    if ((t = r.__k[e]) != null && t.__e != null)
      return t.__e;
  return typeof r.type == "function" ? Tg(r) : null;
}
function MF(r) {
  var e, t;
  if ((r = r.__) != null && r.__c != null) {
    for (r.__e = r.__c.base = null, e = 0; e < r.__k.length; e++)
      if ((t = r.__k[e]) != null && t.__e != null) {
        r.__e = r.__c.base = t.__e;
        break;
      }
    return MF(r);
  }
}
function fS(r) {
  (!r.__d && (r.__d = !0) && tf.push(r) && !n_.__r++ || zN !== Lt.debounceRendering) && ((zN = Lt.debounceRendering) || TF)(n_);
}
function n_() {
  var r, e, t, n, i, s, o, a, c;
  for (tf.sort(uS); r = tf.shift(); )
    r.__d && (e = tf.length, n = void 0, s = (i = (t = r).__v).__e, a = [], c = [], (o = t.__P) && ((n = Il({}, i)).__v = i.__v + 1, Lt.vnode && Lt.vnode(n), TA(o, n, i, t.__n, o.ownerSVGElement !== void 0, 32 & i.__u ? [s] : null, a, s ?? Tg(i), !!(32 & i.__u), c), n.__.__k[n.__i] = n, LF(a, n, c), n.__e != s && MF(n)), tf.length > e && tf.sort(uS));
  n_.__r = 0;
}
function DF(r, e, t, n, i, s, o, a, c, u, f) {
  var d, m, y, b, I, k = n && n.__k || NF, R = e.length;
  for (t.__d = c, X3e(t, e, k), c = t.__d, d = 0; d < R; d++)
    (y = t.__k[d]) != null && typeof y != "boolean" && typeof y != "function" && (m = y.__i === -1 ? bw : k[y.__i] || bw, y.__i = d, TA(r, y, m, i, s, o, a, c, u, f), b = y.__e, y.ref && m.ref != y.ref && (m.ref && OA(m.ref, null, y), f.push(y.ref, y.__c || b, y)), I == null && b != null && (I = b), 65536 & y.__u || m.__k === y.__k ? c = kF(y, c, r) : typeof y.type == "function" && y.__d !== void 0 ? c = y.__d : b && (c = b.nextSibling), y.__d = void 0, y.__u &= -196609);
  t.__d = c, t.__e = I;
}
function X3e(r, e, t) {
  var n, i, s, o, a, c = e.length, u = t.length, f = u, d = 0;
  for (r.__k = [], n = 0; n < c; n++)
    (i = r.__k[n] = (i = e[n]) == null || typeof i == "boolean" || typeof i == "function" ? null : typeof i == "string" || typeof i == "number" || typeof i == "bigint" || i.constructor == String ? _m(null, i, null, null, i) : z3(i) ? _m($y, { children: i }, null, null, null) : i.constructor === void 0 && i.__b > 0 ? _m(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i) != null ? (i.__ = r, i.__b = r.__b + 1, a = eEe(i, t, o = n + d, f), i.__i = a, s = null, a !== -1 && (f--, (s = t[a]) && (s.__u |= 131072)), s == null || s.__v === null ? (a == -1 && d--, typeof i.type != "function" && (i.__u |= 65536)) : a !== o && (a === o + 1 ? d++ : a > o ? f > c - o ? d += a - o : d-- : d = a < o && a == o - 1 ? a - o : 0, a !== n + d && (i.__u |= 65536))) : (s = t[n]) && s.key == null && s.__e && (s.__e == r.__d && (r.__d = Tg(s)), dS(s, s, !1), t[n] = null, f--);
  if (f)
    for (n = 0; n < u; n++)
      (s = t[n]) != null && !(131072 & s.__u) && (s.__e == r.__d && (r.__d = Tg(s)), dS(s, s));
}
function kF(r, e, t) {
  var n, i;
  if (typeof r.type == "function") {
    for (n = r.__k, i = 0; n && i < n.length; i++)
      n[i] && (n[i].__ = r, e = kF(n[i], e, t));
    return e;
  }
  return r.__e != e && (t.insertBefore(r.__e, e || null), e = r.__e), e && e.nextSibling;
}
function $F(r, e) {
  return e = e || [], r == null || typeof r == "boolean" || (z3(r) ? r.some(function(t) {
    $F(t, e);
  }) : e.push(r)), e;
}
function eEe(r, e, t, n) {
  var i = r.key, s = r.type, o = t - 1, a = t + 1, c = e[t];
  if (c === null || c && i == c.key && s === c.type)
    return t;
  if (n > (c != null && !(131072 & c.__u) ? 1 : 0))
    for (; o >= 0 || a < e.length; ) {
      if (o >= 0) {
        if ((c = e[o]) && !(131072 & c.__u) && i == c.key && s === c.type)
          return o;
        o--;
      }
      if (a < e.length) {
        if ((c = e[a]) && !(131072 & c.__u) && i == c.key && s === c.type)
          return a;
        a++;
      }
    }
  return -1;
}
function VN(r, e, t) {
  e[0] === "-" ? r.setProperty(e, t ?? "") : r[e] = t == null ? "" : typeof t != "number" || Q3e.test(e) ? t : t + "px";
}
function _b(r, e, t, n, i) {
  var s;
  e:
    if (e === "style")
      if (typeof t == "string")
        r.style.cssText = t;
      else {
        if (typeof n == "string" && (r.style.cssText = n = ""), n)
          for (e in n)
            t && e in t || VN(r.style, e, "");
        if (t)
          for (e in t)
            n && t[e] === n[e] || VN(r.style, e, t[e]);
      }
    else if (e[0] === "o" && e[1] === "n")
      s = e !== (e = e.replace(/(PointerCapture)$|Capture$/, "$1")), e = e.toLowerCase() in r ? e.toLowerCase().slice(2) : e.slice(2), r.l || (r.l = {}), r.l[e + s] = t, t ? n ? t.u = n.u : (t.u = Date.now(), r.addEventListener(e, s ? GN : qN, s)) : r.removeEventListener(e, s ? GN : qN, s);
    else {
      if (i)
        e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (e !== "width" && e !== "height" && e !== "href" && e !== "list" && e !== "form" && e !== "tabIndex" && e !== "download" && e !== "rowSpan" && e !== "colSpan" && e !== "role" && e in r)
        try {
          r[e] = t ?? "";
          break e;
        } catch {
        }
      typeof t == "function" || (t == null || t === !1 && e[4] !== "-" ? r.removeAttribute(e) : r.setAttribute(e, t));
    }
}
function qN(r) {
  var e = this.l[r.type + !1];
  if (r.t) {
    if (r.t <= e.u)
      return;
  } else
    r.t = Date.now();
  return e(Lt.event ? Lt.event(r) : r);
}
function GN(r) {
  return this.l[r.type + !0](Lt.event ? Lt.event(r) : r);
}
function TA(r, e, t, n, i, s, o, a, c, u) {
  var f, d, m, y, b, I, k, R, T, $, D, L, P, v, F, X = e.type;
  if (e.constructor !== void 0)
    return null;
  128 & t.__u && (c = !!(32 & t.__u), s = [a = e.__e = t.__e]), (f = Lt.__b) && f(e);
  e:
    if (typeof X == "function")
      try {
        if (R = e.props, T = (f = X.contextType) && n[f.__c], $ = f ? T ? T.props.value : f.__ : n, t.__c ? k = (d = e.__c = t.__c).__ = d.__E : ("prototype" in X && X.prototype.render ? e.__c = d = new X(R, $) : (e.__c = d = new Em(R, $), d.constructor = X, d.render = rEe), T && T.sub(d), d.props = R, d.state || (d.state = {}), d.context = $, d.__n = n, m = d.__d = !0, d.__h = [], d._sb = []), d.__s == null && (d.__s = d.state), X.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = Il({}, d.__s)), Il(d.__s, X.getDerivedStateFromProps(R, d.__s))), y = d.props, b = d.state, d.__v = e, m)
          X.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), d.componentDidMount != null && d.__h.push(d.componentDidMount);
        else {
          if (X.getDerivedStateFromProps == null && R !== y && d.componentWillReceiveProps != null && d.componentWillReceiveProps(R, $), !d.__e && (d.shouldComponentUpdate != null && d.shouldComponentUpdate(R, d.__s, $) === !1 || e.__v === t.__v)) {
            for (e.__v !== t.__v && (d.props = R, d.state = d.__s, d.__d = !1), e.__e = t.__e, e.__k = t.__k, e.__k.forEach(function(te) {
              te && (te.__ = e);
            }), D = 0; D < d._sb.length; D++)
              d.__h.push(d._sb[D]);
            d._sb = [], d.__h.length && o.push(d);
            break e;
          }
          d.componentWillUpdate != null && d.componentWillUpdate(R, d.__s, $), d.componentDidUpdate != null && d.__h.push(function() {
            d.componentDidUpdate(y, b, I);
          });
        }
        if (d.context = $, d.props = R, d.__P = r, d.__e = !1, L = Lt.__r, P = 0, "prototype" in X && X.prototype.render) {
          for (d.state = d.__s, d.__d = !1, L && L(e), f = d.render(d.props, d.state, d.context), v = 0; v < d._sb.length; v++)
            d.__h.push(d._sb[v]);
          d._sb = [];
        } else
          do
            d.__d = !1, L && L(e), f = d.render(d.props, d.state, d.context), d.state = d.__s;
          while (d.__d && ++P < 25);
        d.state = d.__s, d.getChildContext != null && (n = Il(Il({}, n), d.getChildContext())), m || d.getSnapshotBeforeUpdate == null || (I = d.getSnapshotBeforeUpdate(y, b)), DF(r, z3(F = f != null && f.type === $y && f.key == null ? f.props.children : f) ? F : [F], e, t, n, i, s, o, a, c, u), d.base = e.__e, e.__u &= -161, d.__h.length && o.push(d), k && (d.__E = d.__ = null);
      } catch (te) {
        e.__v = null, c || s != null ? (e.__e = a, e.__u |= c ? 160 : 32, s[s.indexOf(a)] = null) : (e.__e = t.__e, e.__k = t.__k), Lt.__e(te, e, t);
      }
    else
      s == null && e.__v === t.__v ? (e.__k = t.__k, e.__e = t.__e) : e.__e = tEe(t.__e, e, t, n, i, s, o, c, u);
  (f = Lt.diffed) && f(e);
}
function LF(r, e, t) {
  e.__d = void 0;
  for (var n = 0; n < t.length; n++)
    OA(t[n], t[++n], t[++n]);
  Lt.__c && Lt.__c(e, r), r.some(function(i) {
    try {
      r = i.__h, i.__h = [], r.some(function(s) {
        s.call(i);
      });
    } catch (s) {
      Lt.__e(s, i.__v);
    }
  });
}
function tEe(r, e, t, n, i, s, o, a, c) {
  var u, f, d, m, y, b, I, k = t.props, R = e.props, T = e.type;
  if (T === "svg" && (i = !0), s != null) {
    for (u = 0; u < s.length; u++)
      if ((y = s[u]) && "setAttribute" in y == !!T && (T ? y.localName === T : y.nodeType === 3)) {
        r = y, s[u] = null;
        break;
      }
  }
  if (r == null) {
    if (T === null)
      return document.createTextNode(R);
    r = i ? document.createElementNS("http://www.w3.org/2000/svg", T) : document.createElement(T, R.is && R), s = null, a = !1;
  }
  if (T === null)
    k === R || a && r.data === R || (r.data = R);
  else {
    if (s = s && ky.call(r.childNodes), k = t.props || bw, !a && s != null)
      for (k = {}, u = 0; u < r.attributes.length; u++)
        k[(y = r.attributes[u]).name] = y.value;
    for (u in k)
      y = k[u], u == "children" || (u == "dangerouslySetInnerHTML" ? d = y : u === "key" || u in R || _b(r, u, null, y, i));
    for (u in R)
      y = R[u], u == "children" ? m = y : u == "dangerouslySetInnerHTML" ? f = y : u == "value" ? b = y : u == "checked" ? I = y : u === "key" || a && typeof y != "function" || k[u] === y || _b(r, u, y, k[u], i);
    if (f)
      a || d && (f.__html === d.__html || f.__html === r.innerHTML) || (r.innerHTML = f.__html), e.__k = [];
    else if (d && (r.innerHTML = ""), DF(r, z3(m) ? m : [m], e, t, n, i && T !== "foreignObject", s, o, s ? s[0] : t.__k && Tg(t, 0), a, c), s != null)
      for (u = s.length; u--; )
        s[u] != null && PF(s[u]);
    a || (u = "value", b !== void 0 && (b !== r[u] || T === "progress" && !b || T === "option" && b !== k[u]) && _b(r, u, b, k[u], !1), u = "checked", I !== void 0 && I !== r[u] && _b(r, u, I, k[u], !1));
  }
  return r;
}
function OA(r, e, t) {
  try {
    typeof r == "function" ? r(e) : r.current = e;
  } catch (n) {
    Lt.__e(n, t);
  }
}
function dS(r, e, t) {
  var n, i;
  if (Lt.unmount && Lt.unmount(r), (n = r.ref) && (n.current && n.current !== r.__e || OA(n, null, e)), (n = r.__c) != null) {
    if (n.componentWillUnmount)
      try {
        n.componentWillUnmount();
      } catch (s) {
        Lt.__e(s, e);
      }
    n.base = n.__P = null, r.__c = void 0;
  }
  if (n = r.__k)
    for (i = 0; i < n.length; i++)
      n[i] && dS(n[i], e, t || typeof r.type != "function");
  t || r.__e == null || PF(r.__e), r.__ = r.__e = r.__d = void 0;
}
function rEe(r, e, t) {
  return this.constructor(r, t);
}
function BF(r, e, t) {
  var n, i, s, o;
  Lt.__ && Lt.__(r, e), i = (n = typeof t == "function") ? null : t && t.__k || e.__k, s = [], o = [], TA(e, r = (!n && t || e).__k = hS($y, null, [r]), i || bw, bw, e.ownerSVGElement !== void 0, !n && t ? [t] : i ? null : e.firstChild ? ky.call(e.childNodes) : null, s, !n && t ? t : i ? i.__e : e.firstChild, n, o), LF(s, r, o);
}
function FF(r, e) {
  BF(r, e, FF);
}
function nEe(r, e, t) {
  var n, i, s, o, a = Il({}, r.props);
  for (s in r.type && r.type.defaultProps && (o = r.type.defaultProps), e)
    s == "key" ? n = e[s] : s == "ref" ? i = e[s] : a[s] = e[s] === void 0 && o !== void 0 ? o[s] : e[s];
  return arguments.length > 2 && (a.children = arguments.length > 3 ? ky.call(arguments, 2) : t), _m(r.type, a, n || r.key, i || r.ref, null);
}
function iEe(r, e) {
  var t = { __c: e = "__cC" + OF++, __: r, Consumer: function(n, i) {
    return n.children(i);
  }, Provider: function(n) {
    var i, s;
    return this.getChildContext || (i = [], (s = {})[e] = this, this.getChildContext = function() {
      return s;
    }, this.shouldComponentUpdate = function(o) {
      this.props.value !== o.value && i.some(function(a) {
        a.__e = !0, fS(a);
      });
    }, this.sub = function(o) {
      i.push(o);
      var a = o.componentWillUnmount;
      o.componentWillUnmount = function() {
        i.splice(i.indexOf(o), 1), a && a.call(o);
      };
    }), n.children;
  } };
  return t.Provider.__ = t.Consumer.contextType = t;
}
ky = NF.slice, Lt = { __e: function(r, e, t, n) {
  for (var i, s, o; e = e.__; )
    if ((i = e.__c) && !i.__)
      try {
        if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(r)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(r, n || {}), o = i.__d), o)
          return i.__E = i;
      } catch (a) {
        r = a;
      }
  throw r;
} }, IF = 0, RF = function(r) {
  return r != null && r.constructor == null;
}, Em.prototype.setState = function(r, e) {
  var t;
  t = this.__s != null && this.__s !== this.state ? this.__s : this.__s = Il({}, this.state), typeof r == "function" && (r = r(Il({}, t), this.props)), r && Il(t, r), r != null && this.__v && (e && this._sb.push(e), fS(this));
}, Em.prototype.forceUpdate = function(r) {
  this.__v && (this.__e = !0, r && this.__h.push(r), fS(this));
}, Em.prototype.render = $y, tf = [], TF = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, uS = function(r, e) {
  return r.__v.__b - e.__v.__b;
}, n_.__r = 0, OF = 0;
const sEe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Component: Em,
  Fragment: $y,
  cloneElement: nEe,
  createContext: iEe,
  createElement: hS,
  createRef: Y3e,
  h: hS,
  hydrate: FF,
  get isValidElement() {
    return RF;
  },
  get options() {
    return Lt;
  },
  render: BF,
  toChildArray: $F
}, Symbol.toStringTag, { value: "Module" })), co = /* @__PURE__ */ La(sEe);
function Og(r) {
  return typeof r == "function";
}
var KN = !1, Mo = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(r) {
    if (r) {
      var e = /* @__PURE__ */ new Error();
      "" + e.stack;
    }
    KN = r;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return KN;
  }
};
function $p(r) {
  setTimeout(function() {
    throw r;
  }, 0);
}
var i_ = {
  closed: !0,
  next: function(r) {
  },
  error: function(r) {
    if (Mo.useDeprecatedSynchronousErrorHandling)
      throw r;
    $p(r);
  },
  complete: function() {
  }
}, hs = /* @__PURE__ */ function() {
  return Array.isArray || function(r) {
    return r && typeof r.length == "number";
  };
}();
function NA(r) {
  return r !== null && typeof r == "object";
}
var oEe = /* @__PURE__ */ function() {
  function r(e) {
    return Error.call(this), this.message = e ? e.length + ` errors occurred during unsubscription:
` + e.map(function(t, n) {
      return n + 1 + ") " + t.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = e, this;
  }
  return r.prototype = /* @__PURE__ */ Object.create(Error.prototype), r;
}(), xm = oEe, yn = /* @__PURE__ */ function() {
  function r(e) {
    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, e && (this._ctorUnsubscribe = !0, this._unsubscribe = e);
  }
  return r.prototype.unsubscribe = function() {
    var e;
    if (!this.closed) {
      var t = this, n = t._parentOrParents, i = t._ctorUnsubscribe, s = t._unsubscribe, o = t._subscriptions;
      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, n instanceof r)
        n.remove(this);
      else if (n !== null)
        for (var a = 0; a < n.length; ++a) {
          var c = n[a];
          c.remove(this);
        }
      if (Og(s)) {
        i && (this._unsubscribe = void 0);
        try {
          s.call(this);
        } catch (d) {
          e = d instanceof xm ? ZN(d.errors) : [d];
        }
      }
      if (hs(o))
        for (var a = -1, u = o.length; ++a < u; ) {
          var f = o[a];
          if (NA(f))
            try {
              f.unsubscribe();
            } catch (m) {
              e = e || [], m instanceof xm ? e = e.concat(ZN(m.errors)) : e.push(m);
            }
        }
      if (e)
        throw new xm(e);
    }
  }, r.prototype.add = function(e) {
    var t = e;
    if (!e)
      return r.EMPTY;
    switch (typeof e) {
      case "function":
        t = new r(e);
      case "object":
        if (t === this || t.closed || typeof t.unsubscribe != "function")
          return t;
        if (this.closed)
          return t.unsubscribe(), t;
        if (!(t instanceof r)) {
          var n = t;
          t = new r(), t._subscriptions = [n];
        }
        break;
      default:
        throw new Error("unrecognized teardown " + e + " added to Subscription.");
    }
    var i = t._parentOrParents;
    if (i === null)
      t._parentOrParents = this;
    else if (i instanceof r) {
      if (i === this)
        return t;
      t._parentOrParents = [i, this];
    } else if (i.indexOf(this) === -1)
      i.push(this);
    else
      return t;
    var s = this._subscriptions;
    return s === null ? this._subscriptions = [t] : s.push(t), t;
  }, r.prototype.remove = function(e) {
    var t = this._subscriptions;
    if (t) {
      var n = t.indexOf(e);
      n !== -1 && t.splice(n, 1);
    }
  }, r.EMPTY = function(e) {
    return e.closed = !0, e;
  }(new r()), r;
}();
function ZN(r) {
  return r.reduce(function(e, t) {
    return e.concat(t instanceof xm ? t.errors : t);
  }, []);
}
var s_ = /* @__PURE__ */ function() {
  return typeof Symbol == "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}(), yt = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this) || this;
    switch (s.syncErrorValue = null, s.syncErrorThrown = !1, s.syncErrorThrowable = !1, s.isStopped = !1, arguments.length) {
      case 0:
        s.destination = i_;
        break;
      case 1:
        if (!t) {
          s.destination = i_;
          break;
        }
        if (typeof t == "object") {
          t instanceof e ? (s.syncErrorThrowable = t.syncErrorThrowable, s.destination = t, t.add(s)) : (s.syncErrorThrowable = !0, s.destination = new JN(s, t));
          break;
        }
      default:
        s.syncErrorThrowable = !0, s.destination = new JN(s, t, n, i);
        break;
    }
    return s;
  }
  return e.prototype[s_] = function() {
    return this;
  }, e.create = function(t, n, i) {
    var s = new e(t, n, i);
    return s.syncErrorThrowable = !1, s;
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = !0, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, r.prototype.unsubscribe.call(this));
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    this.destination.error(t), this.unsubscribe();
  }, e.prototype._complete = function() {
    this.destination.complete(), this.unsubscribe();
  }, e.prototype._unsubscribeAndRecycle = function() {
    var t = this._parentOrParents;
    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this;
  }, e;
}(yn), JN = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s) {
    var o = r.call(this) || this;
    o._parentSubscriber = t;
    var a, c = o;
    return Og(n) ? a = n : n && (a = n.next, i = n.error, s = n.complete, n !== i_ && (c = Object.create(n), Og(c.unsubscribe) && o.add(c.unsubscribe.bind(c)), c.unsubscribe = o.unsubscribe.bind(o))), o._context = c, o._next = a, o._error = i, o._complete = s, o;
  }
  return e.prototype.next = function(t) {
    if (!this.isStopped && this._next) {
      var n = this._parentSubscriber;
      !Mo.useDeprecatedSynchronousErrorHandling || !n.syncErrorThrowable ? this.__tryOrUnsub(this._next, t) : this.__tryOrSetError(n, this._next, t) && this.unsubscribe();
    }
  }, e.prototype.error = function(t) {
    if (!this.isStopped) {
      var n = this._parentSubscriber, i = Mo.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        !i || !n.syncErrorThrowable ? (this.__tryOrUnsub(this._error, t), this.unsubscribe()) : (this.__tryOrSetError(n, this._error, t), this.unsubscribe());
      else if (n.syncErrorThrowable)
        i ? (n.syncErrorValue = t, n.syncErrorThrown = !0) : $p(t), this.unsubscribe();
      else {
        if (this.unsubscribe(), i)
          throw t;
        $p(t);
      }
    }
  }, e.prototype.complete = function() {
    var t = this;
    if (!this.isStopped) {
      var n = this._parentSubscriber;
      if (this._complete) {
        var i = function() {
          return t._complete.call(t._context);
        };
        !Mo.useDeprecatedSynchronousErrorHandling || !n.syncErrorThrowable ? (this.__tryOrUnsub(i), this.unsubscribe()) : (this.__tryOrSetError(n, i), this.unsubscribe());
      } else
        this.unsubscribe();
    }
  }, e.prototype.__tryOrUnsub = function(t, n) {
    try {
      t.call(this._context, n);
    } catch (i) {
      if (this.unsubscribe(), Mo.useDeprecatedSynchronousErrorHandling)
        throw i;
      $p(i);
    }
  }, e.prototype.__tryOrSetError = function(t, n, i) {
    if (!Mo.useDeprecatedSynchronousErrorHandling)
      throw new Error("bad call");
    try {
      n.call(this._context, i);
    } catch (s) {
      return Mo.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = s, t.syncErrorThrown = !0, !0) : ($p(s), !0);
    }
    return !1;
  }, e.prototype._unsubscribe = function() {
    var t = this._parentSubscriber;
    this._context = null, this._parentSubscriber = null, t.unsubscribe();
  }, e;
}(yt);
function PA(r) {
  for (; r; ) {
    var e = r, t = e.closed, n = e.destination, i = e.isStopped;
    if (t || i)
      return !1;
    n && n instanceof yt ? r = n : r = null;
  }
  return !0;
}
function aEe(r, e, t) {
  if (r) {
    if (r instanceof yt)
      return r;
    if (r[s_])
      return r[s_]();
  }
  return !r && !e && !t ? new yt(i_) : new yt(r, e, t);
}
var t1 = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function sh(r) {
  return r;
}
function pS() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return UF(r);
}
function UF(r) {
  return r.length === 0 ? sh : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(n, i) {
      return i(n);
    }, t);
  };
}
var ir = /* @__PURE__ */ function() {
  function r(e) {
    this._isScalar = !1, e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, n) {
    var i = this.operator, s = aEe(e, t, n);
    if (i ? s.add(i.call(s, this.source)) : s.add(this.source || Mo.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), Mo.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown))
      throw s.syncErrorValue;
    return s;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      Mo.useDeprecatedSynchronousErrorHandling && (e.syncErrorThrown = !0, e.syncErrorValue = t), PA(e) ? e.error(t) : console.warn(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var n = this;
    return t = QN(t), new t(function(i, s) {
      var o;
      o = n.subscribe(function(a) {
        try {
          e(a);
        } catch (c) {
          s(c), o && o.unsubscribe();
        }
      }, s, i);
    });
  }, r.prototype._subscribe = function(e) {
    var t = this.source;
    return t && t.subscribe(e);
  }, r.prototype[t1] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return e.length === 0 ? this : UF(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = QN(e), new e(function(n, i) {
      var s;
      t.subscribe(function(o) {
        return s = o;
      }, function(o) {
        return i(o);
      }, function() {
        return n(s);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
}();
function QN(r) {
  if (r || (r = Mo.Promise || Promise), !r)
    throw new Error("no Promise impl found");
  return r;
}
var cEe = /* @__PURE__ */ function() {
  function r() {
    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
  }
  return r.prototype = /* @__PURE__ */ Object.create(Error.prototype), r;
}(), vu = cEe, jF = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.subject = t, i.subscriber = n, i.closed = !1, i;
  }
  return e.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.closed = !0;
      var t = this.subject, n = t.observers;
      if (this.subject = null, !(!n || n.length === 0 || t.isStopped || t.closed)) {
        var i = n.indexOf(this.subscriber);
        i !== -1 && n.splice(i, 1);
      }
    }
  }, e;
}(yn), WF = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this, t) || this;
    return n.destination = t, n;
  }
  return e;
}(yt), ui = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    var t = r.call(this) || this;
    return t.observers = [], t.closed = !1, t.isStopped = !1, t.hasError = !1, t.thrownError = null, t;
  }
  return e.prototype[s_] = function() {
    return new WF(this);
  }, e.prototype.lift = function(t) {
    var n = new YN(this, this);
    return n.operator = t, n;
  }, e.prototype.next = function(t) {
    if (this.closed)
      throw new vu();
    if (!this.isStopped)
      for (var n = this.observers, i = n.length, s = n.slice(), o = 0; o < i; o++)
        s[o].next(t);
  }, e.prototype.error = function(t) {
    if (this.closed)
      throw new vu();
    this.hasError = !0, this.thrownError = t, this.isStopped = !0;
    for (var n = this.observers, i = n.length, s = n.slice(), o = 0; o < i; o++)
      s[o].error(t);
    this.observers.length = 0;
  }, e.prototype.complete = function() {
    if (this.closed)
      throw new vu();
    this.isStopped = !0;
    for (var t = this.observers, n = t.length, i = t.slice(), s = 0; s < n; s++)
      i[s].complete();
    this.observers.length = 0;
  }, e.prototype.unsubscribe = function() {
    this.isStopped = !0, this.closed = !0, this.observers = null;
  }, e.prototype._trySubscribe = function(t) {
    if (this.closed)
      throw new vu();
    return r.prototype._trySubscribe.call(this, t);
  }, e.prototype._subscribe = function(t) {
    if (this.closed)
      throw new vu();
    return this.hasError ? (t.error(this.thrownError), yn.EMPTY) : this.isStopped ? (t.complete(), yn.EMPTY) : (this.observers.push(t), new jF(this, t));
  }, e.prototype.asObservable = function() {
    var t = new ir();
    return t.source = this, t;
  }, e.create = function(t, n) {
    return new YN(t, n);
  }, e;
}(ir), YN = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.destination = t, i.source = n, i;
  }
  return e.prototype.next = function(t) {
    var n = this.destination;
    n && n.next && n.next(t);
  }, e.prototype.error = function(t) {
    var n = this.destination;
    n && n.error && this.destination.error(t);
  }, e.prototype.complete = function() {
    var t = this.destination;
    t && t.complete && this.destination.complete();
  }, e.prototype._subscribe = function(t) {
    var n = this.source;
    return n ? this.source.subscribe(t) : yn.EMPTY;
  }, e;
}(ui);
function MA() {
  return function(e) {
    return e.lift(new lEe(e));
  };
}
var lEe = /* @__PURE__ */ function() {
  function r(e) {
    this.connectable = e;
  }
  return r.prototype.call = function(e, t) {
    var n = this.connectable;
    n._refCount++;
    var i = new uEe(e, n), s = t.subscribe(i);
    return i.closed || (i.connection = n.connect()), s;
  }, r;
}(), uEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.connectable = n, i;
  }
  return e.prototype._unsubscribe = function() {
    var t = this.connectable;
    if (!t) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var n = t._refCount;
    if (n <= 0) {
      this.connection = null;
      return;
    }
    if (t._refCount = n - 1, n > 1) {
      this.connection = null;
      return;
    }
    var i = this.connection, s = t._connection;
    this.connection = null, s && (!i || s === i) && s.unsubscribe();
  }, e;
}(yt), HF = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.source = t, i.subjectFactory = n, i._refCount = 0, i._isComplete = !1, i;
  }
  return e.prototype._subscribe = function(t) {
    return this.getSubject().subscribe(t);
  }, e.prototype.getSubject = function() {
    var t = this._subject;
    return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, e.prototype.connect = function() {
    var t = this._connection;
    return t || (this._isComplete = !1, t = this._connection = new yn(), t.add(this.source.subscribe(new fEe(this.getSubject(), this))), t.closed && (this._connection = null, t = yn.EMPTY)), t;
  }, e.prototype.refCount = function() {
    return MA()(this);
  }, e;
}(ir), hEe = /* @__PURE__ */ function() {
  var r = HF.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: !0 },
    _subject: { value: null, writable: !0 },
    _connection: { value: null, writable: !0 },
    _subscribe: { value: r._subscribe },
    _isComplete: { value: r._isComplete, writable: !0 },
    getSubject: { value: r.getSubject },
    connect: { value: r.connect },
    refCount: { value: r.refCount }
  };
}(), fEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.connectable = n, i;
  }
  return e.prototype._error = function(t) {
    this._unsubscribe(), r.prototype._error.call(this, t);
  }, e.prototype._complete = function() {
    this.connectable._isComplete = !0, this._unsubscribe(), r.prototype._complete.call(this);
  }, e.prototype._unsubscribe = function() {
    var t = this.connectable;
    if (t) {
      this.connectable = null;
      var n = t._connection;
      t._refCount = 0, t._subject = null, t._connection = null, n && n.unsubscribe();
    }
  }, e;
}(WF);
function dEe(r, e, t, n) {
  return function(i) {
    return i.lift(new pEe(r, e, t, n));
  };
}
var pEe = /* @__PURE__ */ function() {
  function r(e, t, n, i) {
    this.keySelector = e, this.elementSelector = t, this.durationSelector = n, this.subjectSelector = i;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new gEe(e, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  }, r;
}(), gEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s, o) {
    var a = r.call(this, t) || this;
    return a.keySelector = n, a.elementSelector = i, a.durationSelector = s, a.subjectSelector = o, a.groups = null, a.attemptedToUnsubscribe = !1, a.count = 0, a;
  }
  return e.prototype._next = function(t) {
    var n;
    try {
      n = this.keySelector(t);
    } catch (i) {
      this.error(i);
      return;
    }
    this._group(t, n);
  }, e.prototype._group = function(t, n) {
    var i = this.groups;
    i || (i = this.groups = /* @__PURE__ */ new Map());
    var s = i.get(n), o;
    if (this.elementSelector)
      try {
        o = this.elementSelector(t);
      } catch (u) {
        this.error(u);
      }
    else
      o = t;
    if (!s) {
      s = this.subjectSelector ? this.subjectSelector() : new ui(), i.set(n, s);
      var a = new gS(n, s, this);
      if (this.destination.next(a), this.durationSelector) {
        var c = void 0;
        try {
          c = this.durationSelector(new gS(n, s));
        } catch (u) {
          this.error(u);
          return;
        }
        this.add(c.subscribe(new mEe(n, s, this)));
      }
    }
    s.closed || s.next(o);
  }, e.prototype._error = function(t) {
    var n = this.groups;
    n && (n.forEach(function(i, s) {
      i.error(t);
    }), n.clear()), this.destination.error(t);
  }, e.prototype._complete = function() {
    var t = this.groups;
    t && (t.forEach(function(n, i) {
      n.complete();
    }), t.clear()), this.destination.complete();
  }, e.prototype.removeGroup = function(t) {
    this.groups.delete(t);
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && r.prototype.unsubscribe.call(this));
  }, e;
}(yt), mEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, n) || this;
    return s.key = t, s.group = n, s.parent = i, s;
  }
  return e.prototype._next = function(t) {
    this.complete();
  }, e.prototype._unsubscribe = function() {
    var t = this, n = t.parent, i = t.key;
    this.key = this.parent = null, n && n.removeGroup(i);
  }, e;
}(yt), gS = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this) || this;
    return s.key = t, s.groupSubject = n, s.refCountSubscription = i, s;
  }
  return e.prototype._subscribe = function(t) {
    var n = new yn(), i = this, s = i.refCountSubscription, o = i.groupSubject;
    return s && !s.closed && n.add(new wEe(s)), n.add(o.subscribe(t)), n;
  }, e;
}(ir), wEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.parent = t, t.count++, n;
  }
  return e.prototype.unsubscribe = function() {
    var t = this.parent;
    !t.closed && !this.closed && (r.prototype.unsubscribe.call(this), t.count -= 1, t.count === 0 && t.attemptedToUnsubscribe && t.unsubscribe());
  }, e;
}(yn), zF = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n._value = t, n;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype._subscribe = function(t) {
    var n = r.prototype._subscribe.call(this, t);
    return n && !n.closed && t.next(this._value), n;
  }, e.prototype.getValue = function() {
    if (this.hasError)
      throw this.thrownError;
    if (this.closed)
      throw new vu();
    return this._value;
  }, e.prototype.next = function(t) {
    r.prototype.next.call(this, this._value = t);
  }, e;
}(ui), yEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    return r.call(this) || this;
  }
  return e.prototype.schedule = function(t, n) {
    return this;
  }, e;
}(yn), Ly = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t, n) || this;
    return i.scheduler = t, i.work = n, i.pending = !1, i;
  }
  return e.prototype.schedule = function(t, n) {
    if (n === void 0 && (n = 0), this.closed)
      return this;
    this.state = t;
    var i = this.id, s = this.scheduler;
    return i != null && (this.id = this.recycleAsyncId(s, i, n)), this.pending = !0, this.delay = n, this.id = this.id || this.requestAsyncId(s, this.id, n), this;
  }, e.prototype.requestAsyncId = function(t, n, i) {
    return i === void 0 && (i = 0), setInterval(t.flush.bind(t, this), i);
  }, e.prototype.recycleAsyncId = function(t, n, i) {
    if (i === void 0 && (i = 0), i !== null && this.delay === i && this.pending === !1)
      return n;
    clearInterval(n);
  }, e.prototype.execute = function(t, n) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var i = this._execute(t, n);
    if (i)
      return i;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(t, n) {
    var i = !1, s = void 0;
    try {
      this.work(t);
    } catch (o) {
      i = !0, s = !!o && o || new Error(o);
    }
    if (i)
      return this.unsubscribe(), s;
  }, e.prototype._unsubscribe = function() {
    var t = this.id, n = this.scheduler, i = n.actions, s = i.indexOf(this);
    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, s !== -1 && i.splice(s, 1), t != null && (this.id = this.recycleAsyncId(n, t, null)), this.delay = null;
  }, e;
}(yEe), vEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t, n) || this;
    return i.scheduler = t, i.work = n, i;
  }
  return e.prototype.schedule = function(t, n) {
    return n === void 0 && (n = 0), n > 0 ? r.prototype.schedule.call(this, t, n) : (this.delay = n, this.state = t, this.scheduler.flush(this), this);
  }, e.prototype.execute = function(t, n) {
    return n > 0 || this.closed ? r.prototype.execute.call(this, t, n) : this._execute(t, n);
  }, e.prototype.requestAsyncId = function(t, n, i) {
    return i === void 0 && (i = 0), i !== null && i > 0 || i === null && this.delay > 0 ? r.prototype.requestAsyncId.call(this, t, n, i) : t.flush(this);
  }, e;
}(Ly), mS = /* @__PURE__ */ function() {
  function r(e, t) {
    t === void 0 && (t = r.now), this.SchedulerAction = e, this.now = t;
  }
  return r.prototype.schedule = function(e, t, n) {
    return t === void 0 && (t = 0), new this.SchedulerAction(this, e).schedule(n, t);
  }, r.now = function() {
    return Date.now();
  }, r;
}(), By = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    n === void 0 && (n = mS.now);
    var i = r.call(this, t, function() {
      return e.delegate && e.delegate !== i ? e.delegate.now() : n();
    }) || this;
    return i.actions = [], i.active = !1, i.scheduled = void 0, i;
  }
  return e.prototype.schedule = function(t, n, i) {
    return n === void 0 && (n = 0), e.delegate && e.delegate !== this ? e.delegate.schedule(t, n, i) : r.prototype.schedule.call(this, t, n, i);
  }, e.prototype.flush = function(t) {
    var n = this.actions;
    if (this.active) {
      n.push(t);
      return;
    }
    var i;
    this.active = !0;
    do
      if (i = t.execute(t.state, t.delay))
        break;
    while (t = n.shift());
    if (this.active = !1, i) {
      for (; t = n.shift(); )
        t.unsubscribe();
      throw i;
    }
  }, e;
}(mS), bEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e;
}(By), VF = /* @__PURE__ */ new bEe(vEe), qF = VF, Ng = /* @__PURE__ */ new ir(function(r) {
  return r.complete();
});
function r1(r) {
  return r ? _Ee(r) : Ng;
}
function _Ee(r) {
  return new ir(function(e) {
    return r.schedule(function() {
      return e.complete();
    });
  });
}
function no(r) {
  return r && typeof r.schedule == "function";
}
var GF = function(r) {
  return function(e) {
    for (var t = 0, n = r.length; t < n && !e.closed; t++)
      e.next(r[t]);
    e.complete();
  };
};
function DA(r, e) {
  return new ir(function(t) {
    var n = new yn(), i = 0;
    return n.add(e.schedule(function() {
      if (i === r.length) {
        t.complete();
        return;
      }
      t.next(r[i++]), t.closed || n.add(this.schedule());
    })), n;
  });
}
function Fy(r, e) {
  return e ? DA(r, e) : new ir(GF(r));
}
function V3() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = r[r.length - 1];
  return no(t) ? (r.pop(), DA(r, t)) : Fy(r);
}
function kA(r, e) {
  return e ? new ir(function(t) {
    return e.schedule(EEe, 0, { error: r, subscriber: t });
  }) : new ir(function(t) {
    return t.error(r);
  });
}
function EEe(r) {
  var e = r.error, t = r.subscriber;
  t.error(e);
}
var wS;
wS || (wS = {});
var Nl = /* @__PURE__ */ function() {
  function r(e, t, n) {
    this.kind = e, this.value = t, this.error = n, this.hasValue = e === "N";
  }
  return r.prototype.observe = function(e) {
    switch (this.kind) {
      case "N":
        return e.next && e.next(this.value);
      case "E":
        return e.error && e.error(this.error);
      case "C":
        return e.complete && e.complete();
    }
  }, r.prototype.do = function(e, t, n) {
    var i = this.kind;
    switch (i) {
      case "N":
        return e && e(this.value);
      case "E":
        return t && t(this.error);
      case "C":
        return n && n();
    }
  }, r.prototype.accept = function(e, t, n) {
    return e && typeof e.next == "function" ? this.observe(e) : this.do(e, t, n);
  }, r.prototype.toObservable = function() {
    var e = this.kind;
    switch (e) {
      case "N":
        return V3(this.value);
      case "E":
        return kA(this.error);
      case "C":
        return r1();
    }
    throw new Error("unexpected notification kind value");
  }, r.createNext = function(e) {
    return typeof e < "u" ? new r("N", e) : r.undefinedValueNotification;
  }, r.createError = function(e) {
    return new r("E", void 0, e);
  }, r.createComplete = function() {
    return r.completeNotification;
  }, r.completeNotification = new r("C"), r.undefinedValueNotification = new r("N", void 0), r;
}();
function xEe(r, e) {
  return e === void 0 && (e = 0), function(n) {
    return n.lift(new SEe(r, e));
  };
}
var SEe = /* @__PURE__ */ function() {
  function r(e, t) {
    t === void 0 && (t = 0), this.scheduler = e, this.delay = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new KF(e, this.scheduler, this.delay));
  }, r;
}(), KF = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    i === void 0 && (i = 0);
    var s = r.call(this, t) || this;
    return s.scheduler = n, s.delay = i, s;
  }
  return e.dispatch = function(t) {
    var n = t.notification, i = t.destination;
    n.observe(i), this.unsubscribe();
  }, e.prototype.scheduleMessage = function(t) {
    var n = this.destination;
    n.add(this.scheduler.schedule(e.dispatch, this.delay, new CEe(t, this.destination)));
  }, e.prototype._next = function(t) {
    this.scheduleMessage(Nl.createNext(t));
  }, e.prototype._error = function(t) {
    this.scheduleMessage(Nl.createError(t)), this.unsubscribe();
  }, e.prototype._complete = function() {
    this.scheduleMessage(Nl.createComplete()), this.unsubscribe();
  }, e;
}(yt), CEe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.notification = e, this.destination = t;
  }
  return r;
}(), $A = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    t === void 0 && (t = Number.POSITIVE_INFINITY), n === void 0 && (n = Number.POSITIVE_INFINITY);
    var s = r.call(this) || this;
    return s.scheduler = i, s._events = [], s._infiniteTimeWindow = !1, s._bufferSize = t < 1 ? 1 : t, s._windowTime = n < 1 ? 1 : n, n === Number.POSITIVE_INFINITY ? (s._infiniteTimeWindow = !0, s.next = s.nextInfiniteTimeWindow) : s.next = s.nextTimeWindow, s;
  }
  return e.prototype.nextInfiniteTimeWindow = function(t) {
    if (!this.isStopped) {
      var n = this._events;
      n.push(t), n.length > this._bufferSize && n.shift();
    }
    r.prototype.next.call(this, t);
  }, e.prototype.nextTimeWindow = function(t) {
    this.isStopped || (this._events.push(new AEe(this._getNow(), t)), this._trimBufferThenGetEvents()), r.prototype.next.call(this, t);
  }, e.prototype._subscribe = function(t) {
    var n = this._infiniteTimeWindow, i = n ? this._events : this._trimBufferThenGetEvents(), s = this.scheduler, o = i.length, a;
    if (this.closed)
      throw new vu();
    if (this.isStopped || this.hasError ? a = yn.EMPTY : (this.observers.push(t), a = new jF(this, t)), s && t.add(t = new KF(t, s)), n)
      for (var c = 0; c < o && !t.closed; c++)
        t.next(i[c]);
    else
      for (var c = 0; c < o && !t.closed; c++)
        t.next(i[c].value);
    return this.hasError ? t.error(this.thrownError) : this.isStopped && t.complete(), a;
  }, e.prototype._getNow = function() {
    return (this.scheduler || qF).now();
  }, e.prototype._trimBufferThenGetEvents = function() {
    for (var t = this._getNow(), n = this._bufferSize, i = this._windowTime, s = this._events, o = s.length, a = 0; a < o && !(t - s[a].time < i); )
      a++;
    return o > n && (a = Math.max(a, o - n)), a > 0 && s.splice(0, a), s;
  }, e;
}(ui), AEe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.time = e, this.value = t;
  }
  return r;
}(), n1 = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.value = null, t.hasNext = !1, t.hasCompleted = !1, t;
  }
  return e.prototype._subscribe = function(t) {
    return this.hasError ? (t.error(this.thrownError), yn.EMPTY) : this.hasCompleted && this.hasNext ? (t.next(this.value), t.complete(), yn.EMPTY) : r.prototype._subscribe.call(this, t);
  }, e.prototype.next = function(t) {
    this.hasCompleted || (this.value = t, this.hasNext = !0);
  }, e.prototype.error = function(t) {
    this.hasCompleted || r.prototype.error.call(this, t);
  }, e.prototype.complete = function() {
    this.hasCompleted = !0, this.hasNext && r.prototype.next.call(this, this.value), r.prototype.complete.call(this);
  }, e;
}(ui), IEe = 1, REe = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}(), yS = {};
function XN(r) {
  return r in yS ? (delete yS[r], !0) : !1;
}
var eP = {
  setImmediate: function(r) {
    var e = IEe++;
    return yS[e] = !0, REe.then(function() {
      return XN(e) && r();
    }), e;
  },
  clearImmediate: function(r) {
    XN(r);
  }
}, TEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t, n) || this;
    return i.scheduler = t, i.work = n, i;
  }
  return e.prototype.requestAsyncId = function(t, n, i) {
    return i === void 0 && (i = 0), i !== null && i > 0 ? r.prototype.requestAsyncId.call(this, t, n, i) : (t.actions.push(this), t.scheduled || (t.scheduled = eP.setImmediate(t.flush.bind(t, null))));
  }, e.prototype.recycleAsyncId = function(t, n, i) {
    if (i === void 0 && (i = 0), i !== null && i > 0 || i === null && this.delay > 0)
      return r.prototype.recycleAsyncId.call(this, t, n, i);
    t.actions.length === 0 && (eP.clearImmediate(n), t.scheduled = void 0);
  }, e;
}(Ly), OEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.flush = function(t) {
    this.active = !0, this.scheduled = void 0;
    var n = this.actions, i, s = -1, o = n.length;
    t = t || n.shift();
    do
      if (i = t.execute(t.state, t.delay))
        break;
    while (++s < o && (t = n.shift()));
    if (this.active = !1, i) {
      for (; ++s < o && (t = n.shift()); )
        t.unsubscribe();
      throw i;
    }
  }, e;
}(By), ZF = /* @__PURE__ */ new OEe(TEe), Gb = ZF, JF = /* @__PURE__ */ new By(Ly), fs = JF, NEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t, n) || this;
    return i.scheduler = t, i.work = n, i;
  }
  return e.prototype.requestAsyncId = function(t, n, i) {
    return i === void 0 && (i = 0), i !== null && i > 0 ? r.prototype.requestAsyncId.call(this, t, n, i) : (t.actions.push(this), t.scheduled || (t.scheduled = requestAnimationFrame(function() {
      return t.flush(null);
    })));
  }, e.prototype.recycleAsyncId = function(t, n, i) {
    if (i === void 0 && (i = 0), i !== null && i > 0 || i === null && this.delay > 0)
      return r.prototype.recycleAsyncId.call(this, t, n, i);
    t.actions.length === 0 && (cancelAnimationFrame(n), t.scheduled = void 0);
  }, e;
}(Ly), PEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.flush = function(t) {
    this.active = !0, this.scheduled = void 0;
    var n = this.actions, i, s = -1, o = n.length;
    t = t || n.shift();
    do
      if (i = t.execute(t.state, t.delay))
        break;
    while (++s < o && (t = n.shift()));
    if (this.active = !1, i) {
      for (; ++s < o && (t = n.shift()); )
        t.unsubscribe();
      throw i;
    }
  }, e;
}(By), QF = /* @__PURE__ */ new PEe(NEe), MEe = QF, DEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    t === void 0 && (t = YF), n === void 0 && (n = Number.POSITIVE_INFINITY);
    var i = r.call(this, t, function() {
      return i.frame;
    }) || this;
    return i.maxFrames = n, i.frame = 0, i.index = -1, i;
  }
  return e.prototype.flush = function() {
    for (var t = this, n = t.actions, i = t.maxFrames, s, o; (o = n[0]) && o.delay <= i && (n.shift(), this.frame = o.delay, !(s = o.execute(o.state, o.delay))); )
      ;
    if (s) {
      for (; o = n.shift(); )
        o.unsubscribe();
      throw s;
    }
  }, e.frameTimeFactor = 10, e;
}(By), YF = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    i === void 0 && (i = t.index += 1);
    var s = r.call(this, t, n) || this;
    return s.scheduler = t, s.work = n, s.index = i, s.active = !0, s.index = t.index = i, s;
  }
  return e.prototype.schedule = function(t, n) {
    if (n === void 0 && (n = 0), !this.id)
      return r.prototype.schedule.call(this, t, n);
    this.active = !1;
    var i = new e(this.scheduler, this.work);
    return this.add(i), i.schedule(t, n);
  }, e.prototype.requestAsyncId = function(t, n, i) {
    i === void 0 && (i = 0), this.delay = t.frame + i;
    var s = t.actions;
    return s.push(this), s.sort(e.sortActions), !0;
  }, e.prototype.recycleAsyncId = function(t, n, i) {
  }, e.prototype._execute = function(t, n) {
    if (this.active === !0)
      return r.prototype._execute.call(this, t, n);
  }, e.sortActions = function(t, n) {
    return t.delay === n.delay ? t.index === n.index ? 0 : t.index > n.index ? 1 : -1 : t.delay > n.delay ? 1 : -1;
  }, e;
}(Ly);
function oc() {
}
function kEe(r) {
  return !!r && (r instanceof ir || typeof r.lift == "function" && typeof r.subscribe == "function");
}
var $Ee = /* @__PURE__ */ function() {
  function r() {
    return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
  }
  return r.prototype = /* @__PURE__ */ Object.create(Error.prototype), r;
}(), Pg = $Ee, LEe = /* @__PURE__ */ function() {
  function r() {
    return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
  }
  return r.prototype = /* @__PURE__ */ Object.create(Error.prototype), r;
}(), Uy = LEe, BEe = /* @__PURE__ */ function() {
  function r() {
    return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
  }
  return r.prototype = /* @__PURE__ */ Object.create(Error.prototype), r;
}(), XF = BEe;
function Vo(r, e) {
  return function(n) {
    if (typeof r != "function")
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    return n.lift(new FEe(r, e));
  };
}
var FEe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.project = e, this.thisArg = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new UEe(e, this.project, this.thisArg));
  }, r;
}(), UEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.project = n, s.count = 0, s.thisArg = i || s, s;
  }
  return e.prototype._next = function(t) {
    var n;
    try {
      n = this.project.call(this.thisArg, t, this.count++);
    } catch (i) {
      this.destination.error(i);
      return;
    }
    this.destination.next(n);
  }, e;
}(yt);
function eU(r, e, t) {
  if (e)
    if (no(e))
      t = e;
    else
      return function() {
        for (var n = [], i = 0; i < arguments.length; i++)
          n[i] = arguments[i];
        return eU(r, t).apply(void 0, n).pipe(Vo(function(s) {
          return hs(s) ? e.apply(void 0, s) : e(s);
        }));
      };
  return function() {
    for (var n = [], i = 0; i < arguments.length; i++)
      n[i] = arguments[i];
    var s = this, o, a = {
      context: s,
      subject: o,
      callbackFunc: r,
      scheduler: t
    };
    return new ir(function(c) {
      if (t) {
        var f = {
          args: n,
          subscriber: c,
          params: a
        };
        return t.schedule(jEe, 0, f);
      } else {
        if (!o) {
          o = new n1();
          var u = function() {
            for (var d = [], m = 0; m < arguments.length; m++)
              d[m] = arguments[m];
            o.next(d.length <= 1 ? d[0] : d), o.complete();
          };
          try {
            r.apply(s, n.concat([u]));
          } catch (d) {
            PA(o) ? o.error(d) : console.warn(d);
          }
        }
        return o.subscribe(c);
      }
    });
  };
}
function jEe(r) {
  var e = this, t = r.args, n = r.subscriber, i = r.params, s = i.callbackFunc, o = i.context, a = i.scheduler, c = i.subject;
  if (!c) {
    c = i.subject = new n1();
    var u = function() {
      for (var f = [], d = 0; d < arguments.length; d++)
        f[d] = arguments[d];
      var m = f.length <= 1 ? f[0] : f;
      e.add(a.schedule(WEe, 0, { value: m, subject: c }));
    };
    try {
      s.apply(o, t.concat([u]));
    } catch (f) {
      c.error(f);
    }
  }
  this.add(c.subscribe(n));
}
function WEe(r) {
  var e = r.value, t = r.subject;
  t.next(e), t.complete();
}
function tU(r, e, t) {
  if (e)
    if (no(e))
      t = e;
    else
      return function() {
        for (var n = [], i = 0; i < arguments.length; i++)
          n[i] = arguments[i];
        return tU(r, t).apply(void 0, n).pipe(Vo(function(s) {
          return hs(s) ? e.apply(void 0, s) : e(s);
        }));
      };
  return function() {
    for (var n = [], i = 0; i < arguments.length; i++)
      n[i] = arguments[i];
    var s = {
      subject: void 0,
      args: n,
      callbackFunc: r,
      scheduler: t,
      context: this
    };
    return new ir(function(o) {
      var a = s.context, c = s.subject;
      if (t)
        return t.schedule(HEe, 0, { params: s, subscriber: o, context: a });
      if (!c) {
        c = s.subject = new n1();
        var u = function() {
          for (var f = [], d = 0; d < arguments.length; d++)
            f[d] = arguments[d];
          var m = f.shift();
          if (m) {
            c.error(m);
            return;
          }
          c.next(f.length <= 1 ? f[0] : f), c.complete();
        };
        try {
          r.apply(a, n.concat([u]));
        } catch (f) {
          PA(c) ? c.error(f) : console.warn(f);
        }
      }
      return c.subscribe(o);
    });
  };
}
function HEe(r) {
  var e = this, t = r.params, n = r.subscriber, i = r.context, s = t.callbackFunc, o = t.args, a = t.scheduler, c = t.subject;
  if (!c) {
    c = t.subject = new n1();
    var u = function() {
      for (var f = [], d = 0; d < arguments.length; d++)
        f[d] = arguments[d];
      var m = f.shift();
      if (m)
        e.add(a.schedule(tP, 0, { err: m, subject: c }));
      else {
        var y = f.length <= 1 ? f[0] : f;
        e.add(a.schedule(zEe, 0, { value: y, subject: c }));
      }
    };
    try {
      s.apply(i, o.concat([u]));
    } catch (f) {
      this.add(a.schedule(tP, 0, { err: f, subject: c }));
    }
  }
  this.add(c.subscribe(n));
}
function zEe(r) {
  var e = r.value, t = r.subject;
  t.next(e), t.complete();
}
function tP(r) {
  var e = r.err, t = r.subject;
  t.error(e);
}
var Wd = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.notifyNext = function(t, n, i, s, o) {
    this.destination.next(n);
  }, e.prototype.notifyError = function(t, n) {
    this.destination.error(t);
  }, e.prototype.notifyComplete = function(t) {
    this.destination.complete();
  }, e;
}(yt), VEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this) || this;
    return s.parent = t, s.outerValue = n, s.outerIndex = i, s.index = 0, s;
  }
  return e.prototype._next = function(t) {
    this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this);
  }, e.prototype._error = function(t) {
    this.parent.notifyError(t, this), this.unsubscribe();
  }, e.prototype._complete = function() {
    this.parent.notifyComplete(this), this.unsubscribe();
  }, e;
}(yt), qEe = function(r) {
  return function(e) {
    return r.then(function(t) {
      e.closed || (e.next(t), e.complete());
    }, function(t) {
      return e.error(t);
    }).then(null, $p), e;
  };
};
function GEe() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var oh = /* @__PURE__ */ GEe(), KEe = function(r) {
  return function(e) {
    var t = r[oh]();
    do {
      var n = void 0;
      try {
        n = t.next();
      } catch (i) {
        return e.error(i), e;
      }
      if (n.done) {
        e.complete();
        break;
      }
      if (e.next(n.value), e.closed)
        break;
    } while (!0);
    return typeof t.return == "function" && e.add(function() {
      t.return && t.return();
    }), e;
  };
}, ZEe = function(r) {
  return function(e) {
    var t = r[t1]();
    if (typeof t.subscribe != "function")
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    return t.subscribe(e);
  };
}, rU = function(r) {
  return r && typeof r.length == "number" && typeof r != "function";
};
function nU(r) {
  return !!r && typeof r.subscribe != "function" && typeof r.then == "function";
}
var _w = function(r) {
  if (r && typeof r[t1] == "function")
    return ZEe(r);
  if (rU(r))
    return GF(r);
  if (nU(r))
    return qEe(r);
  if (r && typeof r[oh] == "function")
    return KEe(r);
  var e = NA(r) ? "an invalid object" : "'" + r + "'", t = "You provided " + e + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
  throw new TypeError(t);
};
function Ll(r, e, t, n, i) {
  if (i === void 0 && (i = new VEe(r, t, n)), !i.closed)
    return e instanceof ir ? e.subscribe(i) : _w(e)(i);
}
var rP = {};
function JEe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = void 0, n = void 0;
  return no(r[r.length - 1]) && (n = r.pop()), typeof r[r.length - 1] == "function" && (t = r.pop()), r.length === 1 && hs(r[0]) && (r = r[0]), Fy(r, n).lift(new LA(t));
}
var LA = /* @__PURE__ */ function() {
  function r(e) {
    this.resultSelector = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new QEe(e, this.resultSelector));
  }, r;
}(), QEe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.resultSelector = n, i.active = 0, i.values = [], i.observables = [], i;
  }
  return e.prototype._next = function(t) {
    this.values.push(rP), this.observables.push(t);
  }, e.prototype._complete = function() {
    var t = this.observables, n = t.length;
    if (n === 0)
      this.destination.complete();
    else {
      this.active = n, this.toRespond = n;
      for (var i = 0; i < n; i++) {
        var s = t[i];
        this.add(Ll(this, s, void 0, i));
      }
    }
  }, e.prototype.notifyComplete = function(t) {
    (this.active -= 1) === 0 && this.destination.complete();
  }, e.prototype.notifyNext = function(t, n, i) {
    var s = this.values, o = s[i], a = this.toRespond ? o === rP ? --this.toRespond : this.toRespond : 0;
    s[i] = n, a === 0 && (this.resultSelector ? this._tryResultSelector(s) : this.destination.next(s.slice()));
  }, e.prototype._tryResultSelector = function(t) {
    var n;
    try {
      n = this.resultSelector.apply(this, t);
    } catch (i) {
      this.destination.error(i);
      return;
    }
    this.destination.next(n);
  }, e;
}(Wd);
function YEe(r, e) {
  return new ir(function(t) {
    var n = new yn();
    return n.add(e.schedule(function() {
      var i = r[t1]();
      n.add(i.subscribe({
        next: function(s) {
          n.add(e.schedule(function() {
            return t.next(s);
          }));
        },
        error: function(s) {
          n.add(e.schedule(function() {
            return t.error(s);
          }));
        },
        complete: function() {
          n.add(e.schedule(function() {
            return t.complete();
          }));
        }
      }));
    })), n;
  });
}
function XEe(r, e) {
  return new ir(function(t) {
    var n = new yn();
    return n.add(e.schedule(function() {
      return r.then(function(i) {
        n.add(e.schedule(function() {
          t.next(i), n.add(e.schedule(function() {
            return t.complete();
          }));
        }));
      }, function(i) {
        n.add(e.schedule(function() {
          return t.error(i);
        }));
      });
    })), n;
  });
}
function e5e(r, e) {
  if (!r)
    throw new Error("Iterable cannot be null");
  return new ir(function(t) {
    var n = new yn(), i;
    return n.add(function() {
      i && typeof i.return == "function" && i.return();
    }), n.add(e.schedule(function() {
      i = r[oh](), n.add(e.schedule(function() {
        if (!t.closed) {
          var s, o;
          try {
            var a = i.next();
            s = a.value, o = a.done;
          } catch (c) {
            t.error(c);
            return;
          }
          o ? t.complete() : (t.next(s), this.schedule());
        }
      }));
    })), n;
  });
}
function t5e(r) {
  return r && typeof r[t1] == "function";
}
function r5e(r) {
  return r && typeof r[oh] == "function";
}
function iU(r, e) {
  if (r != null) {
    if (t5e(r))
      return YEe(r, e);
    if (nU(r))
      return XEe(r, e);
    if (rU(r))
      return DA(r, e);
    if (r5e(r) || typeof r == "string")
      return e5e(r, e);
  }
  throw new TypeError((r !== null && typeof r || r) + " is not observable");
}
function Vl(r, e) {
  return e ? iU(r, e) : r instanceof ir ? r : new ir(_w(r));
}
var Rn = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.parent = t, n;
  }
  return e.prototype._next = function(t) {
    this.parent.notifyNext(t);
  }, e.prototype._error = function(t) {
    this.parent.notifyError(t), this.unsubscribe();
  }, e.prototype._complete = function() {
    this.parent.notifyComplete(), this.unsubscribe();
  }, e;
}(yt), Tn = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.notifyNext = function(t) {
    this.destination.next(t);
  }, e.prototype.notifyError = function(t) {
    this.destination.error(t);
  }, e.prototype.notifyComplete = function() {
    this.destination.complete();
  }, e;
}(yt);
function On(r, e) {
  if (!e.closed) {
    if (r instanceof ir)
      return r.subscribe(e);
    var t;
    try {
      t = _w(r)(e);
    } catch (n) {
      e.error(n);
    }
    return t;
  }
}
function bd(r, e, t) {
  return t === void 0 && (t = Number.POSITIVE_INFINITY), typeof e == "function" ? function(n) {
    return n.pipe(bd(function(i, s) {
      return Vl(r(i, s)).pipe(Vo(function(o, a) {
        return e(i, o, s, a);
      }));
    }, t));
  } : (typeof e == "number" && (t = e), function(n) {
    return n.lift(new n5e(r, t));
  });
}
var n5e = /* @__PURE__ */ function() {
  function r(e, t) {
    t === void 0 && (t = Number.POSITIVE_INFINITY), this.project = e, this.concurrent = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new i5e(e, this.project, this.concurrent));
  }, r;
}(), i5e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    i === void 0 && (i = Number.POSITIVE_INFINITY);
    var s = r.call(this, t) || this;
    return s.project = n, s.concurrent = i, s.hasCompleted = !1, s.buffer = [], s.active = 0, s.index = 0, s;
  }
  return e.prototype._next = function(t) {
    this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t);
  }, e.prototype._tryNext = function(t) {
    var n, i = this.index++;
    try {
      n = this.project(t, i);
    } catch (s) {
      this.destination.error(s);
      return;
    }
    this.active++, this._innerSub(n);
  }, e.prototype._innerSub = function(t) {
    var n = new Rn(this), i = this.destination;
    i.add(n);
    var s = On(t, n);
    s !== n && i.add(s);
  }, e.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();
  }, e.prototype.notifyNext = function(t) {
    this.destination.next(t);
  }, e.prototype.notifyComplete = function() {
    var t = this.buffer;
    this.active--, t.length > 0 ? this._next(t.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();
  }, e;
}(Tn), s5e = bd;
function BA(r) {
  return r === void 0 && (r = Number.POSITIVE_INFINITY), bd(sh, r);
}
function sU() {
  return BA(1);
}
function Ew() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return sU()(V3.apply(void 0, r));
}
function FA(r) {
  return new ir(function(e) {
    var t;
    try {
      t = r();
    } catch (i) {
      e.error(i);
      return;
    }
    var n = t ? Vl(t) : r1();
    return n.subscribe(e);
  });
}
function o5e() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  if (r.length === 1) {
    var t = r[0];
    if (hs(t))
      return Eb(t, null);
    if (NA(t) && Object.getPrototypeOf(t) === Object.prototype) {
      var n = Object.keys(t);
      return Eb(n.map(function(s) {
        return t[s];
      }), n);
    }
  }
  if (typeof r[r.length - 1] == "function") {
    var i = r.pop();
    return r = r.length === 1 && hs(r[0]) ? r[0] : r, Eb(r, null).pipe(Vo(function(s) {
      return i.apply(void 0, s);
    }));
  }
  return Eb(r, null);
}
function Eb(r, e) {
  return new ir(function(t) {
    var n = r.length;
    if (n === 0) {
      t.complete();
      return;
    }
    for (var i = new Array(n), s = 0, o = 0, a = function(u) {
      var f = Vl(r[u]), d = !1;
      t.add(f.subscribe({
        next: function(m) {
          d || (d = !0, o++), i[u] = m;
        },
        error: function(m) {
          return t.error(m);
        },
        complete: function() {
          s++, (s === n || !d) && (o === n && t.next(e ? e.reduce(function(m, y, b) {
            return m[y] = i[b], m;
          }, {}) : i), t.complete());
        }
      }));
    }, c = 0; c < n; c++)
      a(c);
  });
}
function oU(r, e, t, n) {
  return Og(t) && (n = t, t = void 0), n ? oU(r, e, t).pipe(Vo(function(i) {
    return hs(i) ? n.apply(void 0, i) : n(i);
  })) : new ir(function(i) {
    function s(o) {
      arguments.length > 1 ? i.next(Array.prototype.slice.call(arguments)) : i.next(o);
    }
    aU(r, e, s, i, t);
  });
}
function aU(r, e, t, n, i) {
  var s;
  if (l5e(r)) {
    var o = r;
    r.addEventListener(e, t, i), s = function() {
      return o.removeEventListener(e, t, i);
    };
  } else if (c5e(r)) {
    var a = r;
    r.on(e, t), s = function() {
      return a.off(e, t);
    };
  } else if (a5e(r)) {
    var c = r;
    r.addListener(e, t), s = function() {
      return c.removeListener(e, t);
    };
  } else if (r && r.length)
    for (var u = 0, f = r.length; u < f; u++)
      aU(r[u], e, t, n, i);
  else
    throw new TypeError("Invalid event target");
  n.add(s);
}
function a5e(r) {
  return r && typeof r.addListener == "function" && typeof r.removeListener == "function";
}
function c5e(r) {
  return r && typeof r.on == "function" && typeof r.off == "function";
}
function l5e(r) {
  return r && typeof r.addEventListener == "function" && typeof r.removeEventListener == "function";
}
function cU(r, e, t) {
  return t ? cU(r, e).pipe(Vo(function(n) {
    return hs(n) ? t.apply(void 0, n) : t(n);
  })) : new ir(function(n) {
    var i = function() {
      for (var o = [], a = 0; a < arguments.length; a++)
        o[a] = arguments[a];
      return n.next(o.length === 1 ? o[0] : o);
    }, s;
    try {
      s = r(i);
    } catch (o) {
      n.error(o);
      return;
    }
    if (Og(e))
      return function() {
        return e(i, s);
      };
  });
}
function u5e(r, e, t, n, i) {
  var s, o;
  if (arguments.length == 1) {
    var a = r;
    o = a.initialState, e = a.condition, t = a.iterate, s = a.resultSelector || sh, i = a.scheduler;
  } else
    n === void 0 || no(n) ? (o = r, s = sh, i = n) : (o = r, s = n);
  return new ir(function(c) {
    var u = o;
    if (i)
      return i.schedule(h5e, 0, {
        subscriber: c,
        iterate: t,
        condition: e,
        resultSelector: s,
        state: u
      });
    do {
      if (e) {
        var f = void 0;
        try {
          f = e(u);
        } catch (m) {
          c.error(m);
          return;
        }
        if (!f) {
          c.complete();
          break;
        }
      }
      var d = void 0;
      try {
        d = s(u);
      } catch (m) {
        c.error(m);
        return;
      }
      if (c.next(d), c.closed)
        break;
      try {
        u = t(u);
      } catch (m) {
        c.error(m);
        return;
      }
    } while (!0);
  });
}
function h5e(r) {
  var e = r.subscriber, t = r.condition;
  if (!e.closed) {
    if (r.needIterate)
      try {
        r.state = r.iterate(r.state);
      } catch (s) {
        e.error(s);
        return;
      }
    else
      r.needIterate = !0;
    if (t) {
      var n = void 0;
      try {
        n = t(r.state);
      } catch (s) {
        e.error(s);
        return;
      }
      if (!n) {
        e.complete();
        return;
      }
      if (e.closed)
        return;
    }
    var i;
    try {
      i = r.resultSelector(r.state);
    } catch (s) {
      e.error(s);
      return;
    }
    if (!e.closed && (e.next(i), !e.closed))
      return this.schedule(r);
  }
}
function f5e(r, e, t) {
  return e === void 0 && (e = Ng), t === void 0 && (t = Ng), FA(function() {
    return r() ? e : t;
  });
}
function Mg(r) {
  return !hs(r) && r - parseFloat(r) + 1 >= 0;
}
function d5e(r, e) {
  return r === void 0 && (r = 0), e === void 0 && (e = fs), (!Mg(r) || r < 0) && (r = 0), (!e || typeof e.schedule != "function") && (e = fs), new ir(function(t) {
    return t.add(e.schedule(p5e, r, { subscriber: t, counter: 0, period: r })), t;
  });
}
function p5e(r) {
  var e = r.subscriber, t = r.counter, n = r.period;
  e.next(t), this.schedule({ subscriber: e, counter: t + 1, period: n }, n);
}
function lU() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Number.POSITIVE_INFINITY, n = null, i = r[r.length - 1];
  return no(i) ? (n = r.pop(), r.length > 1 && typeof r[r.length - 1] == "number" && (t = r.pop())) : typeof i == "number" && (t = r.pop()), n === null && r.length === 1 && r[0] instanceof ir ? r[0] : BA(t)(Fy(r, n));
}
var uU = /* @__PURE__ */ new ir(oc);
function g5e() {
  return uU;
}
function vS() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  if (r.length === 0)
    return Ng;
  var t = r[0], n = r.slice(1);
  return r.length === 1 && hs(t) ? vS.apply(void 0, t) : new ir(function(i) {
    var s = function() {
      return i.add(vS.apply(void 0, n).subscribe(i));
    };
    return Vl(t).subscribe({
      next: function(o) {
        i.next(o);
      },
      error: s,
      complete: s
    });
  });
}
function m5e(r, e) {
  return e ? new ir(function(t) {
    var n = Object.keys(r), i = new yn();
    return i.add(e.schedule(w5e, 0, { keys: n, index: 0, subscriber: t, subscription: i, obj: r })), i;
  }) : new ir(function(t) {
    for (var n = Object.keys(r), i = 0; i < n.length && !t.closed; i++) {
      var s = n[i];
      r.hasOwnProperty(s) && t.next([s, r[s]]);
    }
    t.complete();
  });
}
function w5e(r) {
  var e = r.keys, t = r.index, n = r.subscriber, i = r.subscription, s = r.obj;
  if (!n.closed)
    if (t < e.length) {
      var o = e[t];
      n.next([o, s[o]]), i.add(this.schedule({ keys: e, index: t + 1, subscriber: n, subscription: i, obj: s }));
    } else
      n.complete();
}
function hU(r, e) {
  function t() {
    return !t.pred.apply(t.thisArg, arguments);
  }
  return t.pred = r, t.thisArg = e, t;
}
function ah(r, e) {
  return function(n) {
    return n.lift(new y5e(r, e));
  };
}
var y5e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.predicate = e, this.thisArg = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new v5e(e, this.predicate, this.thisArg));
  }, r;
}(), v5e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.predicate = n, s.thisArg = i, s.count = 0, s;
  }
  return e.prototype._next = function(t) {
    var n;
    try {
      n = this.predicate.call(this.thisArg, t, this.count++);
    } catch (i) {
      this.destination.error(i);
      return;
    }
    n && this.destination.next(t);
  }, e;
}(yt);
function b5e(r, e, t) {
  return [
    ah(e, t)(new ir(_w(r))),
    ah(hU(e, t))(new ir(_w(r)))
  ];
}
function fU() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  if (r.length === 1)
    if (hs(r[0]))
      r = r[0];
    else
      return r[0];
  return Fy(r, void 0).lift(new _5e());
}
var _5e = /* @__PURE__ */ function() {
  function r() {
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new E5e(e));
  }, r;
}(), E5e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this, t) || this;
    return n.hasFirst = !1, n.observables = [], n.subscriptions = [], n;
  }
  return e.prototype._next = function(t) {
    this.observables.push(t);
  }, e.prototype._complete = function() {
    var t = this.observables, n = t.length;
    if (n === 0)
      this.destination.complete();
    else {
      for (var i = 0; i < n && !this.hasFirst; i++) {
        var s = t[i], o = Ll(this, s, void 0, i);
        this.subscriptions && this.subscriptions.push(o), this.add(o);
      }
      this.observables = null;
    }
  }, e.prototype.notifyNext = function(t, n, i) {
    if (!this.hasFirst) {
      this.hasFirst = !0;
      for (var s = 0; s < this.subscriptions.length; s++)
        if (s !== i) {
          var o = this.subscriptions[s];
          o.unsubscribe(), this.remove(o);
        }
      this.subscriptions = null;
    }
    this.destination.next(n);
  }, e;
}(Wd);
function x5e(r, e, t) {
  return r === void 0 && (r = 0), new ir(function(n) {
    e === void 0 && (e = r, r = 0);
    var i = 0, s = r;
    if (t)
      return t.schedule(S5e, 0, {
        index: i,
        count: e,
        start: r,
        subscriber: n
      });
    do {
      if (i++ >= e) {
        n.complete();
        break;
      }
      if (n.next(s++), n.closed)
        break;
    } while (!0);
  });
}
function S5e(r) {
  var e = r.start, t = r.index, n = r.count, i = r.subscriber;
  if (t >= n) {
    i.complete();
    return;
  }
  i.next(e), !i.closed && (r.index = t + 1, r.start = e + 1, this.schedule(r));
}
function dU(r, e, t) {
  r === void 0 && (r = 0);
  var n = -1;
  return Mg(e) ? n = Number(e) < 1 && 1 || Number(e) : no(e) && (t = e), no(t) || (t = fs), new ir(function(i) {
    var s = Mg(r) ? r : +r - t.now();
    return t.schedule(C5e, s, {
      index: 0,
      period: n,
      subscriber: i
    });
  });
}
function C5e(r) {
  var e = r.index, t = r.period, n = r.subscriber;
  if (n.next(e), !n.closed) {
    if (t === -1)
      return n.complete();
    r.index = e + 1, this.schedule(r, t);
  }
}
function A5e(r, e) {
  return new ir(function(t) {
    var n;
    try {
      n = r();
    } catch (a) {
      t.error(a);
      return;
    }
    var i;
    try {
      i = e(n);
    } catch (a) {
      t.error(a);
      return;
    }
    var s = i ? Vl(i) : Ng, o = s.subscribe(t);
    return function() {
      o.unsubscribe(), n && n.unsubscribe();
    };
  });
}
function pU() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = r[r.length - 1];
  return typeof t == "function" && r.pop(), Fy(r, void 0).lift(new gU(t));
}
var gU = /* @__PURE__ */ function() {
  function r(e) {
    this.resultSelector = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new I5e(e, this.resultSelector));
  }, r;
}(), I5e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.resultSelector = n, s.iterators = [], s.active = 0, s.resultSelector = typeof n == "function" ? n : void 0, s;
  }
  return e.prototype._next = function(t) {
    var n = this.iterators;
    hs(t) ? n.push(new T5e(t)) : typeof t[oh] == "function" ? n.push(new R5e(t[oh]())) : n.push(new O5e(this.destination, this, t));
  }, e.prototype._complete = function() {
    var t = this.iterators, n = t.length;
    if (this.unsubscribe(), n === 0) {
      this.destination.complete();
      return;
    }
    this.active = n;
    for (var i = 0; i < n; i++) {
      var s = t[i];
      if (s.stillUnsubscribed) {
        var o = this.destination;
        o.add(s.subscribe());
      } else
        this.active--;
    }
  }, e.prototype.notifyInactive = function() {
    this.active--, this.active === 0 && this.destination.complete();
  }, e.prototype.checkIterators = function() {
    for (var t = this.iterators, n = t.length, i = this.destination, s = 0; s < n; s++) {
      var o = t[s];
      if (typeof o.hasValue == "function" && !o.hasValue())
        return;
    }
    for (var a = !1, c = [], s = 0; s < n; s++) {
      var o = t[s], u = o.next();
      if (o.hasCompleted() && (a = !0), u.done) {
        i.complete();
        return;
      }
      c.push(u.value);
    }
    this.resultSelector ? this._tryresultSelector(c) : i.next(c), a && i.complete();
  }, e.prototype._tryresultSelector = function(t) {
    var n;
    try {
      n = this.resultSelector.apply(this, t);
    } catch (i) {
      this.destination.error(i);
      return;
    }
    this.destination.next(n);
  }, e;
}(yt), R5e = /* @__PURE__ */ function() {
  function r(e) {
    this.iterator = e, this.nextResult = e.next();
  }
  return r.prototype.hasValue = function() {
    return !0;
  }, r.prototype.next = function() {
    var e = this.nextResult;
    return this.nextResult = this.iterator.next(), e;
  }, r.prototype.hasCompleted = function() {
    var e = this.nextResult;
    return !!(e && e.done);
  }, r;
}(), T5e = /* @__PURE__ */ function() {
  function r(e) {
    this.array = e, this.index = 0, this.length = 0, this.length = e.length;
  }
  return r.prototype[oh] = function() {
    return this;
  }, r.prototype.next = function(e) {
    var t = this.index++, n = this.array;
    return t < this.length ? { value: n[t], done: !1 } : { value: null, done: !0 };
  }, r.prototype.hasValue = function() {
    return this.array.length > this.index;
  }, r.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  }, r;
}(), O5e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.parent = n, s.observable = i, s.stillUnsubscribed = !0, s.buffer = [], s.isComplete = !1, s;
  }
  return e.prototype[oh] = function() {
    return this;
  }, e.prototype.next = function() {
    var t = this.buffer;
    return t.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: t.shift(), done: !1 };
  }, e.prototype.hasValue = function() {
    return this.buffer.length > 0;
  }, e.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  }, e.prototype.notifyComplete = function() {
    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
  }, e.prototype.notifyNext = function(t) {
    this.buffer.push(t), this.parent.checkIterators();
  }, e.prototype.subscribe = function() {
    return On(this.observable, new Rn(this));
  }, e;
}(Tn);
const N5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArgumentOutOfRangeError: Pg,
  AsyncSubject: n1,
  BehaviorSubject: zF,
  ConnectableObservable: HF,
  EMPTY: Ng,
  EmptyError: Uy,
  GroupedObservable: gS,
  NEVER: uU,
  Notification: Nl,
  get NotificationKind() {
    return wS;
  },
  ObjectUnsubscribedError: vu,
  Observable: ir,
  ReplaySubject: $A,
  Scheduler: mS,
  Subject: ui,
  Subscriber: yt,
  Subscription: yn,
  TimeoutError: XF,
  UnsubscriptionError: xm,
  VirtualAction: YF,
  VirtualTimeScheduler: DEe,
  animationFrame: MEe,
  animationFrameScheduler: QF,
  asap: Gb,
  asapScheduler: ZF,
  async: fs,
  asyncScheduler: JF,
  bindCallback: eU,
  bindNodeCallback: tU,
  combineLatest: JEe,
  concat: Ew,
  config: Mo,
  defer: FA,
  empty: r1,
  forkJoin: o5e,
  from: Vl,
  fromEvent: oU,
  fromEventPattern: cU,
  generate: u5e,
  identity: sh,
  iif: f5e,
  interval: d5e,
  isObservable: kEe,
  merge: lU,
  never: g5e,
  noop: oc,
  observable: t1,
  of: V3,
  onErrorResumeNext: vS,
  pairs: m5e,
  partition: b5e,
  pipe: pS,
  queue: qF,
  queueScheduler: VF,
  race: fU,
  range: x5e,
  scheduled: iU,
  throwError: kA,
  timer: dU,
  using: A5e,
  zip: pU
}, Symbol.toStringTag, { value: "Module" })), q3 = /* @__PURE__ */ La(N5e);
var G3 = {};
function mU(r) {
  var e, t, n = "";
  if (typeof r == "string" || typeof r == "number")
    n += r;
  else if (typeof r == "object")
    if (Array.isArray(r))
      for (e = 0; e < r.length; e++)
        r[e] && (t = mU(r[e])) && (n && (n += " "), n += t);
    else
      for (e in r)
        r[e] && (n && (n += " "), n += e);
  return n;
}
function nP() {
  for (var r, e, t = 0, n = ""; t < arguments.length; )
    (r = arguments[t++]) && (e = mU(r)) && (n && (n += " "), n += e);
  return n;
}
const P5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: nP,
  default: nP
}, Symbol.toStringTag, { value: "Module" })), K3 = /* @__PURE__ */ La(P5e);
var Bl, Qr, g6, iP, Dg = 0, wU = [], Kb = [], sP = Lt.__b, oP = Lt.__r, aP = Lt.diffed, cP = Lt.__c, lP = Lt.unmount;
function Hd(r, e) {
  Lt.__h && Lt.__h(Qr, r, Dg || e), Dg = 0;
  var t = Qr.__H || (Qr.__H = { __: [], __h: [] });
  return r >= t.__.length && t.__.push({ __V: Kb }), t.__[r];
}
function yU(r) {
  return Dg = 1, vU(_U, r);
}
function vU(r, e, t) {
  var n = Hd(Bl++, 2);
  if (n.t = r, !n.__c && (n.__ = [t ? t(e) : _U(void 0, e), function(a) {
    var c = n.__N ? n.__N[0] : n.__[0], u = n.t(c, a);
    c !== u && (n.__N = [u, n.__[1]], n.__c.setState({}));
  }], n.__c = Qr, !Qr.u)) {
    var i = function(a, c, u) {
      if (!n.__c.__H)
        return !0;
      var f = n.__c.__H.__.filter(function(m) {
        return m.__c;
      });
      if (f.every(function(m) {
        return !m.__N;
      }))
        return !s || s.call(this, a, c, u);
      var d = !1;
      return f.forEach(function(m) {
        if (m.__N) {
          var y = m.__[0];
          m.__ = m.__N, m.__N = void 0, y !== m.__[0] && (d = !0);
        }
      }), !(!d && n.__c.props === a) && (!s || s.call(this, a, c, u));
    };
    Qr.u = !0;
    var s = Qr.shouldComponentUpdate, o = Qr.componentWillUpdate;
    Qr.componentWillUpdate = function(a, c, u) {
      if (this.__e) {
        var f = s;
        s = void 0, i(a, c, u), s = f;
      }
      o && o.call(this, a, c, u);
    }, Qr.shouldComponentUpdate = i;
  }
  return n.__N || n.__;
}
function M5e(r, e) {
  var t = Hd(Bl++, 3);
  !Lt.__s && jA(t.__H, e) && (t.__ = r, t.i = e, Qr.__H.__h.push(t));
}
function bU(r, e) {
  var t = Hd(Bl++, 4);
  !Lt.__s && jA(t.__H, e) && (t.__ = r, t.i = e, Qr.__h.push(t));
}
function D5e(r) {
  return Dg = 5, UA(function() {
    return { current: r };
  }, []);
}
function k5e(r, e, t) {
  Dg = 6, bU(function() {
    return typeof r == "function" ? (r(e()), function() {
      return r(null);
    }) : r ? (r.current = e(), function() {
      return r.current = null;
    }) : void 0;
  }, t == null ? t : t.concat(r));
}
function UA(r, e) {
  var t = Hd(Bl++, 7);
  return jA(t.__H, e) ? (t.__V = r(), t.i = e, t.__h = r, t.__V) : t.__;
}
function $5e(r, e) {
  return Dg = 8, UA(function() {
    return r;
  }, e);
}
function L5e(r) {
  var e = Qr.context[r.__c], t = Hd(Bl++, 9);
  return t.c = r, e ? (t.__ == null && (t.__ = !0, e.sub(Qr)), e.props.value) : r.__;
}
function B5e(r, e) {
  Lt.useDebugValue && Lt.useDebugValue(e ? e(r) : r);
}
function F5e(r) {
  var e = Hd(Bl++, 10), t = yU();
  return e.__ = r, Qr.componentDidCatch || (Qr.componentDidCatch = function(n, i) {
    e.__ && e.__(n, i), t[1](n);
  }), [t[0], function() {
    t[1](void 0);
  }];
}
function U5e() {
  var r = Hd(Bl++, 11);
  if (!r.__) {
    for (var e = Qr.__v; e !== null && !e.__m && e.__ !== null; )
      e = e.__;
    var t = e.__m || (e.__m = [0, 0]);
    r.__ = "P" + t[0] + "-" + t[1]++;
  }
  return r.__;
}
function j5e() {
  for (var r; r = wU.shift(); )
    if (r.__P && r.__H)
      try {
        r.__H.__h.forEach(Zb), r.__H.__h.forEach(bS), r.__H.__h = [];
      } catch (e) {
        r.__H.__h = [], Lt.__e(e, r.__v);
      }
}
Lt.__b = function(r) {
  Qr = null, sP && sP(r);
}, Lt.__r = function(r) {
  oP && oP(r), Bl = 0;
  var e = (Qr = r.__c).__H;
  e && (g6 === Qr ? (e.__h = [], Qr.__h = [], e.__.forEach(function(t) {
    t.__N && (t.__ = t.__N), t.__V = Kb, t.__N = t.i = void 0;
  })) : (e.__h.forEach(Zb), e.__h.forEach(bS), e.__h = [], Bl = 0)), g6 = Qr;
}, Lt.diffed = function(r) {
  aP && aP(r);
  var e = r.__c;
  e && e.__H && (e.__H.__h.length && (wU.push(e) !== 1 && iP === Lt.requestAnimationFrame || ((iP = Lt.requestAnimationFrame) || W5e)(j5e)), e.__H.__.forEach(function(t) {
    t.i && (t.__H = t.i), t.__V !== Kb && (t.__ = t.__V), t.i = void 0, t.__V = Kb;
  })), g6 = Qr = null;
}, Lt.__c = function(r, e) {
  e.some(function(t) {
    try {
      t.__h.forEach(Zb), t.__h = t.__h.filter(function(n) {
        return !n.__ || bS(n);
      });
    } catch (n) {
      e.some(function(i) {
        i.__h && (i.__h = []);
      }), e = [], Lt.__e(n, t.__v);
    }
  }), cP && cP(r, e);
}, Lt.unmount = function(r) {
  lP && lP(r);
  var e, t = r.__c;
  t && t.__H && (t.__H.__.forEach(function(n) {
    try {
      Zb(n);
    } catch (i) {
      e = i;
    }
  }), t.__H = void 0, e && Lt.__e(e, t.__v));
};
var uP = typeof requestAnimationFrame == "function";
function W5e(r) {
  var e, t = function() {
    clearTimeout(n), uP && cancelAnimationFrame(e), setTimeout(r);
  }, n = setTimeout(t, 100);
  uP && (e = requestAnimationFrame(t));
}
function Zb(r) {
  var e = Qr, t = r.__c;
  typeof t == "function" && (r.__c = void 0, t()), Qr = e;
}
function bS(r) {
  var e = Qr;
  r.__c = r.__(), Qr = e;
}
function jA(r, e) {
  return !r || r.length !== e.length || e.some(function(t, n) {
    return t !== r[n];
  });
}
function _U(r, e) {
  return typeof e == "function" ? e(r) : e;
}
const H5e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useCallback: $5e,
  useContext: L5e,
  useDebugValue: B5e,
  useEffect: M5e,
  useErrorBoundary: F5e,
  useId: U5e,
  useImperativeHandle: k5e,
  useLayoutEffect: bU,
  useMemo: UA,
  useReducer: vU,
  useRef: D5e,
  useState: yU
}, Symbol.toStringTag, { value: "Module" })), jy = /* @__PURE__ */ La(H5e);
var _c = {}, Z3 = {};
Object.defineProperty(Z3, "__esModule", { value: !0 });
Z3.CloseIcon = void 0;
const hP = co;
function z5e(r) {
  return (0, hP.h)(
    "svg",
    Object.assign({ width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r),
    (0, hP.h)("path", { d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z" })
  );
}
Z3.CloseIcon = z5e;
var WA = {};
Object.defineProperty(WA, "__esModule", { value: !0 });
WA.default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMTQuMDM3IDE4LjkyNmMtMi43NSAwLTQuOTA3LTIuMjA1LTQuOTA3LTQuOTI2IDAtMi43MiAyLjIzLTQuOTI2IDQuOTA3LTQuOTI2YTQuODY2IDQuODY2IDAgMCAxIDQuODMzIDQuMTE4aDQuOTgyYy0uNDQ2LTUuMDczLTQuNjg0LTkuMDQ0LTkuODE1LTkuMDQ0QzguNjEgNC4xNDggNC4xNDkgOC41NiA0LjE0OSAxNHM0LjM4NyA5Ljg1MiA5Ljg5IDkuODUyYzUuMjA0IDAgOS4zNjgtMy45NyA5LjgxNC05LjA0M0gxOC44N2E0Ljg2NiA0Ljg2NiAwIDAgMS00LjgzMyA0LjExN1oiIGZpbGw9IiNmZmYiLz48L3N2Zz4=";
var HA = {};
Object.defineProperty(HA, "__esModule", { value: !0 });
HA.default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMjMuODUyIDE0QTkuODM0IDkuODM0IDAgMCAxIDE0IDIzLjg1MiA5LjgzNCA5LjgzNCAwIDAgMSA0LjE0OCAxNCA5LjgzNCA5LjgzNCAwIDAgMSAxNCA0LjE0OCA5LjgzNCA5LjgzNCAwIDAgMSAyMy44NTIgMTRaIiBmaWxsPSIjZmZmIi8+PHBhdGggZD0iTTExLjE4NSAxMi41MDRjMC0uNDU2IDAtLjcxLjA5OC0uODYyLjA5OC0uMTUyLjE5Ni0uMzA0LjM0My0uMzU1LjE5Ni0uMTAyLjM5Mi0uMTAyLjg4MS0uMTAyaDIuOTg2Yy40OSAwIC42ODYgMCAuODgyLjEwMi4xNDYuMTAxLjI5My4yMDMuMzQyLjM1NS4wOTguMjAzLjA5OC40MDYuMDk4Ljg2MnYyLjk5MmMwIC40NTcgMCAuNzEtLjA5OC44NjMtLjA5OC4xNTItLjE5NS4zMDQtLjM0Mi4zNTUtLjE5Ni4xMDEtLjM5Mi4xMDEtLjg4Mi4xMDFoLTIuOTg2Yy0uNDkgMC0uNjg1IDAtLjg4LS4xMDEtLjE0OC0uMTAyLS4yOTUtLjIwMy0uMzQ0LS4zNTUtLjA5OC0uMjAzLS4wOTgtLjQwNi0uMDk4LS44NjN2LTIuOTkyWiIgZmlsbD0iIzAwNTJGRiIvPjwvc3ZnPg==";
var J3 = {};
Object.defineProperty(J3, "__esModule", { value: !0 });
J3.QRCodeIcon = void 0;
const rc = co;
function V5e(r) {
  return (0, rc.h)(
    "svg",
    Object.assign({ width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, r),
    (0, rc.h)("path", { d: "M8.2271 1.77124L7.0271 1.77124V2.97124H8.2271V1.77124Z" }),
    (0, rc.h)("path", { d: "M5.44922 0.199219L5.44922 4.54922L9.79922 4.54922V0.199219L5.44922 0.199219ZM8.89922 3.64922L6.34922 3.64922L6.34922 1.09922L8.89922 1.09922V3.64922Z" }),
    (0, rc.h)("path", { d: "M2.97124 1.77124L1.77124 1.77124L1.77124 2.97124H2.97124V1.77124Z" }),
    (0, rc.h)("path", { d: "M0.199219 4.54922L4.54922 4.54922L4.54922 0.199219L0.199219 0.199219L0.199219 4.54922ZM1.09922 1.09922L3.64922 1.09922L3.64922 3.64922L1.09922 3.64922L1.09922 1.09922Z" }),
    (0, rc.h)("path", { d: "M2.97124 7.0271H1.77124L1.77124 8.2271H2.97124V7.0271Z" }),
    (0, rc.h)("path", { d: "M0.199219 9.79922H4.54922L4.54922 5.44922L0.199219 5.44922L0.199219 9.79922ZM1.09922 6.34922L3.64922 6.34922L3.64922 8.89922H1.09922L1.09922 6.34922Z" }),
    (0, rc.h)("path", { d: "M8.89922 7.39912H7.99922V5.40112H5.44922L5.44922 9.79912H6.34922L6.34922 6.30112H7.09922V8.29912H9.79922V5.40112H8.89922V7.39912Z" }),
    (0, rc.h)("path", { d: "M7.99912 8.89917H7.09912V9.79917H7.99912V8.89917Z" }),
    (0, rc.h)("path", { d: "M9.79917 8.89917H8.89917V9.79917H9.79917V8.89917Z" })
  );
}
J3.QRCodeIcon = V5e;
var zA = {};
Object.defineProperty(zA, "__esModule", { value: !0 });
const q5e = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M50 100C77.6142 100 100 77.6142 100 50C100 22.3858 77.6142 0 50 0C22.3858 0 0 22.3858 0 50C0 77.6142 22.3858 100 50 100Z" fill="white"/>
        <path d="M50.512 94C74.2907 94 93.5673 74.5244 93.5673 50.5C93.5673 26.4756 74.2907 7 50.512 7C26.7332 7 7.45667 26.4756 7.45667 50.5C7.45667 74.5244 26.7332 94 50.512 94Z" fill="#0052FF"/>
        <path d="M50.6248 65.4335C42.3697 65.4335 35.8996 58.7469 35.8996 50.5C35.8996 42.2531 42.5928 35.5664 50.6248 35.5664C57.9873 35.5664 64.0111 40.9157 65.1267 48.0481H80.0749C78.7363 32.6688 66.0191 20.6328 50.6248 20.6328C34.3379 20.6328 20.9514 34.0062 20.9514 50.5C20.9514 66.9936 34.1148 80.3671 50.6248 80.3671C66.2422 80.3671 78.7363 68.331 80.0749 52.9516H65.1267C64.0111 60.0841 57.9873 65.4335 50.6248 65.4335Z" fill="white"/>
    </svg>
`;
zA.default = q5e;
var VA = {};
Object.defineProperty(VA, "__esModule", { value: !0 });
VA.default = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="50" fill="white"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
    </svg>
`;
var Q3 = {};
Object.defineProperty(Q3, "__esModule", { value: !0 });
Q3.StatusDotIcon = void 0;
const fP = co;
function G5e(r) {
  return (0, fP.h)(
    "svg",
    Object.assign({ width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, r),
    (0, fP.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.29995 4.99995C2.29995 5.57985 1.82985 6.04995 1.24995 6.04995C0.670052 6.04995 0.199951 5.57985 0.199951 4.99995C0.199951 4.42005 0.670052 3.94995 1.24995 3.94995C1.82985 3.94995 2.29995 4.42005 2.29995 4.99995ZM4.99995 6.04995C5.57985 6.04995 6.04995 5.57985 6.04995 4.99995C6.04995 4.42005 5.57985 3.94995 4.99995 3.94995C4.42005 3.94995 3.94995 4.42005 3.94995 4.99995C3.94995 5.57985 4.42005 6.04995 4.99995 6.04995ZM8.74995 6.04995C9.32985 6.04995 9.79995 5.57985 9.79995 4.99995C9.79995 4.42005 9.32985 3.94995 8.74995 3.94995C8.17005 3.94995 7.69995 4.42005 7.69995 4.99995C7.69995 5.57985 8.17005 6.04995 8.74995 6.04995Z" })
  );
}
Q3.StatusDotIcon = G5e;
var Y3 = {};
function EU(r) {
  this.mode = Ks.MODE_8BIT_BYTE, this.data = r, this.parsedData = [];
  for (var e = 0, t = this.data.length; e < t; e++) {
    var n = [], i = this.data.charCodeAt(e);
    i > 65536 ? (n[0] = 240 | (i & 1835008) >>> 18, n[1] = 128 | (i & 258048) >>> 12, n[2] = 128 | (i & 4032) >>> 6, n[3] = 128 | i & 63) : i > 2048 ? (n[0] = 224 | (i & 61440) >>> 12, n[1] = 128 | (i & 4032) >>> 6, n[2] = 128 | i & 63) : i > 128 ? (n[0] = 192 | (i & 1984) >>> 6, n[1] = 128 | i & 63) : n[0] = i, this.parsedData.push(n);
  }
  this.parsedData = Array.prototype.concat.apply([], this.parsedData), this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239));
}
EU.prototype = {
  getLength: function(r) {
    return this.parsedData.length;
  },
  write: function(r) {
    for (var e = 0, t = this.parsedData.length; e < t; e++)
      r.put(this.parsedData[e], 8);
  }
};
function Ec(r, e) {
  this.typeNumber = r, this.errorCorrectLevel = e, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
}
Ec.prototype = { addData: function(r) {
  var e = new EU(r);
  this.dataList.push(e), this.dataCache = null;
}, isDark: function(r, e) {
  if (r < 0 || this.moduleCount <= r || e < 0 || this.moduleCount <= e)
    throw new Error(r + "," + e);
  return this.modules[r][e];
}, getModuleCount: function() {
  return this.moduleCount;
}, make: function() {
  this.makeImpl(!1, this.getBestMaskPattern());
}, makeImpl: function(r, e) {
  this.moduleCount = this.typeNumber * 4 + 17, this.modules = new Array(this.moduleCount);
  for (var t = 0; t < this.moduleCount; t++) {
    this.modules[t] = new Array(this.moduleCount);
    for (var n = 0; n < this.moduleCount; n++)
      this.modules[t][n] = null;
  }
  this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(r, e), this.typeNumber >= 7 && this.setupTypeNumber(r), this.dataCache == null && (this.dataCache = Ec.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, e);
}, setupPositionProbePattern: function(r, e) {
  for (var t = -1; t <= 7; t++)
    if (!(r + t <= -1 || this.moduleCount <= r + t))
      for (var n = -1; n <= 7; n++)
        e + n <= -1 || this.moduleCount <= e + n || (0 <= t && t <= 6 && (n == 0 || n == 6) || 0 <= n && n <= 6 && (t == 0 || t == 6) || 2 <= t && t <= 4 && 2 <= n && n <= 4 ? this.modules[r + t][e + n] = !0 : this.modules[r + t][e + n] = !1);
}, getBestMaskPattern: function() {
  for (var r = 0, e = 0, t = 0; t < 8; t++) {
    this.makeImpl(!0, t);
    var n = hn.getLostPoint(this);
    (t == 0 || r > n) && (r = n, e = t);
  }
  return e;
}, createMovieClip: function(r, e, t) {
  var n = r.createEmptyMovieClip(e, t), i = 1;
  this.make();
  for (var s = 0; s < this.modules.length; s++)
    for (var o = s * i, a = 0; a < this.modules[s].length; a++) {
      var c = a * i, u = this.modules[s][a];
      u && (n.beginFill(0, 100), n.moveTo(c, o), n.lineTo(c + i, o), n.lineTo(c + i, o + i), n.lineTo(c, o + i), n.endFill());
    }
  return n;
}, setupTimingPattern: function() {
  for (var r = 8; r < this.moduleCount - 8; r++)
    this.modules[r][6] == null && (this.modules[r][6] = r % 2 == 0);
  for (var e = 8; e < this.moduleCount - 8; e++)
    this.modules[6][e] == null && (this.modules[6][e] = e % 2 == 0);
}, setupPositionAdjustPattern: function() {
  for (var r = hn.getPatternPosition(this.typeNumber), e = 0; e < r.length; e++)
    for (var t = 0; t < r.length; t++) {
      var n = r[e], i = r[t];
      if (this.modules[n][i] == null)
        for (var s = -2; s <= 2; s++)
          for (var o = -2; o <= 2; o++)
            s == -2 || s == 2 || o == -2 || o == 2 || s == 0 && o == 0 ? this.modules[n + s][i + o] = !0 : this.modules[n + s][i + o] = !1;
    }
}, setupTypeNumber: function(r) {
  for (var e = hn.getBCHTypeNumber(this.typeNumber), t = 0; t < 18; t++) {
    var n = !r && (e >> t & 1) == 1;
    this.modules[Math.floor(t / 3)][t % 3 + this.moduleCount - 8 - 3] = n;
  }
  for (var t = 0; t < 18; t++) {
    var n = !r && (e >> t & 1) == 1;
    this.modules[t % 3 + this.moduleCount - 8 - 3][Math.floor(t / 3)] = n;
  }
}, setupTypeInfo: function(r, e) {
  for (var t = this.errorCorrectLevel << 3 | e, n = hn.getBCHTypeInfo(t), i = 0; i < 15; i++) {
    var s = !r && (n >> i & 1) == 1;
    i < 6 ? this.modules[i][8] = s : i < 8 ? this.modules[i + 1][8] = s : this.modules[this.moduleCount - 15 + i][8] = s;
  }
  for (var i = 0; i < 15; i++) {
    var s = !r && (n >> i & 1) == 1;
    i < 8 ? this.modules[8][this.moduleCount - i - 1] = s : i < 9 ? this.modules[8][15 - i - 1 + 1] = s : this.modules[8][15 - i - 1] = s;
  }
  this.modules[this.moduleCount - 8][8] = !r;
}, mapData: function(r, e) {
  for (var t = -1, n = this.moduleCount - 1, i = 7, s = 0, o = this.moduleCount - 1; o > 0; o -= 2)
    for (o == 6 && o--; ; ) {
      for (var a = 0; a < 2; a++)
        if (this.modules[n][o - a] == null) {
          var c = !1;
          s < r.length && (c = (r[s] >>> i & 1) == 1);
          var u = hn.getMask(e, n, o - a);
          u && (c = !c), this.modules[n][o - a] = c, i--, i == -1 && (s++, i = 7);
        }
      if (n += t, n < 0 || this.moduleCount <= n) {
        n -= t, t = -t;
        break;
      }
    }
} };
Ec.PAD0 = 236;
Ec.PAD1 = 17;
Ec.createData = function(r, e, t) {
  for (var n = yc.getRSBlocks(r, e), i = new xU(), s = 0; s < t.length; s++) {
    var o = t[s];
    i.put(o.mode, 4), i.put(o.getLength(), hn.getLengthInBits(o.mode, r)), o.write(i);
  }
  for (var a = 0, s = 0; s < n.length; s++)
    a += n[s].dataCount;
  if (i.getLengthInBits() > a * 8)
    throw new Error("code length overflow. (" + i.getLengthInBits() + ">" + a * 8 + ")");
  for (i.getLengthInBits() + 4 <= a * 8 && i.put(0, 4); i.getLengthInBits() % 8 != 0; )
    i.putBit(!1);
  for (; !(i.getLengthInBits() >= a * 8 || (i.put(Ec.PAD0, 8), i.getLengthInBits() >= a * 8)); )
    i.put(Ec.PAD1, 8);
  return Ec.createBytes(i, n);
};
Ec.createBytes = function(r, e) {
  for (var t = 0, n = 0, i = 0, s = new Array(e.length), o = new Array(e.length), a = 0; a < e.length; a++) {
    var c = e[a].dataCount, u = e[a].totalCount - c;
    n = Math.max(n, c), i = Math.max(i, u), s[a] = new Array(c);
    for (var f = 0; f < s[a].length; f++)
      s[a][f] = 255 & r.buffer[f + t];
    t += c;
    var d = hn.getErrorCorrectPolynomial(u), m = new n0(s[a], d.getLength() - 1), y = m.mod(d);
    o[a] = new Array(d.getLength() - 1);
    for (var f = 0; f < o[a].length; f++) {
      var b = f + y.getLength() - o[a].length;
      o[a][f] = b >= 0 ? y.get(b) : 0;
    }
  }
  for (var I = 0, f = 0; f < e.length; f++)
    I += e[f].totalCount;
  for (var k = new Array(I), R = 0, f = 0; f < n; f++)
    for (var a = 0; a < e.length; a++)
      f < s[a].length && (k[R++] = s[a][f]);
  for (var f = 0; f < i; f++)
    for (var a = 0; a < e.length; a++)
      f < o[a].length && (k[R++] = o[a][f]);
  return k;
};
var Ks = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, ju = { L: 1, M: 0, Q: 3, H: 2 }, ou = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 }, hn = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function(r) {
  for (var e = r << 10; hn.getBCHDigit(e) - hn.getBCHDigit(hn.G15) >= 0; )
    e ^= hn.G15 << hn.getBCHDigit(e) - hn.getBCHDigit(hn.G15);
  return (r << 10 | e) ^ hn.G15_MASK;
}, getBCHTypeNumber: function(r) {
  for (var e = r << 12; hn.getBCHDigit(e) - hn.getBCHDigit(hn.G18) >= 0; )
    e ^= hn.G18 << hn.getBCHDigit(e) - hn.getBCHDigit(hn.G18);
  return r << 12 | e;
}, getBCHDigit: function(r) {
  for (var e = 0; r != 0; )
    e++, r >>>= 1;
  return e;
}, getPatternPosition: function(r) {
  return hn.PATTERN_POSITION_TABLE[r - 1];
}, getMask: function(r, e, t) {
  switch (r) {
    case ou.PATTERN000:
      return (e + t) % 2 == 0;
    case ou.PATTERN001:
      return e % 2 == 0;
    case ou.PATTERN010:
      return t % 3 == 0;
    case ou.PATTERN011:
      return (e + t) % 3 == 0;
    case ou.PATTERN100:
      return (Math.floor(e / 2) + Math.floor(t / 3)) % 2 == 0;
    case ou.PATTERN101:
      return e * t % 2 + e * t % 3 == 0;
    case ou.PATTERN110:
      return (e * t % 2 + e * t % 3) % 2 == 0;
    case ou.PATTERN111:
      return (e * t % 3 + (e + t) % 2) % 2 == 0;
    default:
      throw new Error("bad maskPattern:" + r);
  }
}, getErrorCorrectPolynomial: function(r) {
  for (var e = new n0([1], 0), t = 0; t < r; t++)
    e = e.multiply(new n0([1, ai.gexp(t)], 0));
  return e;
}, getLengthInBits: function(r, e) {
  if (1 <= e && e < 10)
    switch (r) {
      case Ks.MODE_NUMBER:
        return 10;
      case Ks.MODE_ALPHA_NUM:
        return 9;
      case Ks.MODE_8BIT_BYTE:
        return 8;
      case Ks.MODE_KANJI:
        return 8;
      default:
        throw new Error("mode:" + r);
    }
  else if (e < 27)
    switch (r) {
      case Ks.MODE_NUMBER:
        return 12;
      case Ks.MODE_ALPHA_NUM:
        return 11;
      case Ks.MODE_8BIT_BYTE:
        return 16;
      case Ks.MODE_KANJI:
        return 10;
      default:
        throw new Error("mode:" + r);
    }
  else if (e < 41)
    switch (r) {
      case Ks.MODE_NUMBER:
        return 14;
      case Ks.MODE_ALPHA_NUM:
        return 13;
      case Ks.MODE_8BIT_BYTE:
        return 16;
      case Ks.MODE_KANJI:
        return 12;
      default:
        throw new Error("mode:" + r);
    }
  else
    throw new Error("type:" + e);
}, getLostPoint: function(r) {
  for (var e = r.getModuleCount(), t = 0, n = 0; n < e; n++)
    for (var i = 0; i < e; i++) {
      for (var s = 0, o = r.isDark(n, i), a = -1; a <= 1; a++)
        if (!(n + a < 0 || e <= n + a))
          for (var c = -1; c <= 1; c++)
            i + c < 0 || e <= i + c || a == 0 && c == 0 || o == r.isDark(n + a, i + c) && s++;
      s > 5 && (t += 3 + s - 5);
    }
  for (var n = 0; n < e - 1; n++)
    for (var i = 0; i < e - 1; i++) {
      var u = 0;
      r.isDark(n, i) && u++, r.isDark(n + 1, i) && u++, r.isDark(n, i + 1) && u++, r.isDark(n + 1, i + 1) && u++, (u == 0 || u == 4) && (t += 3);
    }
  for (var n = 0; n < e; n++)
    for (var i = 0; i < e - 6; i++)
      r.isDark(n, i) && !r.isDark(n, i + 1) && r.isDark(n, i + 2) && r.isDark(n, i + 3) && r.isDark(n, i + 4) && !r.isDark(n, i + 5) && r.isDark(n, i + 6) && (t += 40);
  for (var i = 0; i < e; i++)
    for (var n = 0; n < e - 6; n++)
      r.isDark(n, i) && !r.isDark(n + 1, i) && r.isDark(n + 2, i) && r.isDark(n + 3, i) && r.isDark(n + 4, i) && !r.isDark(n + 5, i) && r.isDark(n + 6, i) && (t += 40);
  for (var f = 0, i = 0; i < e; i++)
    for (var n = 0; n < e; n++)
      r.isDark(n, i) && f++;
  var d = Math.abs(100 * f / e / e - 50) / 5;
  return t += d * 10, t;
} }, ai = { glog: function(r) {
  if (r < 1)
    throw new Error("glog(" + r + ")");
  return ai.LOG_TABLE[r];
}, gexp: function(r) {
  for (; r < 0; )
    r += 255;
  for (; r >= 256; )
    r -= 255;
  return ai.EXP_TABLE[r];
}, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
for (var mi = 0; mi < 8; mi++)
  ai.EXP_TABLE[mi] = 1 << mi;
for (var mi = 8; mi < 256; mi++)
  ai.EXP_TABLE[mi] = ai.EXP_TABLE[mi - 4] ^ ai.EXP_TABLE[mi - 5] ^ ai.EXP_TABLE[mi - 6] ^ ai.EXP_TABLE[mi - 8];
for (var mi = 0; mi < 255; mi++)
  ai.LOG_TABLE[ai.EXP_TABLE[mi]] = mi;
function n0(r, e) {
  if (r.length == null)
    throw new Error(r.length + "/" + e);
  for (var t = 0; t < r.length && r[t] == 0; )
    t++;
  this.num = new Array(r.length - t + e);
  for (var n = 0; n < r.length - t; n++)
    this.num[n] = r[n + t];
}
n0.prototype = { get: function(r) {
  return this.num[r];
}, getLength: function() {
  return this.num.length;
}, multiply: function(r) {
  for (var e = new Array(this.getLength() + r.getLength() - 1), t = 0; t < this.getLength(); t++)
    for (var n = 0; n < r.getLength(); n++)
      e[t + n] ^= ai.gexp(ai.glog(this.get(t)) + ai.glog(r.get(n)));
  return new n0(e, 0);
}, mod: function(r) {
  if (this.getLength() - r.getLength() < 0)
    return this;
  for (var e = ai.glog(this.get(0)) - ai.glog(r.get(0)), t = new Array(this.getLength()), n = 0; n < this.getLength(); n++)
    t[n] = this.get(n);
  for (var n = 0; n < r.getLength(); n++)
    t[n] ^= ai.gexp(ai.glog(r.get(n)) + e);
  return new n0(t, 0).mod(r);
} };
function yc(r, e) {
  this.totalCount = r, this.dataCount = e;
}
yc.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
yc.getRSBlocks = function(r, e) {
  var t = yc.getRsBlockTable(r, e);
  if (t == null)
    throw new Error("bad rs block @ typeNumber:" + r + "/errorCorrectLevel:" + e);
  for (var n = t.length / 3, i = [], s = 0; s < n; s++)
    for (var o = t[s * 3 + 0], a = t[s * 3 + 1], c = t[s * 3 + 2], u = 0; u < o; u++)
      i.push(new yc(a, c));
  return i;
};
yc.getRsBlockTable = function(r, e) {
  switch (e) {
    case ju.L:
      return yc.RS_BLOCK_TABLE[(r - 1) * 4 + 0];
    case ju.M:
      return yc.RS_BLOCK_TABLE[(r - 1) * 4 + 1];
    case ju.Q:
      return yc.RS_BLOCK_TABLE[(r - 1) * 4 + 2];
    case ju.H:
      return yc.RS_BLOCK_TABLE[(r - 1) * 4 + 3];
    default:
      return;
  }
};
function xU() {
  this.buffer = [], this.length = 0;
}
xU.prototype = { get: function(r) {
  var e = Math.floor(r / 8);
  return (this.buffer[e] >>> 7 - r % 8 & 1) == 1;
}, put: function(r, e) {
  for (var t = 0; t < e; t++)
    this.putBit((r >>> e - t - 1 & 1) == 1);
}, getLengthInBits: function() {
  return this.length;
}, putBit: function(r) {
  var e = Math.floor(this.length / 8);
  this.buffer.length <= e && this.buffer.push(0), r && (this.buffer[e] |= 128 >>> this.length % 8), this.length++;
} };
var m6 = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
function SU(r) {
  if (this.options = {
    padding: 4,
    width: 256,
    height: 256,
    typeNumber: 4,
    color: "#000000",
    background: "#ffffff",
    ecl: "M",
    image: {
      svg: "",
      width: 0,
      height: 0
    }
  }, typeof r == "string" && (r = {
    content: r
  }), r)
    for (var e in r)
      this.options[e] = r[e];
  if (typeof this.options.content != "string")
    throw new Error("Expected 'content' as string!");
  if (this.options.content.length === 0)
    throw new Error("Expected 'content' to be non-empty!");
  if (!(this.options.padding >= 0))
    throw new Error("Expected 'padding' value to be non-negative!");
  if (!(this.options.width > 0) || !(this.options.height > 0))
    throw new Error("Expected 'width' or 'height' value to be higher than zero!");
  function t(c) {
    switch (c) {
      case "L":
        return ju.L;
      case "M":
        return ju.M;
      case "Q":
        return ju.Q;
      case "H":
        return ju.H;
      default:
        throw new Error("Unknwon error correction level: " + c);
    }
  }
  function n(c, u) {
    for (var f = i(c), d = 1, m = 0, y = 0, b = m6.length; y <= b; y++) {
      var I = m6[y];
      if (!I)
        throw new Error("Content too long: expected " + m + " but got " + f);
      switch (u) {
        case "L":
          m = I[0];
          break;
        case "M":
          m = I[1];
          break;
        case "Q":
          m = I[2];
          break;
        case "H":
          m = I[3];
          break;
        default:
          throw new Error("Unknwon error correction level: " + u);
      }
      if (f <= m)
        break;
      d++;
    }
    if (d > m6.length)
      throw new Error("Content too long");
    return d;
  }
  function i(c) {
    var u = encodeURI(c).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
    return u.length + (u.length != c ? 3 : 0);
  }
  var s = this.options.content, o = n(s, this.options.ecl), a = t(this.options.ecl);
  this.qrcode = new Ec(o, a), this.qrcode.addData(s), this.qrcode.make();
}
SU.prototype.svg = function(r) {
  var e = this.options || {}, t = this.qrcode.modules;
  typeof r > "u" && (r = { container: e.container || "svg" });
  for (var n = typeof e.pretty < "u" ? !!e.pretty : !0, i = n ? "  " : "", s = n ? `\r
` : "", o = e.width, a = e.height, c = t.length, u = o / (c + 2 * e.padding), f = a / (c + 2 * e.padding), d = typeof e.join < "u" ? !!e.join : !1, m = typeof e.swap < "u" ? !!e.swap : !1, y = typeof e.xmlDeclaration < "u" ? !!e.xmlDeclaration : !0, b = typeof e.predefined < "u" ? !!e.predefined : !1, I = b ? i + '<defs><path id="qrmodule" d="M0 0 h' + f + " v" + u + ' H0 z" style="fill:' + e.color + ';shape-rendering:crispEdges;" /></defs>' + s : "", k = i + '<rect x="0" y="0" width="' + o + '" height="' + a + '" style="fill:' + e.background + ';shape-rendering:crispEdges;"/>' + s, R = "", T = "", $ = 0; $ < c; $++)
    for (var D = 0; D < c; D++) {
      var L = t[D][$];
      if (L) {
        var P = D * u + e.padding * u, v = $ * f + e.padding * f;
        if (m) {
          var F = P;
          P = v, v = F;
        }
        if (d) {
          var X = u + P, te = f + v;
          P = Number.isInteger(P) ? Number(P) : P.toFixed(2), v = Number.isInteger(v) ? Number(v) : v.toFixed(2), X = Number.isInteger(X) ? Number(X) : X.toFixed(2), te = Number.isInteger(te) ? Number(te) : te.toFixed(2), T += "M" + P + "," + v + " V" + te + " H" + X + " V" + v + " H" + P + " Z ";
        } else
          b ? R += i + '<use x="' + P.toString() + '" y="' + v.toString() + '" href="#qrmodule" />' + s : R += i + '<rect x="' + P.toString() + '" y="' + v.toString() + '" width="' + u + '" height="' + f + '" style="fill:' + e.color + ';shape-rendering:crispEdges;"/>' + s;
      }
    }
  d && (R = i + '<path x="0" y="0" style="fill:' + e.color + ';shape-rendering:crispEdges;" d="' + T + '" />');
  let se = "";
  if (this.options.image !== void 0 && this.options.image.svg) {
    const H = o * this.options.image.width / 100, p = a * this.options.image.height / 100, w = o / 2 - H / 2, x = a / 2 - p / 2;
    se += `<svg x="${w}" y="${x}" width="${H}" height="${p}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`, se += this.options.image.svg + s, se += "</svg>";
  }
  var we = "";
  switch (r.container) {
    case "svg":
      y && (we += '<?xml version="1.0" standalone="yes"?>' + s), we += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + o + '" height="' + a + '">' + s, we += I + k + R, we += se, we += "</svg>";
      break;
    case "svg-viewbox":
      y && (we += '<?xml version="1.0" standalone="yes"?>' + s), we += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + o + " " + a + '">' + s, we += I + k + R, we += se, we += "</svg>";
      break;
    case "g":
      we += '<g width="' + o + '" height="' + a + '">' + s, we += I + k + R, we += se, we += "</g>";
      break;
    default:
      we += (I + k + R + se).replace(/^\s+/, "");
      break;
  }
  return we;
};
var K5e = SU, Z5e = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Y3, "__esModule", { value: !0 });
Y3.QRCode = void 0;
const J5e = co, dP = jy, Q5e = Z5e(K5e), Y5e = (r) => {
  const [e, t] = (0, dP.useState)("");
  return (0, dP.useEffect)(() => {
    var n, i;
    const s = new Q5e.default({
      content: r.content,
      background: r.bgColor || "#ffffff",
      color: r.fgColor || "#000000",
      container: "svg",
      ecl: "M",
      width: (n = r.width) !== null && n !== void 0 ? n : 256,
      height: (i = r.height) !== null && i !== void 0 ? i : 256,
      padding: 0,
      image: r.image
    }), o = Buffer.from(s.svg(), "utf8").toString("base64");
    t(`data:image/svg+xml;base64,${o}`);
  }), e ? (0, J5e.h)("img", { src: e, alt: "QR Code" }) : null;
};
Y3.QRCode = Y5e;
var X3 = {}, qA = {};
Object.defineProperty(qA, "__esModule", { value: !0 });
qA.default = ".-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}";
var X5e = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(X3, "__esModule", { value: !0 });
X3.Spinner = void 0;
const xb = co, e4e = X5e(qA), t4e = (r) => {
  var e;
  const t = (e = r.size) !== null && e !== void 0 ? e : 64, n = r.color || "#000";
  return (0, xb.h)(
    "div",
    { class: "-cbwsdk-spinner" },
    (0, xb.h)("style", null, e4e.default),
    (0, xb.h)(
      "svg",
      { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: t, height: t } },
      (0, xb.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: n } })
    )
  );
};
X3.Spinner = t4e;
var GA = {};
Object.defineProperty(GA, "__esModule", { value: !0 });
GA.default = ".-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-item.light.selected{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark.selected{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item.selected{border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}";
var i1 = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(_c, "__esModule", { value: !0 });
_c.CoinbaseAppSteps = _c.CoinbaseWalletSteps = _c.ConnectItem = _c.ConnectContent = void 0;
const ko = i1(K3), Tt = co, pP = jy, r4e = pt, n4e = Gg, i4e = Z3, s4e = i1(WA), o4e = i1(HA), CU = J3, a4e = i1(zA), c4e = i1(VA), l4e = Q3, u4e = Y3, h4e = X3, f4e = i1(GA), gP = {
  "coinbase-wallet-app": {
    title: "Coinbase Wallet app",
    description: "Connect with your self-custody wallet",
    icon: o4e.default,
    steps: IU
  },
  "coinbase-app": {
    title: "Coinbase app",
    description: "Connect with your Coinbase account",
    icon: s4e.default,
    steps: RU
  }
}, d4e = (r) => {
  switch (r) {
    case "coinbase-app":
      return a4e.default;
    case "coinbase-wallet-app":
    default:
      return c4e.default;
  }
}, _S = (r) => r === "light" ? "#FFFFFF" : "#0A0B0D";
function p4e(r) {
  const { theme: e } = r, [t, n] = (0, pP.useState)("coinbase-wallet-app"), i = (0, pP.useCallback)((u) => {
    n(u);
  }, []), s = (0, r4e.createQrUrl)(r.sessionId, r.sessionSecret, r.linkAPIUrl, r.isParentConnection, r.version, r.chainId), o = gP[t];
  if (!t)
    return null;
  const a = o.steps, c = t === "coinbase-app";
  return (0, Tt.h)(
    "div",
    { "data-testid": "connect-content", class: (0, ko.default)("-cbwsdk-connect-content", e) },
    (0, Tt.h)("style", null, f4e.default),
    (0, Tt.h)(
      "div",
      { class: "-cbwsdk-connect-content-header" },
      (0, Tt.h)("h2", { class: (0, ko.default)("-cbwsdk-connect-content-heading", e) }, "Scan to connect with one of our mobile apps"),
      r.onCancel && (0, Tt.h)(
        "button",
        { type: "button", class: "-cbwsdk-cancel-button", onClick: r.onCancel },
        (0, Tt.h)(i4e.CloseIcon, { fill: e === "light" ? "#0A0B0D" : "#FFFFFF" })
      )
    ),
    (0, Tt.h)(
      "div",
      { class: "-cbwsdk-connect-content-layout" },
      (0, Tt.h)(
        "div",
        { class: "-cbwsdk-connect-content-column-left" },
        (0, Tt.h)("div", null, Object.entries(gP).map(([u, f]) => (0, Tt.h)(AU, { key: u, title: f.title, description: f.description, icon: f.icon, selected: t === u, onClick: () => i(u), theme: e }))),
        c && (0, Tt.h)(
          "div",
          { class: (0, ko.default)("-cbwsdk-connect-content-update-app", e) },
          "Dont see a ",
          (0, Tt.h)("strong", null, "Scan"),
          " option? Update your Coinbase app to the latest version and try again."
        )
      ),
      (0, Tt.h)(
        "div",
        { class: "-cbwsdk-connect-content-column-right" },
        (0, Tt.h)(
          "div",
          { class: "-cbwsdk-connect-content-qr-wrapper" },
          (0, Tt.h)(u4e.QRCode, { content: s, width: 200, height: 200, fgColor: "#000", bgColor: "transparent", image: {
            svg: d4e(t),
            width: 25,
            height: 25
          } }),
          (0, Tt.h)("input", { type: "hidden", name: "cbw-cbwsdk-version", value: n4e.LIB_VERSION }),
          (0, Tt.h)("input", { type: "hidden", value: s })
        ),
        (0, Tt.h)(a, { theme: e }),
        !r.isConnected && (0, Tt.h)(
          "div",
          { "data-testid": "connecting-spinner", class: (0, ko.default)("-cbwsdk-connect-content-qr-connecting", e) },
          (0, Tt.h)(h4e.Spinner, { size: 36, color: e === "dark" ? "#FFF" : "#000" }),
          (0, Tt.h)("p", null, "Connecting...")
        )
      )
    )
  );
}
_c.ConnectContent = p4e;
function AU({ title: r, description: e, icon: t, selected: n, theme: i, onClick: s }) {
  return (0, Tt.h)(
    "div",
    { onClick: s, class: (0, ko.default)("-cbwsdk-connect-item", i, { selected: n }) },
    (0, Tt.h)(
      "div",
      null,
      (0, Tt.h)("img", { src: t, alt: r })
    ),
    (0, Tt.h)(
      "div",
      { class: "-cbwsdk-connect-item-copy-wrapper" },
      (0, Tt.h)("h3", { class: "-cbwsdk-connect-item-title" }, r),
      (0, Tt.h)("p", { class: "-cbwsdk-connect-item-description" }, e)
    )
  );
}
_c.ConnectItem = AU;
function IU({ theme: r }) {
  return (0, Tt.h)(
    "ol",
    { class: "-cbwsdk-wallet-steps" },
    (0, Tt.h)(
      "li",
      { class: (0, ko.default)("-cbwsdk-wallet-steps-item", r) },
      (0, Tt.h)("div", { class: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase Wallet app")
    ),
    (0, Tt.h)(
      "li",
      { class: (0, ko.default)("-cbwsdk-wallet-steps-item", r) },
      (0, Tt.h)(
        "div",
        { class: "-cbwsdk-wallet-steps-item-wrapper" },
        (0, Tt.h)(
          "span",
          null,
          "Tap ",
          (0, Tt.h)("strong", null, "Scan"),
          " "
        ),
        (0, Tt.h)(
          "span",
          { class: (0, ko.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", r) },
          (0, Tt.h)(CU.QRCodeIcon, { fill: _S(r) })
        )
      )
    )
  );
}
_c.CoinbaseWalletSteps = IU;
function RU({ theme: r }) {
  return (0, Tt.h)(
    "ol",
    { class: "-cbwsdk-wallet-steps" },
    (0, Tt.h)(
      "li",
      { class: (0, ko.default)("-cbwsdk-wallet-steps-item", r) },
      (0, Tt.h)("div", { class: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase app")
    ),
    (0, Tt.h)(
      "li",
      { class: (0, ko.default)("-cbwsdk-wallet-steps-item", r) },
      (0, Tt.h)(
        "div",
        { class: "-cbwsdk-wallet-steps-item-wrapper" },
        (0, Tt.h)(
          "span",
          null,
          "Tap ",
          (0, Tt.h)("strong", null, "More")
        ),
        (0, Tt.h)(
          "span",
          { class: (0, ko.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", r) },
          (0, Tt.h)(l4e.StatusDotIcon, { fill: _S(r) })
        ),
        (0, Tt.h)(
          "span",
          { class: "-cbwsdk-wallet-steps-pad-left" },
          "then ",
          (0, Tt.h)("strong", null, "Scan")
        ),
        (0, Tt.h)(
          "span",
          { class: (0, ko.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", r) },
          (0, Tt.h)(CU.QRCodeIcon, { fill: _S(r) })
        )
      )
    )
  );
}
_c.CoinbaseAppSteps = RU;
var eE = {}, tE = {};
Object.defineProperty(tE, "__esModule", { value: !0 });
tE.ArrowLeftIcon = void 0;
const mP = co;
function g4e(r) {
  return (0, mP.h)(
    "svg",
    Object.assign({ width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, r),
    (0, mP.h)("path", { d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z" })
  );
}
tE.ArrowLeftIcon = g4e;
var rE = {};
Object.defineProperty(rE, "__esModule", { value: !0 });
rE.LaptopIcon = void 0;
const w6 = co;
function m4e(r) {
  return (0, w6.h)(
    "svg",
    Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, r),
    (0, w6.h)("path", { d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z" }),
    (0, w6.h)("path", { d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z" })
  );
}
rE.LaptopIcon = m4e;
var nE = {};
Object.defineProperty(nE, "__esModule", { value: !0 });
nE.SafeIcon = void 0;
const wP = co;
function w4e(r) {
  return (0, wP.h)(
    "svg",
    Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, r),
    (0, wP.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z" })
  );
}
nE.SafeIcon = w4e;
var KA = {};
Object.defineProperty(KA, "__esModule", { value: !0 });
KA.default = ".-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}";
var TU = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(eE, "__esModule", { value: !0 });
eE.TryExtensionContent = void 0;
const qh = TU(K3), Hn = co, y6 = jy, y4e = tE, v4e = rE, b4e = nE, _4e = TU(KA);
function E4e({ theme: r }) {
  const [e, t] = (0, y6.useState)(!1), n = (0, y6.useCallback)(() => {
    window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
  }, []), i = (0, y6.useCallback)(() => {
    e ? window.location.reload() : (n(), t(!0));
  }, [n, e]);
  return (0, Hn.h)(
    "div",
    { class: (0, qh.default)("-cbwsdk-try-extension", r) },
    (0, Hn.h)("style", null, _4e.default),
    (0, Hn.h)(
      "div",
      { class: "-cbwsdk-try-extension-column-half" },
      (0, Hn.h)("h3", { class: (0, qh.default)("-cbwsdk-try-extension-heading", r) }, "Or try the Coinbase Wallet browser extension"),
      (0, Hn.h)(
        "div",
        { class: "-cbwsdk-try-extension-cta-wrapper" },
        (0, Hn.h)("button", { class: (0, qh.default)("-cbwsdk-try-extension-cta", r), onClick: i }, e ? "Refresh" : "Install"),
        (0, Hn.h)("div", null, !e && (0, Hn.h)(y4e.ArrowLeftIcon, { class: "-cbwsdk-try-extension-cta-icon", fill: r === "light" ? "#0052FF" : "#588AF5" }))
      )
    ),
    (0, Hn.h)(
      "div",
      { class: "-cbwsdk-try-extension-column-half" },
      (0, Hn.h)(
        "ul",
        { class: "-cbwsdk-try-extension-list" },
        (0, Hn.h)(
          "li",
          { class: "-cbwsdk-try-extension-list-item" },
          (0, Hn.h)(
            "div",
            { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
            (0, Hn.h)(
              "span",
              { class: (0, qh.default)("-cbwsdk-try-extension-list-item-icon", r) },
              (0, Hn.h)(v4e.LaptopIcon, { fill: r === "light" ? "#0A0B0D" : "#FFFFFF" })
            )
          ),
          (0, Hn.h)("div", { class: (0, qh.default)("-cbwsdk-try-extension-list-item-copy", r) }, "Connect with dapps with just one click on your desktop browser")
        ),
        (0, Hn.h)(
          "li",
          { class: "-cbwsdk-try-extension-list-item" },
          (0, Hn.h)(
            "div",
            { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
            (0, Hn.h)(
              "span",
              { class: (0, qh.default)("-cbwsdk-try-extension-list-item-icon", r) },
              (0, Hn.h)(b4e.SafeIcon, { fill: r === "light" ? "#0A0B0D" : "#FFFFFF" })
            )
          ),
          (0, Hn.h)("div", { class: (0, qh.default)("-cbwsdk-try-extension-list-item-copy", r) }, "Add an additional layer of security by using a supported Ledger hardware wallet")
        )
      )
    )
  );
}
eE.TryExtensionContent = E4e;
var ZA = {};
Object.defineProperty(ZA, "__esModule", { value: !0 });
ZA.default = ".-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}";
var OU = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(G3, "__esModule", { value: !0 });
G3.ConnectDialog = void 0;
const v6 = OU(K3), Gh = co, b6 = jy, x4e = _c, S4e = eE, C4e = OU(ZA), A4e = (r) => {
  const { isOpen: e, darkMode: t } = r, [n, i] = (0, b6.useState)(!e), [s, o] = (0, b6.useState)(!e);
  (0, b6.useEffect)(() => {
    const c = [
      window.setTimeout(() => {
        o(!e);
      }, 10)
    ];
    return e ? i(!1) : c.push(window.setTimeout(() => {
      i(!0);
    }, 360)), () => {
      c.forEach(window.clearTimeout);
    };
  }, [r.isOpen]);
  const a = t ? "dark" : "light";
  return (0, Gh.h)(
    "div",
    { class: (0, v6.default)("-cbwsdk-connect-dialog-container", n && "-cbwsdk-connect-dialog-container-hidden") },
    (0, Gh.h)("style", null, C4e.default),
    (0, Gh.h)("div", { class: (0, v6.default)("-cbwsdk-connect-dialog-backdrop", a, s && "-cbwsdk-connect-dialog-backdrop-hidden") }),
    (0, Gh.h)(
      "div",
      { class: "-cbwsdk-connect-dialog" },
      (0, Gh.h)(
        "div",
        { class: (0, v6.default)("-cbwsdk-connect-dialog-box", s && "-cbwsdk-connect-dialog-box-hidden") },
        r.connectDisabled ? null : (0, Gh.h)(x4e.ConnectContent, { theme: a, version: r.version, sessionId: r.sessionId, sessionSecret: r.sessionSecret, linkAPIUrl: r.linkAPIUrl, isConnected: r.isConnected, isParentConnection: r.isParentConnection, chainId: r.chainId, onCancel: r.onCancel }),
        (0, Gh.h)(S4e.TryExtensionContent, { theme: a })
      )
    )
  );
};
G3.ConnectDialog = A4e;
Object.defineProperty(H3, "__esModule", { value: !0 });
H3.LinkFlow = void 0;
const _6 = co, yP = q3, I4e = G3;
class R4e {
  constructor(e) {
    this.extensionUI$ = new yP.BehaviorSubject({}), this.subscriptions = new yP.Subscription(), this.isConnected = !1, this.chainId = 1, this.isOpen = !1, this.onCancel = null, this.root = null, this.connectDisabled = !1, this.darkMode = e.darkMode, this.version = e.version, this.sessionId = e.sessionId, this.sessionSecret = e.sessionSecret, this.linkAPIUrl = e.linkAPIUrl, this.isParentConnection = e.isParentConnection, this.connected$ = e.connected$, this.chainId$ = e.chainId$;
  }
  attach(e) {
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-link-flow-root", e.appendChild(this.root), this.render(), this.subscriptions.add(this.connected$.subscribe((t) => {
      this.isConnected !== t && (this.isConnected = t, this.render());
    })), this.subscriptions.add(this.chainId$.subscribe((t) => {
      this.chainId !== t && (this.chainId = t, this.render());
    }));
  }
  detach() {
    var e;
    this.root && (this.subscriptions.unsubscribe(), (0, _6.render)(null, this.root), (e = this.root.parentElement) === null || e === void 0 || e.removeChild(this.root));
  }
  setConnectDisabled(e) {
    this.connectDisabled = e;
  }
  open(e) {
    this.isOpen = !0, this.onCancel = e.onCancel, this.render();
  }
  close() {
    this.isOpen = !1, this.onCancel = null, this.render();
  }
  render() {
    if (!this.root)
      return;
    const e = this.extensionUI$.subscribe(() => {
      this.root && (0, _6.render)((0, _6.h)(I4e.ConnectDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
    });
    this.subscriptions.add(e);
  }
}
H3.LinkFlow = R4e;
var NU = {}, JA = {};
Object.defineProperty(JA, "__esModule", { value: !0 });
JA.default = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}";
(function(r) {
  var e = ze && ze.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(r, "__esModule", { value: !0 }), r.SnackbarInstance = r.SnackbarContainer = r.Snackbar = void 0;
  const t = e(K3), n = co, i = jy, s = e(JA), o = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
  function a(d) {
    switch (d) {
      case "coinbase-app":
        return "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE0LjY3NCAxOC44NThjLTIuMDQ1IDAtMy42NDgtMS43MjItMy42NDgtMy44NDVzMS42NTktMy44NDUgMy42NDgtMy44NDVjMS44MjQgMCAzLjMxNyAxLjM3NyAzLjU5MyAzLjIxNGgzLjcwM2MtLjMzMS0zLjk2LTMuNDgyLTcuMDU5LTcuMjk2LTcuMDU5LTQuMDM0IDAtNy4zNSAzLjQ0My03LjM1IDcuNjkgMCA0LjI0NiAzLjI2IDcuNjkgNy4zNSA3LjY5IDMuODcgMCA2Ljk2NS0zLjEgNy4yOTYtNy4wNTloLTMuNzAzYy0uMjc2IDEuODM2LTEuNzY5IDMuMjE0LTMuNTkzIDMuMjE0WiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0wIDEwLjY3OGMwLTMuNzExIDAtNS41OTYuNzQyLTcuMDIzQTYuNTMyIDYuNTMyIDAgMCAxIDMuNjU1Ljc0MkM1LjA4MiAwIDYuOTY3IDAgMTAuNjc4IDBoNy45MzhjMy43MTEgMCA1LjU5NiAwIDcuMDIzLjc0MmE2LjUzMSA2LjUzMSAwIDAgMSAyLjkxMyAyLjkxM2MuNzQyIDEuNDI3Ljc0MiAzLjMxMi43NDIgNy4wMjN2Ny45MzhjMCAzLjcxMSAwIDUuNTk2LS43NDIgNy4wMjNhNi41MzEgNi41MzEgMCAwIDEtMi45MTMgMi45MTNjLTEuNDI3Ljc0Mi0zLjMxMi43NDItNy4wMjMuNzQyaC03LjkzOGMtMy43MTEgMC01LjU5NiAwLTcuMDIzLS43NDJhNi41MzEgNi41MzEgMCAwIDEtMi45MTMtMi45MTNDMCAyNC4yMTIgMCAyMi4zODQgMCAxOC42MTZ2LTcuOTM4WiIgZmlsbD0iIzAwNTJGRiIvPjxwYXRoIGQ9Ik0xNC42ODQgMTkuNzczYy0yLjcyNyAwLTQuODY0LTIuMjk1LTQuODY0LTUuMTI2IDAtMi44MzEgMi4yMS01LjEyNyA0Ljg2NC01LjEyNyAyLjQzMiAwIDQuNDIyIDEuODM3IDQuNzkgNC4yODVoNC45MzhjLS40NDItNS4yOC00LjY0My05LjQxMS05LjcyOC05LjQxMS01LjM4IDAtOS44MDIgNC41OS05LjgwMiAxMC4yNTMgMCA1LjY2MiA0LjM0OCAxMC4yNTMgOS44MDIgMTAuMjUzIDUuMTU5IDAgOS4yODYtNC4xMzIgOS43MjgtOS40MTFoLTQuOTM4Yy0uMzY4IDIuNDQ4LTIuMzU4IDQuMjg0LTQuNzkgNC4yODRaIiBmaWxsPSIjZmZmIi8+PC9zdmc+";
      case "coinbase-wallet-app":
      default:
        return "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+";
    }
  }
  class c {
    constructor(m) {
      this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = m.darkMode;
    }
    attach(m) {
      this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", m.appendChild(this.root), this.render();
    }
    presentItem(m) {
      const y = this.nextItemKey++;
      return this.items.set(y, m), this.render(), () => {
        this.items.delete(y), this.render();
      };
    }
    clear() {
      this.items.clear(), this.render();
    }
    render() {
      this.root && (0, n.render)((0, n.h)(
        "div",
        null,
        (0, n.h)(r.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([m, y]) => (0, n.h)(r.SnackbarInstance, Object.assign({}, y, { key: m }))))
      ), this.root);
    }
  }
  r.Snackbar = c;
  const u = (d) => (0, n.h)(
    "div",
    { class: (0, t.default)("-cbwsdk-snackbar-container") },
    (0, n.h)("style", null, s.default),
    (0, n.h)("div", { class: "-cbwsdk-snackbar" }, d.children)
  );
  r.SnackbarContainer = u;
  const f = ({ autoExpand: d, message: m, menuItems: y, appSrc: b }) => {
    const [I, k] = (0, i.useState)(!0), [R, T] = (0, i.useState)(d ?? !1);
    (0, i.useEffect)(() => {
      const D = [
        window.setTimeout(() => {
          k(!1);
        }, 1),
        window.setTimeout(() => {
          T(!0);
        }, 1e4)
      ];
      return () => {
        D.forEach(window.clearTimeout);
      };
    });
    const $ = () => {
      T(!R);
    };
    return (0, n.h)(
      "div",
      { class: (0, t.default)("-cbwsdk-snackbar-instance", I && "-cbwsdk-snackbar-instance-hidden", R && "-cbwsdk-snackbar-instance-expanded") },
      (0, n.h)(
        "div",
        { class: "-cbwsdk-snackbar-instance-header", onClick: $ },
        (0, n.h)("img", { src: a(b), class: "-cbwsdk-snackbar-instance-header-cblogo" }),
        (0, n.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, m),
        (0, n.h)(
          "div",
          { class: "-gear-container" },
          !R && (0, n.h)(
            "svg",
            { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, n.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
          ),
          (0, n.h)("img", { src: o, class: "-gear-icon", title: "Expand" })
        )
      ),
      y && y.length > 0 && (0, n.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, y.map((D, L) => (0, n.h)(
        "div",
        { class: (0, t.default)("-cbwsdk-snackbar-instance-menu-item", D.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: D.onClick, key: L },
        (0, n.h)(
          "svg",
          { width: D.svgWidth, height: D.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          (0, n.h)("path", { "fill-rule": D.defaultFillRule, "clip-rule": D.defaultClipRule, d: D.path, fill: "#AAAAAA" })
        ),
        (0, n.h)("span", { class: (0, t.default)("-cbwsdk-snackbar-instance-menu-item-info", D.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, D.info)
      )))
    );
  };
  r.SnackbarInstance = f;
})(NU);
var iE = {}, QA = {};
Object.defineProperty(QA, "__esModule", { value: !0 });
QA.default = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
var T4e = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(iE, "__esModule", { value: !0 });
iE.injectCssReset = void 0;
const O4e = T4e(QA);
function N4e() {
  const r = document.createElement("style");
  r.type = "text/css", r.appendChild(document.createTextNode(O4e.default)), document.documentElement.appendChild(r);
}
iE.injectCssReset = N4e;
Object.defineProperty(W3, "__esModule", { value: !0 });
W3.WalletSDKUI = void 0;
const P4e = H3, M4e = NU, D4e = iE;
class k4e {
  constructor(e) {
    this.standalone = null, this.attached = !1, this.appSrc = null, this.snackbar = new M4e.Snackbar({
      darkMode: e.darkMode
    }), this.linkFlow = new P4e.LinkFlow({
      darkMode: e.darkMode,
      version: e.version,
      sessionId: e.session.id,
      sessionSecret: e.session.secret,
      linkAPIUrl: e.linkAPIUrl,
      connected$: e.connected$,
      chainId$: e.chainId$,
      isParentConnection: !1
    });
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    const e = document.documentElement, t = document.createElement("div");
    t.className = "-cbwsdk-css-reset", e.appendChild(t), this.linkFlow.attach(t), this.snackbar.attach(t), this.attached = !0, (0, D4e.injectCssReset)();
  }
  setConnectDisabled(e) {
    this.linkFlow.setConnectDisabled(e);
  }
  /* istanbul ignore next */
  addEthereumChain(e) {
  }
  /* istanbul ignore next */
  watchAsset(e) {
  }
  /* istanbul ignore next */
  switchEthereumChain(e) {
  }
  requestEthereumAccounts(e) {
    this.linkFlow.open({ onCancel: e.onCancel });
  }
  hideRequestEthereumAccounts() {
    this.linkFlow.close();
  }
  /* istanbul ignore next */
  signEthereumMessage(e) {
  }
  /* istanbul ignore next */
  signEthereumTransaction(e) {
  }
  /* istanbul ignore next */
  submitEthereumTransaction(e) {
  }
  /* istanbul ignore next */
  ethereumAddressFromSignedMessage(e) {
  }
  showConnecting(e) {
    let t;
    return e.isUnlinkedErrorState ? t = {
      autoExpand: !0,
      message: "Connection lost",
      appSrc: this.appSrc,
      menuItems: [
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    } : t = {
      message: "Confirm on phone",
      appSrc: this.appSrc,
      menuItems: [
        {
          isRed: !0,
          info: "Cancel transaction",
          svgWidth: "11",
          svgHeight: "11",
          path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
          defaultFillRule: "inherit",
          defaultClipRule: "inherit",
          onClick: e.onCancel
        },
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    }, this.snackbar.presentItem(t);
  }
  /* istanbul ignore next */
  setAppSrc(e) {
    this.appSrc = e;
  }
  /* istanbul ignore next */
  reloadUI() {
    document.location.reload();
  }
  /* istanbul ignore next */
  inlineAccountsResponse() {
    return !1;
  }
  /* istanbul ignore next */
  inlineAddEthereumChain(e) {
    return !1;
  }
  /* istanbul ignore next */
  inlineWatchAsset() {
    return !1;
  }
  /* istanbul ignore next */
  inlineSwitchEthereumChain() {
    return !1;
  }
  /* istanbul ignore next */
  setStandalone(e) {
    this.standalone = e;
  }
  /* istanbul ignore next */
  isStandalone() {
    var e;
    return (e = this.standalone) !== null && e !== void 0 ? e : !1;
  }
}
W3.WalletSDKUI = k4e;
var sE = {}, oE = {};
Object.defineProperty(oE, "__esModule", { value: !0 });
var Lp;
(function(r) {
  r.typeOfFunction = "function", r.boolTrue = !0;
})(Lp || (Lp = {}));
function PU(r, e, t) {
  if (!t || typeof t.value !== Lp.typeOfFunction)
    throw new TypeError("Only methods can be decorated with @bind. <" + e + "> is not a method!");
  return {
    configurable: Lp.boolTrue,
    get: function() {
      var n = t.value.bind(this);
      return Object.defineProperty(this, e, {
        value: n,
        configurable: Lp.boolTrue,
        writable: Lp.boolTrue
      }), n;
    }
  };
}
oE.bind = PU;
oE.default = PU;
function MU(r) {
  return function(t) {
    return t.lift(new $4e(r));
  };
}
var $4e = /* @__PURE__ */ function() {
  function r(e) {
    this.durationSelector = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new L4e(e, this.durationSelector));
  }, r;
}(), L4e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.durationSelector = n, i.hasValue = !1, i;
  }
  return e.prototype._next = function(t) {
    if (this.value = t, this.hasValue = !0, !this.throttled) {
      var n = void 0;
      try {
        var i = this.durationSelector;
        n = i(t);
      } catch (o) {
        return this.destination.error(o);
      }
      var s = On(n, new Rn(this));
      !s || s.closed ? this.clearThrottle() : this.add(this.throttled = s);
    }
  }, e.prototype.clearThrottle = function() {
    var t = this, n = t.value, i = t.hasValue, s = t.throttled;
    s && (this.remove(s), this.throttled = void 0, s.unsubscribe()), i && (this.value = void 0, this.hasValue = !1, this.destination.next(n));
  }, e.prototype.notifyNext = function() {
    this.clearThrottle();
  }, e.prototype.notifyComplete = function() {
    this.clearThrottle();
  }, e;
}(Tn);
function B4e(r, e) {
  return e === void 0 && (e = fs), MU(function() {
    return dU(r, e);
  });
}
function F4e(r) {
  return function(t) {
    return t.lift(new U4e(r));
  };
}
var U4e = /* @__PURE__ */ function() {
  function r(e) {
    this.closingNotifier = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new j4e(e, this.closingNotifier));
  }, r;
}(), j4e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.buffer = [], i.add(On(n, new Rn(i))), i;
  }
  return e.prototype._next = function(t) {
    this.buffer.push(t);
  }, e.prototype.notifyNext = function() {
    var t = this.buffer;
    this.buffer = [], this.destination.next(t);
  }, e;
}(Tn);
function W4e(r, e) {
  return e === void 0 && (e = null), function(n) {
    return n.lift(new H4e(r, e));
  };
}
var H4e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.bufferSize = e, this.startBufferEvery = t, !t || e === t ? this.subscriberClass = z4e : this.subscriberClass = V4e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new this.subscriberClass(e, this.bufferSize, this.startBufferEvery));
  }, r;
}(), z4e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.bufferSize = n, i.buffer = [], i;
  }
  return e.prototype._next = function(t) {
    var n = this.buffer;
    n.push(t), n.length == this.bufferSize && (this.destination.next(n), this.buffer = []);
  }, e.prototype._complete = function() {
    var t = this.buffer;
    t.length > 0 && this.destination.next(t), r.prototype._complete.call(this);
  }, e;
}(yt), V4e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.bufferSize = n, s.startBufferEvery = i, s.buffers = [], s.count = 0, s;
  }
  return e.prototype._next = function(t) {
    var n = this, i = n.bufferSize, s = n.startBufferEvery, o = n.buffers, a = n.count;
    this.count++, a % s === 0 && o.push([]);
    for (var c = o.length; c--; ) {
      var u = o[c];
      u.push(t), u.length === i && (o.splice(c, 1), this.destination.next(u));
    }
  }, e.prototype._complete = function() {
    for (var t = this, n = t.buffers, i = t.destination; n.length > 0; ) {
      var s = n.shift();
      s.length > 0 && i.next(s);
    }
    r.prototype._complete.call(this);
  }, e;
}(yt);
function q4e(r) {
  var e = arguments.length, t = fs;
  no(arguments[arguments.length - 1]) && (t = arguments[arguments.length - 1], e--);
  var n = null;
  e >= 2 && (n = arguments[1]);
  var i = Number.POSITIVE_INFINITY;
  return e >= 3 && (i = arguments[2]), function(o) {
    return o.lift(new G4e(r, n, i, t));
  };
}
var G4e = /* @__PURE__ */ function() {
  function r(e, t, n, i) {
    this.bufferTimeSpan = e, this.bufferCreationInterval = t, this.maxBufferSize = n, this.scheduler = i;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Z4e(e, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  }, r;
}(), K4e = /* @__PURE__ */ function() {
  function r() {
    this.buffer = [];
  }
  return r;
}(), Z4e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s, o) {
    var a = r.call(this, t) || this;
    a.bufferTimeSpan = n, a.bufferCreationInterval = i, a.maxBufferSize = s, a.scheduler = o, a.contexts = [];
    var c = a.openContext();
    if (a.timespanOnly = i == null || i < 0, a.timespanOnly) {
      var u = { subscriber: a, context: c, bufferTimeSpan: n };
      a.add(c.closeAction = o.schedule(vP, n, u));
    } else {
      var f = { subscriber: a, context: c }, d = { bufferTimeSpan: n, bufferCreationInterval: i, subscriber: a, scheduler: o };
      a.add(c.closeAction = o.schedule(DU, n, f)), a.add(o.schedule(J4e, i, d));
    }
    return a;
  }
  return e.prototype._next = function(t) {
    for (var n = this.contexts, i = n.length, s, o = 0; o < i; o++) {
      var a = n[o], c = a.buffer;
      c.push(t), c.length == this.maxBufferSize && (s = a);
    }
    s && this.onBufferFull(s);
  }, e.prototype._error = function(t) {
    this.contexts.length = 0, r.prototype._error.call(this, t);
  }, e.prototype._complete = function() {
    for (var t = this, n = t.contexts, i = t.destination; n.length > 0; ) {
      var s = n.shift();
      i.next(s.buffer);
    }
    r.prototype._complete.call(this);
  }, e.prototype._unsubscribe = function() {
    this.contexts = null;
  }, e.prototype.onBufferFull = function(t) {
    this.closeContext(t);
    var n = t.closeAction;
    if (n.unsubscribe(), this.remove(n), !this.closed && this.timespanOnly) {
      t = this.openContext();
      var i = this.bufferTimeSpan, s = { subscriber: this, context: t, bufferTimeSpan: i };
      this.add(t.closeAction = this.scheduler.schedule(vP, i, s));
    }
  }, e.prototype.openContext = function() {
    var t = new K4e();
    return this.contexts.push(t), t;
  }, e.prototype.closeContext = function(t) {
    this.destination.next(t.buffer);
    var n = this.contexts, i = n ? n.indexOf(t) : -1;
    i >= 0 && n.splice(n.indexOf(t), 1);
  }, e;
}(yt);
function vP(r) {
  var e = r.subscriber, t = r.context;
  t && e.closeContext(t), e.closed || (r.context = e.openContext(), r.context.closeAction = this.schedule(r, r.bufferTimeSpan));
}
function J4e(r) {
  var e = r.bufferCreationInterval, t = r.bufferTimeSpan, n = r.subscriber, i = r.scheduler, s = n.openContext(), o = this;
  n.closed || (n.add(s.closeAction = i.schedule(DU, t, { subscriber: n, context: s })), o.schedule(r, e));
}
function DU(r) {
  var e = r.subscriber, t = r.context;
  e.closeContext(t);
}
function Q4e(r, e) {
  return function(n) {
    return n.lift(new Y4e(r, e));
  };
}
var Y4e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.openings = e, this.closingSelector = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new X4e(e, this.openings, this.closingSelector));
  }, r;
}(), X4e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.closingSelector = i, s.contexts = [], s.add(Ll(s, n)), s;
  }
  return e.prototype._next = function(t) {
    for (var n = this.contexts, i = n.length, s = 0; s < i; s++)
      n[s].buffer.push(t);
  }, e.prototype._error = function(t) {
    for (var n = this.contexts; n.length > 0; ) {
      var i = n.shift();
      i.subscription.unsubscribe(), i.buffer = null, i.subscription = null;
    }
    this.contexts = null, r.prototype._error.call(this, t);
  }, e.prototype._complete = function() {
    for (var t = this.contexts; t.length > 0; ) {
      var n = t.shift();
      this.destination.next(n.buffer), n.subscription.unsubscribe(), n.buffer = null, n.subscription = null;
    }
    this.contexts = null, r.prototype._complete.call(this);
  }, e.prototype.notifyNext = function(t, n) {
    t ? this.closeBuffer(t) : this.openBuffer(n);
  }, e.prototype.notifyComplete = function(t) {
    this.closeBuffer(t.context);
  }, e.prototype.openBuffer = function(t) {
    try {
      var n = this.closingSelector, i = n.call(this, t);
      i && this.trySubscribe(i);
    } catch (s) {
      this._error(s);
    }
  }, e.prototype.closeBuffer = function(t) {
    var n = this.contexts;
    if (n && t) {
      var i = t.buffer, s = t.subscription;
      this.destination.next(i), n.splice(n.indexOf(t), 1), this.remove(s), s.unsubscribe();
    }
  }, e.prototype.trySubscribe = function(t) {
    var n = this.contexts, i = [], s = new yn(), o = { buffer: i, subscription: s };
    n.push(o);
    var a = Ll(this, t, o);
    !a || a.closed ? this.closeBuffer(o) : (a.context = o, this.add(a), s.add(a));
  }, e;
}(Wd);
function e6e(r) {
  return function(e) {
    return e.lift(new t6e(r));
  };
}
var t6e = /* @__PURE__ */ function() {
  function r(e) {
    this.closingSelector = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new r6e(e, this.closingSelector));
  }, r;
}(), r6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.closingSelector = n, i.subscribing = !1, i.openBuffer(), i;
  }
  return e.prototype._next = function(t) {
    this.buffer.push(t);
  }, e.prototype._complete = function() {
    var t = this.buffer;
    t && this.destination.next(t), r.prototype._complete.call(this);
  }, e.prototype._unsubscribe = function() {
    this.buffer = void 0, this.subscribing = !1;
  }, e.prototype.notifyNext = function() {
    this.openBuffer();
  }, e.prototype.notifyComplete = function() {
    this.subscribing ? this.complete() : this.openBuffer();
  }, e.prototype.openBuffer = function() {
    var t = this.closingSubscription;
    t && (this.remove(t), t.unsubscribe());
    var n = this.buffer;
    this.buffer && this.destination.next(n), this.buffer = [];
    var i;
    try {
      var s = this.closingSelector;
      i = s();
    } catch (o) {
      return this.error(o);
    }
    t = new yn(), this.closingSubscription = t, this.add(t), this.subscribing = !0, t.add(On(i, new Rn(this))), this.subscribing = !1;
  }, e;
}(Tn);
function n6e(r) {
  return function(t) {
    var n = new i6e(r), i = t.lift(n);
    return n.caught = i;
  };
}
var i6e = /* @__PURE__ */ function() {
  function r(e) {
    this.selector = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new s6e(e, this.selector, this.caught));
  }, r;
}(), s6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.selector = n, s.caught = i, s;
  }
  return e.prototype.error = function(t) {
    if (!this.isStopped) {
      var n = void 0;
      try {
        n = this.selector(t, this.caught);
      } catch (o) {
        r.prototype.error.call(this, o);
        return;
      }
      this._unsubscribeAndRecycle();
      var i = new Rn(this);
      this.add(i);
      var s = On(n, i);
      s !== i && this.add(s);
    }
  }, e;
}(Tn);
function o6e(r) {
  return function(e) {
    return e.lift(new LA(r));
  };
}
function a6e() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = null;
  return typeof r[r.length - 1] == "function" && (t = r.pop()), r.length === 1 && hs(r[0]) && (r = r[0].slice()), function(n) {
    return n.lift.call(Vl([n].concat(r)), new LA(t));
  };
}
function c6e() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return function(t) {
    return t.lift.call(Ew.apply(void 0, [t].concat(r)));
  };
}
function kU(r, e) {
  return bd(r, e, 1);
}
function l6e(r, e) {
  return kU(function() {
    return r;
  }, e);
}
function u6e(r) {
  return function(e) {
    return e.lift(new h6e(r, e));
  };
}
var h6e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.predicate = e, this.source = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new f6e(e, this.predicate, this.source));
  }, r;
}(), f6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.predicate = n, s.source = i, s.count = 0, s.index = 0, s;
  }
  return e.prototype._next = function(t) {
    this.predicate ? this._tryPredicate(t) : this.count++;
  }, e.prototype._tryPredicate = function(t) {
    var n;
    try {
      n = this.predicate(t, this.index++, this.source);
    } catch (i) {
      this.destination.error(i);
      return;
    }
    n && this.count++;
  }, e.prototype._complete = function() {
    this.destination.next(this.count), this.destination.complete();
  }, e;
}(yt);
function d6e(r) {
  return function(e) {
    return e.lift(new p6e(r));
  };
}
var p6e = /* @__PURE__ */ function() {
  function r(e) {
    this.durationSelector = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new g6e(e, this.durationSelector));
  }, r;
}(), g6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.durationSelector = n, i.hasValue = !1, i;
  }
  return e.prototype._next = function(t) {
    try {
      var n = this.durationSelector.call(this, t);
      n && this._tryNext(t, n);
    } catch (i) {
      this.destination.error(i);
    }
  }, e.prototype._complete = function() {
    this.emitValue(), this.destination.complete();
  }, e.prototype._tryNext = function(t, n) {
    var i = this.durationSubscription;
    this.value = t, this.hasValue = !0, i && (i.unsubscribe(), this.remove(i)), i = On(n, new Rn(this)), i && !i.closed && this.add(this.durationSubscription = i);
  }, e.prototype.notifyNext = function() {
    this.emitValue();
  }, e.prototype.notifyComplete = function() {
    this.emitValue();
  }, e.prototype.emitValue = function() {
    if (this.hasValue) {
      var t = this.value, n = this.durationSubscription;
      n && (this.durationSubscription = void 0, n.unsubscribe(), this.remove(n)), this.value = void 0, this.hasValue = !1, r.prototype._next.call(this, t);
    }
  }, e;
}(Tn);
function m6e(r, e) {
  return e === void 0 && (e = fs), function(t) {
    return t.lift(new w6e(r, e));
  };
}
var w6e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.dueTime = e, this.scheduler = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new y6e(e, this.dueTime, this.scheduler));
  }, r;
}(), y6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.dueTime = n, s.scheduler = i, s.debouncedSubscription = null, s.lastValue = null, s.hasValue = !1, s;
  }
  return e.prototype._next = function(t) {
    this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(v6e, this.dueTime, this));
  }, e.prototype._complete = function() {
    this.debouncedNext(), this.destination.complete();
  }, e.prototype.debouncedNext = function() {
    if (this.clearDebounce(), this.hasValue) {
      var t = this.lastValue;
      this.lastValue = null, this.hasValue = !1, this.destination.next(t);
    }
  }, e.prototype.clearDebounce = function() {
    var t = this.debouncedSubscription;
    t !== null && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null);
  }, e;
}(yt);
function v6e(r) {
  r.debouncedNext();
}
function Wy(r) {
  return r === void 0 && (r = null), function(e) {
    return e.lift(new b6e(r));
  };
}
var b6e = /* @__PURE__ */ function() {
  function r(e) {
    this.defaultValue = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new _6e(e, this.defaultValue));
  }, r;
}(), _6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.defaultValue = n, i.isEmpty = !0, i;
  }
  return e.prototype._next = function(t) {
    this.isEmpty = !1, this.destination.next(t);
  }, e.prototype._complete = function() {
    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
  }, e;
}(yt);
function $U(r) {
  return r instanceof Date && !isNaN(+r);
}
function E6e(r, e) {
  e === void 0 && (e = fs);
  var t = $U(r), n = t ? +r - e.now() : Math.abs(r);
  return function(i) {
    return i.lift(new x6e(n, e));
  };
}
var x6e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.delay = e, this.scheduler = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new S6e(e, this.delay, this.scheduler));
  }, r;
}(), S6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.delay = n, s.scheduler = i, s.queue = [], s.active = !1, s.errored = !1, s;
  }
  return e.dispatch = function(t) {
    for (var n = t.source, i = n.queue, s = t.scheduler, o = t.destination; i.length > 0 && i[0].time - s.now() <= 0; )
      i.shift().notification.observe(o);
    if (i.length > 0) {
      var a = Math.max(0, i[0].time - s.now());
      this.schedule(t, a);
    } else
      this.unsubscribe(), n.active = !1;
  }, e.prototype._schedule = function(t) {
    this.active = !0;
    var n = this.destination;
    n.add(t.schedule(e.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: t
    }));
  }, e.prototype.scheduleNotification = function(t) {
    if (this.errored !== !0) {
      var n = this.scheduler, i = new C6e(n.now() + this.delay, t);
      this.queue.push(i), this.active === !1 && this._schedule(n);
    }
  }, e.prototype._next = function(t) {
    this.scheduleNotification(Nl.createNext(t));
  }, e.prototype._error = function(t) {
    this.errored = !0, this.queue = [], this.destination.error(t), this.unsubscribe();
  }, e.prototype._complete = function() {
    this.scheduleNotification(Nl.createComplete()), this.unsubscribe();
  }, e;
}(yt), C6e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.time = e, this.notification = t;
  }
  return r;
}();
function A6e(r, e) {
  return e ? function(t) {
    return new R6e(t, e).lift(new bP(r));
  } : function(t) {
    return t.lift(new bP(r));
  };
}
var bP = /* @__PURE__ */ function() {
  function r(e) {
    this.delayDurationSelector = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new I6e(e, this.delayDurationSelector));
  }, r;
}(), I6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.delayDurationSelector = n, i.completed = !1, i.delayNotifierSubscriptions = [], i.index = 0, i;
  }
  return e.prototype.notifyNext = function(t, n, i, s, o) {
    this.destination.next(t), this.removeSubscription(o), this.tryComplete();
  }, e.prototype.notifyError = function(t, n) {
    this._error(t);
  }, e.prototype.notifyComplete = function(t) {
    var n = this.removeSubscription(t);
    n && this.destination.next(n), this.tryComplete();
  }, e.prototype._next = function(t) {
    var n = this.index++;
    try {
      var i = this.delayDurationSelector(t, n);
      i && this.tryDelay(i, t);
    } catch (s) {
      this.destination.error(s);
    }
  }, e.prototype._complete = function() {
    this.completed = !0, this.tryComplete(), this.unsubscribe();
  }, e.prototype.removeSubscription = function(t) {
    t.unsubscribe();
    var n = this.delayNotifierSubscriptions.indexOf(t);
    return n !== -1 && this.delayNotifierSubscriptions.splice(n, 1), t.outerValue;
  }, e.prototype.tryDelay = function(t, n) {
    var i = Ll(this, t, n);
    if (i && !i.closed) {
      var s = this.destination;
      s.add(i), this.delayNotifierSubscriptions.push(i);
    }
  }, e.prototype.tryComplete = function() {
    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();
  }, e;
}(Wd), R6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.source = t, i.subscriptionDelay = n, i;
  }
  return e.prototype._subscribe = function(t) {
    this.subscriptionDelay.subscribe(new T6e(t, this.source));
  }, e;
}(ir), T6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.parent = t, i.source = n, i.sourceSubscribed = !1, i;
  }
  return e.prototype._next = function(t) {
    this.subscribeToSource();
  }, e.prototype._error = function(t) {
    this.unsubscribe(), this.parent.error(t);
  }, e.prototype._complete = function() {
    this.unsubscribe(), this.subscribeToSource();
  }, e.prototype.subscribeToSource = function() {
    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
  }, e;
}(yt);
function O6e() {
  return function(e) {
    return e.lift(new N6e());
  };
}
var N6e = /* @__PURE__ */ function() {
  function r() {
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new P6e(e));
  }, r;
}(), P6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype._next = function(t) {
    t.observe(this.destination);
  }, e;
}(yt);
function M6e(r, e) {
  return function(t) {
    return t.lift(new D6e(r, e));
  };
}
var D6e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.keySelector = e, this.flushes = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new k6e(e, this.keySelector, this.flushes));
  }, r;
}(), k6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.keySelector = n, s.values = /* @__PURE__ */ new Set(), i && s.add(On(i, new Rn(s))), s;
  }
  return e.prototype.notifyNext = function() {
    this.values.clear();
  }, e.prototype.notifyError = function(t) {
    this._error(t);
  }, e.prototype._next = function(t) {
    this.keySelector ? this._useKeySelector(t) : this._finalizeNext(t, t);
  }, e.prototype._useKeySelector = function(t) {
    var n, i = this.destination;
    try {
      n = this.keySelector(t);
    } catch (s) {
      i.error(s);
      return;
    }
    this._finalizeNext(n, t);
  }, e.prototype._finalizeNext = function(t, n) {
    var i = this.values;
    i.has(t) || (i.add(t), this.destination.next(n));
  }, e;
}(Tn);
function LU(r, e) {
  return function(t) {
    return t.lift(new $6e(r, e));
  };
}
var $6e = /* @__PURE__ */ function() {
  function r(e, t) {
    this.compare = e, this.keySelector = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new L6e(e, this.compare, this.keySelector));
  }, r;
}(), L6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.keySelector = i, s.hasKey = !1, typeof n == "function" && (s.compare = n), s;
  }
  return e.prototype.compare = function(t, n) {
    return t === n;
  }, e.prototype._next = function(t) {
    var n;
    try {
      var i = this.keySelector;
      n = i ? i(t) : t;
    } catch (a) {
      return this.destination.error(a);
    }
    var s = !1;
    if (this.hasKey)
      try {
        var o = this.compare;
        s = o(this.key, n);
      } catch (a) {
        return this.destination.error(a);
      }
    else
      this.hasKey = !0;
    s || (this.key = n, this.destination.next(t));
  }, e;
}(yt);
function B6e(r, e) {
  return LU(function(t, n) {
    return e ? e(t[r], n[r]) : t[r] === n[r];
  });
}
function aE(r) {
  return r === void 0 && (r = j6e), function(e) {
    return e.lift(new F6e(r));
  };
}
var F6e = /* @__PURE__ */ function() {
  function r(e) {
    this.errorFactory = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new U6e(e, this.errorFactory));
  }, r;
}(), U6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.errorFactory = n, i.hasValue = !1, i;
  }
  return e.prototype._next = function(t) {
    this.hasValue = !0, this.destination.next(t);
  }, e.prototype._complete = function() {
    if (this.hasValue)
      return this.destination.complete();
    var t = void 0;
    try {
      t = this.errorFactory();
    } catch (n) {
      t = n;
    }
    this.destination.error(t);
  }, e;
}(yt);
function j6e() {
  return new Uy();
}
function YA(r) {
  return function(e) {
    return r === 0 ? r1() : e.lift(new W6e(r));
  };
}
var W6e = /* @__PURE__ */ function() {
  function r(e) {
    if (this.total = e, this.total < 0)
      throw new Pg();
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new H6e(e, this.total));
  }, r;
}(), H6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.total = n, i.count = 0, i;
  }
  return e.prototype._next = function(t) {
    var n = this.total, i = ++this.count;
    i <= n && (this.destination.next(t), i === n && (this.destination.complete(), this.unsubscribe()));
  }, e;
}(yt);
function z6e(r, e) {
  if (r < 0)
    throw new Pg();
  var t = arguments.length >= 2;
  return function(n) {
    return n.pipe(ah(function(i, s) {
      return s === r;
    }), YA(1), t ? Wy(e) : aE(function() {
      return new Pg();
    }));
  };
}
function V6e() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return function(t) {
    return Ew(t, V3.apply(void 0, r));
  };
}
function q6e(r, e) {
  return function(t) {
    return t.lift(new G6e(r, e, t));
  };
}
var G6e = /* @__PURE__ */ function() {
  function r(e, t, n) {
    this.predicate = e, this.thisArg = t, this.source = n;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new K6e(e, this.predicate, this.thisArg, this.source));
  }, r;
}(), K6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s) {
    var o = r.call(this, t) || this;
    return o.predicate = n, o.thisArg = i, o.source = s, o.index = 0, o.thisArg = i || o, o;
  }
  return e.prototype.notifyComplete = function(t) {
    this.destination.next(t), this.destination.complete();
  }, e.prototype._next = function(t) {
    var n = !1;
    try {
      n = this.predicate.call(this.thisArg, t, this.index++, this.source);
    } catch (i) {
      this.destination.error(i);
      return;
    }
    n || this.notifyComplete(!1);
  }, e.prototype._complete = function() {
    this.notifyComplete(!0);
  }, e;
}(yt);
function Z6e() {
  return function(r) {
    return r.lift(new J6e());
  };
}
var J6e = /* @__PURE__ */ function() {
  function r() {
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Q6e(e));
  }, r;
}(), Q6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this, t) || this;
    return n.hasCompleted = !1, n.hasSubscription = !1, n;
  }
  return e.prototype._next = function(t) {
    this.hasSubscription || (this.hasSubscription = !0, this.add(On(t, new Rn(this))));
  }, e.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
  }, e.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, e;
}(Tn);
function BU(r, e) {
  return e ? function(t) {
    return t.pipe(BU(function(n, i) {
      return Vl(r(n, i)).pipe(Vo(function(s, o) {
        return e(n, s, i, o);
      }));
    }));
  } : function(t) {
    return t.lift(new Y6e(r));
  };
}
var Y6e = /* @__PURE__ */ function() {
  function r(e) {
    this.project = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new X6e(e, this.project));
  }, r;
}(), X6e = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.project = n, i.hasSubscription = !1, i.hasCompleted = !1, i.index = 0, i;
  }
  return e.prototype._next = function(t) {
    this.hasSubscription || this.tryNext(t);
  }, e.prototype.tryNext = function(t) {
    var n, i = this.index++;
    try {
      n = this.project(t, i);
    } catch (s) {
      this.destination.error(s);
      return;
    }
    this.hasSubscription = !0, this._innerSub(n);
  }, e.prototype._innerSub = function(t) {
    var n = new Rn(this), i = this.destination;
    i.add(n);
    var s = On(t, n);
    s !== n && i.add(s);
  }, e.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
  }, e.prototype.notifyNext = function(t) {
    this.destination.next(t);
  }, e.prototype.notifyError = function(t) {
    this.destination.error(t);
  }, e.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, e;
}(Tn);
function exe(r, e, t) {
  return e === void 0 && (e = Number.POSITIVE_INFINITY), e = (e || 0) < 1 ? Number.POSITIVE_INFINITY : e, function(n) {
    return n.lift(new txe(r, e, t));
  };
}
var txe = /* @__PURE__ */ function() {
  function r(e, t, n) {
    this.project = e, this.concurrent = t, this.scheduler = n;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new rxe(e, this.project, this.concurrent, this.scheduler));
  }, r;
}(), rxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s) {
    var o = r.call(this, t) || this;
    return o.project = n, o.concurrent = i, o.scheduler = s, o.index = 0, o.active = 0, o.hasCompleted = !1, i < Number.POSITIVE_INFINITY && (o.buffer = []), o;
  }
  return e.dispatch = function(t) {
    var n = t.subscriber, i = t.result, s = t.value, o = t.index;
    n.subscribeToProjection(i, s, o);
  }, e.prototype._next = function(t) {
    var n = this.destination;
    if (n.closed) {
      this._complete();
      return;
    }
    var i = this.index++;
    if (this.active < this.concurrent) {
      n.next(t);
      try {
        var s = this.project, o = s(t, i);
        if (!this.scheduler)
          this.subscribeToProjection(o, t, i);
        else {
          var a = { subscriber: this, result: o, value: t, index: i }, c = this.destination;
          c.add(this.scheduler.schedule(e.dispatch, 0, a));
        }
      } catch (u) {
        n.error(u);
      }
    } else
      this.buffer.push(t);
  }, e.prototype.subscribeToProjection = function(t, n, i) {
    this.active++;
    var s = this.destination;
    s.add(On(t, new Rn(this)));
  }, e.prototype._complete = function() {
    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();
  }, e.prototype.notifyNext = function(t) {
    this._next(t);
  }, e.prototype.notifyComplete = function() {
    var t = this.buffer;
    this.active--, t && t.length > 0 && this._next(t.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();
  }, e;
}(Tn);
function nxe(r) {
  return function(e) {
    return e.lift(new ixe(r));
  };
}
var ixe = /* @__PURE__ */ function() {
  function r(e) {
    this.callback = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new sxe(e, this.callback));
  }, r;
}(), sxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.add(new yn(n)), i;
  }
  return e;
}(yt);
function oxe(r, e) {
  if (typeof r != "function")
    throw new TypeError("predicate is not a function");
  return function(t) {
    return t.lift(new FU(r, t, !1, e));
  };
}
var FU = /* @__PURE__ */ function() {
  function r(e, t, n, i) {
    this.predicate = e, this.source = t, this.yieldIndex = n, this.thisArg = i;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new axe(e, this.predicate, this.source, this.yieldIndex, this.thisArg));
  }, r;
}(), axe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s, o) {
    var a = r.call(this, t) || this;
    return a.predicate = n, a.source = i, a.yieldIndex = s, a.thisArg = o, a.index = 0, a;
  }
  return e.prototype.notifyComplete = function(t) {
    var n = this.destination;
    n.next(t), n.complete(), this.unsubscribe();
  }, e.prototype._next = function(t) {
    var n = this, i = n.predicate, s = n.thisArg, o = this.index++;
    try {
      var a = i.call(s || this, t, o, this.source);
      a && this.notifyComplete(this.yieldIndex ? o : t);
    } catch (c) {
      this.destination.error(c);
    }
  }, e.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  }, e;
}(yt);
function cxe(r, e) {
  return function(t) {
    return t.lift(new FU(r, t, !0, e));
  };
}
function lxe(r, e) {
  var t = arguments.length >= 2;
  return function(n) {
    return n.pipe(r ? ah(function(i, s) {
      return r(i, s, n);
    }) : sh, YA(1), t ? Wy(e) : aE(function() {
      return new Uy();
    }));
  };
}
function uxe() {
  return function(e) {
    return e.lift(new hxe());
  };
}
var hxe = /* @__PURE__ */ function() {
  function r() {
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new fxe(e));
  }, r;
}(), fxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype._next = function(t) {
  }, e;
}(yt);
function dxe() {
  return function(r) {
    return r.lift(new pxe());
  };
}
var pxe = /* @__PURE__ */ function() {
  function r() {
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new gxe(e));
  }, r;
}(), gxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.notifyComplete = function(t) {
    var n = this.destination;
    n.next(t), n.complete();
  }, e.prototype._next = function(t) {
    this.notifyComplete(!1);
  }, e.prototype._complete = function() {
    this.notifyComplete(!0);
  }, e;
}(yt);
function o_(r) {
  return function(t) {
    return r === 0 ? r1() : t.lift(new mxe(r));
  };
}
var mxe = /* @__PURE__ */ function() {
  function r(e) {
    if (this.total = e, this.total < 0)
      throw new Pg();
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new wxe(e, this.total));
  }, r;
}(), wxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.total = n, i.ring = new Array(), i.count = 0, i;
  }
  return e.prototype._next = function(t) {
    var n = this.ring, i = this.total, s = this.count++;
    if (n.length < i)
      n.push(t);
    else {
      var o = s % i;
      n[o] = t;
    }
  }, e.prototype._complete = function() {
    var t = this.destination, n = this.count;
    if (n > 0)
      for (var i = this.count >= this.total ? this.total : this.count, s = this.ring, o = 0; o < i; o++) {
        var a = n++ % i;
        t.next(s[a]);
      }
    t.complete();
  }, e;
}(yt);
function yxe(r, e) {
  var t = arguments.length >= 2;
  return function(n) {
    return n.pipe(r ? ah(function(i, s) {
      return r(i, s, n);
    }) : sh, o_(1), t ? Wy(e) : aE(function() {
      return new Uy();
    }));
  };
}
function vxe(r) {
  return function(e) {
    return e.lift(new bxe(r));
  };
}
var bxe = /* @__PURE__ */ function() {
  function r(e) {
    this.value = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new _xe(e, this.value));
  }, r;
}(), _xe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.value = n, i;
  }
  return e.prototype._next = function(t) {
    this.destination.next(this.value);
  }, e;
}(yt);
function Exe() {
  return function(e) {
    return e.lift(new xxe());
  };
}
var xxe = /* @__PURE__ */ function() {
  function r() {
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Sxe(e));
  }, r;
}(), Sxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype._next = function(t) {
    this.destination.next(Nl.createNext(t));
  }, e.prototype._error = function(t) {
    var n = this.destination;
    n.next(Nl.createError(t)), n.complete();
  }, e.prototype._complete = function() {
    var t = this.destination;
    t.next(Nl.createComplete()), t.complete();
  }, e;
}(yt);
function a_(r, e) {
  var t = !1;
  return arguments.length >= 2 && (t = !0), function(i) {
    return i.lift(new Cxe(r, e, t));
  };
}
var Cxe = /* @__PURE__ */ function() {
  function r(e, t, n) {
    n === void 0 && (n = !1), this.accumulator = e, this.seed = t, this.hasSeed = n;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Axe(e, this.accumulator, this.seed, this.hasSeed));
  }, r;
}(), Axe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s) {
    var o = r.call(this, t) || this;
    return o.accumulator = n, o._seed = i, o.hasSeed = s, o.index = 0, o;
  }
  return Object.defineProperty(e.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(t) {
      this.hasSeed = !0, this._seed = t;
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype._next = function(t) {
    if (!this.hasSeed)
      this.seed = t, this.destination.next(t);
    else
      return this._tryNext(t);
  }, e.prototype._tryNext = function(t) {
    var n = this.index++, i;
    try {
      i = this.accumulator(this.seed, t, n);
    } catch (s) {
      this.destination.error(s);
    }
    this.seed = i, this.destination.next(i);
  }, e;
}(yt);
function cE(r, e) {
  return arguments.length >= 2 ? function(n) {
    return pS(a_(r, e), o_(1), Wy(e))(n);
  } : function(n) {
    return pS(a_(function(i, s, o) {
      return r(i, s, o + 1);
    }), o_(1))(n);
  };
}
function Ixe(r) {
  var e = typeof r == "function" ? function(t, n) {
    return r(t, n) > 0 ? t : n;
  } : function(t, n) {
    return t > n ? t : n;
  };
  return cE(e);
}
function Rxe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return function(t) {
    return t.lift.call(lU.apply(void 0, [t].concat(r)));
  };
}
function Txe(r, e, t) {
  return t === void 0 && (t = Number.POSITIVE_INFINITY), typeof e == "function" ? bd(function() {
    return r;
  }, e, t) : (typeof e == "number" && (t = e), bd(function() {
    return r;
  }, t));
}
function Oxe(r, e, t) {
  return t === void 0 && (t = Number.POSITIVE_INFINITY), function(n) {
    return n.lift(new Nxe(r, e, t));
  };
}
var Nxe = /* @__PURE__ */ function() {
  function r(e, t, n) {
    this.accumulator = e, this.seed = t, this.concurrent = n;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Pxe(e, this.accumulator, this.seed, this.concurrent));
  }, r;
}(), Pxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s) {
    var o = r.call(this, t) || this;
    return o.accumulator = n, o.acc = i, o.concurrent = s, o.hasValue = !1, o.hasCompleted = !1, o.buffer = [], o.active = 0, o.index = 0, o;
  }
  return e.prototype._next = function(t) {
    if (this.active < this.concurrent) {
      var n = this.index++, i = this.destination, s = void 0;
      try {
        var o = this.accumulator;
        s = o(this.acc, t, n);
      } catch (a) {
        return i.error(a);
      }
      this.active++, this._innerSub(s);
    } else
      this.buffer.push(t);
  }, e.prototype._innerSub = function(t) {
    var n = new Rn(this), i = this.destination;
    i.add(n);
    var s = On(t, n);
    s !== n && i.add(s);
  }, e.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();
  }, e.prototype.notifyNext = function(t) {
    var n = this.destination;
    this.acc = t, this.hasValue = !0, n.next(t);
  }, e.prototype.notifyComplete = function() {
    var t = this.buffer;
    this.active--, t.length > 0 ? this._next(t.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());
  }, e;
}(Tn);
function Mxe(r) {
  var e = typeof r == "function" ? function(t, n) {
    return r(t, n) < 0 ? t : n;
  } : function(t, n) {
    return t < n ? t : n;
  };
  return cE(e);
}
function _d(r, e) {
  return function(n) {
    var i;
    if (typeof r == "function" ? i = r : i = function() {
      return r;
    }, typeof e == "function")
      return n.lift(new Dxe(i, e));
    var s = Object.create(n, hEe);
    return s.source = n, s.subjectFactory = i, s;
  };
}
var Dxe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.subjectFactory = e, this.selector = t;
  }
  return r.prototype.call = function(e, t) {
    var n = this.selector, i = this.subjectFactory(), s = n(i).subscribe(e);
    return s.add(t.subscribe(i)), s;
  }, r;
}();
function kxe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return r.length === 1 && hs(r[0]) && (r = r[0]), function(t) {
    return t.lift(new $xe(r));
  };
}
var $xe = /* @__PURE__ */ function() {
  function r(e) {
    this.nextSources = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Lxe(e, this.nextSources));
  }, r;
}(), Lxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.destination = t, i.nextSources = n, i;
  }
  return e.prototype.notifyError = function() {
    this.subscribeToNextSource();
  }, e.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  }, e.prototype._error = function(t) {
    this.subscribeToNextSource(), this.unsubscribe();
  }, e.prototype._complete = function() {
    this.subscribeToNextSource(), this.unsubscribe();
  }, e.prototype.subscribeToNextSource = function() {
    var t = this.nextSources.shift();
    if (t) {
      var n = new Rn(this), i = this.destination;
      i.add(n);
      var s = On(t, n);
      s !== n && i.add(s);
    } else
      this.destination.complete();
  }, e;
}(Tn);
function Bxe() {
  return function(r) {
    return r.lift(new Fxe());
  };
}
var Fxe = /* @__PURE__ */ function() {
  function r() {
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Uxe(e));
  }, r;
}(), Uxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this, t) || this;
    return n.hasPrev = !1, n;
  }
  return e.prototype._next = function(t) {
    var n;
    this.hasPrev ? n = [this.prev, t] : this.hasPrev = !0, this.prev = t, n && this.destination.next(n);
  }, e;
}(yt);
function jxe(r, e) {
  return function(t) {
    return [
      ah(r, e)(t),
      ah(hU(r, e))(t)
    ];
  };
}
function Wxe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = r.length;
  if (t === 0)
    throw new Error("list of properties cannot be empty.");
  return function(n) {
    return Vo(Hxe(r, t))(n);
  };
}
function Hxe(r, e) {
  var t = function(n) {
    for (var i = n, s = 0; s < e; s++) {
      var o = i != null ? i[r[s]] : void 0;
      if (o !== void 0)
        i = o;
      else
        return;
    }
    return i;
  };
  return t;
}
function zxe(r) {
  return r ? _d(function() {
    return new ui();
  }, r) : _d(new ui());
}
function Vxe(r) {
  return function(e) {
    return _d(new zF(r))(e);
  };
}
function qxe() {
  return function(r) {
    return _d(new n1())(r);
  };
}
function Gxe(r, e, t, n) {
  t && typeof t != "function" && (n = t);
  var i = typeof t == "function" ? t : void 0, s = new $A(r, e, n);
  return function(o) {
    return _d(function() {
      return s;
    }, i)(o);
  };
}
function Kxe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return function(n) {
    return r.length === 1 && hs(r[0]) && (r = r[0]), n.lift.call(fU.apply(void 0, [n].concat(r)));
  };
}
function Zxe(r) {
  return r === void 0 && (r = -1), function(e) {
    return r === 0 ? r1() : r < 0 ? e.lift(new _P(-1, e)) : e.lift(new _P(r - 1, e));
  };
}
var _P = /* @__PURE__ */ function() {
  function r(e, t) {
    this.count = e, this.source = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Jxe(e, this.count, this.source));
  }, r;
}(), Jxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.count = n, s.source = i, s;
  }
  return e.prototype.complete = function() {
    if (!this.isStopped) {
      var t = this, n = t.source, i = t.count;
      if (i === 0)
        return r.prototype.complete.call(this);
      i > -1 && (this.count = i - 1), n.subscribe(this._unsubscribeAndRecycle());
    }
  }, e;
}(yt);
function Qxe(r) {
  return function(e) {
    return e.lift(new Yxe(r));
  };
}
var Yxe = /* @__PURE__ */ function() {
  function r(e) {
    this.notifier = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new Xxe(e, this.notifier, t));
  }, r;
}(), Xxe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.notifier = n, s.source = i, s.sourceIsBeingSubscribedTo = !0, s;
  }
  return e.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);
  }, e.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === !1)
      return r.prototype.complete.call(this);
  }, e.prototype.complete = function() {
    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)
        return r.prototype.complete.call(this);
      this._unsubscribeAndRecycle(), this.notifications.next(void 0);
    }
  }, e.prototype._unsubscribe = function() {
    var t = this, n = t.notifications, i = t.retriesSubscription;
    n && (n.unsubscribe(), this.notifications = void 0), i && (i.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, e.prototype._unsubscribeAndRecycle = function() {
    var t = this._unsubscribe;
    return this._unsubscribe = null, r.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = t, this;
  }, e.prototype.subscribeToRetries = function() {
    this.notifications = new ui();
    var t;
    try {
      var n = this.notifier;
      t = n(this.notifications);
    } catch {
      return r.prototype.complete.call(this);
    }
    this.retries = t, this.retriesSubscription = On(t, new Rn(this));
  }, e;
}(Tn);
function eSe(r) {
  return r === void 0 && (r = -1), function(e) {
    return e.lift(new tSe(r, e));
  };
}
var tSe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.count = e, this.source = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new rSe(e, this.count, this.source));
  }, r;
}(), rSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.count = n, s.source = i, s;
  }
  return e.prototype.error = function(t) {
    if (!this.isStopped) {
      var n = this, i = n.source, s = n.count;
      if (s === 0)
        return r.prototype.error.call(this, t);
      s > -1 && (this.count = s - 1), i.subscribe(this._unsubscribeAndRecycle());
    }
  }, e;
}(yt);
function nSe(r) {
  return function(e) {
    return e.lift(new iSe(r, e));
  };
}
var iSe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.notifier = e, this.source = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new sSe(e, this.notifier, this.source));
  }, r;
}(), sSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.notifier = n, s.source = i, s;
  }
  return e.prototype.error = function(t) {
    if (!this.isStopped) {
      var n = this.errors, i = this.retries, s = this.retriesSubscription;
      if (i)
        this.errors = void 0, this.retriesSubscription = void 0;
      else {
        n = new ui();
        try {
          var o = this.notifier;
          i = o(n);
        } catch (a) {
          return r.prototype.error.call(this, a);
        }
        s = On(i, new Rn(this));
      }
      this._unsubscribeAndRecycle(), this.errors = n, this.retries = i, this.retriesSubscription = s, n.next(t);
    }
  }, e.prototype._unsubscribe = function() {
    var t = this, n = t.errors, i = t.retriesSubscription;
    n && (n.unsubscribe(), this.errors = void 0), i && (i.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, e.prototype.notifyNext = function() {
    var t = this._unsubscribe;
    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = t, this.source.subscribe(this);
  }, e;
}(Tn);
function oSe(r) {
  return function(e) {
    return e.lift(new aSe(r));
  };
}
var aSe = /* @__PURE__ */ function() {
  function r(e) {
    this.notifier = e;
  }
  return r.prototype.call = function(e, t) {
    var n = new cSe(e), i = t.subscribe(n);
    return i.add(On(this.notifier, new Rn(n))), i;
  }, r;
}(), cSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.hasValue = !1, t;
  }
  return e.prototype._next = function(t) {
    this.value = t, this.hasValue = !0;
  }, e.prototype.notifyNext = function() {
    this.emitValue();
  }, e.prototype.notifyComplete = function() {
    this.emitValue();
  }, e.prototype.emitValue = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
  }, e;
}(Tn);
function lSe(r, e) {
  return e === void 0 && (e = fs), function(t) {
    return t.lift(new uSe(r, e));
  };
}
var uSe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.period = e, this.scheduler = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new hSe(e, this.period, this.scheduler));
  }, r;
}(), hSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.period = n, s.scheduler = i, s.hasValue = !1, s.add(i.schedule(fSe, n, { subscriber: s, period: n })), s;
  }
  return e.prototype._next = function(t) {
    this.lastValue = t, this.hasValue = !0;
  }, e.prototype.notifyNext = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
  }, e;
}(yt);
function fSe(r) {
  var e = r.subscriber, t = r.period;
  e.notifyNext(), this.schedule(r, t);
}
function dSe(r, e) {
  return function(t) {
    return t.lift(new pSe(r, e));
  };
}
var pSe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.compareTo = e, this.comparator = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new gSe(e, this.compareTo, this.comparator));
  }, r;
}(), gSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.compareTo = n, s.comparator = i, s._a = [], s._b = [], s._oneComplete = !1, s.destination.add(n.subscribe(new mSe(t, s))), s;
  }
  return e.prototype._next = function(t) {
    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(t), this.checkValues());
  }, e.prototype._complete = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();
  }, e.prototype.checkValues = function() {
    for (var t = this, n = t._a, i = t._b, s = t.comparator; n.length > 0 && i.length > 0; ) {
      var o = n.shift(), a = i.shift(), c = !1;
      try {
        c = s ? s(o, a) : o === a;
      } catch (u) {
        this.destination.error(u);
      }
      c || this.emit(!1);
    }
  }, e.prototype.emit = function(t) {
    var n = this.destination;
    n.next(t), n.complete();
  }, e.prototype.nextB = function(t) {
    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(t), this.checkValues());
  }, e.prototype.completeB = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;
  }, e;
}(yt), mSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.parent = n, i;
  }
  return e.prototype._next = function(t) {
    this.parent.nextB(t);
  }, e.prototype._error = function(t) {
    this.parent.error(t), this.unsubscribe();
  }, e.prototype._complete = function() {
    this.parent.completeB(), this.unsubscribe();
  }, e;
}(yt);
function wSe() {
  return new ui();
}
function ySe() {
  return function(r) {
    return MA()(_d(wSe)(r));
  };
}
function vSe(r, e, t) {
  var n;
  return r && typeof r == "object" ? n = r : n = {
    bufferSize: r,
    windowTime: e,
    refCount: !1,
    scheduler: t
  }, function(i) {
    return i.lift(bSe(n));
  };
}
function bSe(r) {
  var e = r.bufferSize, t = e === void 0 ? Number.POSITIVE_INFINITY : e, n = r.windowTime, i = n === void 0 ? Number.POSITIVE_INFINITY : n, s = r.refCount, o = r.scheduler, a, c = 0, u, f = !1, d = !1;
  return function(y) {
    c++;
    var b;
    !a || f ? (f = !1, a = new $A(t, i, o), b = a.subscribe(this), u = y.subscribe({
      next: function(I) {
        a.next(I);
      },
      error: function(I) {
        f = !0, a.error(I);
      },
      complete: function() {
        d = !0, u = void 0, a.complete();
      }
    }), d && (u = void 0)) : b = a.subscribe(this), this.add(function() {
      c--, b.unsubscribe(), b = void 0, u && !d && s && c === 0 && (u.unsubscribe(), u = void 0, a = void 0);
    });
  };
}
function _Se(r) {
  return function(e) {
    return e.lift(new ESe(r, e));
  };
}
var ESe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.predicate = e, this.source = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new xSe(e, this.predicate, this.source));
  }, r;
}(), xSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.predicate = n, s.source = i, s.seenValue = !1, s.index = 0, s;
  }
  return e.prototype.applySingleValue = function(t) {
    this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = t);
  }, e.prototype._next = function(t) {
    var n = this.index++;
    this.predicate ? this.tryNext(t, n) : this.applySingleValue(t);
  }, e.prototype.tryNext = function(t, n) {
    try {
      this.predicate(t, n, this.source) && this.applySingleValue(t);
    } catch (i) {
      this.destination.error(i);
    }
  }, e.prototype._complete = function() {
    var t = this.destination;
    this.index > 0 ? (t.next(this.seenValue ? this.singleValue : void 0), t.complete()) : t.error(new Uy());
  }, e;
}(yt);
function SSe(r) {
  return function(e) {
    return e.lift(new CSe(r));
  };
}
var CSe = /* @__PURE__ */ function() {
  function r(e) {
    this.total = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new ASe(e, this.total));
  }, r;
}(), ASe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.total = n, i.count = 0, i;
  }
  return e.prototype._next = function(t) {
    ++this.count > this.total && this.destination.next(t);
  }, e;
}(yt);
function ISe(r) {
  return function(e) {
    return e.lift(new RSe(r));
  };
}
var RSe = /* @__PURE__ */ function() {
  function r(e) {
    if (this._skipCount = e, this._skipCount < 0)
      throw new Pg();
  }
  return r.prototype.call = function(e, t) {
    return this._skipCount === 0 ? t.subscribe(new yt(e)) : t.subscribe(new TSe(e, this._skipCount));
  }, r;
}(), TSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i._skipCount = n, i._count = 0, i._ring = new Array(n), i;
  }
  return e.prototype._next = function(t) {
    var n = this._skipCount, i = this._count++;
    if (i < n)
      this._ring[i] = t;
    else {
      var s = i % n, o = this._ring, a = o[s];
      o[s] = t, this.destination.next(a);
    }
  }, e;
}(yt);
function OSe(r) {
  return function(e) {
    return e.lift(new NSe(r));
  };
}
var NSe = /* @__PURE__ */ function() {
  function r(e) {
    this.notifier = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new PSe(e, this.notifier));
  }, r;
}(), PSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    i.hasValue = !1;
    var s = new Rn(i);
    i.add(s), i.innerSubscription = s;
    var o = On(n, s);
    return o !== s && (i.add(o), i.innerSubscription = o), i;
  }
  return e.prototype._next = function(t) {
    this.hasValue && r.prototype._next.call(this, t);
  }, e.prototype.notifyNext = function() {
    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
  }, e.prototype.notifyComplete = function() {
  }, e;
}(Tn);
function MSe(r) {
  return function(e) {
    return e.lift(new DSe(r));
  };
}
var DSe = /* @__PURE__ */ function() {
  function r(e) {
    this.predicate = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new kSe(e, this.predicate));
  }, r;
}(), kSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.predicate = n, i.skipping = !0, i.index = 0, i;
  }
  return e.prototype._next = function(t) {
    var n = this.destination;
    this.skipping && this.tryCallPredicate(t), this.skipping || n.next(t);
  }, e.prototype.tryCallPredicate = function(t) {
    try {
      var n = this.predicate(t, this.index++);
      this.skipping = !!n;
    } catch (i) {
      this.destination.error(i);
    }
  }, e;
}(yt);
function $Se() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = r[r.length - 1];
  return no(t) ? (r.pop(), function(n) {
    return Ew(r, n, t);
  }) : function(n) {
    return Ew(r, n);
  };
}
var LSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    n === void 0 && (n = 0), i === void 0 && (i = Gb);
    var s = r.call(this) || this;
    return s.source = t, s.delayTime = n, s.scheduler = i, (!Mg(n) || n < 0) && (s.delayTime = 0), (!i || typeof i.schedule != "function") && (s.scheduler = Gb), s;
  }
  return e.create = function(t, n, i) {
    return n === void 0 && (n = 0), i === void 0 && (i = Gb), new e(t, n, i);
  }, e.dispatch = function(t) {
    var n = t.source, i = t.subscriber;
    return this.add(n.subscribe(i));
  }, e.prototype._subscribe = function(t) {
    var n = this.delayTime, i = this.source, s = this.scheduler;
    return s.schedule(e.dispatch, n, {
      source: i,
      subscriber: t
    });
  }, e;
}(ir);
function BSe(r, e) {
  return e === void 0 && (e = 0), function(n) {
    return n.lift(new FSe(r, e));
  };
}
var FSe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.scheduler = e, this.delay = t;
  }
  return r.prototype.call = function(e, t) {
    return new LSe(t, this.delay, this.scheduler).subscribe(e);
  }, r;
}();
function xw(r, e) {
  return typeof e == "function" ? function(t) {
    return t.pipe(xw(function(n, i) {
      return Vl(r(n, i)).pipe(Vo(function(s, o) {
        return e(n, s, i, o);
      }));
    }));
  } : function(t) {
    return t.lift(new USe(r));
  };
}
var USe = /* @__PURE__ */ function() {
  function r(e) {
    this.project = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new jSe(e, this.project));
  }, r;
}(), jSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.project = n, i.index = 0, i;
  }
  return e.prototype._next = function(t) {
    var n, i = this.index++;
    try {
      n = this.project(t, i);
    } catch (s) {
      this.destination.error(s);
      return;
    }
    this._innerSub(n);
  }, e.prototype._innerSub = function(t) {
    var n = this.innerSubscription;
    n && n.unsubscribe();
    var i = new Rn(this), s = this.destination;
    s.add(i), this.innerSubscription = On(t, i), this.innerSubscription !== i && s.add(this.innerSubscription);
  }, e.prototype._complete = function() {
    var t = this.innerSubscription;
    (!t || t.closed) && r.prototype._complete.call(this), this.unsubscribe();
  }, e.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  }, e.prototype.notifyComplete = function() {
    this.innerSubscription = void 0, this.isStopped && r.prototype._complete.call(this);
  }, e.prototype.notifyNext = function(t) {
    this.destination.next(t);
  }, e;
}(Tn);
function WSe() {
  return xw(sh);
}
function HSe(r, e) {
  return e ? xw(function() {
    return r;
  }, e) : xw(function() {
    return r;
  });
}
function zSe(r) {
  return function(e) {
    return e.lift(new VSe(r));
  };
}
var VSe = /* @__PURE__ */ function() {
  function r(e) {
    this.notifier = e;
  }
  return r.prototype.call = function(e, t) {
    var n = new qSe(e), i = On(this.notifier, new Rn(n));
    return i && !n.seenValue ? (n.add(i), t.subscribe(n)) : n;
  }, r;
}(), qSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this, t) || this;
    return n.seenValue = !1, n;
  }
  return e.prototype.notifyNext = function() {
    this.seenValue = !0, this.complete();
  }, e.prototype.notifyComplete = function() {
  }, e;
}(Tn);
function GSe(r, e) {
  return e === void 0 && (e = !1), function(t) {
    return t.lift(new KSe(r, e));
  };
}
var KSe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.predicate = e, this.inclusive = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new ZSe(e, this.predicate, this.inclusive));
  }, r;
}(), ZSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.predicate = n, s.inclusive = i, s.index = 0, s;
  }
  return e.prototype._next = function(t) {
    var n = this.destination, i;
    try {
      i = this.predicate(t, this.index++);
    } catch (s) {
      n.error(s);
      return;
    }
    this.nextOrComplete(t, i);
  }, e.prototype.nextOrComplete = function(t, n) {
    var i = this.destination;
    n ? i.next(t) : (this.inclusive && i.next(t), i.complete());
  }, e;
}(yt);
function JSe(r, e, t) {
  return function(i) {
    return i.lift(new QSe(r, e, t));
  };
}
var QSe = /* @__PURE__ */ function() {
  function r(e, t, n) {
    this.nextOrObserver = e, this.error = t, this.complete = n;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new YSe(e, this.nextOrObserver, this.error, this.complete));
  }, r;
}(), YSe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s) {
    var o = r.call(this, t) || this;
    return o._tapNext = oc, o._tapError = oc, o._tapComplete = oc, o._tapError = i || oc, o._tapComplete = s || oc, Og(n) ? (o._context = o, o._tapNext = n) : n && (o._context = n, o._tapNext = n.next || oc, o._tapError = n.error || oc, o._tapComplete = n.complete || oc), o;
  }
  return e.prototype._next = function(t) {
    try {
      this._tapNext.call(this._context, t);
    } catch (n) {
      this.destination.error(n);
      return;
    }
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this._tapError.call(this._context, t);
    } catch (n) {
      this.destination.error(n);
      return;
    }
    this.destination.error(t);
  }, e.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (t) {
      this.destination.error(t);
      return;
    }
    return this.destination.complete();
  }, e;
}(yt), UU = {
  leading: !0,
  trailing: !1
};
function XSe(r, e) {
  return e === void 0 && (e = UU), function(t) {
    return t.lift(new eCe(r, !!e.leading, !!e.trailing));
  };
}
var eCe = /* @__PURE__ */ function() {
  function r(e, t, n) {
    this.durationSelector = e, this.leading = t, this.trailing = n;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new tCe(e, this.durationSelector, this.leading, this.trailing));
  }, r;
}(), tCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s) {
    var o = r.call(this, t) || this;
    return o.destination = t, o.durationSelector = n, o._leading = i, o._trailing = s, o._hasValue = !1, o;
  }
  return e.prototype._next = function(t) {
    this._hasValue = !0, this._sendValue = t, this._throttled || (this._leading ? this.send() : this.throttle(t));
  }, e.prototype.send = function() {
    var t = this, n = t._hasValue, i = t._sendValue;
    n && (this.destination.next(i), this.throttle(i)), this._hasValue = !1, this._sendValue = void 0;
  }, e.prototype.throttle = function(t) {
    var n = this.tryDurationSelector(t);
    n && this.add(this._throttled = On(n, new Rn(this)));
  }, e.prototype.tryDurationSelector = function(t) {
    try {
      return this.durationSelector(t);
    } catch (n) {
      return this.destination.error(n), null;
    }
  }, e.prototype.throttlingDone = function() {
    var t = this, n = t._throttled, i = t._trailing;
    n && n.unsubscribe(), this._throttled = void 0, i && this.send();
  }, e.prototype.notifyNext = function() {
    this.throttlingDone();
  }, e.prototype.notifyComplete = function() {
    this.throttlingDone();
  }, e;
}(Tn);
function rCe(r, e, t) {
  return e === void 0 && (e = fs), t === void 0 && (t = UU), function(n) {
    return n.lift(new nCe(r, e, t.leading, t.trailing));
  };
}
var nCe = /* @__PURE__ */ function() {
  function r(e, t, n, i) {
    this.duration = e, this.scheduler = t, this.leading = n, this.trailing = i;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new iCe(e, this.duration, this.scheduler, this.leading, this.trailing));
  }, r;
}(), iCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s, o) {
    var a = r.call(this, t) || this;
    return a.duration = n, a.scheduler = i, a.leading = s, a.trailing = o, a._hasTrailingValue = !1, a._trailingValue = null, a;
  }
  return e.prototype._next = function(t) {
    this.throttled ? this.trailing && (this._trailingValue = t, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(sCe, this.duration, { subscriber: this })), this.leading ? this.destination.next(t) : this.trailing && (this._trailingValue = t, this._hasTrailingValue = !0));
  }, e.prototype._complete = function() {
    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
  }, e.prototype.clearThrottle = function() {
    var t = this.throttled;
    t && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), t.unsubscribe(), this.remove(t), this.throttled = null);
  }, e;
}(yt);
function sCe(r) {
  var e = r.subscriber;
  e.clearThrottle();
}
function oCe(r) {
  return r === void 0 && (r = fs), function(e) {
    return FA(function() {
      return e.pipe(a_(function(t, n) {
        var i = t.current;
        return { value: n, current: r.now(), last: i };
      }, { current: r.now(), value: void 0, last: void 0 }), Vo(function(t) {
        var n = t.current, i = t.last, s = t.value;
        return new aCe(s, n - i);
      }));
    });
  };
}
var aCe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.value = e, this.interval = t;
  }
  return r;
}();
function jU(r, e, t) {
  return t === void 0 && (t = fs), function(n) {
    var i = $U(r), s = i ? +r - t.now() : Math.abs(r);
    return n.lift(new cCe(s, i, e, t));
  };
}
var cCe = /* @__PURE__ */ function() {
  function r(e, t, n, i) {
    this.waitFor = e, this.absoluteTimeout = t, this.withObservable = n, this.scheduler = i;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new lCe(e, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  }, r;
}(), lCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s, o) {
    var a = r.call(this, t) || this;
    return a.absoluteTimeout = n, a.waitFor = i, a.withObservable = s, a.scheduler = o, a.scheduleTimeout(), a;
  }
  return e.dispatchTimeout = function(t) {
    var n = t.withObservable;
    t._unsubscribeAndRecycle(), t.add(On(n, new Rn(t)));
  }, e.prototype.scheduleTimeout = function() {
    var t = this.action;
    t ? this.action = t.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(e.dispatchTimeout, this.waitFor, this));
  }, e.prototype._next = function(t) {
    this.absoluteTimeout || this.scheduleTimeout(), r.prototype._next.call(this, t);
  }, e.prototype._unsubscribe = function() {
    this.action = void 0, this.scheduler = null, this.withObservable = null;
  }, e;
}(Tn);
function uCe(r, e) {
  return e === void 0 && (e = fs), jU(r, kA(new XF()), e);
}
function hCe(r) {
  return r === void 0 && (r = fs), Vo(function(e) {
    return new fCe(e, r.now());
  });
}
var fCe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.value = e, this.timestamp = t;
  }
  return r;
}();
function dCe(r, e, t) {
  return t === 0 ? [e] : (r.push(e), r);
}
function pCe() {
  return cE(dCe, []);
}
function gCe(r) {
  return function(t) {
    return t.lift(new mCe(r));
  };
}
var mCe = /* @__PURE__ */ function() {
  function r(e) {
    this.windowBoundaries = e;
  }
  return r.prototype.call = function(e, t) {
    var n = new wCe(e), i = t.subscribe(n);
    return i.closed || n.add(On(this.windowBoundaries, new Rn(n))), i;
  }, r;
}(), wCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t) {
    var n = r.call(this, t) || this;
    return n.window = new ui(), t.next(n.window), n;
  }
  return e.prototype.notifyNext = function() {
    this.openWindow();
  }, e.prototype.notifyError = function(t) {
    this._error(t);
  }, e.prototype.notifyComplete = function() {
    this._complete();
  }, e.prototype._next = function(t) {
    this.window.next(t);
  }, e.prototype._error = function(t) {
    this.window.error(t), this.destination.error(t);
  }, e.prototype._complete = function() {
    this.window.complete(), this.destination.complete();
  }, e.prototype._unsubscribe = function() {
    this.window = null;
  }, e.prototype.openWindow = function() {
    var t = this.window;
    t && t.complete();
    var n = this.destination, i = this.window = new ui();
    n.next(i);
  }, e;
}(Tn);
function yCe(r, e) {
  return e === void 0 && (e = 0), function(n) {
    return n.lift(new vCe(r, e));
  };
}
var vCe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.windowSize = e, this.startWindowEvery = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new bCe(e, this.windowSize, this.startWindowEvery));
  }, r;
}(), bCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.destination = t, s.windowSize = n, s.startWindowEvery = i, s.windows = [new ui()], s.count = 0, t.next(s.windows[0]), s;
  }
  return e.prototype._next = function(t) {
    for (var n = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, i = this.destination, s = this.windowSize, o = this.windows, a = o.length, c = 0; c < a && !this.closed; c++)
      o[c].next(t);
    var u = this.count - s + 1;
    if (u >= 0 && u % n === 0 && !this.closed && o.shift().complete(), ++this.count % n === 0 && !this.closed) {
      var f = new ui();
      o.push(f), i.next(f);
    }
  }, e.prototype._error = function(t) {
    var n = this.windows;
    if (n)
      for (; n.length > 0 && !this.closed; )
        n.shift().error(t);
    this.destination.error(t);
  }, e.prototype._complete = function() {
    var t = this.windows;
    if (t)
      for (; t.length > 0 && !this.closed; )
        t.shift().complete();
    this.destination.complete();
  }, e.prototype._unsubscribe = function() {
    this.count = 0, this.windows = null;
  }, e;
}(yt);
function _Ce(r) {
  var e = fs, t = null, n = Number.POSITIVE_INFINITY;
  return no(arguments[3]) && (e = arguments[3]), no(arguments[2]) ? e = arguments[2] : Mg(arguments[2]) && (n = Number(arguments[2])), no(arguments[1]) ? e = arguments[1] : Mg(arguments[1]) && (t = Number(arguments[1])), function(s) {
    return s.lift(new ECe(r, t, n, e));
  };
}
var ECe = /* @__PURE__ */ function() {
  function r(e, t, n, i) {
    this.windowTimeSpan = e, this.windowCreationInterval = t, this.maxWindowSize = n, this.scheduler = i;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new SCe(e, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  }, r;
}(), xCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t._numberOfNextedValues = 0, t;
  }
  return e.prototype.next = function(t) {
    this._numberOfNextedValues++, r.prototype.next.call(this, t);
  }, Object.defineProperty(e.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: !0,
    configurable: !0
  }), e;
}(ui), SCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i, s, o) {
    var a = r.call(this, t) || this;
    a.destination = t, a.windowTimeSpan = n, a.windowCreationInterval = i, a.maxWindowSize = s, a.scheduler = o, a.windows = [];
    var c = a.openWindow();
    if (i !== null && i >= 0) {
      var u = { subscriber: a, window: c, context: null }, f = { windowTimeSpan: n, windowCreationInterval: i, subscriber: a, scheduler: o };
      a.add(o.schedule(WU, n, u)), a.add(o.schedule(ACe, i, f));
    } else {
      var d = { subscriber: a, window: c, windowTimeSpan: n };
      a.add(o.schedule(CCe, n, d));
    }
    return a;
  }
  return e.prototype._next = function(t) {
    for (var n = this.windows, i = n.length, s = 0; s < i; s++) {
      var o = n[s];
      o.closed || (o.next(t), o.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(o));
    }
  }, e.prototype._error = function(t) {
    for (var n = this.windows; n.length > 0; )
      n.shift().error(t);
    this.destination.error(t);
  }, e.prototype._complete = function() {
    for (var t = this.windows; t.length > 0; ) {
      var n = t.shift();
      n.closed || n.complete();
    }
    this.destination.complete();
  }, e.prototype.openWindow = function() {
    var t = new xCe();
    this.windows.push(t);
    var n = this.destination;
    return n.next(t), t;
  }, e.prototype.closeWindow = function(t) {
    t.complete();
    var n = this.windows;
    n.splice(n.indexOf(t), 1);
  }, e;
}(yt);
function CCe(r) {
  var e = r.subscriber, t = r.windowTimeSpan, n = r.window;
  n && e.closeWindow(n), r.window = e.openWindow(), this.schedule(r, t);
}
function ACe(r) {
  var e = r.windowTimeSpan, t = r.subscriber, n = r.scheduler, i = r.windowCreationInterval, s = t.openWindow(), o = this, a = { action: o, subscription: null }, c = { subscriber: t, window: s, context: a };
  a.subscription = n.schedule(WU, e, c), o.add(a.subscription), o.schedule(r, i);
}
function WU(r) {
  var e = r.subscriber, t = r.window, n = r.context;
  n && n.action && n.subscription && n.action.remove(n.subscription), e.closeWindow(t);
}
function ICe(r, e) {
  return function(t) {
    return t.lift(new RCe(r, e));
  };
}
var RCe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.openings = e, this.closingSelector = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new TCe(e, this.openings, this.closingSelector));
  }, r;
}(), TCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    return s.openings = n, s.closingSelector = i, s.contexts = [], s.add(s.openSubscription = Ll(s, n, n)), s;
  }
  return e.prototype._next = function(t) {
    var n = this.contexts;
    if (n)
      for (var i = n.length, s = 0; s < i; s++)
        n[s].window.next(t);
  }, e.prototype._error = function(t) {
    var n = this.contexts;
    if (this.contexts = null, n)
      for (var i = n.length, s = -1; ++s < i; ) {
        var o = n[s];
        o.window.error(t), o.subscription.unsubscribe();
      }
    r.prototype._error.call(this, t);
  }, e.prototype._complete = function() {
    var t = this.contexts;
    if (this.contexts = null, t)
      for (var n = t.length, i = -1; ++i < n; ) {
        var s = t[i];
        s.window.complete(), s.subscription.unsubscribe();
      }
    r.prototype._complete.call(this);
  }, e.prototype._unsubscribe = function() {
    var t = this.contexts;
    if (this.contexts = null, t)
      for (var n = t.length, i = -1; ++i < n; ) {
        var s = t[i];
        s.window.unsubscribe(), s.subscription.unsubscribe();
      }
  }, e.prototype.notifyNext = function(t, n, i, s, o) {
    if (t === this.openings) {
      var a = void 0;
      try {
        var c = this.closingSelector;
        a = c(n);
      } catch (y) {
        return this.error(y);
      }
      var u = new ui(), f = new yn(), d = { window: u, subscription: f };
      this.contexts.push(d);
      var m = Ll(this, a, d);
      m.closed ? this.closeWindow(this.contexts.length - 1) : (m.context = d, f.add(m)), this.destination.next(u);
    } else
      this.closeWindow(this.contexts.indexOf(t));
  }, e.prototype.notifyError = function(t) {
    this.error(t);
  }, e.prototype.notifyComplete = function(t) {
    t !== this.openSubscription && this.closeWindow(this.contexts.indexOf(t.context));
  }, e.prototype.closeWindow = function(t) {
    if (t !== -1) {
      var n = this.contexts, i = n[t], s = i.window, o = i.subscription;
      n.splice(t, 1), s.complete(), o.unsubscribe();
    }
  }, e;
}(Wd);
function OCe(r) {
  return function(t) {
    return t.lift(new NCe(r));
  };
}
var NCe = /* @__PURE__ */ function() {
  function r(e) {
    this.closingSelector = e;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new PCe(e, this.closingSelector));
  }, r;
}(), PCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n) {
    var i = r.call(this, t) || this;
    return i.destination = t, i.closingSelector = n, i.openWindow(), i;
  }
  return e.prototype.notifyNext = function(t, n, i, s, o) {
    this.openWindow(o);
  }, e.prototype.notifyError = function(t) {
    this._error(t);
  }, e.prototype.notifyComplete = function(t) {
    this.openWindow(t);
  }, e.prototype._next = function(t) {
    this.window.next(t);
  }, e.prototype._error = function(t) {
    this.window.error(t), this.destination.error(t), this.unsubscribeClosingNotification();
  }, e.prototype._complete = function() {
    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();
  }, e.prototype.unsubscribeClosingNotification = function() {
    this.closingNotification && this.closingNotification.unsubscribe();
  }, e.prototype.openWindow = function(t) {
    t === void 0 && (t = null), t && (this.remove(t), t.unsubscribe());
    var n = this.window;
    n && n.complete();
    var i = this.window = new ui();
    this.destination.next(i);
    var s;
    try {
      var o = this.closingSelector;
      s = o();
    } catch (a) {
      this.destination.error(a), this.window.error(a);
      return;
    }
    this.add(this.closingNotification = Ll(this, s));
  }, e;
}(Wd);
function MCe() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return function(t) {
    var n;
    typeof r[r.length - 1] == "function" && (n = r.pop());
    var i = r;
    return t.lift(new DCe(i, n));
  };
}
var DCe = /* @__PURE__ */ function() {
  function r(e, t) {
    this.observables = e, this.project = t;
  }
  return r.prototype.call = function(e, t) {
    return t.subscribe(new kCe(e, this.observables, this.project));
  }, r;
}(), kCe = /* @__PURE__ */ function(r) {
  Pe(e, r);
  function e(t, n, i) {
    var s = r.call(this, t) || this;
    s.observables = n, s.project = i, s.toRespond = [];
    var o = n.length;
    s.values = new Array(o);
    for (var a = 0; a < o; a++)
      s.toRespond.push(a);
    for (var a = 0; a < o; a++) {
      var c = n[a];
      s.add(Ll(s, c, void 0, a));
    }
    return s;
  }
  return e.prototype.notifyNext = function(t, n, i) {
    this.values[i] = n;
    var s = this.toRespond;
    if (s.length > 0) {
      var o = s.indexOf(i);
      o !== -1 && s.splice(o, 1);
    }
  }, e.prototype.notifyComplete = function() {
  }, e.prototype._next = function(t) {
    if (this.toRespond.length === 0) {
      var n = [t].concat(this.values);
      this.project ? this._tryProject(n) : this.destination.next(n);
    }
  }, e.prototype._tryProject = function(t) {
    var n;
    try {
      n = this.project.apply(this, t);
    } catch (i) {
      this.destination.error(i);
      return;
    }
    this.destination.next(n);
  }, e;
}(Wd);
function $Ce() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return function(n) {
    return n.lift.call(pU.apply(void 0, [n].concat(r)));
  };
}
function LCe(r) {
  return function(e) {
    return e.lift(new gU(r));
  };
}
const BCe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit: MU,
  auditTime: B4e,
  buffer: F4e,
  bufferCount: W4e,
  bufferTime: q4e,
  bufferToggle: Q4e,
  bufferWhen: e6e,
  catchError: n6e,
  combineAll: o6e,
  combineLatest: a6e,
  concat: c6e,
  concatAll: sU,
  concatMap: kU,
  concatMapTo: l6e,
  count: u6e,
  debounce: d6e,
  debounceTime: m6e,
  defaultIfEmpty: Wy,
  delay: E6e,
  delayWhen: A6e,
  dematerialize: O6e,
  distinct: M6e,
  distinctUntilChanged: LU,
  distinctUntilKeyChanged: B6e,
  elementAt: z6e,
  endWith: V6e,
  every: q6e,
  exhaust: Z6e,
  exhaustMap: BU,
  expand: exe,
  filter: ah,
  finalize: nxe,
  find: oxe,
  findIndex: cxe,
  first: lxe,
  flatMap: s5e,
  groupBy: dEe,
  ignoreElements: uxe,
  isEmpty: dxe,
  last: yxe,
  map: Vo,
  mapTo: vxe,
  materialize: Exe,
  max: Ixe,
  merge: Rxe,
  mergeAll: BA,
  mergeMap: bd,
  mergeMapTo: Txe,
  mergeScan: Oxe,
  min: Mxe,
  multicast: _d,
  observeOn: xEe,
  onErrorResumeNext: kxe,
  pairwise: Bxe,
  partition: jxe,
  pluck: Wxe,
  publish: zxe,
  publishBehavior: Vxe,
  publishLast: qxe,
  publishReplay: Gxe,
  race: Kxe,
  reduce: cE,
  refCount: MA,
  repeat: Zxe,
  repeatWhen: Qxe,
  retry: eSe,
  retryWhen: nSe,
  sample: oSe,
  sampleTime: lSe,
  scan: a_,
  sequenceEqual: dSe,
  share: ySe,
  shareReplay: vSe,
  single: _Se,
  skip: SSe,
  skipLast: ISe,
  skipUntil: OSe,
  skipWhile: MSe,
  startWith: $Se,
  subscribeOn: BSe,
  switchAll: WSe,
  switchMap: xw,
  switchMapTo: HSe,
  take: YA,
  takeLast: o_,
  takeUntil: zSe,
  takeWhile: GSe,
  tap: JSe,
  throttle: XSe,
  throttleTime: rCe,
  throwIfEmpty: aE,
  timeInterval: oCe,
  timeout: uCe,
  timeoutWith: jU,
  timestamp: hCe,
  toArray: pCe,
  window: gCe,
  windowCount: yCe,
  windowTime: _Ce,
  windowToggle: ICe,
  windowWhen: OCe,
  withLatestFrom: MCe,
  zip: $Ce,
  zipAll: LCe
}, Symbol.toStringTag, { value: "Module" })), XA = /* @__PURE__ */ La(BCe);
var lE = {}, Do = {};
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.ClientMessagePublishEvent = Do.ClientMessageSetSessionConfig = Do.ClientMessageGetSessionConfig = Do.ClientMessageIsLinked = Do.ClientMessageHostSession = void 0;
function FCe(r) {
  return Object.assign({ type: "HostSession" }, r);
}
Do.ClientMessageHostSession = FCe;
function UCe(r) {
  return Object.assign({ type: "IsLinked" }, r);
}
Do.ClientMessageIsLinked = UCe;
function jCe(r) {
  return Object.assign({ type: "GetSessionConfig" }, r);
}
Do.ClientMessageGetSessionConfig = jCe;
function WCe(r) {
  return Object.assign({ type: "SetSessionConfig" }, r);
}
Do.ClientMessageSetSessionConfig = WCe;
function HCe(r) {
  return Object.assign({ type: "PublishEvent" }, r);
}
Do.ClientMessagePublishEvent = HCe;
var HU = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.RxWebSocket = r.ConnectionState = void 0;
  const e = q3, t = XA;
  var n;
  (function(s) {
    s[s.DISCONNECTED = 0] = "DISCONNECTED", s[s.CONNECTING = 1] = "CONNECTING", s[s.CONNECTED = 2] = "CONNECTED";
  })(n = r.ConnectionState || (r.ConnectionState = {}));
  class i {
    /**
     * Constructor
     * @param url WebSocket server URL
     * @param [WebSocketClass] Custom WebSocket implementation
     */
    constructor(o, a = WebSocket) {
      this.WebSocketClass = a, this.webSocket = null, this.connectionStateSubject = new e.BehaviorSubject(n.DISCONNECTED), this.incomingDataSubject = new e.Subject(), this.url = o.replace(/^http/, "ws");
    }
    /**
     * Make a websocket connection
     * @returns an Observable that completes when connected
     */
    connect() {
      return this.webSocket ? (0, e.throwError)(new Error("webSocket object is not null")) : new e.Observable((o) => {
        let a;
        try {
          this.webSocket = a = new this.WebSocketClass(this.url);
        } catch (c) {
          o.error(c);
          return;
        }
        this.connectionStateSubject.next(n.CONNECTING), a.onclose = (c) => {
          this.clearWebSocket(), o.error(new Error(`websocket error ${c.code}: ${c.reason}`)), this.connectionStateSubject.next(n.DISCONNECTED);
        }, a.onopen = (c) => {
          o.next(), o.complete(), this.connectionStateSubject.next(n.CONNECTED);
        }, a.onmessage = (c) => {
          this.incomingDataSubject.next(c.data);
        };
      }).pipe((0, t.take)(1));
    }
    /**
     * Disconnect from server
     */
    disconnect() {
      const { webSocket: o } = this;
      if (o) {
        this.clearWebSocket(), this.connectionStateSubject.next(n.DISCONNECTED);
        try {
          o.close();
        } catch {
        }
      }
    }
    /**
     * Emit current connection state and subsequent changes
     * @returns an Observable for the connection state
     */
    get connectionState$() {
      return this.connectionStateSubject.asObservable();
    }
    /**
     * Emit incoming data from server
     * @returns an Observable for the data received
     */
    get incomingData$() {
      return this.incomingDataSubject.asObservable();
    }
    /**
     * Emit incoming JSON data from server. non-JSON data are ignored
     * @returns an Observable for parsed JSON data
     */
    get incomingJSONData$() {
      return this.incomingData$.pipe((0, t.flatMap)((o) => {
        let a;
        try {
          a = JSON.parse(o);
        } catch {
          return (0, e.empty)();
        }
        return (0, e.of)(a);
      }));
    }
    /**
     * Send data to server
     * @param data text to send
     */
    sendData(o) {
      const { webSocket: a } = this;
      if (!a)
        throw new Error("websocket is not connected");
      a.send(o);
    }
    clearWebSocket() {
      const { webSocket: o } = this;
      o && (this.webSocket = null, o.onclose = null, o.onerror = null, o.onmessage = null, o.onopen = null);
    }
  }
  r.RxWebSocket = i;
})(HU);
var uE = {};
Object.defineProperty(uE, "__esModule", { value: !0 });
uE.isServerMessageFail = void 0;
function zCe(r) {
  return r && r.type === "Fail" && typeof r.id == "number" && typeof r.sessionId == "string" && typeof r.error == "string";
}
uE.isServerMessageFail = zCe;
Object.defineProperty(lE, "__esModule", { value: !0 });
lE.WalletSDKConnection = void 0;
const sa = q3, mr = XA, z1 = Kg, vp = xy, V1 = Do, q1 = qg, Sb = HU, E6 = uE, EP = 1e4, VCe = 6e4;
class qCe {
  /**
   * Constructor
   * @param sessionId Session ID
   * @param sessionKey Session Key
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(e, t, n, i, s = WebSocket) {
    this.sessionId = e, this.sessionKey = t, this.diagnostic = i, this.subscriptions = new sa.Subscription(), this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = (0, vp.IntNumber)(1), this.connectedSubject = new sa.BehaviorSubject(!1), this.linkedSubject = new sa.BehaviorSubject(!1), this.sessionConfigSubject = new sa.ReplaySubject(1);
    const o = new Sb.RxWebSocket(n + "/rpc", s);
    this.ws = o, this.subscriptions.add(o.connectionState$.pipe(
      (0, mr.tap)((a) => {
        var c;
        return (c = this.diagnostic) === null || c === void 0 ? void 0 : c.log(q1.EVENTS.CONNECTED_STATE_CHANGE, {
          state: a,
          sessionIdHash: z1.Session.hash(e)
        });
      }),
      // ignore initial DISCONNECTED state
      (0, mr.skip)(1),
      // if DISCONNECTED and not destroyed
      (0, mr.filter)((a) => a === Sb.ConnectionState.DISCONNECTED && !this.destroyed),
      // wait 5 seconds
      (0, mr.delay)(5e3),
      // check whether it's destroyed again
      (0, mr.filter)((a) => !this.destroyed),
      // reconnect
      (0, mr.flatMap)((a) => o.connect()),
      (0, mr.retry)()
    ).subscribe()), this.subscriptions.add(o.connectionState$.pipe(
      // ignore initial DISCONNECTED and CONNECTING states
      (0, mr.skip)(2),
      (0, mr.switchMap)((a) => (0, sa.iif)(
        () => a === Sb.ConnectionState.CONNECTED,
        // if CONNECTED, authenticate, and then check link status
        this.authenticate().pipe((0, mr.tap)((c) => this.sendIsLinked()), (0, mr.tap)((c) => this.sendGetSessionConfig()), (0, mr.map)((c) => !0)),
        // if not CONNECTED, emit false immediately
        (0, sa.of)(!1)
      )),
      (0, mr.distinctUntilChanged)(),
      (0, mr.catchError)((a) => (0, sa.of)(!1))
    ).subscribe((a) => this.connectedSubject.next(a))), this.subscriptions.add(o.connectionState$.pipe(
      // ignore initial DISCONNECTED state
      (0, mr.skip)(1),
      (0, mr.switchMap)((a) => (0, sa.iif)(
        () => a === Sb.ConnectionState.CONNECTED,
        // if CONNECTED, start the heartbeat timer
        (0, sa.timer)(0, EP)
      ))
    ).subscribe((a) => (
      // first timer event updates lastHeartbeat timestamp
      // subsequent calls send heartbeat message
      a === 0 ? this.updateLastHeartbeat() : this.heartbeat()
    ))), this.subscriptions.add(o.incomingData$.pipe((0, mr.filter)((a) => a === "h")).subscribe((a) => this.updateLastHeartbeat())), this.subscriptions.add(o.incomingJSONData$.pipe((0, mr.filter)((a) => ["IsLinkedOK", "Linked"].includes(a.type))).subscribe((a) => {
      var c;
      const u = a;
      (c = this.diagnostic) === null || c === void 0 || c.log(q1.EVENTS.LINKED, {
        sessionIdHash: z1.Session.hash(e),
        linked: u.linked,
        type: a.type,
        onlineGuests: u.onlineGuests
      }), this.linkedSubject.next(u.linked || u.onlineGuests > 0);
    })), this.subscriptions.add(o.incomingJSONData$.pipe((0, mr.filter)((a) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(a.type))).subscribe((a) => {
      var c;
      const u = a;
      (c = this.diagnostic) === null || c === void 0 || c.log(q1.EVENTS.SESSION_CONFIG_RECEIVED, {
        sessionIdHash: z1.Session.hash(e),
        metadata_keys: u && u.metadata ? Object.keys(u.metadata) : void 0
      }), this.sessionConfigSubject.next({
        webhookId: u.webhookId,
        webhookUrl: u.webhookUrl,
        metadata: u.metadata
      });
    }));
  }
  /**
   * Make a connection to the server
   */
  connect() {
    var e;
    if (this.destroyed)
      throw new Error("instance is destroyed");
    (e = this.diagnostic) === null || e === void 0 || e.log(q1.EVENTS.STARTED_CONNECTING, {
      sessionIdHash: z1.Session.hash(this.sessionId)
    }), this.ws.connect().subscribe();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  destroy() {
    var e;
    this.subscriptions.unsubscribe(), this.ws.disconnect(), (e = this.diagnostic) === null || e === void 0 || e.log(q1.EVENTS.DISCONNECTED, {
      sessionIdHash: z1.Session.hash(this.sessionId)
    }), this.destroyed = !0;
  }
  get isDestroyed() {
    return this.destroyed;
  }
  /**
   * Emit true if connected and authenticated, else false
   * @returns an Observable
   */
  get connected$() {
    return this.connectedSubject.asObservable();
  }
  /**
   * Emit once connected
   * @returns an Observable
   */
  get onceConnected$() {
    return this.connected$.pipe((0, mr.filter)((e) => e), (0, mr.take)(1), (0, mr.map)(() => {
    }));
  }
  /**
   * Emit true if linked (a guest has joined before)
   * @returns an Observable
   */
  get linked$() {
    return this.linkedSubject.asObservable();
  }
  /**
   * Emit once when linked
   * @returns an Observable
   */
  get onceLinked$() {
    return this.linked$.pipe((0, mr.filter)((e) => e), (0, mr.take)(1), (0, mr.map)(() => {
    }));
  }
  /**
   * Emit current session config if available, and subsequent updates
   * @returns an Observable for the session config
   */
  get sessionConfig$() {
    return this.sessionConfigSubject.asObservable();
  }
  /**
   * Emit incoming Event messages
   * @returns an Observable for the messages
   */
  get incomingEvent$() {
    return this.ws.incomingJSONData$.pipe((0, mr.filter)((e) => {
      if (e.type !== "Event")
        return !1;
      const t = e;
      return typeof t.sessionId == "string" && typeof t.eventId == "string" && typeof t.event == "string" && typeof t.data == "string";
    }), (0, mr.map)((e) => e));
  }
  /**
   * Set session metadata in SessionConfig object
   * @param key
   * @param value
   * @returns an Observable that completes when successful
   */
  setSessionMetadata(e, t) {
    const n = (0, V1.ClientMessageSetSessionConfig)({
      id: (0, vp.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      metadata: { [e]: t }
    });
    return this.onceConnected$.pipe((0, mr.flatMap)((i) => this.makeRequest(n)), (0, mr.map)((i) => {
      if ((0, E6.isServerMessageFail)(i))
        throw new Error(i.error || "failed to set session metadata");
    }));
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param data event data
   * @param callWebhook whether the webhook should be invoked
   * @returns an Observable that emits event ID when successful
   */
  publishEvent(e, t, n = !1) {
    const i = (0, V1.ClientMessagePublishEvent)({
      id: (0, vp.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      event: e,
      data: t,
      callWebhook: n
    });
    return this.onceLinked$.pipe((0, mr.flatMap)((s) => this.makeRequest(i)), (0, mr.map)((s) => {
      if ((0, E6.isServerMessageFail)(s))
        throw new Error(s.error || "failed to publish event");
      return s.eventId;
    }));
  }
  sendData(e) {
    this.ws.sendData(JSON.stringify(e));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > EP * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch {
    }
  }
  makeRequest(e, t = VCe) {
    const n = e.id;
    try {
      this.sendData(e);
    } catch (i) {
      return (0, sa.throwError)(i);
    }
    return this.ws.incomingJSONData$.pipe((0, mr.timeoutWith)(t, (0, sa.throwError)(new Error(`request ${n} timed out`))), (0, mr.filter)((i) => i.id === n), (0, mr.take)(1));
  }
  authenticate() {
    const e = (0, V1.ClientMessageHostSession)({
      id: (0, vp.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      sessionKey: this.sessionKey
    });
    return this.makeRequest(e).pipe((0, mr.map)((t) => {
      if ((0, E6.isServerMessageFail)(t))
        throw new Error(t.error || "failed to authentcate");
    }));
  }
  sendIsLinked() {
    const e = (0, V1.ClientMessageIsLinked)({
      id: (0, vp.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId
    });
    this.sendData(e);
  }
  sendGetSessionConfig() {
    const e = (0, V1.ClientMessageGetSessionConfig)({
      id: (0, vp.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId
    });
    this.sendData(e);
  }
}
lE.WalletSDKConnection = qCe;
var kg = {};
Object.defineProperty(kg, "__esModule", { value: !0 });
kg.decrypt = kg.encrypt = void 0;
const c_ = pt;
async function GCe(r, e) {
  if (e.length !== 64)
    throw Error("secret must be 256 bits");
  const t = crypto.getRandomValues(new Uint8Array(12)), n = await crypto.subtle.importKey("raw", (0, c_.hexStringToUint8Array)(e), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), i = new TextEncoder(), s = await window.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv: t
  }, n, i.encode(r)), o = 16, a = s.slice(s.byteLength - o), c = s.slice(0, s.byteLength - o), u = new Uint8Array(a), f = new Uint8Array(c), d = new Uint8Array([
    ...t,
    ...u,
    ...f
  ]);
  return (0, c_.uint8ArrayToHex)(d);
}
kg.encrypt = GCe;
function KCe(r, e) {
  if (e.length !== 64)
    throw Error("secret must be 256 bits");
  return new Promise((t, n) => {
    (async function() {
      const i = await crypto.subtle.importKey("raw", (0, c_.hexStringToUint8Array)(e), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), s = (0, c_.hexStringToUint8Array)(r), o = s.slice(0, 12), a = s.slice(12, 28), c = s.slice(28), u = new Uint8Array([
        ...c,
        ...a
      ]), f = {
        name: "AES-GCM",
        iv: new Uint8Array(o)
      };
      try {
        const d = await window.crypto.subtle.decrypt(f, i, u), m = new TextDecoder();
        t(m.decode(d));
      } catch (d) {
        n(d);
      }
    })();
  });
}
kg.decrypt = KCe;
var hE = {}, fE = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.RelayMessageType = void 0, function(e) {
    e.SESSION_ID_REQUEST = "SESSION_ID_REQUEST", e.SESSION_ID_RESPONSE = "SESSION_ID_RESPONSE", e.LINKED = "LINKED", e.UNLINKED = "UNLINKED", e.WEB3_REQUEST = "WEB3_REQUEST", e.WEB3_REQUEST_CANCELED = "WEB3_REQUEST_CANCELED", e.WEB3_RESPONSE = "WEB3_RESPONSE";
  }(r.RelayMessageType || (r.RelayMessageType = {}));
})(fE);
Object.defineProperty(hE, "__esModule", { value: !0 });
hE.Web3RequestCanceledMessage = void 0;
const ZCe = fE;
function JCe(r) {
  return { type: ZCe.RelayMessageType.WEB3_REQUEST_CANCELED, id: r };
}
hE.Web3RequestCanceledMessage = JCe;
var dE = {};
Object.defineProperty(dE, "__esModule", { value: !0 });
dE.Web3RequestMessage = void 0;
const QCe = fE;
function YCe(r) {
  return Object.assign({ type: QCe.RelayMessageType.WEB3_REQUEST }, r);
}
dE.Web3RequestMessage = YCe;
var $g = {};
Object.defineProperty($g, "__esModule", { value: !0 });
$g.isWeb3ResponseMessage = $g.Web3ResponseMessage = void 0;
const zU = fE;
function XCe(r) {
  return Object.assign({ type: zU.RelayMessageType.WEB3_RESPONSE }, r);
}
$g.Web3ResponseMessage = XCe;
function eAe(r) {
  return r && r.type === zU.RelayMessageType.WEB3_RESPONSE;
}
$g.isWeb3ResponseMessage = eAe;
var tAe = ze && ze.__createBinding || (Object.create ? function(r, e, t, n) {
  n === void 0 && (n = t), Object.defineProperty(r, n, { enumerable: !0, get: function() {
    return e[t];
  } });
} : function(r, e, t, n) {
  n === void 0 && (n = t), r[n] = e[t];
}), rAe = ze && ze.__setModuleDefault || (Object.create ? function(r, e) {
  Object.defineProperty(r, "default", { enumerable: !0, value: e });
} : function(r, e) {
  r.default = e;
}), VU = ze && ze.__decorate || function(r, e, t, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(r, e, t, n);
  else
    for (var a = r.length - 1; a >= 0; a--)
      (o = r[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}, nAe = ze && ze.__importStar || function(r) {
  if (r && r.__esModule)
    return r;
  var e = {};
  if (r != null)
    for (var t in r)
      t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && tAe(e, r, t);
  return rAe(e, r), e;
}, iAe = ze && ze.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(sE, "__esModule", { value: !0 });
sE.WalletSDKRelay = void 0;
const qU = iAe(oE), Kh = q3, Kn = XA, Ri = qg, sAe = lE, bp = wy, oAe = xy, on = pt, au = nAe(kg), cu = Kg, Cb = Aa, di = m3, aAe = hE, cAe = dE, xo = tn, xs = $g;
class Ea extends Cb.WalletSDKRelayAbstract {
  constructor(e) {
    var t;
    super(), this.accountsCallback = null, this.chainCallback = null, this.dappDefaultChainSubject = new Kh.BehaviorSubject(1), this.dappDefaultChain = 1, this.appName = "", this.appLogoUrl = null, this.subscriptions = new Kh.Subscription(), this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage, this.options = e;
    const { session: n, ui: i, connection: s } = this.subscribe();
    if (this._session = n, this.connection = s, this.relayEventManager = e.relayEventManager, e.diagnosticLogger && e.eventListener)
      throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
    e.eventListener ? this.diagnostic = {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      log: e.eventListener.onEvent
    } : this.diagnostic = e.diagnosticLogger, this._reloadOnDisconnect = (t = e.reloadOnDisconnect) !== null && t !== void 0 ? t : !0, this.ui = i;
  }
  subscribe() {
    this.subscriptions.add(this.dappDefaultChainSubject.subscribe((i) => {
      this.dappDefaultChain !== i && (this.dappDefaultChain = i);
    }));
    const e = cu.Session.load(this.storage) || new cu.Session(this.storage).save(), t = new sAe.WalletSDKConnection(e.id, e.key, this.linkAPIUrl, this.diagnostic);
    this.subscriptions.add(t.sessionConfig$.subscribe({
      next: (i) => {
        this.onSessionConfigChanged(i);
      },
      error: () => {
        var i;
        (i = this.diagnostic) === null || i === void 0 || i.log(Ri.EVENTS.GENERAL_ERROR, {
          message: "error while invoking session config callback"
        });
      }
    })), this.subscriptions.add(t.incomingEvent$.pipe((0, Kn.filter)((i) => i.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent })), this.subscriptions.add(t.linked$.pipe((0, Kn.skip)(1), (0, Kn.tap)((i) => {
      var s;
      this.isLinked = i;
      const o = this.storage.getItem(Cb.LOCAL_STORAGE_ADDRESSES_KEY);
      if (i && (this.session.linked = i), this.isUnlinkedErrorState = !1, o) {
        const a = o.split(" "), c = this.storage.getItem("IsStandaloneSigning") === "true";
        if (a[0] !== "" && !i && this.session.linked && !c) {
          this.isUnlinkedErrorState = !0;
          const u = this.getSessionIdHash();
          (s = this.diagnostic) === null || s === void 0 || s.log(Ri.EVENTS.UNLINKED_ERROR_STATE, {
            sessionIdHash: u
          });
        }
      }
    })).subscribe()), this.subscriptions.add(t.sessionConfig$.pipe((0, Kn.filter)((i) => !!i.metadata && i.metadata.__destroyed === "1")).subscribe(() => {
      var i;
      const s = t.isDestroyed;
      return (i = this.diagnostic) === null || i === void 0 || i.log(Ri.EVENTS.METADATA_DESTROYED, {
        alreadyDestroyed: s,
        sessionIdHash: this.getSessionIdHash()
      }), this.resetAndReload();
    })), this.subscriptions.add(t.sessionConfig$.pipe((0, Kn.filter)((i) => i.metadata && i.metadata.WalletUsername !== void 0)).pipe((0, Kn.mergeMap)((i) => au.decrypt(i.metadata.WalletUsername, e.secret))).subscribe({
      next: (i) => {
        this.storage.setItem(Cb.WALLET_USER_NAME_KEY, i);
      },
      error: () => {
        var i;
        (i = this.diagnostic) === null || i === void 0 || i.log(Ri.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "username"
        });
      }
    })), this.subscriptions.add(t.sessionConfig$.pipe((0, Kn.filter)((i) => i.metadata && i.metadata.AppVersion !== void 0)).pipe((0, Kn.mergeMap)((i) => au.decrypt(i.metadata.AppVersion, e.secret))).subscribe({
      next: (i) => {
        this.storage.setItem(Cb.APP_VERSION_KEY, i);
      },
      error: () => {
        var i;
        (i = this.diagnostic) === null || i === void 0 || i.log(Ri.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "appversion"
        });
      }
    })), this.subscriptions.add(t.sessionConfig$.pipe((0, Kn.filter)((i) => i.metadata && i.metadata.ChainId !== void 0 && i.metadata.JsonRpcUrl !== void 0)).pipe((0, Kn.mergeMap)((i) => (0, Kh.zip)(au.decrypt(i.metadata.ChainId, e.secret), au.decrypt(i.metadata.JsonRpcUrl, e.secret)))).pipe((0, Kn.distinctUntilChanged)()).subscribe({
      next: ([i, s]) => {
        this.chainCallback && this.chainCallback(i, s);
      },
      error: () => {
        var i;
        (i = this.diagnostic) === null || i === void 0 || i.log(Ri.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "chainId|jsonRpcUrl"
        });
      }
    })), this.subscriptions.add(t.sessionConfig$.pipe((0, Kn.filter)((i) => i.metadata && i.metadata.EthereumAddress !== void 0)).pipe((0, Kn.mergeMap)((i) => au.decrypt(i.metadata.EthereumAddress, e.secret))).subscribe({
      next: (i) => {
        this.accountsCallback && this.accountsCallback([i]), Ea.accountRequestCallbackIds.size > 0 && (Array.from(Ea.accountRequestCallbackIds.values()).forEach((s) => {
          const o = (0, xs.Web3ResponseMessage)({
            id: s,
            response: (0, xo.RequestEthereumAccountsResponse)([
              i
            ])
          });
          this.invokeCallback(Object.assign(Object.assign({}, o), { id: s }));
        }), Ea.accountRequestCallbackIds.clear());
      },
      error: () => {
        var i;
        (i = this.diagnostic) === null || i === void 0 || i.log(Ri.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "selectedAddress"
        });
      }
    })), this.subscriptions.add(t.sessionConfig$.pipe((0, Kn.filter)((i) => i.metadata && i.metadata.AppSrc !== void 0)).pipe((0, Kn.mergeMap)((i) => au.decrypt(i.metadata.AppSrc, e.secret))).subscribe({
      next: (i) => {
        this.ui.setAppSrc(i);
      },
      error: () => {
        var i;
        (i = this.diagnostic) === null || i === void 0 || i.log(Ri.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "appSrc"
        });
      }
    }));
    const n = this.options.uiConstructor({
      linkAPIUrl: this.options.linkAPIUrl,
      version: this.options.version,
      darkMode: this.options.darkMode,
      session: e,
      connected$: t.connected$,
      chainId$: this.dappDefaultChainSubject
    });
    return t.connect(), { session: e, ui: n, connection: t };
  }
  attachUI() {
    this.ui.attach();
  }
  resetAndReload() {
    this.connection.setSessionMetadata("__destroyed", "1").pipe((0, Kn.timeout)(1e3), (0, Kn.catchError)((e) => (0, Kh.of)(null))).subscribe((e) => {
      var t, n, i;
      const s = this.ui.isStandalone();
      try {
        this.subscriptions.unsubscribe();
      } catch {
        (t = this.diagnostic) === null || t === void 0 || t.log(Ri.EVENTS.GENERAL_ERROR, {
          message: "Had error unsubscribing"
        });
      }
      (n = this.diagnostic) === null || n === void 0 || n.log(Ri.EVENTS.SESSION_STATE_CHANGE, {
        method: "relay::resetAndReload",
        sessionMetadataChange: "__destroyed, 1",
        sessionIdHash: this.getSessionIdHash()
      }), this.connection.destroy();
      const o = cu.Session.load(this.storage);
      if ((o == null ? void 0 : o.id) === this._session.id ? this.storage.clear() : o && ((i = this.diagnostic) === null || i === void 0 || i.log(Ri.EVENTS.SKIPPED_CLEARING_SESSION, {
        sessionIdHash: this.getSessionIdHash(),
        storedSessionIdHash: cu.Session.hash(o.id)
      })), this._reloadOnDisconnect) {
        this.ui.reloadUI();
        return;
      }
      this.accountsCallback && this.accountsCallback([], !0), this.subscriptions = new Kh.Subscription();
      const { session: a, ui: c, connection: u } = this.subscribe();
      this._session = a, this.connection = u, this.ui = c, s && this.ui.setStandalone && this.ui.setStandalone(!0), this.attachUI();
    }, (e) => {
      var t;
      (t = this.diagnostic) === null || t === void 0 || t.log(Ri.EVENTS.FAILURE, {
        method: "relay::resetAndReload",
        message: `failed to reset and reload with ${e}`,
        sessionIdHash: this.getSessionIdHash()
      });
    });
  }
  setAppInfo(e, t) {
    this.appName = e, this.appLogoUrl = t;
  }
  getStorageItem(e) {
    return this.storage.getItem(e);
  }
  get session() {
    return this._session;
  }
  setStorageItem(e, t) {
    this.storage.setItem(e, t);
  }
  signEthereumMessage(e, t, n, i) {
    return this.sendRequest({
      method: di.Web3Method.signEthereumMessage,
      params: {
        message: (0, on.hexStringFromBuffer)(e, !0),
        address: t,
        addPrefix: n,
        typedDataJson: i || null
      }
    });
  }
  ethereumAddressFromSignedMessage(e, t, n) {
    return this.sendRequest({
      method: di.Web3Method.ethereumAddressFromSignedMessage,
      params: {
        message: (0, on.hexStringFromBuffer)(e, !0),
        signature: (0, on.hexStringFromBuffer)(t, !0),
        addPrefix: n
      }
    });
  }
  signEthereumTransaction(e) {
    return this.sendRequest({
      method: di.Web3Method.signEthereumTransaction,
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: (0, on.bigIntStringFromBN)(e.weiValue),
        data: (0, on.hexStringFromBuffer)(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? (0, on.bigIntStringFromBN)(e.gasPriceInWei) : null,
        maxFeePerGas: e.gasPriceInWei ? (0, on.bigIntStringFromBN)(e.gasPriceInWei) : null,
        maxPriorityFeePerGas: e.gasPriceInWei ? (0, on.bigIntStringFromBN)(e.gasPriceInWei) : null,
        gasLimit: e.gasLimit ? (0, on.bigIntStringFromBN)(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !1
      }
    });
  }
  signAndSubmitEthereumTransaction(e) {
    return this.sendRequest({
      method: di.Web3Method.signEthereumTransaction,
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: (0, on.bigIntStringFromBN)(e.weiValue),
        data: (0, on.hexStringFromBuffer)(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? (0, on.bigIntStringFromBN)(e.gasPriceInWei) : null,
        maxFeePerGas: e.maxFeePerGas ? (0, on.bigIntStringFromBN)(e.maxFeePerGas) : null,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas ? (0, on.bigIntStringFromBN)(e.maxPriorityFeePerGas) : null,
        gasLimit: e.gasLimit ? (0, on.bigIntStringFromBN)(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !0
      }
    });
  }
  submitEthereumTransaction(e, t) {
    return this.sendRequest({
      method: di.Web3Method.submitEthereumTransaction,
      params: {
        signedTransaction: (0, on.hexStringFromBuffer)(e, !0),
        chainId: t
      }
    });
  }
  scanQRCode(e) {
    return this.sendRequest({
      method: di.Web3Method.scanQRCode,
      params: { regExp: e }
    });
  }
  getQRCodeUrl() {
    return (0, on.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, !1, this.options.version, this.dappDefaultChain);
  }
  genericRequest(e, t) {
    return this.sendRequest({
      method: di.Web3Method.generic,
      params: {
        action: t,
        data: e
      }
    });
  }
  sendGenericMessage(e) {
    return this.sendRequest(e);
  }
  sendRequest(e) {
    let t = null;
    const n = (0, on.randomBytesHex)(8), i = (o) => {
      this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, e.method, o), t == null || t();
    };
    return { promise: new Promise((o, a) => {
      this.ui.isStandalone() || (t = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: i,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      })), this.relayEventManager.callbacks.set(n, (c) => {
        if (t == null || t(), c.errorMessage)
          return a(new Error(c.errorMessage));
        o(c);
      }), this.ui.isStandalone() ? this.sendRequestStandalone(n, e) : this.publishWeb3RequestEvent(n, e);
    }), cancel: i };
  }
  setConnectDisabled(e) {
    this.ui.setConnectDisabled(e);
  }
  setAccountsCallback(e) {
    this.accountsCallback = e;
  }
  setChainCallback(e) {
    this.chainCallback = e;
  }
  setDappDefaultChainCallback(e) {
    this.dappDefaultChainSubject.next(e);
  }
  publishWeb3RequestEvent(e, t) {
    var n;
    const i = (0, cAe.Web3RequestMessage)({ id: e, request: t }), s = cu.Session.load(this.storage);
    (n = this.diagnostic) === null || n === void 0 || n.log(Ri.EVENTS.WEB3_REQUEST, {
      eventId: i.id,
      method: `relay::${i.request.method}`,
      sessionIdHash: this.getSessionIdHash(),
      storedSessionIdHash: s ? cu.Session.hash(s.id) : "",
      isSessionMismatched: ((s == null ? void 0 : s.id) !== this._session.id).toString()
    }), this.subscriptions.add(this.publishEvent("Web3Request", i, !0).subscribe({
      next: (o) => {
        var a;
        (a = this.diagnostic) === null || a === void 0 || a.log(Ri.EVENTS.WEB3_REQUEST_PUBLISHED, {
          eventId: i.id,
          method: `relay::${i.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: s ? cu.Session.hash(s.id) : "",
          isSessionMismatched: ((s == null ? void 0 : s.id) !== this._session.id).toString()
        });
      },
      error: (o) => {
        this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
          id: i.id,
          response: {
            method: i.request.method,
            errorMessage: o.message
          }
        }));
      }
    }));
  }
  publishWeb3RequestCanceledEvent(e) {
    const t = (0, aAe.Web3RequestCanceledMessage)(e);
    this.subscriptions.add(this.publishEvent("Web3RequestCanceled", t, !1).subscribe());
  }
  publishEvent(e, t, n) {
    const i = this.session.secret;
    return new Kh.Observable((s) => {
      au.encrypt(JSON.stringify(Object.assign(Object.assign({}, t), { origin: location.origin })), i).then((o) => {
        s.next(o), s.complete();
      });
    }).pipe((0, Kn.mergeMap)((s) => this.connection.publishEvent(e, s, n)));
  }
  handleIncomingEvent(e) {
    try {
      this.subscriptions.add((0, Kh.from)(au.decrypt(e.data, this.session.secret)).pipe((0, Kn.map)((t) => JSON.parse(t))).subscribe({
        next: (t) => {
          const n = (0, xs.isWeb3ResponseMessage)(t) ? t : null;
          n && this.handleWeb3ResponseMessage(n);
        },
        error: () => {
          var t;
          (t = this.diagnostic) === null || t === void 0 || t.log(Ri.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "incomingEvent"
          });
        }
      }));
    } catch {
      return;
    }
  }
  handleWeb3ResponseMessage(e) {
    var t;
    const { response: n } = e;
    if ((t = this.diagnostic) === null || t === void 0 || t.log(Ri.EVENTS.WEB3_RESPONSE, {
      eventId: e.id,
      method: `relay::${n.method}`,
      sessionIdHash: this.getSessionIdHash()
    }), (0, xo.isRequestEthereumAccountsResponse)(n)) {
      Ea.accountRequestCallbackIds.forEach((i) => this.invokeCallback(Object.assign(Object.assign({}, e), { id: i }))), Ea.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(e);
  }
  handleErrorResponse(e, t, n, i) {
    var s;
    const o = (s = n == null ? void 0 : n.message) !== null && s !== void 0 ? s : (0, bp.standardErrorMessage)(i);
    this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
      id: e,
      response: {
        method: t,
        errorMessage: o,
        errorCode: i
      }
    }));
  }
  invokeCallback(e) {
    const t = this.relayEventManager.callbacks.get(e.id);
    t && (t(e.response), this.relayEventManager.callbacks.delete(e.id));
  }
  requestEthereumAccounts() {
    const e = {
      method: di.Web3Method.requestEthereumAccounts,
      params: {
        appName: this.appName,
        appLogoUrl: this.appLogoUrl || null
      }
    }, t = (0, on.randomBytesHex)(8), n = (s) => {
      this.publishWeb3RequestCanceledEvent(t), this.handleErrorResponse(t, e.method, s);
    };
    return { promise: new Promise((s, o) => {
      var a;
      this.relayEventManager.callbacks.set(t, (u) => {
        if (this.ui.hideRequestEthereumAccounts(), u.errorMessage)
          return o(new Error(u.errorMessage));
        s(u);
      });
      const c = ((a = window == null ? void 0 : window.navigator) === null || a === void 0 ? void 0 : a.userAgent) || null;
      if (c && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(c)) {
        let u;
        try {
          (0, on.isInIFrame)() && window.top ? u = window.top.location : u = window.location;
        } catch {
          u = window.location;
        }
        u.href = `https://www.coinbase.com/connect-dapp?uri=${encodeURIComponent(u.href)}`;
        return;
      }
      if (this.ui.inlineAccountsResponse()) {
        const u = (f) => {
          this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
            id: t,
            response: (0, xo.RequestEthereumAccountsResponse)(f)
          }));
        };
        this.ui.requestEthereumAccounts({
          onCancel: n,
          onAccounts: u
        });
      } else {
        const u = bp.standardErrors.provider.userRejectedRequest("User denied account authorization");
        this.ui.requestEthereumAccounts({
          onCancel: () => n(u)
        });
      }
      Ea.accountRequestCallbackIds.add(t), !this.ui.inlineAccountsResponse() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(t, e);
    }), cancel: n };
  }
  selectProvider(e) {
    const t = {
      method: di.Web3Method.selectProvider,
      params: {
        providerOptions: e
      }
    }, n = (0, on.randomBytesHex)(8), i = (o) => {
      this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, t.method, o);
    }, s = new Promise((o, a) => {
      this.relayEventManager.callbacks.set(n, (f) => {
        if (f.errorMessage)
          return a(new Error(f.errorMessage));
        o(f);
      });
      const c = (f) => {
        this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
          id: n,
          response: (0, xo.SelectProviderResponse)(oAe.ProviderType.Unselected)
        }));
      }, u = (f) => {
        this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
          id: n,
          response: (0, xo.SelectProviderResponse)(f)
        }));
      };
      this.ui.selectProvider && this.ui.selectProvider({
        onApprove: u,
        onCancel: c,
        providerOptions: e
      });
    });
    return { cancel: i, promise: s };
  }
  watchAsset(e, t, n, i, s, o) {
    const a = {
      method: di.Web3Method.watchAsset,
      params: {
        type: e,
        options: {
          address: t,
          symbol: n,
          decimals: i,
          image: s
        },
        chainId: o
      }
    };
    let c = null;
    const u = (0, on.randomBytesHex)(8), f = (m) => {
      this.publishWeb3RequestCanceledEvent(u), this.handleErrorResponse(u, a.method, m), c == null || c();
    };
    this.ui.inlineWatchAsset() || (c = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: f,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }));
    const d = new Promise((m, y) => {
      this.relayEventManager.callbacks.set(u, (k) => {
        if (c == null || c(), k.errorMessage)
          return y(new Error(k.errorMessage));
        m(k);
      });
      const b = (k) => {
        this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
          id: u,
          response: (0, xo.WatchAssetReponse)(!1)
        }));
      }, I = () => {
        this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
          id: u,
          response: (0, xo.WatchAssetReponse)(!0)
        }));
      };
      this.ui.inlineWatchAsset() && this.ui.watchAsset({
        onApprove: I,
        onCancel: b,
        type: e,
        address: t,
        symbol: n,
        decimals: i,
        image: s,
        chainId: o
      }), !this.ui.inlineWatchAsset() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(u, a);
    });
    return { cancel: f, promise: d };
  }
  addEthereumChain(e, t, n, i, s, o) {
    const a = {
      method: di.Web3Method.addEthereumChain,
      params: {
        chainId: e,
        rpcUrls: t,
        blockExplorerUrls: i,
        chainName: s,
        iconUrls: n,
        nativeCurrency: o
      }
    };
    let c = null;
    const u = (0, on.randomBytesHex)(8), f = (m) => {
      this.publishWeb3RequestCanceledEvent(u), this.handleErrorResponse(u, a.method, m), c == null || c();
    };
    return this.ui.inlineAddEthereumChain(e) || (c = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: f,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    })), { promise: new Promise((m, y) => {
      this.relayEventManager.callbacks.set(u, (k) => {
        if (c == null || c(), k.errorMessage)
          return y(new Error(k.errorMessage));
        m(k);
      });
      const b = (k) => {
        this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
          id: u,
          response: (0, xo.AddEthereumChainResponse)({
            isApproved: !1,
            rpcUrl: ""
          })
        }));
      }, I = (k) => {
        this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
          id: u,
          response: (0, xo.AddEthereumChainResponse)({ isApproved: !0, rpcUrl: k })
        }));
      };
      this.ui.inlineAddEthereumChain(e) && this.ui.addEthereumChain({
        onCancel: b,
        onApprove: I,
        chainId: a.params.chainId,
        rpcUrls: a.params.rpcUrls,
        blockExplorerUrls: a.params.blockExplorerUrls,
        chainName: a.params.chainName,
        iconUrls: a.params.iconUrls,
        nativeCurrency: a.params.nativeCurrency
      }), !this.ui.inlineAddEthereumChain(e) && !this.ui.isStandalone() && this.publishWeb3RequestEvent(u, a);
    }), cancel: f };
  }
  switchEthereumChain(e, t) {
    const n = {
      method: di.Web3Method.switchEthereumChain,
      params: Object.assign({ chainId: e }, { address: t })
    }, i = (0, on.randomBytesHex)(8), s = (a) => {
      this.publishWeb3RequestCanceledEvent(i), this.handleErrorResponse(i, n.method, a);
    };
    return { promise: new Promise((a, c) => {
      this.relayEventManager.callbacks.set(i, (d) => {
        if ((0, xo.isErrorResponse)(d) && d.errorCode)
          return c(bp.standardErrors.provider.custom({
            code: d.errorCode,
            message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
          }));
        if (d.errorMessage)
          return c(new Error(d.errorMessage));
        a(d);
      });
      const u = (d) => {
        var m;
        if (d) {
          const y = (m = (0, bp.getErrorCode)(d)) !== null && m !== void 0 ? m : bp.standardErrorCodes.provider.unsupportedChain;
          this.handleErrorResponse(i, di.Web3Method.switchEthereumChain, d instanceof Error ? d : bp.standardErrors.provider.unsupportedChain(e), y);
        } else
          this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
            id: i,
            response: (0, xo.SwitchEthereumChainResponse)({
              isApproved: !1,
              rpcUrl: ""
            })
          }));
      }, f = (d) => {
        this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
          id: i,
          response: (0, xo.SwitchEthereumChainResponse)({
            isApproved: !0,
            rpcUrl: d
          })
        }));
      };
      this.ui.switchEthereumChain({
        onCancel: u,
        onApprove: f,
        chainId: n.params.chainId,
        address: n.params.address
      }), !this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(i, n);
    }), cancel: s };
  }
  inlineAddEthereumChain(e) {
    return this.ui.inlineAddEthereumChain(e);
  }
  getSessionIdHash() {
    return cu.Session.hash(this._session.id);
  }
  sendRequestStandalone(e, t) {
    const n = (s) => {
      this.handleErrorResponse(e, t.method, s);
    }, i = (s) => {
      this.handleWeb3ResponseMessage((0, xs.Web3ResponseMessage)({
        id: e,
        response: s
      }));
    };
    switch (t.method) {
      case di.Web3Method.signEthereumMessage:
        this.ui.signEthereumMessage({
          request: t,
          onSuccess: i,
          onCancel: n
        });
        break;
      case di.Web3Method.signEthereumTransaction:
        this.ui.signEthereumTransaction({
          request: t,
          onSuccess: i,
          onCancel: n
        });
        break;
      case di.Web3Method.submitEthereumTransaction:
        this.ui.submitEthereumTransaction({
          request: t,
          onSuccess: i,
          onCancel: n
        });
        break;
      case di.Web3Method.ethereumAddressFromSignedMessage:
        this.ui.ethereumAddressFromSignedMessage({
          request: t,
          onSuccess: i
        });
        break;
      default:
        n();
        break;
    }
  }
  onSessionConfigChanged(e) {
  }
}
Ea.accountRequestCallbackIds = /* @__PURE__ */ new Set();
VU([
  qU.default
], Ea.prototype, "resetAndReload", null);
VU([
  qU.default
], Ea.prototype, "handleIncomingEvent", null);
sE.WalletSDKRelay = Ea;
var pE = {};
Object.defineProperty(pE, "__esModule", { value: !0 });
pE.WalletSDKRelayEventManager = void 0;
const lAe = pt;
class uAe {
  constructor() {
    this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const e = this._nextRequestId, t = (0, lAe.prepend0x)(e.toString(16));
    return this.callbacks.get(t) && this.callbacks.delete(t), e;
  }
}
pE.WalletSDKRelayEventManager = uAe;
Object.defineProperty(mw, "__esModule", { value: !0 });
mw.CoinbaseWalletSDK = void 0;
const hAe = h3, fAe = f3, dAe = d3, pAe = bg, gAe = W3, mAe = sE, wAe = pE, yAe = pt, GU = Gg;
class gE {
  /**
   * Constructor
   * @param options Coinbase Wallet SDK constructor options
   */
  constructor(e) {
    var t, n, i;
    this._appName = "", this._appLogoUrl = null, this._relay = null, this._relayEventManager = null;
    const s = e.linkAPIUrl || fAe.LINK_API_URL;
    let o;
    if (e.uiConstructor ? o = e.uiConstructor : o = (u) => new gAe.WalletSDKUI(u), typeof e.overrideIsMetaMask > "u" ? this._overrideIsMetaMask = !1 : this._overrideIsMetaMask = e.overrideIsMetaMask, this._overrideIsCoinbaseWallet = (t = e.overrideIsCoinbaseWallet) !== null && t !== void 0 ? t : !0, this._overrideIsCoinbaseBrowser = (n = e.overrideIsCoinbaseBrowser) !== null && n !== void 0 ? n : !1, e.diagnosticLogger && e.eventListener)
      throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
    e.eventListener ? this._diagnosticLogger = {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      log: e.eventListener.onEvent
    } : this._diagnosticLogger = e.diagnosticLogger, this._reloadOnDisconnect = (i = e.reloadOnDisconnect) !== null && i !== void 0 ? i : !0;
    const a = new URL(s), c = `${a.protocol}//${a.host}`;
    this._storage = new dAe.ScopedLocalStorage(`-walletlink:${c}`), this._storage.setItem("version", gE.VERSION), !(this.walletExtension || this.coinbaseBrowser) && (this._relayEventManager = new wAe.WalletSDKRelayEventManager(), this._relay = new mAe.WalletSDKRelay({
      linkAPIUrl: s,
      version: GU.LIB_VERSION,
      darkMode: !!e.darkMode,
      uiConstructor: o,
      storage: this._storage,
      relayEventManager: this._relayEventManager,
      diagnosticLogger: this._diagnosticLogger,
      reloadOnDisconnect: this._reloadOnDisconnect
    }), this.setAppInfo(e.appName, e.appLogoUrl), !e.headlessMode && this._relay.attachUI());
  }
  /**
   * Create a Web3 Provider object
   * @param jsonRpcUrl Ethereum JSON RPC URL (Default: "")
   * @param chainId Ethereum Chain ID (Default: 1)
   * @returns A Web3 Provider
   */
  makeWeb3Provider(e = "", t = 1) {
    const n = this.walletExtension;
    if (n)
      return this.isCipherProvider(n) || n.setProviderInfo(e, t), this._reloadOnDisconnect === !1 && typeof n.disableReloadOnDisconnect == "function" && n.disableReloadOnDisconnect(), n;
    const i = this.coinbaseBrowser;
    if (i)
      return i;
    const s = this._relay;
    if (!s || !this._relayEventManager || !this._storage)
      throw new Error("Relay not initialized, should never happen");
    return e || s.setConnectDisabled(!0), new pAe.CoinbaseWalletProvider({
      relayProvider: () => Promise.resolve(s),
      relayEventManager: this._relayEventManager,
      storage: this._storage,
      jsonRpcUrl: e,
      chainId: t,
      qrUrl: this.getQrUrl(),
      diagnosticLogger: this._diagnosticLogger,
      overrideIsMetaMask: this._overrideIsMetaMask,
      overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
      overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
    });
  }
  /**
   * Set application information
   * @param appName Application name
   * @param appLogoUrl Application logo image URL
   */
  setAppInfo(e, t) {
    var n;
    this._appName = e || "DApp", this._appLogoUrl = t || (0, yAe.getFavicon)();
    const i = this.walletExtension;
    i ? this.isCipherProvider(i) || i.setAppInfo(this._appName, this._appLogoUrl) : (n = this._relay) === null || n === void 0 || n.setAppInfo(this._appName, this._appLogoUrl);
  }
  /**
   * Disconnect. After disconnecting, this will reload the web page to ensure
   * all potential stale state is cleared.
   */
  disconnect() {
    var e;
    const t = this.walletExtension;
    t ? t.close() : (e = this._relay) === null || e === void 0 || e.resetAndReload();
  }
  /**
   * Return QR URL for mobile wallet connection, will return null if extension is installed
   */
  getQrUrl() {
    var e, t;
    return (t = (e = this._relay) === null || e === void 0 ? void 0 : e.getQRCodeUrl()) !== null && t !== void 0 ? t : null;
  }
  /**
   * Official Coinbase Wallet logo for developers to use on their frontend
   * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
   * @param width Width of the logo (Optional)
   * @returns SVG Data URI
   */
  getCoinbaseWalletLogo(e, t = 240) {
    return (0, hAe.walletLogo)(e, t);
  }
  get walletExtension() {
    var e;
    return (e = window.coinbaseWalletExtension) !== null && e !== void 0 ? e : window.walletLinkExtension;
  }
  get coinbaseBrowser() {
    var e, t;
    try {
      const n = (e = window.ethereum) !== null && e !== void 0 ? e : (t = window.top) === null || t === void 0 ? void 0 : t.ethereum;
      return n && "isCoinbaseBrowser" in n && n.isCoinbaseBrowser ? n : void 0;
    } catch {
      return;
    }
  }
  isCipherProvider(e) {
    return typeof e.isCipher == "boolean" && e.isCipher;
  }
}
mw.CoinbaseWalletSDK = gE;
gE.VERSION = GU.LIB_VERSION;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.CoinbaseWalletProvider = r.CoinbaseWalletSDK = void 0;
  const e = mw, t = bg;
  var n = mw;
  Object.defineProperty(r, "CoinbaseWalletSDK", { enumerable: !0, get: function() {
    return n.CoinbaseWalletSDK;
  } });
  var i = bg;
  Object.defineProperty(r, "CoinbaseWalletProvider", { enumerable: !0, get: function() {
    return i.CoinbaseWalletProvider;
  } }), r.default = e.CoinbaseWalletSDK, typeof window < "u" && (window.CoinbaseWalletSDK = e.CoinbaseWalletSDK, window.CoinbaseWalletProvider = t.CoinbaseWalletProvider, window.WalletLink = e.CoinbaseWalletSDK, window.WalletLinkProvider = t.CoinbaseWalletProvider);
})(cL);
function iRe(r) {
  const { enableEIP6963: e = !0, enableInjected: t = !0, enableCoinbase: n = !0, enableEmail: i = !1, metadata: s, rpcUrl: o, defaultChainId: a } = r;
  let c, u;
  const f = { metadata: s };
  function d() {
    if (c)
      return c;
    if (!(typeof window > "u") && window.ethereum)
      return c = window.ethereum, c;
  }
  function m() {
    return u || (typeof window > "u" ? void 0 : (u = new cL.CoinbaseWalletSDK({
      appName: s.name,
      appLogoUrl: s.icons[0],
      darkMode: !1
    }).makeWeb3Provider(o, a), u));
  }
  return t && (f.injected = d()), n && o && a && (f.coinbase = m()), e && (f.EIP6963 = !0), i && (f.email = !0), f;
}
function sRe(r) {
  return new Tpe({ ...r, _sdkVersion: `html-ethers-${Je.VERSION}` });
}
export {
  AP as a,
  Jw as b,
  sRe as c,
  iRe as d,
  ji as p,
  Mc as s
};
